<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Информация о массиве</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-28 14:08:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 1276--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse91.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse89.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse89.html#tailclmse89.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse90.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch17.html#clmse90.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">17.3   </span> <a 
href="clm.html#QQ2-112-245" id="x112-21600017.3">Информация о массиве</a></h3>
<!--l. 1278--><p class="noindent" >Следующие функции извлекают интересную информацию, и это не элементы
массива.
<div class=defun>
<!--l. 1281--><p class="noindent" ><i>[Функция]</i><a 
 id="dx112-216001"></a><a 
 id="x112-216002r508"></a><b> array-element-type</b>  <i>array</i>
<!--l. 1283--><p class="noindent" ><a 
href="#x112-216002r508">array-element-type</a> возвращает спецификатор типа для множества объектов,
которые могут быть сохранены в массиве <i>array</i>. Это множество может быть
больше чем то, которое запрашивалось в функции <a 
href="clmse88.html#x110-214002r501">make-array</a>. Например,
результат <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(array-element-type (make-array 5 :element-type &#x2019;(mod 5)))
</td></tr></table>
<!--l. 1290--><p class="indent" >
</div>
</div>
<!--l. 1291--><p class="noindent" >может быть (mod 5), (mod 8), ﬁxnum, <a 
href="clmse31.html#x42-74004r19">t</a> или любой другой тип, для которого
(mod 5) является подтипом. Смотрите <a 
href="clmse32.html#x43-76004r21">subtypep</a>.
</div>
<div class=defun>
<!--l. 1295--><p class="noindent" ><i>[Функция]</i><a 
 id="dx112-216003"></a><a 
 id="x112-216004r509"></a><b> array-rank</b>  <i>array</i>
<!--l. 1297--><p class="noindent" >Эта функция возвращает количество измерений (осей) массива <i>array</i>.
Результат будет неотрицательным целым. Смотрите <a 
href="clmse88.html#x110-214004r502">array-rank-limit</a>.
</div>
<div class=defun>
<!--l. 1303--><p class="noindent" ><i>[Функция]</i><a 
 id="dx112-216005"></a><a 
 id="x112-216006r510"></a><b> array-dimension</b>  <i>array</i> <i>axis-number</i>
<!--l. 1305--><p class="noindent" >Данная функция возвращает размер измерения <i>axis-number</i> массива <i>array</i>.
<i>array</i> может быть любым видом массива, и <i>axis-number</i> должен быть
неотрицательным целым меньшим чем ранг массива <i>array</i>. Если <i>array</i>
является вектором с указателем заполнения, <a 
href="#x112-216006r510">array-dimension</a> возвращает
общий размер вектора, включая неактивные элементы, а не размер
                                                                          

                                                                          
ограниченный указателем заполнения. (Функция <a 
href="clmse75.html#x94-195008r351">length</a> будет возвращать
размер ограниченный указателем заполнения.)
</div>
<div class=defun>
<!--l. 1317--><p class="noindent" ><i>[Функция]</i><a 
 id="dx112-216007"></a><a 
 id="x112-216008r511"></a><b> array-dimensions</b>  <i>array</i>
<!--l. 1319--><p class="noindent" ><a 
href="#x112-216008r511">array-dimensions</a> возвращает список, элементы которого являются размерами
измерений массива <i>array</i>.
</div>
<div class=defun>
<!--l. 1324--><p class="noindent" ><i>[Функция]</i><a 
 id="dx112-216009"></a><a 
 id="x112-216010r512"></a><b> array-total-size</b>  <i>array</i>
<!--l. 1326--><p class="noindent" ><a 
href="#x112-216010r512">array-total-size</a> возвращает общее количество элементов массива <i>array</i>,
которое вычислено как произведение размеров всех измерений. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(array-total-size <i>x</i>)
</td></tr></table>
<!--l. 1330--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ≡</span> (apply #&#x2019;* (array-dimensions <i>x</i>))</td></tr></table>
<!--l. 1331--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ≡</span> (reduce #&#x2019;* (array-dimensions <i>x</i>))</td></tr></table>
<!--l. 1333--><p class="indent" >
</div>
</div>
<!--l. 1334--><p class="noindent" >Следует отметить, что общий размер нульмерного (FIXME) массива равен 1.
Общий размер одномерного массива вычисляется без учёта указателя
заполнения.
</div>
<div class=defun>
<!--l. 1338--><p class="noindent" ><i>[Функция]</i><a 
 id="dx112-216011"></a><a 
 id="x112-216012r513"></a><b> array-in-bounds-p</b>  <i>array</i> &#x0026;rest  <i>subscripts</i>
<!--l. 1340--><p class="noindent" >Данный предикат проверяет, являются ли индексы <i>subscripts</i> для массива
<i>array</i> корректными. Если они корректны, предикат истинен, иначе ложен.
<i>subscripts</i> должен быть целыми числами. Количество индексов <i>subscripts</i>
должно равняться рангу массива. Как и <a 
href="clmse89.html#x111-215002r506">aref</a>, <a 
href="#x112-216012r513">array-in-bounds-p</a> игнорирует
указатели заполнения.
</div>
<div class=defun>
<!--l. 1349--><p class="noindent" ><i>[Функция]</i><a 
 id="dx112-216013"></a><a 
 id="x112-216014r514"></a><b> array-row-major-index</b>  <i>array</i> &#x0026;rest  <i>subscripts</i>
<!--l. 1351--><p class="noindent" >Данная функция принимает массив и корректные для него индексы и
возвращает одиночное неотрицательное целое значение меньшее чем
                                                                          

                                                                          
общий размер массива, которое идентифицирует элемент, полагаясь на
построчный порядок хранения элементов. Количество указанных индексов
<i>subscripts</i> должно равняться рангу массива. Каждый индекс должен быть
неотрицательным целым числом меньшим чем соответствующий размер
измерения. Как и <a 
href="clmse89.html#x111-215002r506">aref</a>, <a 
href="#x112-216014r514">array-row-major-index</a> игнорирует указатели
заполнения.
<!--l. 1361--><p class="indent" >   Возможно определение <a 
href="#x112-216014r514">array-row-major-index</a>, без проверки на ошибки,
может выглядеть так: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun array-row-major-index (a &#x0026;rest subscripts)
</td></tr></table>
<!--l. 1364--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (apply #&#x2019;+ (maplist #&#x2019;(lambda (x y)</td></tr></table>
<!--l. 1365--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                          (* (car x) (apply #&#x2019;* (cdr y))))</td></tr></table>
<!--l. 1366--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      subscripts</td></tr></table>
<!--l. 1367--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      (array-dimensions a))))</td></tr></table>
<!--l. 1369--><p class="indent" >
</div>
</div>
<!--l. 1370--><p class="noindent" >Для одномерного массива, результат <a 
href="#x112-216014r514">array-row-major-index</a> всегда равен
переданному индексу.
</div>
<div class=defun>
<!--l. 1374--><p class="noindent" ><i>[Функция]</i><a 
 id="dx112-216015"></a><a 
 id="x112-216016r515"></a><b> row-major-aref</b>  <i>array</i> <i>index</i>
<!--l. 1376--><p class="noindent" >Данная функция позволяет получить доступ к элементу, как если бы массив
был одномерный. Аргумент <i>index</i> должен быть неотрицательным целым
меньшим чем общий размер массива <i>array</i>. Данная функция индексирует
массив, как если бы он был одномерный с построчным порядком. Эту
функцию можно понять в терминах <a 
href="clmse89.html#x111-215002r506">aref</a>: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(row-major-aref <i>array</i> <i>index</i>) <span class="math"> ≡</span>
</td></tr></table>
<!--l. 1384--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (aref (make-array (array-total-size array))</td></tr></table>
<!--l. 1385--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    :displaced-to array</td></tr></table>
<!--l. 1386--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    :element-type (array-element-type array))</td></tr></table>
<!--l. 1387--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        index)</td></tr></table>
<!--l. 1389--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1390--><p class="noindent" >Другими словами, можно обработать массив как одномерный с помощью
создания нового одномерного массива, который <i>соединён</i> с исходным, и
получить доступ к новому массиву. И наоборот, <a 
href="clmse89.html#x111-215002r506">aref</a> может быть описана в
терминах <a 
href="#x112-216016r515">row-major-aref</a>: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(aref <i>array</i> <span class="math"><i>i</i><sub>0</sub></span> <span class="math"><i>i</i><sub>1</sub></span> ... <span class="math"><i>i</i><sub>n−1</sub></span>) <span class="math"> ≡</span>
</td></tr></table>
<!--l. 1395--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (row-major-aref array</td></tr></table>
<!--l. 1396--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  (array-row-major-index array <span class="math"><i>i</i><sub>0</sub></span> <span class="math"><i>i</i><sub>1</sub></span> ... <span class="math"><i>i</i><sub>n−1</sub></span>)</td></tr></table>
<!--l. 1398--><p class="indent" >
</div>
</div>
<!--l. 1400--><p class="indent" >   Как и <a 
href="clmse89.html#x111-215002r506">aref</a>, <a 
href="#x112-216016r515">row-major-aref</a> полностью игнорирует указатели заполнения.
Для изменения элемента массива, можно комбинировать вызов <a 
href="#x112-216016r515">row-major-aref</a>
с формой <a 
href="clmse36.html#x48-90002r64">setf</a>.
<!--l. 1405--><p class="indent" >   Эта операция облегчает написание кода, который обрабатывает массивы
различных рангов. Предположим, что необходимо обнулить содержимое
массива tennis-scores. Можно решить это так: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬁll (make-array (array-total-size tennis-scores)
</td></tr></table>
<!--l. 1409--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  :element-type (array-element-type tennis-scores)</td></tr></table>
<!--l. 1410--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  :displaced-to tennis-scores)</td></tr></table>
<!--l. 1411--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      0)</td></tr></table>
<!--l. 1413--><p class="indent" >
</div>
</div>
<!--l. 1414--><p class="noindent" >К сожалению, так как <a 
href="clmse77.html#x96-197002r363">ﬁll</a> не может принимать многомерные массивы, в данном
примере создаётся <i>соединённый</i> массив, что является лишней операцией.
Другим способом является отдельная обработка каждого измерения
многомерного массива: <div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ecase (array-rank tennis-scores)
</td></tr></table>
<!--l. 1419--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (0 (setf (aref tennis-scores) 0))</td></tr></table>
<!--l. 1420--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (1 (dotimes (i0 (array-dimension tennis-scores 0))</td></tr></table>
<!--l. 1421--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (setf (aref tennis-scores i0) 0)))</td></tr></table>
<!--l. 1422--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (2 (dotimes (i0 (array-dimension tennis-scores 0))</td></tr></table>
<!--l. 1423--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (dotimes (i1 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 1424--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (setf (aref tennis-scores i0 i1) 0))))</td></tr></table>
<!--l. 1425--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 1426--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (7 (dotimes (i0 (array-dimension tennis-scores 0))</td></tr></table>
<!--l. 1427--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (dotimes (i1 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 1428--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (dotimes (i2 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 1429--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (dotimes (i3 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 1430--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (dotimes (i4 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 1431--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               (dotimes (i5 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 1432--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 (dotimes (i6 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 1433--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (setf (aref tennis-scores i0 i1 i2 i3 i4 i5 i6)</td></tr></table>
<!--l. 1434--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                         0)))))))))</td></tr></table>
<!--l. 1435--><p class="indent" >                                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  )</td></tr></table>
<!--l. 1437--><p class="indent" >
</div>
</div>
<!--l. 1438--><p class="noindent" >От такого кода быстро приходит усталость. Кроме того, данный подход не
желателен, так как некоторые реализации Common Lisp&#x2019;а будут фактически
поддерживать не более 7 измерений. Рекурсивно вложенные циклы
справляются с задачей лучше, но код всё ещё выглядит как лапша:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(labels
</td></tr></table>
<!--l. 1443--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ((grok-any-rank (&#x0026;rest indices)</td></tr></table>
<!--l. 1444--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">     (let ((d (- (array-rank tennis-scores) (length indices)))</td></tr></table>
<!--l. 1445--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (if (= d 0)</td></tr></table>
<!--l. 1446--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (setf (apply #&#x2019;row-major-aref indices) 0)</td></tr></table>
<!--l. 1447--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (dotimes (i (array-dimension tennis-scores (- d 1)))</td></tr></table>
<!--l. 1448--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (apply #&#x2019;grok-any-rank i indices))))))</td></tr></table>
<!--l. 1449--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (grok-any-rank))</td></tr></table>
<!--l. 1451--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1452--><p class="noindent" >Является ли этот код эффективным зависит от многих параметров реализации,
таких как способ обработки ??est
<!--l. 1453--><p class="indent" >   аргументов и компиляции <a 
href="clmse37.html#x49-95002r68">apply</a> вызовов. Только посмотрите как просто
использовать для задачи <a 
href="#x112-216016r515">row-major-aref</a>! <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(dotimes (i (array-total-size tennis-scores))
</td></tr></table>
<!--l. 1456--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf (row-major-aref tennis-scores i) 0))</td></tr></table>
<!--l. 1458--><p class="indent" >
</div>
</div>
<!--l. 1459--><p class="noindent" >Нет сомнения, что этот код, слаще любых медовых сот.
</div>
<div class=defun>
<!--l. 1462--><p class="noindent" ><i>[Функция]</i><a 
 id="dx112-216017"></a><a 
 id="x112-216018r516"></a><b> adjustable-array-p</b>  <i>array</i>
<!--l. 1464--><p class="noindent" >Если аргумент, который должен быть массивом, может быть расширен,
данный предикат истинен, иначе ложен.
</div>
                                                                          

                                                                          
   <!--l. 1469--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse91.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse89.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse89.html#tailclmse89.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse90.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch17.html#clmse90.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 1469--><p class="indent" >   <a 
 id="tailclmse90.html"></a>  
</body></html> 
