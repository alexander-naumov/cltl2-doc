<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Using Lists as Sets</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-22 17:23:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 950--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse91.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse89.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse89.html#tailclmse89.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse90.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch15.html#clmse90.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">15.5   </span> <a 
 id="x110-15200015.5"></a>Using Lists as Sets</h3>
<!--l. 952--><p class="noindent" >Common Lisp includes functions that allow a list of items to be treated as a set.
There are functions to add, remove, and search for items in a list, based
on various criteria. There are also set union, intersection, and diﬀerence
functions.
<!--l. 958--><p class="indent" >   The naming conventions for these functions and for their keyword arguments
generally follow the conventions that apply to the generic sequence functions. See
chapter <a 
href="clmch14.html#x99-14100014">14<!--tex4ht:ref: KSEQUE --></a>.
<div class=defun>
<!--l. 962--><p class="noindent" > <i>[Function]</i>   <b>member</b> <a 
 id="dx110-152001"></a><a 
 id="x110-152002r517"></a>   <i>item</i>  <i>list</i>  <b>&#x0026;key</b>  :test  :test-not  :key <br 
class="newline" /><i>[Function]</i>   <b>member-if</b> <a 
 id="dx110-152003"></a><a 
 id="x110-152004r518"></a>   <i>predicate</i>  <i>list</i>  <b>&#x0026;key</b>  :key <br 
class="newline" /><i>[Function]</i>   <b>member-if-not</b> <a 
 id="dx110-152005"></a><a 
 id="x110-152006r519"></a>   <i>predicate</i>  <i>list</i>  <b>&#x0026;key</b>  :key
<!--l. 966--><p class="noindent" >The list is searched for an element that satisﬁes the test. If none is found, <a 
href="clmse31.html#x42-70002r19">nil</a> is
returned; otherwise, the tail of list beginning with the ﬁrst element that satisﬁed
the test is returned. The list is searched on the top level only. These functions are
suitable for use as predicates.
<!--l. 974--><p class="indent" >   For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(member &#x2019;snerd &#x2019;(a b c d))  ⇒ <a 
href="clmse31.html#x42-70002r19">nil</a>
</td></tr></table>
<!--l. 976--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(member-if #&#x2019;numberp &#x2019;(a #<tt>\</tt>Space 5/3 foo))  ⇒ (5/3 foo)</td></tr></table>
<!--l. 977--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(member &#x2019;a &#x2019;(g (a y) c a d e a f))  ⇒ (a d e a f)</td></tr></table>
<!--l. 979--><p class="indent" >
</div>
</div>
<!--l. 980--><p class="noindent" >Note, in the last example, that the value returned by <a 
href="#x110-152002r517">member</a> is <a 
href="clmse33.html#x44-74002r46">eq</a> to the portion of
the list beginning with a. Thus <a 
href="clmse88.html#x108-150002r507">rplaca</a> on the result of <a 
href="#x110-152002r517">member</a> may be used to
alter the found list element, if a check is ﬁrst made that <a 
href="#x110-152002r517">member</a> did not return
<a 
href="clmse31.html#x42-70002r19">nil</a>.
<!--l. 987--><p class="indent" >   See also <a 
href="clmse84.html#x103-145002r428">ﬁnd</a> and <a 
href="clmse84.html#x103-145008r431">position</a>.
                                                                          

                                                                          
<div class=new>
<!--l. 990--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to restrict user side eﬀects; see section <a 
href="clmse43.html#x55-920007.9">7.9<!--tex4ht:ref: STRUCTURE-TRAVERSAL-SECTION --></a>.
</div>
<div class=incompatibility>
<!--l. 996--><p class="noindent" ><b>Compatibility note:</b> In MacLisp, the <a 
href="#x110-152002r517">member</a> function uses an <a 
href="clmse33.html#x44-74006r48">equal</a> comparison
rather than <a 
href="clmse33.html#x44-74004r47">eql</a>, which is the default test for <a 
href="#x110-152002r517">member</a> in Common Lisp. Where in
MacLisp one would write <i>(member x y)</i>, in Common Lisp one must write <i>(member x y
:test #&#x2019;equal)</i> to get a completely identical eﬀect. Similarly, one can get the precise
eﬀect, and no more, of the MacLisp <i>(memq x y)</i> by writing in Common Lisp <i>(member x
y :test #&#x2019;eq)</i>.
</div>
</div>
<div class=defun>
<!--l. 1008--><p class="noindent" > <i>[Function]</i>   <b>tailp</b> <a 
 id="dx110-152007"></a><a 
 id="x110-152008r520"></a>   <i>sublist</i>  <i>list</i>
<!--l. 1010--><p class="noindent" >This predicate is true if sublist is a sublist of list (that is, one of the conses
that makes up list); otherwise it is false. Another way to look at this
is that <a 
href="#x110-152008r520">tailp</a> is true if <i>(nthcdr n list)</i> is sublist, for some value of n. See
<a 
href="clmse87.html#x107-149066r506">ldiﬀ</a>.
<div class=new>
<!--l. 1018--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to strike the parenthetical remark that
suggests that the sublist must be a cons, to clarify that <a 
href="#x110-152008r520">tailp</a> is true if and only if
there exists an integer n such that <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql sublist (nthcdr n list))
</td></tr></table>
<!--l. 1025--><p class="indent" >
</div>
</div>
<!--l. 1026--><p class="noindent" >and to specify that list may be a dotted list (implying that implementations must use
<a 
href="clmse32.html#x43-73006r25">atom</a> and not <a 
href="clmse87.html#x107-149002r474">endp</a> to check for the end of the list).
</div>
</div>
<div class=defun>
<!--l. 1032--><p class="noindent" > <i>[Function]</i>   <b>adjoin</b> <a 
 id="dx110-152009"></a><a 
 id="x110-152010r521"></a>   <i>item</i>  <i>list</i>  <b>&#x0026;key</b>  :test  :test-not  :key
<!--l. 1034--><p class="noindent" ><a 
href="#x110-152010r521">adjoin</a> is used to add an element to a set, provided that it is not already a
member. The equality test defaults to <a 
href="clmse33.html#x44-74004r47">eql</a>. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(adjoin item list)  ≡ (if (member item list) list (cons item list))
</td></tr></table>
<!--l. 1039--><p class="indent" >
</div>
</div>
<!--l. 1040--><p class="noindent" >In general, the test may be any predicate; the item is added to the list only if there is
no element of the list that “satisﬁes the test.”
<!--l. 1043--><p class="indent" >   <a 
href="#x110-152010r521">adjoin</a> deviates from the usual rules described in chapter <a 
href="clmch14.html#x99-14100014">14<!--tex4ht:ref: KSEQUE --></a> for the treatment
of arguments named item and <i>:key</i>. If a <i>:key</i> function is speciﬁed, it is applied to
item as well as to each element of the list. The rationale is that if the item is not
yet in the list, it soon will be, and so the test is more properly viewed as being
between two elements rather than between a separate item and an element. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(adjoin item list :key fn)
</td></tr></table>
<!--l. 1051--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ≡ (if (member (funcall fn item) list :key fn) list (cons item list))</td></tr></table>
<!--l. 1053--><p class="indent" >
</div>
</div>
<!--l. 1054--><p class="noindent" >See <a 
href="clmse87.html#x107-149058r502">pushnew</a>. <div class=new>Notice of correction. In the ﬁrst edition, the form <i>(fn item)</i> appeared in
this example without the required <a 
href="clmse37.html#x49-81004r78">funcall</a>.
</div>
<div class=new>
<!--l. 1062--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to restrict user side eﬀects; see section <a 
href="clmse43.html#x55-920007.9">7.9<!--tex4ht:ref: STRUCTURE-TRAVERSAL-SECTION --></a>.
</div>
</div>
<div class=defun>
<!--l. 1068--><p class="noindent" > <i>[Function]</i>   <b>union</b> <a 
 id="dx110-152011"></a><a 
 id="x110-152012r522"></a>   <i>list1</i>  <i>list2</i>  <b>&#x0026;key</b>  :test  :test-not  :key <br 
class="newline" /><i>[Function]</i>   <b>nunion</b> <a 
 id="dx110-152013"></a><a 
 id="x110-152014r523"></a>   <i>list1</i>  <i>list2</i>  <b>&#x0026;key</b>  :test  :test-not  :key
<!--l. 1071--><p class="noindent" ><a 
href="#x110-152012r522">union</a> takes two lists and returns a new list containing everything that is an
element of either of the lists. If there is a duplication between two lists, only one
of the duplicate instances will be in the result. If either of the arguments has
duplicate entries within it, the redundant entries may or may not appear in the
result. For example: <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(union &#x2019;(a b c) &#x2019;(f a d))
</td></tr></table>
<!--l. 1081--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (a b c f d) or (b c f a d) or (d f a b c) or ...</td></tr></table>
<!--l. 1082--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1083--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(union &#x2019;((x 5) (y 6)) &#x2019;((z 2) (x 4)) :key #&#x2019;car)</td></tr></table>
<!--l. 1084--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ ((x 5) (y 6) (z 2)) or ((x 4) (y 6) (z 2)) or ...</td></tr></table>
<!--l. 1086--><p class="indent" >
</div>
</div>
<!--l. 1088--><p class="indent" >   There is no guarantee that the order of elements in the result will reﬂect the
ordering of the arguments in any particular way. The implementation is therefore
free to use any of a variety of strategies. The result list may share cells with, or be
<a 
href="clmse33.html#x44-74002r46">eq</a> to, either of the arguments if appropriate.
<!--l. 1094--><p class="indent" >   In general, the test may be any predicate, and the union operation may be
described as follows. For all possible ordered pairs consisting of one element from
list1 and one element from list2, the test is used to determine whether they
“match.” For every matching pair, at least one of the two elements of the
pair will be in the result. Moreover, any element from either list that
matches no element of the other will appear in the result. All this is very
general, but probably not particularly useful unless the test is an equivalence
relation.
<!--l. 1103--><p class="indent" >   The <i>:test-not</i> argument can be useful when the test function is the logical
negation of an equivalence test. A good example of this is the function <a 
href="clmse84.html#x103-145020r437">mismatch</a>,
which is logically inverted so that possibly useful information can be returned
if the arguments do not match. This additional “useful information” is
discarded in the following example; <a 
href="clmse84.html#x103-145020r437">mismatch</a> is used purely as a predicate. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(union &#x2019;(#(a b) #(5 0 6) #(f 3))
</td></tr></table>
<!--l. 1110--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       &#x2019;(#(5 0 6) (a b) #(g h))</td></tr></table>
<!--l. 1111--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :test-not</td></tr></table>
<!--l. 1112--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       #&#x2019;mismatch)</td></tr></table>
<!--l. 1113--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (#(a b) #(5 0 6) #(f 3) #(g h))     ;One possible result</td></tr></table>
<!--l. 1114--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ ((a b) #(f 3) #(5 0 6) #(g h))      ;Another possible result</td></tr></table>
<!--l. 1116--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1117--><p class="noindent" >Using <i><i>:test-not</i> #&#x2019;mismatch</i> diﬀers from using <i><i>:test</i> #&#x2019;equalp</i>, for example, because
<a 
href="clmse84.html#x103-145020r437">mismatch</a> will determine that <i>#(a b)</i> and <i>(a b)</i> are the same, while <a 
href="clmse33.html#x44-74008r49">equalp</a> would
regard them as not the same.
<!--l. 1122--><p class="indent" >   <a 
href="#x110-152014r523">nunion</a> is the destructive version of <a 
href="#x110-152012r522">union</a>. It performs the same operation but
may destroy the argument lists, perhaps in order to use their cells to construct the
result.
<div class=new>
<!--l. 1127--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to restrict user side eﬀects; see section <a 
href="clmse43.html#x55-920007.9">7.9<!--tex4ht:ref: STRUCTURE-TRAVERSAL-SECTION --></a>.
</div>
<div class=newer>
<!--l. 1133--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify the permissible side eﬀects of certain
operations; <a 
href="#x110-152014r523">nunion</a> is permitted to perform a <a 
href="clmse36.html#x48-80002r66">setf</a> on any part, car or cdr, of the
top-level list structure of any of the argument lists.
</div>
</div>
<div class=defun>
<!--l. 1141--><p class="noindent" > <i>[Function]</i>   <b>intersection</b> <a 
 id="dx110-152015"></a><a 
 id="x110-152016r524"></a>   <i>list1</i>  <i>list2</i>  <b>&#x0026;key</b>  :test  :test-not  :key
<br 
class="newline" /><i>[Function]</i>   <b>nintersection</b> <a 
 id="dx110-152017"></a><a 
 id="x110-152018r525"></a>   <i>list1</i>  <i>list2</i>  <b>&#x0026;key</b>  :test  :test-not  :key
<!--l. 1144--><p class="noindent" ><a 
href="#x110-152016r524">intersection</a> takes two lists and returns a new list containing everything that is an
element of both argument lists. If either list has duplicate entries, the
redundant entries may or may not appear in the result. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(intersection &#x2019;(a b c) &#x2019;(f a d))  ⇒ (a)
</td></tr></table>
<!--l. 1152--><p class="indent" >
</div>
</div>
<!--l. 1153--><p class="noindent" >There is no guarantee that the order of elements in the result will reﬂect the ordering
of the arguments in any particular way. The implementation is therefore free to
use any of a variety of strategies. The result list may share cells with, or be <a 
href="clmse33.html#x44-74002r46">eq</a> to,
either of the arguments if appropriate.
<!--l. 1159--><p class="indent" >   In general, the test may be any predicate, and the intersection operation may
                                                                          

                                                                          
be described as follows. For all possible ordered pairs consisting of one element
from list1 and one element from list2, the test is used to determine whether they
“match.” For every matching pair, exactly one of the two elements of the
pair will be put in the result. No element from either list appears in the
result that does not match an element from the other list. All this is very
general, but probably not particularly useful unless the test is an equivalence
relation.
<!--l. 1169--><p class="indent" >   <a 
href="#x110-152018r525">nintersection</a> is the destructive version of <a 
href="#x110-152016r524">intersection</a>. It performs the same
operation, but may destroy list1, perhaps in order to use its cells to construct the
result. (The argument list2 is not destroyed.)
<div class=new>
<!--l. 1175--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to restrict user side eﬀects; see section <a 
href="clmse43.html#x55-920007.9">7.9<!--tex4ht:ref: STRUCTURE-TRAVERSAL-SECTION --></a>.
</div>
<div class=newer>
<!--l. 1181--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify the permissible side eﬀects of
certain operations; <a 
href="#x110-152018r525">nintersection</a> is permitted to perform a <a 
href="clmse36.html#x48-80002r66">setf</a> on any
part, car or cdr, of the top-level list structure of any of the argument
lists.
</div>
</div>
<div class=defun>
<!--l. 1189--><p class="noindent" > <i>[Function]</i>   <b>set-diﬀerence</b> <a 
 id="dx110-152019"></a><a 
 id="x110-152020r526"></a>   <i>list1</i>  <i>list2</i>  <b>&#x0026;key</b>  :test  :test-not  :key
<br 
class="newline" /><i>[Function]</i>   <b>nset-diﬀerence</b> <a 
 id="dx110-152021"></a><a 
 id="x110-152022r527"></a>   <i>list1</i>  <i>list2</i>  <b>&#x0026;key</b>  :test  :test-not  :key
<!--l. 1192--><p class="noindent" ><a 
href="#x110-152020r526">set-diﬀerence</a> returns a list of elements of list1 that do not appear in list2. This
operation is not destructive.
<!--l. 1197--><p class="indent" >   There is no guarantee that the order of elements in the result will reﬂect the
ordering of the arguments in any particular way. The implementation is therefore
free to use any of a variety of strategies. The result list may share cells with, or be
<a 
href="clmse33.html#x44-74002r46">eq</a> to, either of the arguments if appropriate.
<!--l. 1203--><p class="indent" >   In general, the test may be any predicate, and the set diﬀerence operation may
be described as follows. For all possible ordered pairs consisting of one
element from list1 and one element from list2, the test is used to determine
whether they “match.” An element of list1 appears in the result if and
only if it does not match any element of list2. This is very general and
permits interesting applications. For example, one can remove from a list
of strings all those strings containing one of a given list of characters: <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;; Remove all ﬂavor names that contain &#x0022;c&#x0022; or &#x0022;w&#x0022;.
</td></tr></table>
<!--l. 1212--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-diﬀerence &#x2019;(&#x0022;strawberry&#x0022; &#x0022;chocolate&#x0022; &#x0022;banana&#x0022;</td></tr></table>
<!--l. 1213--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  &#x0022;lemon&#x0022; &#x0022;pistachio&#x0022; &#x0022;rhubarb&#x0022;)</td></tr></table>
<!--l. 1214--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                &#x2019;(#<tt>\</tt>c #<tt>\</tt>w)</td></tr></table>
<!--l. 1215--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                :test</td></tr></table>
<!--l. 1216--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                #&#x2019;(lambda (s c) (ﬁnd c s)))</td></tr></table>
<!--l. 1217--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (&#x0022;banana&#x0022; &#x0022;rhubarb&#x0022; &#x0022;lemon&#x0022;)     ;One possible ordering</td></tr></table>
<!--l. 1219--><p class="indent" >
</div>
</div>
<!--l. 1221--><p class="indent" >   <a 
href="#x110-152022r527">nset-diﬀerence</a> is the destructive version of <a 
href="#x110-152020r526">set-diﬀerence</a>. This operation may
destroy list1.
<div class=new>
<!--l. 1225--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to restrict user side eﬀects; see section <a 
href="clmse43.html#x55-920007.9">7.9<!--tex4ht:ref: STRUCTURE-TRAVERSAL-SECTION --></a>.
</div>
<div class=incompatibility>
<!--l. 1231--><p class="noindent" ><b>Compatibility note:</b> An approximately equivalent Interlisp function is ldiﬀerence.
</div>
</div>
<div class=defun>
<!--l. 1238--><p class="noindent" > <i>[Function]</i>   <b>set-exclusive-or</b> <a 
 id="dx110-152023"></a><a 
 id="x110-152024r528"></a>   <i>list1</i>  <i>list2</i>  <b>&#x0026;key</b>  :test  :test-not  :key
<br 
class="newline" /><i>[Function]</i>   <b>nset-exclusive-or</b> <a 
 id="dx110-152025"></a><a 
 id="x110-152026r529"></a>   <i>list1</i>  <i>list2</i>  <b>&#x0026;key</b>  :test  :test-not
:key
<!--l. 1241--><p class="noindent" ><a 
href="#x110-152024r528">set-exclusive-or</a> returns a list of elements that appear in exactly one of list1 and
list2. This operation is not destructive.
<!--l. 1246--><p class="indent" >   There is no guarantee that the order of elements in the result will reﬂect the
ordering of the arguments in any particular way. The implementation is therefore
free to use any of a variety of strategies. The result list may share cells with, or be
<a 
href="clmse33.html#x44-74002r46">eq</a> to, either of the arguments if appropriate.
<!--l. 1252--><p class="indent" >   In general, the test may be any predicate, and the set-exclusive-or operation
may be described as follows. For all possible ordered pairs consisting of one
element from list1 and one element from list2, the test is used to determine
whether they “match.” The result contains precisely those elements of list1 and
list2 that appear in no matching pair.
                                                                          

                                                                          
<!--l. 1258--><p class="indent" >
                                                                          

                                                                          
<!--l. 1260--><p class="indent" >   <a 
href="#x110-152026r529">nset-exclusive-or</a> is the destructive version of <a 
href="#x110-152024r528">set-exclusive-or</a>. Both lists may
be destroyed in producing the result.
<div class=new>
<!--l. 1264--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to restrict user side eﬀects; see section <a 
href="clmse43.html#x55-920007.9">7.9<!--tex4ht:ref: STRUCTURE-TRAVERSAL-SECTION --></a>.
</div>
<div class=newer>
<!--l. 1270--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify the permissible side eﬀects of
certain operations; <a 
href="#x110-152026r529">nset-exclusive-or</a> is permitted to perform a <a 
href="clmse36.html#x48-80002r66">setf</a> on any
part, car or cdr, of the top-level list structure of any of the argument
lists.
</div>
</div>
<div class=defun>
<!--l. 1278--><p class="noindent" > <i>[Function]</i>   <b>subsetp</b> <a 
 id="dx110-152027"></a><a 
 id="x110-152028r530"></a>   <i>list1</i>  <i>list2</i>  <b>&#x0026;key</b>  :test  :test-not  :key
<!--l. 1280--><p class="noindent" ><a 
href="#x110-152028r530">subsetp</a> is a predicate that is true if every element of list1 appears in (“matches”
some element of) list2, and false otherwise.
<div class=new>
<!--l. 1285--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to restrict user side eﬀects; see section <a 
href="clmse43.html#x55-920007.9">7.9<!--tex4ht:ref: STRUCTURE-TRAVERSAL-SECTION --></a>.
</div>
</div>
                                                                          

                                                                          
   <!--l. 1292--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse91.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse89.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse89.html#tailclmse89.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse90.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch15.html#clmse90.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 1292--><p class="indent" >   <a 
 id="tailclmse90.html"></a>  
</body></html> 
