%Part{Dtspec, Root = "CLM.MSS"}
%Chapter of Common Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\chapter{Type Specif{\kern0pt}iers}    % Avoid ligature
\label{DTSPEC}

In Common Lisp, types are named by Lisp objects, specifically symbols and lists,
called {\it type specifiers}.  Symbols name predefined classes of objects,
whereas lists usually indicate combinations or
specializations of simpler types.
Symbols or lists may also be abbreviations for types that could
be specified in other ways.

\section{Type Specifier Symbols}

The type symbols defined by the system include those shown in
table~\ref{TYPE-SYMBOLS-TABLE}.
In addition, when a structure type is defined using \cd{defstruct},
the name of the structure type becomes a valid type symbol.

\begin{new}%CORR
{\it Notice of correction.}
In the first edition, the type specifiers \cd{signed-byte} and
\cd{unsigned-byte} were inadvertently omitted from
table~\ref{TYPE-SYMBOLS-TABLE}.
\end{new}

\begin{newer}
X3J13 voted in March 1989 \issue{COMMON-TYPE}
to eliminate the type \cd{common}; this fact is indicated by the brackets around
the \cd{common} type specifier in the table.

X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to eliminate the type \cd{string-char};
this fact is indicated by the brackets around
the \cd{string-char} type specifier in the table.

X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to add the type \cd{extended-character} and the type \cd{base-character}.

X3J13 voted in March 1989 \issue{REAL-NUMBER-TYPE}
to add the type specifier \cd{real}.

X3J13 votes have also implicitly added
many other type specifiers as names of classes (see chapter~\ref{CLOS})
or of conditions (see chapter~\ref{CONDITION}).
\end{newer}

\section{Type Specifier Lists}

If a type specifier is a list, the {\it car}
of the list is a symbol, and the rest of the list is subsidiary
type information.  In many cases a subsidiary item may be
{\it unspecified}.  The unspecified subsidiary item is indicated
by writing \cd{*}.  For example, to completely specify
a vector type, one must mention the type of the elements
and the length of the vector, as for example
\begin{lisp}
(vector double-float 100)
\end{lisp}
To leave the length unspecified, one would write
\begin{lisp}
(vector double-float *)
\end{lisp}
To leave the element type unspecified, one would write
\begin{lisp}
(vector * 100)
\end{lisp}
\begin{newer}
\noindent
One may also leave both length and element type unspecified:
\begin{lisp}
(vector * *)
\end{lisp}
\end{newer}
Suppose that two type specifiers are the same except that the first
has a \cd{*} where the second has a more explicit specification.
Then the second denotes a subtype of the type denoted by the first.

\begin{table}[t]
\caption{Standard Type Specifier Symbols}
\label{TYPE-SYMBOLS-TABLE}
\divide\tabcolsep by 2\relax
\begin{flushleft}
\cf
\begin{tabular*}{\textwidth}{@{}l@{\extracolsep{\fill}}l@{\extracolsep{\fill}}l@{\extracolsep{\fill}}l@{}}
array&fixnum&package&simple-string \\
atom&float&pathname&simple-vector \\
bignum&function&random-state&single-float \\
bit&hash-table&ratio&standard-char \\
bit-vector&integer&rational&stream \\
character&keyword&readtable&string \\
{\rm [}common{\rm ]}&list&sequence&{\rm [}string-char{\rm ]} \\
compiled-function&long-float&short-float&symbol \\
complex&nil&signed-byte&t \\
cons&null&simple-array&unsigned-byte \\
double-float&number&simple-bit-vector&vector
\end{tabular*}
\end{flushleft}

\begin{newer}
X3J13 voted in March 1989 \issue{COMMON-TYPE} to remove the type \cd{common}.

X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL} to remove the type \cd{string-char}.

X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to add \cd{base-character} and \cd{extended-character}.

X3J13 voted in March 1989 \issue{REAL-NUMBER-TYPE} to add the type \cd{real}.
\end{newer}
\end{table}

As a convenience, if a list
has one or more unspecified items at the end, such items
may simply be dropped rather than writing an explicit \cd{*} for each one.
If dropping all occurrences of \cd{*} results in a singleton list,
then the parentheses may be dropped as well (the list may be replaced
by the symbol in its {\it car}).  For example,
\cd{(vector double-float *)} may be abbreviated to \cd{(vector double-float)},
and \cd{(vector * *)} may be abbreviated to \cd{(vector)} and then to
simply \cd{vector}.

\section{Predicating Type Specifiers}
\label{PREDICATING-TYPE-SPECIFIERS-SECTION}

A type specifier list \cd{(satisfies {\it predicate-name})} denotes
the set of all objects that satisfy the predicate named by {\it predicate-name},
which must be a symbol whose global function definition is a one-argument
predicate.
(A name is required; lambda-expressions are disallowed in order to avoid
scoping problems.)  For example, the type \cd{(satisfies numberp)} is the
same as the type \cd{number}.
The call \cd{(typep x '(satisfies p))} results in applying \cd{p} to \cd{x}
and returning \cd{t} if the result is true and {\nil} if the result is false.

\begin{obsolete}
As an example, the type \cd{string-char} could be defined as
\begin{lisp}
(deftype string-char () \\
~~'(and character (satisfies string-char-p)))
\end{lisp}
See \cd{deftype}.
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989 \issue{COMMON-TYPE} to remove the type \cd{string-char}
and the function \cd{string-char-p} from the language.
\end{newer}

It is not a good idea for
a predicate appearing in a \cd{satisfies} type specifier to
cause any side effects when invoked.

\section{Type Specifiers That Combine}

The following type specifier lists define a type in terms of
other types or objects.

\begin{flushdesc}
\item[\cd{(member {\it object1} {\it object2} ...)}]
This denotes the set
containing precisely those objects named.  An object is of
this type if and only if it is \cd{eql} to one of the specified objects.

\beforenoterule
\begin{incompatibility}
This is roughly equivalent to
the Interlisp DECL package's \cd{memq}.
\end{incompatibility}
\afternoterule
\end{flushdesc}

\begin{newer}
\begin{flushdesc}
\item[\cd{(eql {\it object})}]
X3J13 voted in June 1988 \issue{CLOS} to add the \cd{eql} type specifier.
It may be used as a parameter specializer for CLOS methods
(see section~\ref{Introduction-to-Methods-SECTION}
and \cd{find-method}).
It denotes the set of the one object named;  an object is of
this type if and only if it is \cd{eql} to {\it object}.  While
\cd{(eql {\it object})} denotes the same type as \cd{(member {\it object})},
only \cd{(eql {\it object})} may be used as a CLOS parameter specializer.
\end{flushdesc}
\end{newer}

\begin{flushdesc}
\item[\cd{(not {\it type})}]
This denotes the set of all those objects that
are {\it not} of the specified type.

\item[\cd{(and {\it type1} {\it type2} ...)}]
This denotes the intersection of
the specified types.

\beforenoterule
\begin{incompatibility}
This is roughly equivalent to
the Interlisp DECL package's \cd{allof}.
\end{incompatibility}
\afternoterule

When \cd{typep} processes an \cd{and} type specifier, it always
tests each of the component types in order from left to right
and stops processing as soon as one component of the intersection has
been found to which the object in question does not belong.
In this respect an \cd{and} type specifier is similar to an
executable \cd{and} form.  The purpose of this similarity is to allow
a \cd{satisfies} type specifier to depend on filtering by previous
type specifiers.  For example, suppose there were a function \cd{primep}
that takes an integer and says whether it is prime.  Suppose also that
it is an error to give any object other than an integer to \cd{primep}.
Then the type specifier
\begin{lisp}
(and integer (satisfies primep))
\end{lisp}
is guaranteed never to result in an error because the function \cd{primep}
will not be invoked unless the object in question has already been
determined to be an integer.

\item[\cd{(or {\it type1} {\it type2} ...)}]
This denotes the union of the
specified types.  For example, the type \cd{list} by definition is the same as
\cd{(or null cons)}.  Also, the value returned by the function
\cd{position} is always of type \cd{(or null (integer 0 *))}
(either {\nil} or a non-negative integer).

\beforenoterule
\begin{incompatibility}
This is roughly equivalent to
the Interlisp DECL package's \cd{oneof}.
\end{incompatibility}
\afternoterule

As for \cd{and},
when \cd{typep} processes an \cd{or} type specifier, it always
tests each of the component types in order from left to right
and stops processing as soon as one component of the union has
been found to which the object in question belongs.
\end{flushdesc}

\section{Type Specifiers That Specialize}
\label{SPECIALIZED-TYPE-SPECIFIER-SECTION}

Some type specifier lists denote {\it specializations} of
data types named by symbols.  These specializations may be
reflected by more efficient representations in the underlying
implementation.  As an example, consider the type \cd{(array short-float)}.
Implementation A may choose to provide a specialized representation
for arrays of short floating-point numbers, and implementation B
may choose not to.

If you should want to create an array for the
express purpose of holding only short-float objects, you may
optionally specify to \cd{make-array} the element type
\cd{short-float}.  This does not {\it require} \cd{make-array} to create
an object of type \cd{(array short-float)}; it merely {\it permits} it.  The
request is construed to mean ``Produce the most specialized array
representation capable of holding short-floats that the implementation
can provide.''  Implementation A will then produce a specialized
array of type \cd{(array short-float)}, and implementation B
will produce an ordinary array of type \cd{(array t)}.

If one were then to ask whether the array were actually of type
\cd{(array short-float)}, implementation A would say ``yes,'' but
implementation B would say ``no.''  This is a property of \cd{make-array}
and similar functions: what you ask for is not necessarily what you get.

\begin{obsolete}
Types can therefore be used for two different purposes:
{\it declaration} and {\it discrimination}.  Declaring to \cd{make-array}
that elements will always be of type \cd{short-float} permits
optimization.  Similarly, declaring that a variable takes on
values of type \cd{(array short-float)} amounts to saying that
the variable will take on values that might be produced by specifying
element type \cd{short-float} to \cd{make-array}.
On the other hand, if the predicate \cd{typep} is used to test
whether an object is of type \cd{(array short-float)},
only objects actually of that specialized type can satisfy the test;
in implementation B no object can pass that test.
\end{obsolete}

\begin{new}
X3J13 voted in January 1989
\issue{ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS}
to eliminate the differing treatment of types
when used ``for discrimination'' rather than ``for declaration'' on the grounds
that implementors have not treated the distinction consistently
and (which is more important) users have found the distinction confusing.

As a consequence of this change, the behavior of \cd{typep} and \cd{subtypep}
on \cd{array} and \cd{complex} type specifiers must be modified.
See the descriptions of those functions.  In particular, under their new
behavior, implementation B would say ``yes,'' agreeing with implementation A,
in the discussion above.

Note that the distinction between declaration and discrimination remains
useful, if only so that we may remark that the specialized (list)
form of the
\cd{function} type specifier may still be used only for declaration and
not for discrimination.
\end{new}

\begin{new}
X3J13 voted in June 1988 \issue{FUNCTION-TYPE} to clarify that
while the specialized form of the \cd{function} type specifier
(a list of the symbol \cd{function} possibly followed by
argument and value type specifiers)
may be used only for declaration, the symbol form (simply the name
\cd{function}) may be used for discrimination.
\end{new}

The valid list-format names for data types are as follows:
\begin{flushdesc}
\item[\cd{(array {\it element-type} {\it dimensions})}]
This denotes the set
of specialized arrays
whose elements are all members of the type {\it element-type}
and whose dimensions match {\it dimensions}.
For declaration purposes, this type encompasses those arrays
that can result by specifying {\it element-type} as the element type
to the function \cd{make-array}; this may be different
from what the type means for discrimination purposes.
{\it element-type} must be a valid type specifier or unspecified.
{\it dimensions} may be a non-negative integer, which is the number
of dimensions, or it may be a list of non-negative integers
representing the length of each dimension (any dimension
may be unspecified instead), or it may be unspecified.
For example:
\begin{lisp}
(array integer 3)~~~~~~~~~~~;{\rm Three-dimensional arrays of integers} \\
(array integer (* * *))~~~~~;{\rm Three-dimensional arrays of integers} \\
(array * (4 5 6))~~~~~~~~~~~;{\rm 4-by-5-by-6 arrays} \\
(array character (3 *))~~~~~;{\rm Two-dimensional arrays of characters} \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~;~{\rm that have exactly three rows} \\
(array short-float {\emptylist})~~~~~~;{\rm Zero-rank arrays of short-format} \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~;~{\rm floating-point numbers}
\end{lisp}
Note that \cd{(array~t)} is a proper subset of \cd{(array~*)}.
The reason is that \cd{(array~t)} is the set of arrays that can
hold any Common Lisp object (the elements are of type \cd{t},
which includes all objects).  On the other hand, \cd{(array~*)}
is the set of all arrays whatsoever, including, for example,
arrays that can hold only characters.  Now
\cd{(array character)} is not a subset of \cd{(array~t)}; the two sets
are in fact disjoint because \cd{(array character)} is not the
set of all arrays that can hold characters but rather the set of
arrays that are specialized to hold precisely characters and no
other objects.  To test whether an array \cd{foo} can hold a character,
one should not use
\begin{lisp}
(typep foo '(array character))
\end{lisp}
but rather
\begin{lisp}
(subtypep 'character (array-element-type foo))
\end{lisp}
See \cd{array-element-type}.
\begin{new}
X3J13 voted in January 1989
\issue{ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS}
to change \cd{typep} and \cd{subtypep}
so that the specialized \cd{array} type specifier
means the same thing for discrimination
as for declaration: it encompasses those arrays
that can result by specifying {\it element-type} as the element type
to the function \cd{make-array}.
Under this interpretation \cd{(array character)} might be
the same type as \cd{(array t)}
(although it also might not be the same).
See \cd{upgraded-array-element-type}.
However,
\begin{lisp}
(typep foo '(array character))
\end{lisp}
is still not a legitimate test of whether the array
\cd{foo} can hold a character; one must still say
\begin{lisp}
(subtypep 'character (array-element-type foo))
\end{lisp}
to determine that question.

X3J13 also voted in January 1989
\issue{DECLARE-ARRAY-TYPE-ELEMENT-REFERENCES}
to specify that within the lexical scope of an array type declaration,
it is an error for an array element, when referenced, not to be
of the exact declared element type.  A compiler may, for example,
treat every reference to an element of a declared array as if
the reference were surrounded by a \cd{the} form mentioning the
declared array element type ({\it not} the upgraded array element type).  Thus
\begin{lisp}
(defun snarf-hex-digits (the-array) \\*
~~(declare (type (array (unsigned-byte 4) 1) the-array)) \\*
~~(do ((j (- (length array) 1) (- j 1)) \\*
~~~~~~~(val 0 (logior (ash val 4) \\*
~~~~~~~~~~~~~~~~~~~~~~(aref the-array j)))) \\*
~~~~~~((< j 0) val)))
\end{lisp}
may be treated as
\begin{lisp}
(defun snarf-hex-digits (the-array) \\*
~~(declare (type (array (unsigned-byte 4) 1) the-array)) \\*
~~(do ((j (- (length array) 1) (- j 1)) \\*
~~~~~~~(val 0 (logior (ash val 4) \\*
~~~~~~~~~~~~~~~~~~~~~~(the (unsigned-byte 4) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~(aref the-array j))))) \\*
~~~~~~((< j 0) val)))
\end{lisp}
The declaration amounts to a promise by the user that the \cd{aref}
will never produce a value outside the interval 0 to 15, even if
in that particular implementation the array element type
\cd{(unsigned-byte 4)} is upgraded to, say, \cd{(unsigned-byte 8)}.
If~such upgrading does occur, then values outside that range may in fact
be stored in \cd{the-array}, as long as the code in \cd{snarf-hex-digits}
never sees them.


As a general rule, a compiler would be justified in transforming
\begin{lisp}
(aref (the (array {\it elt-type} ...) {\it a}) ...)
\end{lisp}
into
\begin{lisp}
(the {\it elt-type} (aref (the (array {\it elt-type} ...) {\it a}) ...)
\end{lisp}
It may also make inferences involving more complex functions,
such as \cd{position} or \cd{find}.
For example, \cd{find} applied to an array always returns either \cd{nil}
or an object whose type is the element type of the array.
\end{new}

\item[\cd{(simple-array {\it element-type} {\it dimensions})}]
This is equivalent
to \cd{(array {\it element-type} {\it dimensions})} except that it additionally
specifies that objects of the type are {\it simple} arrays
(see section~\ref{ARRAY-TYPE-SECTION}).

\item[\cd{(vector {\it element-type} {\it size})}]
This denotes the set of
specialized one-dimensional arrays whose elements are all of type {\it
element-type} and whose lengths match {\it size}.  This is entirely equivalent to
\cd{(array {\it element-type} ({\it size}))}.
For example:
\begin{lisp}
(vector double-float)~~~~~;{\rm Vectors of double-format} \\
~~~~~~~~~~~~~~~~~~~~~~~~~~;~{\rm floating-point numbers} \\
(vector * 5)~~~~~~~~~~~~~~;{\rm Vectors of length 5} \\
(vector t 5)~~~~~~~~~~~~~~;{\rm General vectors of length 5} \\
(vector (mod 32) *)~~~~~~~;{\rm Vectors of integers between 0 and 31}
\end{lisp}
\begin{obsolete}
The specialized types \cd{(vector string-char)} and \cd{(vector bit)} are so
useful that they have the special names \cd{string} and \cd{bit-vector}.
Every implementation of Common Lisp must provide distinct representations for
these as distinct specialized data types.
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to eliminate the type \cd{string-char} and to redefine the type
\cd{string} to be the union of one or more specialized vector
types, the types of whose elements are subtypes of the type \cd{character}.
\end{newer}

\item[\cd{(simple-vector {\it size})}]
This is the same
as \cd{(vector t {\it size})} except that it additionally specifies
that its elements are {\it simple} general vectors.

\item[\cd{(complex {\it type})}]
Every element of this type is a
complex number whose real part
and imaginary part are each of type {\it type}.
For declaration purposes, this type encompasses those complex numbers
that can result by giving numbers of the specified type
to the function \cd{complex}; this may be different
from what the type means for discrimination purposes.
As an example, Gaussian integers might be
described as \cd{(complex integer)}, even in implementations
where giving two integers to the function \cd{complex} results
in an object of type \cd{(complex rational)}.

\begin{new}
X3J13 voted in January 1989
\issue{ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS}
to change \cd{typep} and \cd{subtypep}
so that the specialized \cd{complex}
type specifier means the same thing for discrimination purposes
as for declaration purposes.
See \cd{upgraded-complex-part-type}.
\end{new}

\vskip 0pt plus 6pt

\item[\cd{(function ({\it arg1-type} {\it arg2-type} ...) {\it value-type})}]
\relax This type may be used only for declaration and not for
discrimination; \cd{typep} will signal an error if it encounters a specifier of
this form. Every element of this type is
a function that accepts arguments at {\it least} of the
types specified by the {\it argj-type} forms and returns a value that is a
member of the types specified by the {\it value-type} form.  The
\cd{\&optional}, \cd{\&rest}, and \cd{\&key} markers
may appear in the list of argument types.
The {\it value-type} may be a \cd{values} type specifier
in order to indicate the types of multiple values.

\begin{new}
X3J13 voted in January 1989
\issue{FUNCTION-TYPE-REST-LIST-ELEMENT}
to specify that the {\it arg-type} that
follows a \cd{\&rest} marker indicates the type of each actual argument
that would be gathered into the list for a \cd{\&rest} parameter,
and not the type of the \cd{\&rest} parameter itself (which is always
\cd{list}).  Thus one might declare the function \cd{gcd} to
be of type \cd{(function (\&rest~integer) integer)}, or
the function \cd{aref} to be of type
\cd{(function (array \&rest fixnum) t)}.
\end{new}

\begin{newer}
X3J13 voted in March 1988 \issue{FUNCTION-TYPE-KEY-NAME}
to specify that, in a \cd{function} type specifier,
an argument type specifier following \cd{\&key}
must be a list of two items, a keyword and a type specifier.
The keyword must be a valid keyword-name symbol that may be
supplied in the actual arguments of a call to the function,
and the type specifier indicates the permitted type of
the corresponding argument value.  (The keyword-name symbol
is typically a keyword,
but another X3J13 vote \issue{KEYWORD-ARGUMENT-NAME-PACKAGE}
allows it to be any symbol.)
Furthermore, if \cd{\&allow-other-keys} is not present,
the set of keyword-names mentioned in the \cd{function}
type specifier may be assumed to be exhaustive;
for example, a compiler would be justified in issuing
a warning for a function call using a keyword argument name
not mentioned in the type declaration for the function being called.
If \cd{\&allow-other-keys}
is present in the \cd{function}
type specifier, other keyword arguments may be supplied
when calling a function of the indicated type, and if supplied such
arguments may possibly be used.
\end{newer}

\begin{obsolete}
As an example, the function \cd{cons} is of type \cd{(function (t t) cons)},
because it can accept any two arguments and always returns a cons.
The function \cd{cons} is
also of type \cd{(function (float string) list)}, because it can certainly
accept a floating-point number and a string (among other things), and its
result is always of type \cd{list} (in fact a \cd{cons} is never \cd{null},
but that does not matter for this type declaration).
The function \cd{truncate} is of type
\cd{(function (number number) (values number number))}, as well as of type
\cd{(function (integer (mod 8)) integer)}.
\end{obsolete}

\begin{new}
X3J13 voted in January 1989
\issue{FUNCTION-TYPE-ARGUMENT-TYPE-SEMANTICS}
to alter the meaning of the
\cd{function} type specifier when used in \cd{type} and \cd{ftype}
declarations.  While the preceding formulation may be theoretically
elegant, they have found that it is not useful to compiler implementors
and that it is not the interpretation that users expect.  X3J13 prescribed instead the
following interpretation of declarations.

A declaration specifier of the form
\begin{lisp}
(ftype (function ({\it arg1-type} {\it arg2-type} ... {\it argn-type}) {\it value-type}) {\it fname})
\end{lisp}
implies that any function call of the form
\begin{lisp}
({\it fname} {\it arg1} {\it arg2} ...)
\end{lisp}
within the scope of the declaration can be treated as if it were
rewritten to use \cd{the}-forms in the following manner:
\begin{lisp}
(the {\it value-type} \\*
~~~~~({\it fname} \=(the {\it arg1-type} {\it arg1}) \\*
                  \>(the {\it arg2-type} {\it arg2}) \\*
                  \>... \\*
                  \>(the {\it argn-type} {\it argn})))
\end{lisp}
That is, it is an error for any of the actual arguments not to be of
its specified type {\it arg-type} or for the result not to be of the specified
type {\it value-type}.  (In particular, if any argument is not of
its specified type, then the result is not guaranteed to be of the
specified type---if indeed a result is returned at all.)

Similarly, a declaration specifier of the form
\begin{lisp}
(type (function ({\it arg1-type} {\it arg2-type} ... {\it argn-type}) {\it value-type}) {\it var})
\end{lisp}
is interpreted to mean that any reference to the variable {\it var}
will find that its value is a function, and that
it is an error to call this function with any actual argument not of
its specified type {\it arg-type}.
Also, it is an error for the result not to be of the specified
type {\it value-type}.
For example, a function call of the form
\begin{lisp}
(funcall {\it var} {\it arg1} {\it arg2} ...)
\end{lisp}
could be rewritten to use \cd{the}-forms as well.
If any argument is not of
its specified type, then the result is not guaranteed to be of the
specified type---if indeed a result is returned at all.


Thus, a \cd{type} or \cd{ftype} declaration specifier describes type
requirements imposed on calls to a function
as opposed to requirements imposed on the definition of the function.
This is analogous to the treatment of type declarations of variables
as imposing type requirements on references to variables, rather than
on the contents of variables.  See the vote of X3J13 on \cd{type}
declaration specifiers in general, discussed
in section~\ref{DECLARATION-SPECIFIERS-SECTION}.

In the same manner as for variable type declarations in general,
if two or more
of these declarations apply to the same function call (which can
occur if declaration scopes are suitably nested), then they all apply;
in effect, the types for each argument or result are intersected.
For example, the code fragment
\begin{lisp}
(locally (declare (ftype (function (biped) digit) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~butcher-fudge)) \\*
~~(locally (declare (ftype (function (featherless) opposable) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~butcher-fudge)) \\*
~~~~(butcher-fudge sam)))
\end{lisp}
may be regarded as equivalent to
\begin{lisp}
(the opposable \\*
~~~~~(the digit (butcher-fudge (the featherless \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(the biped sam)))))
\end{lisp}
or to
\begin{lisp}
(the (and opposable digit) \\*
~~~~~(butcher-fudge (the (and featherless biped) sam)))
\end{lisp}
That is, \cd{sam} had better be both \cd{featherless} and a \cd{biped},
and the result of \cd{butcher-fudge} had better be both
\cd{opposable} and a \cd{digit}; otherwise the code is in error.
Therefore a compiler may generate code that relies on these type assumptions,
for example.
\end{new}


\item[\cd{(values {\it value1-type} {\it value2-type} ...)}]
This type specifier is extremely restricted: it may be used {\it only}
as the {\it value-type} in a \cd{function} type specifier or in
a \cd{the} special form.  It is used to specify individual types when
multiple values are involved.
The
\cd{\&optional}, \cd{\&rest}, and \cd{\&key} markers may appear in the {\it value-type} list;
they thereby indicate the parameter list of a
function that, when given to \cd{multiple-value-call} along with
the values, would be suitable for receiving those values.
\end{flushdesc}


\section{Type Specifiers That Abbreviate}

The following type specifiers are, for the most part,
abbreviations for other type specifiers that would be far too
verbose to write out explicitly (using, for example, \cd{member}).

\begin{flushdesc}
\item[\cd{(integer {\it low} {\it high})}]
Denotes the integers between
{\it low} and {\it high}.  The limits {\it low} and {\it high}
must each be an integer, a list of an integer, or unspecified.
An integer is an inclusive limit,
a list of an integer is an exclusive limit, and
\cd{*} means that a limit does not exist
and so effectively denotes minus or plus infinity, respectively.
The type \cd{fixnum} is simply a name
for \cd{(integer {\it smallest} {\it largest})} for implementation-dependent
values of {\it smallest} and {\it largest}
(see \cd{most-negative-fixnum} and \cd{most-positive-fixnum}).
The type \cd{(integer 0 1)}
is so useful that it has the special name \cd{bit}.

\item[\cd{(mod {\it n})}]
Denotes the set of non-negative integers less than {\it n}.
This is equivalent to \cd{(integer 0 ${\it n}-1$)}
or to \cd{(integer 0 ({\it n}))}.

\item[\cd{(signed-byte {\it s})}]
Denotes the set of integers that can be represented
in two's-complement form in a byte of {\it s} bits.  This is
equivalent to
\cd{(integer $-2^{\hbox{\scriptsize\it s}-1}$ $2^{\hbox{\scriptsize\it s}-1}-1$)}.
Simply \cd{signed-byte} or \cd{(signed-byte *)} is the same as \cd{integer}.

\item[\cd{(unsigned-byte {\it s})}]
Denotes the set of non-negative integers that can be
represented in a byte of {\it s} bits.  This is equivalent to \cd{(mod
$2^{\hbox{\scriptsize\it s}}$)}, that is, \cd{(integer 0 $2^{\hbox{\scriptsize\it s}}-1$)}.
Simply \cd{unsigned-byte} or \cd{(unsigned-byte *)} is the same as
\cd{(integer 0 *)}, the set of non-negative integers.

\item[\cd{(rational {\it low} {\it high})}]
Denotes the rationals between
{\it low} and {\it high}.  The limits {\it low} and {\it high}
must each be a rational, a list of a rational, or unspecified.
A rational is an inclusive limit,
a list of a rational is an exclusive limit, and
\cd{*} means that a limit does not exist
and so effectively denotes minus or plus infinity, respectively.

\item[\cd{(float {\it low} {\it high})}]
Denotes the set of floating-point numbers between
{\it low} and {\it high}.  The limits {\it low} and {\it high}
must each be a floating-point number, a list of a floating-point number,
or unspecified; a floating-point number is an inclusive limit, a list of a
floating-point number is an exclusive limit, and
\cd{*} means that a limit does not exist
and so effectively denotes minus or plus infinity, respectively.

In a similar manner, one may use:
\begin{lisp}
(short-float {\it low} {\it high}) \\
(single-float {\it low} {\it high}) \\
(double-float {\it low} {\it high}) \\
(long-float {\it low} {\it high})
\end{lisp}
In this case, if a limit is a floating-point
number (or a list of one), it must be one of the appropriate format.
\end{flushdesc}

\begin{newer}
X3J13 voted in March 1989 \issue{REAL-NUMBER-TYPE} to add a list form of the \cd{real}
type specifier to denote an interval of \cd{real} numbers.

\begin{flushdesc}
\item[\cd{(real {\it low} {\it high})}]
Denotes the real numbers between
{\it low} and {\it high}.  The limits {\it low} and {\it high}
must each be a real, a list of a real, or unspecified.
A real is an inclusive limit,
a list of a real is an exclusive limit, and
\cd{*} means that a limit does not exist
and so effectively denotes minus or plus infinity, respectively.
\end{flushdesc}
\end{newer}

\begin{obsolete}
\begin{flushdesc}
\item[\cd{(string {\it size})}]
Means the same as
\cd{(array string-char ({\it size}))}: the set of strings of the indicated size.

\item[\cd{(simple-string {\it size})}]
Means the same
as \cd{(simple-array string-char ({\it size}))}: the set of simple
strings of the indicated size.
\end{flushdesc}
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to eliminate the type \cd{string-char} and to redefine the type
\cd{string} to be the union of one or more specialized vector
types, the types of whose elements are subtypes of the type \cd{character}.
Similarly, the type
\cd{simple-string} is redefined to be the union of one or more specialized
simple vector
types, the types of whose elements are subtypes of the type \cd{character}.

\begin{flushdesc}
\item[\cd{(base-string {\it size})}]
Means the same as
\cd{(vector base-character {\it size})}: the set of base
strings of the indicated size.

\penalty-3000%manual

\item[\cd{(simple-base-string {\it size})}]
Means the same
as \cd{(simple-array base-character ({\it size}))}: the set of simple base
strings of the indicated size.
\end{flushdesc}
\end{newer}

\begin{flushdesc}
\item[\cd{(bit-vector {\it size})}]
Means the same as \cd{(array bit ({\it size}))}:
the set of bit-vectors of the indicated size.

\item[\cd{(simple-bit-vector {\it size})}]
This means the same as
\cd{(simple-array bit ({\it size}))}: the set of bit-vectors of
the indicated size.
\end{flushdesc}

\section{Defining New Type Specifiers}

New type specifiers can come into existence in two ways.
First, defining a new structure type with \cd{defstruct} automatically
causes the name of the structure to be a new type specifier symbol.
Second, the \cd{deftype} special form can be used to define new type-specifier
abbreviations.


\begin{defmac}
deftype name lambda-list <{declaration}* | doc-string> {\,form}*

This is very similar to a \cd{defmacro} form: {\it name} is the
symbol that identifies the type specifier being defined, {\it lambda-list} is
a lambda-list (and may contain \cd{\&optional} and \cd{\&rest}
markers), and
the {\it forms} constitute the body of the expander function.  If we view a
type specifier list as a list containing the type specifier name and some argument forms,
the argument forms (unevaluated) are bound to the corresponding
parameters in {\it lambda-list}.  Then the body forms are evaluated
as an implicit \cd{progn}, and the value of the last form
is interpreted as a new type specifier for which the original specifier
was an abbreviation.  The {\it name} is returned as the value of the
\cd{deftype} form.

\cd{deftype} differs from \cd{defmacro} in that if no {\it initform}
is specified for an \cd{\&optional} parameter, the default value
is \cd{*}, not {\nil}.

If the optional documentation string {\it doc-string} is present,
then it is attached to the {\it name}
as a documentation string of type \cd{type}; see \cd{documentation}.

Here are some examples of the use of \cd{deftype}:
\begin{lisp}
(deftype mod (n) {\Xbq}(integer 0 (,n))) \\
 \\
(deftype list () '(or null cons))
\end{lisp}

%manual

\begin{lisp}
(deftype square-matrix (\cd{\&optional} type size) \\*
~~"SQUARE-MATRIX includes all square two-dimensional arrays." \\*
~~{\Xbq}(array ,type (,size ,size))) \\
 \\
(square-matrix short-float 7)  {\rm means}  (array short-float (7 7)) \\
 \\
(square-matrix bit)  {\rm means}  (array bit (* *))
\end{lisp}
If the type name defined by \cd{deftype} is used simply as a type
specifier symbol, it is interpreted as a type specifier list with
no argument forms.  Thus, in the example above, \cd{square-matrix}
would mean \cd{(array * (* *))}, the set of two-dimensional arrays.
This would unfortunately fail to convey the constraint that the two
dimensions be the same; \cd{(square-matrix bit)} has the same problem.
A better definition is
\begin{lisp}
(defun equidimensional (a) \\
~~(or (< (array-rank a) 2) \\
~~~~~~(apply \#'= (array-dimensions a)))) \\
 \\
(deftype square-matrix (\cd{\&optional} type size) \\
~~{\Xbq}(and (array ,type (,size ,size)) \\
~~~~~~~~(satisfies equidimensional)))
\end{lisp}

\begin{newer}
X3J13 voted in March 1988 \issue{FLET-IMPLICIT-BLOCK}
to specify that the body of the expander function defined
by \cd{deftype} is implicitly enclosed in a \cd{block} construct
whose name is the same as the {\it name} of the defined type.
Therefore \cd{return-from} may be used to exit from the function.
\end{newer}

\begin{newer}
X3J13 voted in March 1989 \issue{DEFINING-MACROS-NON-TOP-LEVEL}
to clarify that, while defining forms normally appear at top level,
it is meaningful to place them in non-top-level contexts;
\cd{deftype} must define the expander function
within the enclosing lexical environment, not within the global
environment.
\end{newer}

\end{defmac}

\section{Type Conversion Function}

The following function may be used to convert an object to an
equivalent object of another type.

\begin{defun}[Function]
coerce object result-type

The {\it result-type} must be a type specifier; the {\it object} is converted
to an ``equivalent'' object of the specified type.
If the coercion cannot be performed, then an error is signaled.
In particular, \cd{(coerce x 'nil)} always signals an error.
If {\it object} is already of the specified type, as determined
by \cd{typep}, then it is simply returned.
It is not generally
possible to convert any object to be of any type whatsoever; only certain
conversions are permitted:
\begin{itemize}
\item
Any sequence type may be converted to any other sequence type, provided
the new sequence can contain all actual elements of the old sequence
(it is an error if it cannot).  If the {\it result-type} is specified as
simply \cd{array}, for example, then \cd{(array t)} is assumed.  A
specialized type such as \cd{string} or \cd{(vector (complex short-float))}
may be specified; of course, the result may be of either that type or
some more general type, as determined by the implementation.
Elements of the new sequence will be \cd{eql} to corresponding elements
of the old sequence.
If the
{\it sequence} is already of the specified type, it may be returned without
copying it; in this, \cd{(coerce {\it sequence} {\it type})} differs from
\cd{(concatenate {\it type} {\it sequence})}, for the latter is required to
copy the argument {\it sequence}.  In particular, if one specifies
\cd{sequence}, then the argument may simply be returned if it already is
a \cd{sequence}.
\begin{lisp}
(coerce '(a b c) 'vector) \EV\ \#(a b c)
\end{lisp}
\end{itemize}

\begin{newer}
X3J13 voted in June 1989 \issue{SEQUENCE-TYPE-LENGTH} to specify that
\cd{coerce} should signal an error if the new sequence type specifies the
number of elements and the old sequence has a different length.
\end{newer}

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to specify that if the {\it result-type} is \cd{string}
then it is understood to mean \cd{(vector character)},
and \cd{simple-string} is understood to mean \cd{(simple-array character (*))}.
\end{newer}

\begin{obsolete}
\begin{itemize}
\item
Some strings, symbols, and integers may be converted to characters.
If {\it object} is a string of length 1, then the
sole element of the string is returned.  If {\it object} is a symbol
whose print name is of length 1, then the sole element of the print name
is returned.  If {\it object} is an integer {\it n}, then \cd{(int-char {\it n})}
is returned.  See \cd{character}.
\begin{lisp}
(coerce "a" 'character) \EV\ \#{\Xbackslash}a
\end{lisp}
\end{itemize}
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to eliminate \cd{int-char} from Common Lisp.
Presumably this eliminates the possibility of coercing an
integer to a character, although the vote did not address
this question directly.
\end{newer}

\begin{itemize}
\item
Any non-complex number can be converted to a \cd{short-float},
\cd{single-float}, \cd{double-float}, or \cd{long-float}.  If simply \cd{float}
is specified, and {\it object} is not already a \cd{float} of some kind, then
the object is converted to a \cd{single-float}.
\begin{lisp}
(coerce 0 'short-float) \EV\ 0.0S0 \\
(coerce 3.5L0 'float) \EV\ 3.5L0 \\
(coerce 7/2 'float) \EV\ 3.5
\end{lisp}

\item
Any number can be converted to a complex number.
If the number is not already complex, then a zero imaginary part
is provided by coercing the integer zero to the type of the given real part.
(If the given real part is rational, however, then the rule of
canonical representation for complex rationals will result
in the immediate re-conversion of the result from type \cd{complex}
back to type \cd{rational}.)
\begin{lisp}
(coerce 4.5s0 'complex) \EV\ \#C(4.5S0 0.0S0) \\
(coerce 7/2 'complex) \EV\ 7/2 \\
(coerce \#C(7/2 0) '(complex double-float)) \\
~~~\EV\ \#C(3.5D0 0.0D0)
\end{lisp}

\item
Any object may be coerced to type \cd{t}.
\begin{lisp}
(coerce x 't) \EQ\ (identity x) \EQ\ x
\end{lisp}
\end{itemize}

\begin{newer}
X3J13 voted in June 1988 \issue{FUNCTION-TYPE}
to allow coercion of certain objects to the type \cd{function}:
\begin{itemize}
\item
A symbol or lambda-expression can be converted to a function.
A symbol is coerced to type \cd{function} as if by applying
\cd{symbol-function} to the symbol; an error is signaled if the predicate
\cd{fboundp} is not true of
the symbol or if the symbol names a macro or special form.
A list {\it x} whose {\it car} is the symbol \cd{lambda}
is coerced to a function as if by execution of \cd{(eval {\Xbq}\#',{\it x})},
that is, of \cd{(eval (list 'function~{\it x}))}.
\end{itemize}
\end{newer}

Coercions from floating-point numbers to rationals and from ratios
to integers are purposely {\it not} provided because of rounding
problems.  The functions \cd{rational}, \cd{rationalize},
\cd{floor}, \cd{ceiling}, \cd{truncate}, and \cd{round} may be used for
such purposes.  Similarly, coercions from characters to integers
are purposely not provided; \cd{char-code} or \cd{char-int} may be
used explicitly to perform such conversions.
\end{defun}

\section{Determining the Type of an Object}

The following function may be used to obtain a type specifier
describing the type of a given object.

\begin{defun}[Function]
type-of object

\begin{obsolete}
\noindent
\cd{(type-of {\it object})} returns an implementation-dependent result:
some {\it type} of which the {\it object} is a member.  Implementors
are encouraged to arrange for
\cd{type-of} to return the most specific type that can be
conveniently computed and is likely to be useful to the user.
If the argument is a user-defined named
structure created by \cd{defstruct}, then \cd{type-of} will return the type name
of that structure.
Because the result is implementation-dependent, it is usually better
to use \cd{type-of} primarily for debugging purposes;
however, in a few situations portable code requires the use of
\cd{type-of}, such as when the result is to be given to the
\cd{coerce} or \cd{map} function.
On the other hand, often the \cd{typep} function
or the \cd{typecase} construct
is more appropriate than \cd{type-of}.
\end{obsolete}

\beforenoterule
\begin{incompatibility}
In MacLisp the function \cd{type-of} is called \cd{typep},
and anomalously so, for it is not a predicate.
\end{incompatibility}
\afternoterule

\begin{new}
Many have observed (and rightly so) that this specification is totally wimpy
and therefore nearly useless.  X3J13 voted in June 1989
\issue{TYPE-OF-UNDERCONSTRAINED}
to place the following constraints on \cd{type-of}:
\begin{itemize}
\item
Let {\it x} be an object such that \cd{(typep~{\it x}~{\it type})}
is true and {\it type} is one of the following:

\begin{flushleft}
\cf
\begin{tabular}{@{}llll@{}}
array          & float        & package        & sequence \\
bit-vector     & function     & pathname       & short-float \\
character      & hash-table   & random-state~~ & single-float \\
complex        & integer      & ratio          & stream \\
condition      & long-float~~ & rational       & string \\
cons           & null         & readtable      & symbol \\
double-float~~ & number       & restart        & vector
\end{tabular}
\end{flushleft}

Then
\cd{(subtypep (type-of {\it x}) {\it type}))}
must return the values \cd{t} and \cd{t}; that is, \cd{type-of} applied
to {\it x} must return either {\it type} itself or a subtype of {\it type}
that \cd{subtypep} can recognize in that implementation.

\item
For any object {\it x}, \cd{(subtypep (type-of {\it x}) (class-of {\it x}))}
must produce the values \cd{t} and \cd{t}.

\item
For every object {\it x}, \cd{(typep {\it x} (type-of {\it x}))}
must be true.  (This implies that \cd{type-of} can never return \cd{nil},
for no object is of type \cd{nil}.)

\item
\cd{type-of} never returns \cd{t} and never uses
a \cd{satisfies}, \cd{and}, \cd{or}, \cd{not},
or \cd{values} type specifier in its result.

\item
For objects of CLOS metaclass \cd{structure-class} or of \cd{standard-class},
\cd{type-of} returns the proper name of the class returned by \cd{class-of}
if it has a proper name, and otherwise returns the class itself.
In particular,
for any object created by a \cd{defstruct} constructor function,
where the \cd{defstruct} had the name {\it name} and no \cd{:type} option,
\cd{type-of} will return {\it name}.
\end{itemize}

As an example, \cd{(type-of "acetylcholinesterase")}
may return \cd{string} or \cd{simple-string} or \cd{(simple-string ~20)},
but not \cd{array} or \cd{simple-vector}.
As another example, it is permitted for
\cd{(type-of 1729)} to return
\cd{integer} or \cd{fixnum} (if it is indeed a fixnum) or
\cd{(signed-byte 16)} or \cd{(integer 1729 1729)} or \cd{(integer 1685 1750)}
% Bach's "St. Matthew Passion"
or even \cd{(mod 1730)}, but not \cd{rational} or \cd{number}, because
\begin{lisp}
(typep (+ (expt 9 3) (expt 10 3)) 'integer)
\end{lisp}
is true, \cd{integer} is in the list of types mentioned above, and
\begin{lisp}
(subtypep (type-of (+ (expt 1 3) (expt 12 3))) 'integer)
\end{lisp}
would be false if \cd{type-of} were to return \cd{rational} or \cd{number}.
% Ramanujan and Hardy?
\end{new}
\end{defun}



\begin{new}

\section{Type Upgrading}

X3J13 voted in January 1989
\issue{ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS}
to add new functions by which a program
can determine, in a given Common Lisp implementation, how that
implementation will {\it upgrade} a type when constructing an array
specialized to contain elements of that type,
or a complex number specialized to contain parts of that type.


\begin{defun}[Function]
upgraded-array-element-type type

A type specifier is returned, indicating the element type
of the most specialized array representation capable of holding
items of the specified argument {\it type}.
The result is necessarily a supertype of the given {\it type}.
Furthermore, if a type {\it A} is a subtype of type {\it B}, then
\cd{(upgraded-array-element-type {\it A})} is a subtype of
\cd{(upgraded-array-element-type {\it B})}.

The manner in which an array element type is upgraded depends
only on the element type as such and not on any other property of
the array such as size, rank, adjustability,
presence or absence of a fill pointer, or displacement.

\beforenoterule
\begin{rationale}
If upgrading were allowed to depend on any of these properties,
all of which can be referred to, directly or indirectly, in the
language of type specifiers, then it would not be possible
to displace an array in a consistent and dependable manner
to another array created with the same \cd{:element-type} argument
but differing in one of these properties.
\end{rationale}
\afternoterule

Note that \cd{upgraded-array-element-type} could be defined as
\begin{lisp}
(defun upgraded-array-element-type (type) \\
~~(array-element-type (make-array 0 :element-type type)))
\end{lisp}
but this definition has the disadvantage of allocating an array and
then immediately discarding it.  The clever implementor surely can
conjure up a more practical approach.
\end{defun}


\begin{defun}[Function]
upgraded-complex-part-type type

A type specifier is returned, indicating the element type
of the most specialized complex number representation capable of having
parts of the specified argument {\it type}.
The result is necessarily a supertype of the given {\it type}.
Furthermore, if a type {\it A} is a subtype of type {\it B}, then
\cd{(upgraded-complex-part-type {\it A})} is a subtype of
\cd{(upgraded-complex-part-type {\it B})}.
\end{defun}

\end{new}
