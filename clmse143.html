<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Programmer Interface Concepts</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-28 14:08:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 56--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse144.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html#tailclmch28.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse143.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html#clmse143.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">28.1   </span> <a 
href="clm.html#QQ2-176-401" id="x176-36000028.1">Programmer Interface Concepts</a></h3>
<!--l. 58--><p class="noindent" >The Объектная система Common Lisp&#x2019;а (CLOS) is an object-oriented extension
to Common Lisp. It is based on generic functions, multiple inheritance,
declarative method combination, and a meta-object protocol.
<!--l. 62--><p class="indent" >   The ﬁrst two parts of this speciﬁcation describe the standard Programmer
Interface for the Объектная система Common Lisp&#x2019;а. The ﬁrst part,
Programmer Interface Concepts, contains a description of the concepts of the
Объектная система Common Lisp&#x2019;а, and the second part, Functions in
the Programmer Interface, contains a description of the functions and
macros in the Объектная система Common Lisp&#x2019;а Programmer Interface.
The third part, The Объектная система Common Lisp&#x2019;а Meta-Object
Protocol, explains how the Объектная система Common Lisp&#x2019;а can be
customized. [The third part has not yet been approved by X3J13 for inclusion
in the forthcoming Common Lisp standard and is not included in this
book.—GLS]
<!--l. 73--><p class="indent" >   The fundamental objects of the Объектная система Common Lisp&#x2019;а are
classes, instances, generic functions, and methods.
<!--l. 76--><p class="indent" >   A <i>class</i> object determines the structure and behavior of a set of other objects,
which are called its <i>instances</i>. Every Common Lisp object is an <i>instance</i> of a
class. The class of an object determines the set of operations that can be
performed on the object.
<!--l. 81--><p class="indent" >   A <i>generic function</i> is a function whose behavior depends on the classes or
identities of the arguments supplied to it. A generic function object contains a set
of methods, a lambda-list, a method combination type, and other information.
The <i>methods</i> deﬁne the class-speciﬁc behavior and operations of the generic
function; a method is said to <i>specialize</i> a generic function. When invoked, a
generic function executes a subset of its methods based on the classes of its
arguments.
<!--l. 90--><p class="indent" >   A generic function can be used in the same ways as an ordinary function in
Common Lisp; in particular, a generic function can be used as an argument to
<a 
href="clmse37.html#x49-95004r69">funcall</a> and <a 
href="clmse37.html#x49-95002r68">apply</a> and can be given a global or a local name.
<!--l. 95--><p class="indent" >   A <i>method</i> is an object that contains a method function, a sequence of
<i>parameter specializers</i> that specify when the given method is applicable, and a
                                                                          

                                                                          
sequence of <i>qualiﬁers</i> that is used by the <i>method combination</i> facility to
distinguish among methods. Each required formal parameter of each method has
an associated parameter specializer, and the method will be invoked only on
arguments that satisfy its parameter specializers.
<!--l. 103--><p class="indent" >   The method combination facility controls the selection of methods, the order
in which they are run, and the values that are returned by the generic
function. The Объектная система Common Lisp&#x2019;а oﬀers a default method
combination type and provides a facility for declaring new types of method
combination.
<!--l. 109--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.1   </span> <a 
href="clmli1.html#QQ2-176-402" id="x176-36100028.1.1">Error Terminology</a></h4>
<!--l. 112--><p class="noindent" >The terminology used in this chapter to describe erroneous situations diﬀers from
the terminology used in the ﬁrst edition. The new terminology involves <i>situations</i>;
a situation is the evaluation of an expression in some speciﬁc context. For
example, a situation might be the invocation of a function on arguments that fail
to satisfy some speciﬁed constraints.
<!--l. 120--><p class="indent" >   In the speciﬁcation of the Объектная система Common Lisp&#x2019;а, the behavior
of programs in all situations is described, and the options available to the
implementor are deﬁned. No implementation is allowed to extend the syntax or
semantics of the Объектная система except as explicitly deﬁned in the
Объектная система speciﬁcation. In particular, no implementation is allowed to
extend the syntax of the Объектная система in such a way that ambiguity
between the speciﬁed syntax of the Объектная система and those extensions is
possible.
<div class=flushdesc>
<!--l. 129--><p class="indent" >
      <ul><li><b>
“When situation <i>S</i> occurs, an error is signaled.” </b></li>
      <!--l. 131--><p class="noindent" >This terminology has the following meaning:
           <ul class="itemize1">
           <li class="itemize">If this situation occurs, an error will be signaled in the interpreter
           and in code compiled under all compiler safety optimization levels.
                                                                          

                                                                          
           </li>
           <li class="itemize">Valid programs may rely on the fact that an error will be signaled
           in the interpreter and in code compiled under all compiler safety
           optimization levels.
           </li>
           <li class="itemize">Every  implementation  is  required  to  detect  such  an  error  in
           the interpreter and in code compiled under all compiler safety
           optimization levels.
           </li></ul>
      <li><b>
“When situation <i>S</i> occurs, an error should be signaled.” </b></li>
      <!--l. 151--><p class="noindent" >This terminology has the following meaning:
           <ul class="itemize1">
           <li class="itemize">If this situation occurs, an error will be signaled at least in the
           interpreter and in code compiled under the safest compiler safety
           optimization level.
           </li>
           <li class="itemize">Valid programs may not rely on the fact that an error will be
           signaled.
           </li>
           <li class="itemize">Every implementation is required to detect such an error at least
           in the interpreter and in code compiled under the safest compiler
           safety optimization level.
           </li>
           <li class="itemize">When  an  error  is  not  signaled,  the  results  are  undeﬁned  (see
           below).
           </li></ul>
      <li><b>
“When situation <i>S</i> occurs, the results are undeﬁned.” </b></li>
      <!--l. 173--><p class="noindent" >This terminology has the following meaning:
                                                                          

                                                                          
           <ul class="itemize1">
           <li class="itemize">If this situation occurs, the results are unpredictable. The results
           may range from harmless to fatal.
           </li>
           <li class="itemize">Implementations are allowed to detect this situation and signal an
           error, but no implementation is required to detect the situation.
           </li>
           <li class="itemize">No valid program may depend on the eﬀects of this situation, and
           all valid programs are required to treat the eﬀects of this situation
           as unpredictable.
           </li></ul>
      <li><b>
“When situation <i>S</i> occurs, the results are unspeciﬁed.” </b></li>
      <!--l. 192--><p class="noindent" >This terminology has the following meaning:
           <ul class="itemize1">
           <li class="itemize">The eﬀects of this situation are not speciﬁed in the Объектная
           система, but the eﬀects are harmless.
           </li>
           <li class="itemize">Implementations are allowed to specify the eﬀects of this situation.
           </li>
           <li class="itemize">No portable program can depend on the eﬀects of this situation,
           and all portable programs are required to treat the situation as
           unpredictable but harmless.
           </li></ul>
      <li><b>
“The Объектная система Common Lisp&#x2019;а may be extended to cover situation <i>S</i>.” </b></li>
      <!--l. 211--><p class="noindent" >The meaning of this terminology is that an implementation is free to treat
      situation <i>S</i> in one of three ways:
           <ul class="itemize1">
           <li class="itemize">When  situation  <i>S</i> occurs,  an  error  is  signaled  at  least  in  the
                                                                          

                                                                          
           interpreter and in code compiled under the safest compiler safety
           optimization level.
           </li>
           <li class="itemize">When situation <i>S</i> occurs, the results are undeﬁned.
           </li>
           <li class="itemize">When situation <i>S</i> occurs, the results are deﬁned and speciﬁed.
           </li></ul>
      <!--l. 227--><p class="noindent" >In addition, this terminology has the following meaning:
           <ul class="itemize1">
           <li class="itemize">No portable program can depend on the eﬀects of this situation,
           and all portable programs are required to treat the situation as
           undeﬁned.
           </li></ul>
      <li><b>
“Implementations are free to extend the syntax <i>S</i>.” </b></li>
      <!--l. 240--><p class="noindent" >This terminology has the following meaning:
           <ul class="itemize1">
           <li class="itemize">Implementations are allowed to deﬁne unambiguous extensions to
           syntax <i>S</i>.
           </li>
           <li class="itemize">No  portable  program  can  depend  on  this  extension,  and  all
           portable programs are required to treat the syntax as meaningless.
           </li></ul>
      </ul>
</div>
<!--l. 254--><p class="indent" >   The Объектная система Common Lisp&#x2019;а speciﬁcation may disallow certain
extensions while allowing others.
                                                                          

                                                                          
<!--l. 257--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.2   </span> <a 
href="clmli1.html#QQ2-176-403" id="x176-36200028.1.2">Classes</a></h4>
<!--l. 260--><p class="noindent" >A <i>class</i> is an object that determines the structure and behavior of a set of other
objects, which are called its <i>instances</i>.
<!--l. 263--><p class="indent" >   A class can inherit structure and behavior from other classes. A class whose
deﬁnition refers to other classes for the purpose of inheriting from them is said to
be a <i>subclass</i> of each of those classes. The classes that are designated
for purposes of inheritance are said to be <i>superclasses</i> of the inheriting
class.
<!--l. 270--><p class="indent" >   A class can have a <i>name</i>. The function <a 
href="clmse144.html#x177-411012r840">class-name</a> takes a class object and
returns its name. The name of an anonymous class is <a 
href="clmse31.html#x42-74002r18">nil</a>. A symbol can <i>name</i> a
class. The function <a 
href="clmse144.html#x177-415038r867">ﬁnd-class</a> takes a symbol and returns the class that the symbol
names. A class has a <i>proper name</i> if the name is a symbol and if the name of the
class names that class. That is, a class <i>C</i> has the <i>proper name</i> <i>S</i> if <i>S</i> <span class="math"> =</span>
(class-name <i>C</i>) and <i>C</i> <span class="math"> =</span> (ﬁnd-class <i>S</i>). Notice that it is possible for (ﬁnd-class
<span class="math">S<sub>1</sub></span>) <span class="math"> =</span> (ﬁnd-class <span class="math">S<sub>2</sub></span>) and <span class="math">S<sub>1</sub>≠<i>S</i><sub>2</sub></span>. If <i>C</i> <span class="math"> =</span> (ﬁnd-class <i>S</i>), we say that <i>C</i> is the
<i>class named</i> <i>S</i>.
<!--l. 283--><p class="indent" >   A class <span class="math">C<sub>1</sub></span> is a <i>direct superclass</i> of a class <span class="math">C<sub>2</sub></span> if <span class="math">C<sub>2</sub></span> explicitly designates <span class="math">C<sub>1</sub></span> as
a superclass in its deﬁnition. In this case, <span class="math">C<sub>2</sub></span> is a <i>direct subclass</i> of <span class="math">C<sub>1</sub></span>. A class <span class="math">C<sub>n</sub></span>
is a <i>superclass</i> of a class <span class="math">C<sub>1</sub></span> if there exists a series of classes <span class="math">C<sub>2</sub>,…,C<sub>n−1</sub></span> such that
<span class="math">C<sub>i+1</sub></span> is a direct superclass of <span class="math">C<sub>i</sub></span> for <span class="math">1 ≤<i>i</i> &#x003C; <i>n</i></span>. In this case, <span class="math">C<sub>1</sub></span> is a <i>subclass</i> of <span class="math">C<sub>n</sub></span>.
A class is considered neither a superclass nor a subclass of itself. That is, if
<span class="math">C<sub>1</sub></span> is a superclass of <span class="math">C<sub>2</sub></span>, then <span class="math">C<sub>1</sub>≠C<sub>2</sub></span>. The set of classes consisting of
some given class <i>C</i> along with all of its superclasses is called “<i>C</i> and its
superclasses.”
<!--l. 298--><p class="indent" >   Each class has a <i>class precedence list</i>, which is a total ordering on the set of
the given class and its superclasses. The total ordering is expressed as a list
ordered from most speciﬁc to least speciﬁc. The class precedence list is used in
several ways. In general, more speciﬁc classes can <i>shadow</i>, or override, features
that would otherwise be inherited from less speciﬁc classes. The method selection
and combination process uses the class precedence list to order methods from
most speciﬁc to least speciﬁc.
<!--l. 307--><p class="indent" >   When a class is deﬁned, the order in which its direct superclasses are
mentioned in the deﬁning form is important. Each class has a <i>local precedence
order</i>, which is a list consisting of the class followed by its direct superclasses in
the order mentioned in the deﬁning form.
<!--l. 313--><p class="indent" >   A class precedence list is always consistent with the local precedence order of
each class in the list. The classes in each local precedence order appear within the
                                                                          

                                                                          
class precedence list in the same order. If the local precedence orders are
inconsistent with each other, no class precedence list can be constructed, and an
error is signaled. The class precedence list and its computation is discussed in
section <a 
href="#x176-37300028.1.5">28.1.5<!--tex4ht:ref: Determining-the-Class-Precedence-List-SECTION --></a>.
<!--l. 321--><p class="indent" >   Classes are organized into a <i>directed acyclic graph</i>. There are two
distinguished classes, named <a 
href="clmse31.html#x42-74004r19">t</a> and standard-object. The class named <a 
href="clmse31.html#x42-74004r19">t</a> has
no superclasses. It is a superclass of every class except itself. The class
named standard-object is an instance of the class standard-class and is
a superclass of every class that is an instance of standard-class except
itself.
<!--l. 328--><p class="indent" >   There is a mapping from the Common Lisp Object System class space into the
Common Lisp type space. Many of the standard Common Lisp types have a
corresponding class that has the same name as the type. Some Common Lisp
types do not have a corresponding class. The integration of the type and class
systems is discussed in section <a 
href="#x176-37200028.1.4">28.1.4<!--tex4ht:ref: Integrating-Types-and-Classes-SECTION --></a>.
<!--l. 335--><p class="indent" >   Classes are represented by objects that are themselves instances of
classes. The class of the class of an object is termed the <i>metaclass</i> of
that object. When no misinterpretation is possible, the term <i>metaclass</i>
will be used to refer to a class that has instances that are themselves
classes. The metaclass determines the form of inheritance used by the
classes that are its instances and the representation of the instances of
those classes. The Объектная система Common Lisp&#x2019;а provides a default
metaclass, standard-class, that is appropriate for most programs. The
meta-object protocol provides mechanisms for deﬁning and using new
metaclasses.
<!--l. 346--><p class="indent" >   Except where otherwise speciﬁed, all classes mentioned in this chapter are
instances of the class standard-class, all generic functions are instances of the
class standard-generic-function, and all methods are instances of the class
standard-method.
<!--l. 351--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-36300028.1.2" id="x176-36300028.1.2">Deﬁning Classes</a></h5>
<!--l. 353--><p class="noindent" >The macro <a 
href="clmse144.html#x177-411022r845">defclass</a> is used to deﬁne a new named class. The deﬁnition of a class
includes the following:
      <ul class="itemize1">
                                                                          

                                                                          
      <li class="itemize">The name of the new class. For newly deﬁned classes this is a proper
      name.
      </li>
      <li class="itemize">The list of the direct superclasses of the new class.
      </li>
      <li class="itemize">A set of <i>slot speciﬁers</i>. Each slot speciﬁer includes the name of the
      slot and zero or more <i>slot options</i>. A slot option pertains only to a
      single slot. If a class deﬁnition contains two slot speciﬁers with the same
      name, an error is signaled.
      </li>
      <li class="itemize">A set of <i>class options</i>. Each class option pertains to the class as a whole.</li></ul>
<!--l. 371--><p class="noindent" >The slot options and class options of the <a 
href="clmse144.html#x177-411022r845">defclass</a> form provide mechanisms for the
following:
      <ul class="itemize1">
      <li class="itemize">Supplying a default initial value form for a given slot.
      </li>
      <li class="itemize">Requesting  that  methods  for  generic  functions  be  automatically
      generated for reading or writing slots.
      </li>
      <li class="itemize">Controlling whether a given slot is shared by instances of the class or
      whether each instance of the class has its own slot.
      </li>
      <li class="itemize">Supplying a set of initialization arguments and initialization argument
      defaults to be used in instance creation.
      </li>
      <li class="itemize">Indicating that the metaclass is to be other than the default.
      </li>
      <li class="itemize">Indicating the expected type for the value stored in the slot.
                                                                          

                                                                          
      </li>
      <li class="itemize">Indicating the documentation string for the slot.
      </li></ul>
<!--l. 398--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-36400028.1.2" id="x176-36400028.1.2">Creating Instances of Classes</a></h5>
<!--l. 400--><p class="noindent" >The generic function <a 
href="clmse144.html#x177-418012r880">make-instance</a> creates and returns a new instance of a class.
The Объектная система provides several mechanisms for specifying how a new
instance is to be initialized. For example, it is possible to specify the initial values
for slots in newly created instances either by giving arguments to <a 
href="clmse144.html#x177-418012r880">make-instance</a>
or by providing default initial values.
<!--l. 407--><p class="indent" >   Further initialization activities can be performed by methods written for
generic functions that are part of the initialization protocol. The complete
initialization protocol is described in section <a 
href="#x176-39100028.1.9">28.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<!--l. 412--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-36500028.1.2" id="x176-36500028.1.2">Slots</a></h5>
<!--l. 414--><p class="noindent" >An object that has standard-class as its metaclass has zero or more named slots.
The slots of an object are determined by the class of the object. Each slot can
hold one value. The name of a slot is a symbol that is syntactically valid for use as
a variable name.
<!--l. 420--><p class="indent" >   When a slot does not have a value, the slot is said to be <i>unbound</i>. When an
unbound slot is read, the generic function <a 
href="clmse144.html#x177-418065r906">slot-unbound</a> is invoked. The
system-supplied primary method for <a 
href="clmse144.html#x177-418065r906">slot-unbound</a> signals an error.
<!--l. 424--><p class="indent" >   The default initial value form for a slot is deﬁned by the  :initform slot option.
When the :initform form is used to supply a value, it is evaluated in the lexical
environment in which the <a 
href="clmse144.html#x177-411022r845">defclass</a> form was evaluated. The :initform along with
the lexical environment in which the <a 
href="clmse144.html#x177-411022r845">defclass</a> form was evaluated is called a
<i>captured</i> :initform. See section <a 
href="#x176-39100028.1.9">28.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<!--l. 432--><p class="indent" >   A <i>local slot</i> is deﬁned to be a slot that is visible to exactly one instance,
namely the one in which the slot is allocated. A <i>shared slot</i> is deﬁned to be
a slot that is visible to more than one instance of a given class and its
subclasses.
<!--l. 437--><p class="indent" >   A class is said to <i>deﬁne</i> a slot with a given name when the <a 
href="clmse144.html#x177-411022r845">defclass</a> form for
                                                                          

                                                                          
that class contains a slot speciﬁer with that name. Deﬁning a local slot does not
immediately create a slot; it causes a slot to be created each time an
instance of the class is created. Deﬁning a shared slot immediately creates a
slot.
<!--l. 443--><p class="indent" >   The :allocation slot option to <a 
href="clmse144.html#x177-411022r845">defclass</a> controls the kind of slot that is deﬁned.
If the value of the :allocation slot option is :instance, a local slot is created. If the
value of :allocation is :class, a shared slot is created.
<!--l. 448--><p class="indent" >   A slot is said to be <i>accessible</i> in an instance of a class if the slot is deﬁned by
the class of the instance or is inherited from a superclass of that class. At most
                                                                          

                                                                          
one slot of a given name can be accessible in an instance. A shared slot deﬁned by
a class is accessible in all instances of that class. A detailed explanation of the
inheritance of slots is given in section <a 
href="#x176-36900028.1.3">28.1.3<!--tex4ht:ref: Inheritance-of-Slots-and-Slot-Options-SECTION --></a>.
<!--l. 456--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-36600028.1.2" id="x176-36600028.1.2">Accessing Slots</a></h5>
<!--l. 458--><p class="noindent" >Slots can be accessed in two ways: by use of the primitive function <a 
href="clmse144.html#x177-418067r907">slot-value</a> and
by use of generic functions generated by the <a 
href="clmse144.html#x177-411022r845">defclass</a> form.
<!--l. 462--><p class="indent" >   The function <a 
href="clmse144.html#x177-418067r907">slot-value</a> can be used with any slot name speciﬁed in the
<a 
href="clmse144.html#x177-411022r845">defclass</a> form to access a speciﬁc slot accessible in an instance of the given
class.
<!--l. 466--><p class="indent" >   The macro <a 
href="clmse144.html#x177-411022r845">defclass</a> provides syntax for generating methods to read and write
slots. If a <i>reader</i> is requested, a method is automatically generated for reading the
value of the slot, but no method for storing a value into it is generated. If a <i>writer</i>
is requested, a method is automatically generated for storing a value into the slot,
but no method for reading its value is generated. If an <i>accessor</i> is requested, a
method for reading the value of the slot and a method for storing a value into the
slot are automatically generated. Reader and writer methods are implemented
using <a 
href="clmse144.html#x177-418067r907">slot-value</a>.
<!--l. 477--><p class="indent" >   When a reader or writer is speciﬁed for a slot, the name of the generic
function to which the generated method belongs is directly speciﬁed. If the
name speciﬁed for the writer option is the symbol <i>name</i>, the name of the
generic function for writing the slot is the symbol <i>name</i>, and the generic
function takes two arguments: the new value and the instance, in that order.
If the name speciﬁed for the accessor option is the symbol <i>name</i>, the
name of the generic function for reading the slot is the symbol name,
and the name of the generic function for writing the slot is the list (setf
<i>name</i>).
<!--l. 488--><p class="indent" >   A generic function created or modiﬁed by supplying reader, writer,
or accessor slot options can be treated exactly as an ordinary generic
function.
<!--l. 492--><p class="indent" >   Note that <a 
href="clmse144.html#x177-418067r907">slot-value</a> can be used to read or write the value of a slot whether or
not reader or writer methods exist for that slot. When <a 
href="clmse144.html#x177-418067r907">slot-value</a> is used, no
reader or writer methods are invoked.
<!--l. 497--><p class="indent" >   The macro <a 
href="clmse144.html#x177-420002r914">with-slots</a> can be used to establish a lexical environment in
which speciﬁed slots are lexically available as if they were variables. The
                                                                          

                                                                          
macro <a 
href="clmse144.html#x177-420002r914">with-slots</a> invokes the function <a 
href="clmse144.html#x177-418067r907">slot-value</a> to access the speciﬁed
slots.
<!--l. 502--><p class="indent" >   The macro <a 
href="clmse144.html#x177-418077r912">with-accessors</a> can be used to establish a lexical environment in
which speciﬁed slots are lexically available through their accessors as if they were
variables. The macro <a 
href="clmse144.html#x177-418077r912">with-accessors</a> invokes the appropriate accessors to access
the speciﬁed slots. Any accessors speciﬁed by <a 
href="clmse144.html#x177-418077r912">with-accessors</a> must already have
been deﬁned before they are used.
                                                                          

                                                                          
<!--l. 511--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.3   </span> <a 
href="clmli1.html#QQ2-176-408" id="x176-36700028.1.3">Inheritance</a></h4>
<!--l. 514--><p class="noindent" >A class can inherit methods, slots, and some <a 
href="clmse144.html#x177-411022r845">defclass</a> options from its superclasses.
The following sections describe the inheritance of methods, the inheritance of slots
and slot options, and the inheritance of class options.
<!--l. 519--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-36800028.1.3" id="x176-36800028.1.3">Inheritance of Methods</a></h5>
<!--l. 522--><p class="noindent" >A subclass inherits methods in the sense that any method applicable to all
instances of a class is also applicable to all instances of any subclass of that
class.
<!--l. 526--><p class="indent" >   The inheritance of methods acts the same way regardless of whether the
method was created by using one of the method-deﬁning forms or by
using one of the <a 
href="clmse144.html#x177-411022r845">defclass</a> options that causes methods to be generated
automatically.
<!--l. 531--><p class="indent" >   The inheritance of methods is described in detail in section <a 
href="#x176-38200028.1.7">28.1.7<!--tex4ht:ref: Method-Selection-and-Combination-SECTION --></a>.
<!--l. 535--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-36900028.1.3" id="x176-36900028.1.3">Inheritance of Slots and Slot Options</a></h5>
<!--l. 538--><p class="noindent" >The set of names of all slots accessible in an instance of a class <i>C</i> is the
union of the sets of names of slots deﬁned by <i>C</i> and its superclasses.
The <i>structure</i> of an instance is the set of names of local slots in that
instance.
<!--l. 543--><p class="indent" >   In the simplest case, only one class among <i>C</i> and its superclasses deﬁnes a slot
with a given slot name. If a slot is deﬁned by a superclass of <i>C</i>, the slot is said to
be <i>inherited</i>. The characteristics of the slot are determined by the slot
speciﬁer of the deﬁning class. Consider the deﬁning class for a slot <i>S</i>. If
the value of the :allocation slot option is :instance, then <i>S</i> is a local slot
and each instance of <i>C</i> has its own slot named <i>S</i> that stores its own
value. If the value of the :allocation slot option is :class, then <i>S</i> is a shared
slot, the class that deﬁned <i>S</i> stores the value, and all instances of <i>C</i> can
access that single slot. If the :allocation slot option is omitted, :instance is
used.
                                                                          

                                                                          
<!--l. 556--><p class="indent" >   In general, more than one class among <i>C</i> and its superclasses can
deﬁne a slot with a given name. In such cases, only one slot with the
given name is accessible in an instance of <i>C</i>, and the characteristics of
that slot are a combination of the several slot speciﬁers, computed as
follows:
      <ul class="itemize1">
      <li class="itemize">All the slot speciﬁers for a given slot name are ordered from most
      speciﬁc to least speciﬁc, according to the order in <i>C</i>&#x2019;s class precedence
      list of the classes that deﬁne them. All references to the speciﬁcity of
      slot speciﬁers immediately following refer to this ordering.
      </li>
      <li class="itemize">The allocation of a slot is controlled by the most speciﬁc slot speciﬁer.
      If the most speciﬁc slot speciﬁer does not contain an :allocation slot
      option, :instance is used. Less speciﬁc slot speciﬁers do not aﬀect the
      allocation.
      </li>
      <li class="itemize">The default initial value form for a slot is the value of the :initform slot
      option in the most speciﬁc slot speciﬁer that contains one. If no slot
      speciﬁer contains an :initform slot option, the slot has no default initial
      value form.
      </li>
      <li class="itemize">The contents of a slot will always be of type (and <span class="math">T<sub>1</sub></span>  <span class="math">…</span> <span class="math">T<sub>n</sub></span>) where
      <span class="math">T<sub>1</sub>,…,T<sub>n</sub></span> are the values of the :type slot options contained in all of the
      slot speciﬁers. If no slot speciﬁer contains the :type slot option, the
      contents of the slot will always be of type <a 
href="clmse31.html#x42-74004r19">t</a>. The result of attempting
      to store in a slot a value that does not satisfy the type of the slot is
      undeﬁned.
      </li>
      <li class="itemize">The set of initialization arguments that initialize a given slot is the
      union of the initialization arguments declared in the :initarg slot options
      in all the slot speciﬁers.
      </li>
      <li class="itemize">The documentation string for a slot is the value of the :documentation
                                                                          

                                                                          
      slot option in the most speciﬁc slot speciﬁer that contains one. If no
      slot speciﬁer contains a :documentation slot option, the slot has no
      documentation string.</li></ul>
<!--l. 600--><p class="indent" >   A consequence of the allocation rule is that a shared slot can be shadowed. For
example, if a class <span class="math">C<sub>1</sub></span> deﬁnes a slot named <i>S</i> whose value for the :allocation slot
option is :class, that slot is accessible in instances of <span class="math">C<sub>1</sub></span> and all of its subclasses.
However, if <span class="math">C<sub>2</sub></span> is a subclass of <span class="math">C<sub>1</sub></span> and also deﬁnes a slot named <i>S</i>, <span class="math">C<sub>1</sub></span>&#x2019;s slot is not
shared by instances of <span class="math">C<sub>2</sub></span> and its subclasses. When a class <span class="math">C<sub>1</sub></span> deﬁnes a shared
slot, any subclass <span class="math">C<sub>2</sub></span> of <span class="math">C<sub>1</sub></span> will share this single slot unless the <a 
href="clmse144.html#x177-411022r845">defclass</a> form for
<span class="math">C<sub>2</sub></span> speciﬁes a slot of the same name or there is a superclass of <span class="math">C<sub>2</sub></span> that
precedes <span class="math">C<sub>1</sub></span> in the class precedence list of <span class="math">C<sub>2</sub></span> that deﬁnes a slot of the same
name.
<!--l. 613--><p class="indent" >   A consequence of the type rule is that the value of a slot satisﬁes the type
constraint of each slot speciﬁer that contributes to that slot. Because the result of
attempting to store in a slot a value that does not satisfy the type constraint
for the slot is undeﬁned, the value in a slot might fail to satisfy its type
constraint.
<!--l. 619--><p class="indent" >   The :reader, :writer, and :accessor slot options create methods rather than
deﬁne the characteristics of a slot. Reader and writer methods are inherited in the
sense described in section <a 
href="#x176-36800028.1.3">28.1.3<!--tex4ht:ref: Inheritance-of-Methods-SECTION --></a>.
<!--l. 624--><p class="indent" >   Methods that access slots use only the name of the slot and the type of the
slot&#x2019;s value. Suppose a superclass provides a method that expects to access a
shared slot of a given name, and a subclass deﬁnes a local slot with the same
name. If the method provided by the superclass is used on an instance of the
subclass, the method accesses the local slot.
<!--l. 631--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-37000028.1.3" id="x176-37000028.1.3">Inheritance of Class Options</a></h5>
<!--l. 633--><p class="noindent" >The :default-initargs class option is inherited. The set of defaulted initialization
arguments for a class is the union of the sets of initialization arguments
speciﬁed in the :default-initargs class options of the class and its superclasses.
When more than one default initial value form is supplied for a given
initialization argument, the default initial value form that is used is the one
supplied by the class that is most speciﬁc according to the class precedence
list.
<!--l. 643--><p class="indent" >   If a given :default-initargs class option speciﬁes an initialization argument of
                                                                          

                                                                          
the same name more than once, an error is signaled.
<!--l. 647--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-37100028.1.3" id="x176-37100028.1.3">Examples</a></h5>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass C1 ()
</td></tr></table>
<!--l. 650--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ((S1 :initform 5.4 :type number)</td></tr></table>
<!--l. 651--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (S2 :allocation :class)))</td></tr></table>
<!--l. 652--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 653--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass C2 (C1)</td></tr></table>
<!--l. 654--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ((S1 :initform 5 :type integer)</td></tr></table>
<!--l. 655--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (S2 :allocation :instance)</td></tr></table>
<!--l. 656--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (S3 :accessor C2-S3)))</td></tr></table>
<!--l. 658--><p class="indent" >
</div>
</div>
<!--l. 660--><p class="noindent" >Instances of the class C1 have a local slot named S1, whose default initial value is
5.4 and whose value should always be a number. The class C1 also has a shared
slot named S2.
<!--l. 664--><p class="indent" >   There is a local slot named S1 in instances of C2. The default initial value of
S1 is 5. The value of S1 will be of type (and integer number). There are also local
slots named S2 and S3 in instances of C2. The class C2 has a method for C2-S3
for reading the value of slot S3; there is also a method for (setf C2-S3) that writes
the value of S3.
<!--l. 673--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.4   </span> <a 
href="clmli1.html#QQ2-176-413" id="x176-37200028.1.4">Integrating Types and Classes</a></h4>
<!--l. 676--><p class="noindent" >The Объектная система Common Lisp&#x2019;а maps the space of classes into the
Common Lisp type space. Every class that has a proper name has a corresponding
type with the same name.
                                                                          

                                                                          
<!--l. 680--><p class="indent" >   The proper name of every class is a valid type speciﬁer. In addition, every class
object is a valid type speciﬁer. Thus the expression (typep <i>object class</i>)
evaluates to true if the class of <i>object</i> is <i>class</i> itself or a subclass of class. The
evaluation of the expression (subtypep <i>class1 class2</i>) returns the values
<a 
href="clmse31.html#x42-74004r19">t</a> and <a 
href="clmse31.html#x42-74004r19">t</a> if <i>class1</i> is a subclass of <i>class2</i> or if they are the same class;
otherwise it returns the values <a 
href="clmse31.html#x42-74002r18">nil</a> and <a 
href="clmse31.html#x42-74004r19">t</a>. If <i>I</i> is an instance of some class
<i>C</i> named <i>S</i> and <i>C</i> is an instance of standard-class, the evaluation of
the expression (type-of <i>I</i>) will return <i>S</i> if <i>S</i> is the proper name of <i>C</i>; if
<i>S</i> is not the proper name of <i>C</i>, the expression (type-of <i>I</i>) will return
<i>C</i>.
<!--l. 694--><p class="indent" >   Because the names of classes and class objects are type speciﬁers, they may be
used in the special form <a 
href="clmse50.html#x64-154002r126">the</a> and in type declarations.
<!--l. 697--><p class="indent" >   Many but not all of the predeﬁned Common Lisp type speciﬁers have a
corresponding class with the same proper name as the type. These type speciﬁers
are listed in table <a 
href="#x176-3720021">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a>. For example, the type array has a corresponding class
named array. No type speciﬁer that is a list, such as (vector double-ﬂoat
100), has a corresponding class. The form <a 
href="clmse24.html#x33-51002r6">deftype</a> does not create any
classes.
<!--l. 704--><p class="indent" >   Each class that corresponds to a predeﬁned Common Lisp type speciﬁer can
be implemented in one of three ways, at the discretion of each implementation. It
can be a <i>standard class</i> (of the kind deﬁned by <a 
href="clmse144.html#x177-411022r845">defclass</a>), a <i>structure class</i> (deﬁned
by <a 
href="clmse98.html#x122-226002r561">defstruct</a>), or a <i>built-in class</i> (implemented in a special, non-extensible
way).
<!--l. 711--><p class="indent" >   A built-in class is one whose instances have restricted capabilities or special
representations. Attempting to use <a 
href="clmse144.html#x177-411022r845">defclass</a> to deﬁne subclasses of a built-in
class signals an error. Calling <a 
href="clmse144.html#x177-418012r880">make-instance</a> to create an instance of a
built-in class signals an error. Calling <a 
href="clmse144.html#x177-418067r907">slot-value</a> on an instance of a built-in
class signals an error. Redeﬁning a built-in class or using <a 
href="clmse144.html#x177-411008r838">change-class</a>
to change the class of an instance to or from a built-in class signals an
error. However, built-in classes can be used as parameter specializers in
methods.
<!--l. 726--><p class="indent" >   It is possible to determine whether a class is a built-in class by checking the
metaclass. A standard class is an instance of standard-class, a built-in class
is an instance of built-in-class, and a structure class is an instance of
structure-class.
<!--l. 732--><p class="indent" >   Each structure type created by <a 
href="clmse98.html#x122-226002r561">defstruct</a> without using the :type option has a
corresponding class. This class is an instance of structure-class. The :include
option of <a 
href="clmse98.html#x122-226002r561">defstruct</a> creates a direct subclass of the class that corresponds to the
                                                                          

                                                                          
included structure.
<!--l. 743--><p class="indent" >   The purpose of specifying that many of the standard Common Lisp type
speciﬁers have a corresponding class is to enable users to write methods that
discriminate on these types. Method selection requires that a class precedence list
can be determined for each class.
<!--l. 749--><p class="indent" >   The hierarchical relationships among the Common Lisp type speciﬁers are
mirrored by relationships among the classes corresponding to those types. The
existing type hierarchy is used for determining the class precedence list for each
class that corresponds to a predeﬁned Common Lisp type. In some cases, the ﬁrst
edition did not specify a local precedence order for two supertypes of a given type
speciﬁer. For example, <a 
href="clmse32.html#x43-77002r22">null</a> is a subtype of both <a 
href="clmch10.html#x65-15600010">symbol</a> and <a 
href="clmse81.html#x101-202034r441">list</a>, but the ﬁrst
edition did not specify whether <a 
href="clmch10.html#x65-15600010">symbol</a> is more speciﬁc or less speciﬁc
than <a 
href="clmse81.html#x101-202034r441">list</a>. The CLOS speciﬁcation deﬁnes those relationships for all such
classes.
<!--l. 761--><p class="indent" >   Table <a 
href="#x176-3720021">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a> lists the set of classes required by the Объектная система that
correspond to predeﬁned Common Lisp type speciﬁers. The superclasses of each
such class are presented in order from most speciﬁc to most general, thereby
deﬁning the class precedence list for the class. The local precedence order for each
class that corresponds to a Common Lisp type speciﬁer can be derived from this
table.
<!--l. 769--><p class="indent" >   Individual implementations may be extended to deﬁne other type speciﬁers to
have a corresponding class. Individual implementations can be extended to
add other subclass relationships and to add other elements to the class
precedence lists in the above table as long as they do not violate the type
relationships and disjointness requirements speciﬁed in section ??. A
standard class deﬁned with no direct superclasses is guaranteed to be
disjoint from all of the classes in the table, except for the class named
<a 
href="clmse31.html#x42-74004r19">t</a>.
<!--l. 779--><p class="indent" >   [At this point the original CLOS report speciﬁed that certain Common Lisp
types were to appear in table <a 
href="#x176-3720021">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a> if and only if X3J13 voted to make them
disjoint from <a 
href="clmse80.html#x100-201062r423">cons</a>, <a 
href="clmch10.html#x65-15600010">symbol</a>, array, number, and <a 
href="clmse74.html#x92-193002r341">character</a>. X3J13 voted to do so in
June 1988 <a 
 id="dx176-372001"></a>. I have added these types and their class precedence lists to the table;
the new types are indicated by asterisks.—GLS]
   <div class="table">
                                                                          

                                                                          
<!--l. 789--><p class="indent" >   <a 
 id="x176-3720021"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 28.1: </span><span  
class="content">Class Precedence Lists for Predeﬁned Types</span></div><!--tex4ht:label?: x176-3720021 -->
<div class="flushleft" 
>
<!--l. 792--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Predeﬁned Common Lisp Type</td><td align="left" >Class Precedence List for Corresponding Class</td>
</tr><tr><td align="left" >array                                  </td><td align="left" >(array t)                                                  </td>
</tr><tr><td align="left" >bit-vector                            </td><td align="left" >(bit-vector vector array sequence t)               </td>
</tr><tr><td align="left" >character                             </td><td align="left" >(character t)                                            </td>
</tr><tr><td align="left" >complex                              </td><td align="left" >(complex number t)                                   </td>
</tr><tr><td align="left" >cons                                   </td><td align="left" >(cons list sequence t)                                 </td>
</tr><tr><td align="left" >ﬂoat                                   </td><td align="left" >(ﬂoat number t)                                        </td>
</tr><tr><td align="left" >function *                            </td><td align="left" >(function t)                                              </td>
</tr><tr><td align="left" >hash-table *                         </td><td align="left" >(hash-table t)                                           </td>
</tr><tr><td align="left" >integer                                </td><td align="left" >(integer rational number t)                          </td>
</tr><tr><td align="left" >list                                     </td><td align="left" >(list sequence t)                                        </td>
</tr><tr><td align="left" >null                                    </td><td align="left" >(null symbol list sequence t)                        </td>
</tr><tr><td align="left" >number                               </td><td align="left" >(number t)                                               </td>
</tr><tr><td align="left" >package *                            </td><td align="left" >(package t)                                              </td>
</tr><tr><td align="left" >pathname *                          </td><td align="left" >(pathname t)                                            </td>
</tr><tr><td align="left" >random-state *                     </td><td align="left" >(random-state t)                                       </td>
</tr><tr><td align="left" >ratio                                   </td><td align="left" >(ratio rational number t)                            </td>
</tr><tr><td align="left" >rational                               </td><td align="left" >(rational number t)                                   </td>
</tr><tr><td align="left" >readtable *                          </td><td align="left" >(readtable t)                                            </td>
</tr><tr><td align="left" >sequence                              </td><td align="left" >(sequence t)                                             </td>
</tr><tr><td align="left" >stream *                              </td><td align="left" >(stream t)                                                </td>
</tr><tr><td align="left" >string                                 </td><td align="left" >(string vector array sequence t)                    </td>
</tr><tr><td align="left" >symbol                                </td><td align="left" >(symbol t)                                               </td>
</tr><tr><td align="left" >t                                        </td><td align="left" >(t)                                                          </td>
</tr><tr><td align="left" >vector                                 </td><td align="left" >(vector array sequence t)                            </td></tr></table>
</div></div>
<!--l. 823--><p class="noindent" >[An asterisk indicates a type added to this table as a consequence of a portion of
the CLOS speciﬁcation that was conditional on X3J13 voting to make that type
disjoint from certain other built-in types <a 
 id="dx176-372003"></a>.—GLS]
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
   <h4 class="subsectionHead"><span class="titlemark">28.1.5   </span> <a 
href="clmli1.html#QQ2-176-415" id="x176-37300028.1.5">Determining the Class Precedence List</a></h4>
<!--l. 833--><p class="noindent" >The <a 
href="clmse144.html#x177-411022r845">defclass</a> form for a class provides a total ordering on that class and its direct
superclasses. This ordering is called the <i>local precedence order</i>. It is an ordered list
of the class and its direct superclasses. The <i>class precedence list</i> for a class <i>C</i> is a
total ordering on <i>C</i> and its superclasses that is consistent with the local
precedence orders for <i>C</i> and its superclasses.
<!--l. 840--><p class="indent" >   A class precedes its direct superclasses, and a direct superclass precedes all
other direct superclasses speciﬁed to its right in the superclasses list of the
<a 
href="clmse144.html#x177-411022r845">defclass</a> form. For every class <i>C</i>, deﬁne
<span class="math">
                  R<sub>C</sub> = {(C,C<sub>1</sub>), (C<sub>1</sub>,C<sub>2</sub>),…, (C<sub>n−1</sub>,C<sub>n</sub>)}
</span> where <span class="math">C<sub>1</sub>,…,C<sub>n</sub></span> are the direct superclasses of <i>C</i> in the order in which they are
mentioned in the <a 
href="clmse144.html#x177-411022r845">defclass</a> form. These ordered pairs generate the total ordering on
the class <i>C</i> and its direct superclasses.
<!--l. 851--><p class="indent" >   Let <span class="math">S<sub>C</sub></span> be the set of <i>C</i> and its superclasses. Let <i>R</i> be
<span class="math">
                                                                          

                                                                          
                             R = ⋃
  <sub>c ∈ S<sub>
C</sub></sub>R<sub>c</sub>
</span>
<!--l. 854--><p class="indent" >   The set <i>R</i> may or may not generate a partial ordering, depending on whether
the <span class="math">R<sub>c</sub></span>, <span class="math">c ∈ S<sub>C</sub></span>, are consistent; it is assumed that they are consistent and that <i>R</i>
generates a partial ordering. When the <span class="math">R<sub>c</sub></span> are not consistent, it is said that <i>R</i> is
inconsistent.
<!--l. 861--><p class="indent" >   To compute the class precedence list for <i>C</i>, topologically sort the elements
of <span class="math">S<sub>C</sub></span> with respect to the partial ordering generated by <i>R</i>. When the
topological sort must select a class from a set of two or more classes, none of
which are preceded by other classes with respect to <i>R</i>, the class selected is
chosen deterministically, as described below. If <i>R</i> is inconsistent, an error is
signaled.
                                                                          

                                                                          
<!--l. 872--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-37400028.1.5" id="x176-37400028.1.5">Topological Sorting</a></h5>
<!--l. 874--><p class="noindent" >Topological sorting proceeds by ﬁnding a class <i>C</i> in <span class="math">S<sub>C</sub></span> such that no other class
precedes that element according to the elements in <i>R</i>. The class <i>C</i> is placed ﬁrst
in the result. Remove <i>C</i> from <span class="math">S<sub>C</sub></span>, and remove all pairs of the form <span class="math">(C,D)</span>,
<span class="math">D ∈ S<sub>C</sub></span>, from <i>R</i>. Repeat the process, adding classes with no predecessors to
the end of the result. Stop when no element can be found that has no
predecessor.
<!--l. 883--><p class="indent" >   If <span class="math">S<sub>C</sub></span> is not empty and the process has stopped, the set <i>R</i> is inconsistent. If
every class in the ﬁnite set of classes is preceded by another, then <i>R</i> contains a
loop. That is, there is a chain of classes <span class="math">C<sub>1</sub>,…,C<sub>n</sub></span> such that <span class="math">C<sub>i</sub></span> precedes <span class="math">C<sub>i+1</sub></span>,
<span class="math">1 ≤ i &#x003C; n</span>, and <span class="math">C<sub>n</sub></span> precedes <span class="math">C<sub>1</sub></span>.
<!--l. 891--><p class="indent" >   Sometimes there are several classes from <span class="math">S<sub>C</sub></span> with no predecessors. In this case
select the one that has a direct subclass rightmost in the class precedence list
computed so far. If there is no such candidate class, <i>R</i> does not generate a partial
ordering—the <span class="math">R<sub>c</sub></span>, <span class="math">c ∈ S<sub>C</sub></span>, are inconsistent.
<!--l. 901--><p class="indent" >   In more precise terms, let <span class="math">{N<sub>1</sub>,…,N<sub>m</sub>}</span>, <span class="math">m ≥ 2</span>, be the classes from <span class="math">S<sub>C</sub></span> with no
predecessors. Let <span class="math">(C<sub>1</sub>…C<sub>n</sub>)</span>, <span class="math">n ≥ 1</span>, be the class precedence list constructed so far.
<span class="math">C<sub>1</sub></span> is the most speciﬁc class, and <span class="math">C<sub>n</sub></span> is the least speciﬁc. Let <span class="math">1 ≤ j ≤ n</span> be the
largest number such that there exists an <i>i</i> where <span class="math">1 ≤ i ≤ m</span> and <span class="math">N<sub>i</sub></span> is a direct
superclass of <span class="math">C<sub>j</sub></span>; <span class="math">N<sub>i</sub></span> is placed next.
<!--l. 912--><p class="indent" >   The eﬀect of this rule for selecting from a set of classes with no predecessors is
that classes in a simple superclass chain are adjacent in the class precedence
list and that classes in each relatively separated subgraph are adjacent
in the class precedence list. For example, let <span class="math">T<sub>1</sub></span> and <span class="math">T<sub>2</sub></span> be subgraphs
whose only element in common is the class <i>J</i>. Suppose that no superclass
of <i>J</i> appears in either <span class="math">T<sub>1</sub></span> or <span class="math">T<sub>2</sub></span>. Let <span class="math">C<sub>1</sub></span> be the bottom of <span class="math">T<sub>1</sub></span>; and let
<span class="math">C<sub>2</sub></span> be the bottom of <span class="math">T<sub>2</sub></span>. Suppose <i>C</i> is a class whose direct superclasses
are <span class="math">C<sub>1</sub></span> and <span class="math">C<sub>2</sub></span> in that order; then the class precedence list for <i>C</i> will
start with <i>C</i> and will be followed by all classes in <span class="math">T<sub>1</sub></span> except <i>J</i>. All the
classes of <span class="math">T<sub>2</sub></span> will be next. The class <i>J</i> and its superclasses will appear
last.
<!--l. 927--><p class="noindent" >
                                                                          

                                                                          
   <h5 class="subsubsectionHead"><a 
href="#x176-37500028.1.5" id="x176-37500028.1.5">Examples</a></h5>
<!--l. 929--><p class="noindent" >This example determines a class precedence list for the class pie. The following
classes are deﬁned:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass pie (apple cinnamon) ())
</td></tr></table>
<!--l. 933--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass apple (fruit) ())</td></tr></table>
<!--l. 934--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass cinnamon (spice) ())</td></tr></table>
<!--l. 935--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass fruit (food) ())</td></tr></table>
<!--l. 936--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass spice (food) ())</td></tr></table>
<!--l. 937--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass food () ())</td></tr></table>
<!--l. 939--><p class="indent" >
</div>
</div>
<div class="flushleft" 
>
<!--l. 941--><p class="noindent" >
<!--l. 948--><p class="indent" >                                                                             The set <span class="math">  S = {pie, apple, cinnamon, fruit, spice, food, standard<a 
href="clmse105.html#x130-238008r571">-</a> object, <a 
href="clmse31.html#x42-74004r19">t</a> }</span>.
The set <span class="math">R =
{(pie,apple), (apple,cinnamon), (cinnamon,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (apple,fruit), (fruit,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (cinnamon,spice), (spice,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (fruit,food), (food,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (spice,food), (standard<a 
href="clmse105.html#x130-238008r571">-</a>object,<a 
href="clmse31.html#x42-74004r19">t</a>)}</span>.
<!--l. 980--><p class="indent" >  [The original CLOS speciﬁcation <span class="cite">[<a 
href="clmli5.html#XSIGPLAN-CLOS">5</a>, <a 
href="clmli5.html#XLASC-CLOS-PART-1">6</a>]</span> contained a minor error in this
example: the pairs <span class="math">(cinnamon,standard<a 
href="clmse105.html#x130-238008r571">-</a>object)</span>, <span class="math">(fruit,standard<a 
href="clmse105.html#x130-238008r571">-</a>object)</span>,
and <span class="math">(spice,standard<a 
href="clmse105.html#x130-238008r571">-</a>object)</span> were inadvertently omitted from <i>R</i> in the
preceding paragraph. It is important to understand that <a 
href="clmse144.html#x177-411022r845">defclass</a> implicitly
appends the class standard-object to the list of superclasses when the
metaclass is standard-class (the normal situation), in order to insure that
standard-object will be a superclass of every instance of standard-class
except standard-object itself (see section <a 
href="#x176-36200028.1.2">28.1.2<!--tex4ht:ref: Classes-SECTION --></a>). <span class="math">R<sub>c</sub></span> is then generated from
this augmented list of superclasses; this is where the extra pairs come from.
I have corrected the example by adding these pairs as appropriate
throughout the example. The ﬁnal result, the class precedence list for pie, is
unchanged.—GLS]
                                                                          

                                                                          
<!--l. 1001--><p class="indent" >  The class pie is not preceded by anything, so it comes ﬁrst; the result so
far is (pie). Remove pie from <i>S</i> and pairs mentioning pie from <i>R</i> to get
<span class="math">S = {apple,cinnamon,fruit,spice,food,standard<a 
href="clmse105.html#x130-238008r571">-</a>object,<a 
href="clmse31.html#x42-74004r19">t</a>}</span> and <span class="math">R =
{(apple,cinnamon), (cinnamon,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (apple,fruit), (fruit,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (cinnamon,spice), (spice,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (fruit,food), (food,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (spice,food), (standard<a 
href="clmse105.html#x130-238008r571">-</a>object,<a 
href="clmse31.html#x42-74004r19">t</a>)}</span>.
<!--l. 1032--><p class="indent" >  The class apple is not preceded by anything, so it is next; the result is
(pie apple). Removing apple and the relevant pairs results in
<span class="math">S = {cinnamon,fruit,spice,food,standard<a 
href="clmse105.html#x130-238008r571">-</a>object,<a 
href="clmse31.html#x42-74004r19">t</a>}</span> and <span class="math">R =
{(cinnamon,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (fruit,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (cinnamon,spice), (spice,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (fruit,food), (food,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (spice,food), (standard<a 
href="clmse105.html#x130-238008r571">-</a>object,<a 
href="clmse31.html#x42-74004r19">t</a>)}</span>.
<!--l. 1056--><p class="indent" >  The classes cinnamon and fruit are not preceded by anything, so the one
with a direct subclass rightmost in the class precedence list computed so far
goes next. The class apple is a direct subclass of fruit, and the class pie is a
direct subclass of cinnamon. Because apple appears to the right of pie in
the precedence list, fruit goes next, and the result so far is (pie apple fruit).
<span class="math">S = {cinnamon,spice,food,standard<a 
href="clmse105.html#x130-238008r571">-</a>object,<a 
href="clmse31.html#x42-74004r19">t</a>}</span>; <span class="math">R =
{(cinnamon,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (cinnamon,spice), (spice,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (food,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (spice,food), (standard<a 
href="clmse105.html#x130-238008r571">-</a>object,<a 
href="clmse31.html#x42-74004r19">t</a>)}</span>.
<!--l. 1079--><p class="indent" >  The class cinnamon is next, giving the result so far as (pie apple fruit
cinnamon). At this point <span class="math">S = {spice,food,standard<a 
href="clmse105.html#x130-238008r571">-</a>object,<a 
href="clmse31.html#x42-74004r19">t</a>}</span>; <span class="math">R =
{(spice,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (food,standard<a 
href="clmse105.html#x130-238008r571">-</a>object), (spice,food), (standard<a 
href="clmse105.html#x130-238008r571">-</a>object,<a 
href="clmse31.html#x42-74004r19">t</a>)}</span>.</div>
<!--l. 1093--><p class="indent" >   The classes spice, food, standard-object, and <a 
href="clmse31.html#x42-74004r19">t</a> are then added in that order,
and the ﬁnal class precedence list for pie is <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pie apple fruit cinnamon spice food standard-object t)
</td></tr></table>
<!--l. 1097--><p class="indent" >
</div>
</div>
<!--l. 1099--><p class="indent" >   It is possible to write a set of class deﬁnitions that cannot be ordered. For
example:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass new-class (fruit apple) ())
</td></tr></table>
<!--l. 1103--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass apple (fruit) ())</td></tr></table>
<!--l. 1105--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1107--><p class="indent" >   The class fruit must precede apple because the local ordering of superclasses
must be preserved. The class apple must precede fruit because a class always
precedes its own superclasses. When this situation occurs, an error is signaled
when the system tries to compute the class precedence list.
<!--l. 1113--><p class="indent" >   The following might appear to be a conﬂicting set of deﬁnitions:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass pie (apple cinnamon) ())
</td></tr></table>
<!--l. 1116--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass pastry (cinnamon apple) ())</td></tr></table>
<!--l. 1117--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass apple () ())</td></tr></table>
<!--l. 1118--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass cinnamon () ())</td></tr></table>
<!--l. 1120--><p class="indent" >
</div>
</div>
<!--l. 1122--><p class="indent" >   The class precedence list for pie is <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pie apple cinnamon standard-object t)
</td></tr></table>
<!--l. 1125--><p class="indent" >
</div>
</div>
<!--l. 1127--><p class="indent" >   The class precedence list for pastry is <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pastry cinnamon apple standard-object t)
</td></tr></table>
<!--l. 1130--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 1132--><p class="indent" >   It is not a problem for apple to precede cinnamon in the ordering
of the superclasses of pie but not in the ordering for pastry. However,
it is not possible to build a new class that has both pie and pastry as
superclasses.
<!--l. 1138--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.6   </span> <a 
href="clmli1.html#QQ2-176-418" id="x176-37600028.1.6">Generic Functions and Methods</a></h4>
<!--l. 1140--><p class="noindent" >A <i>generic function</i> is a function whose behavior depends on the classes or
identities of the arguments supplied to it. The <i>methods</i> deﬁne the class-speciﬁc
behavior and operations of the generic function. The following sections describe
generic functions and methods.
<!--l. 1146--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-37700028.1.6" id="x176-37700028.1.6">Introduction to Generic Functions</a></h5>
<!--l. 1148--><p class="noindent" >A generic function object contains a set of methods, a lambda-list, a method
combination type, and other information.
<!--l. 1151--><p class="indent" >   Like an ordinary Lisp function, a generic function takes arguments, performs a
series of operations, and perhaps returns useful values. An ordinary function
has a single body of code that is always executed when the function is
called. A generic function has a set of bodies of code of which a subset is
selected for execution. The selected bodies of code and the manner of their
combination are determined by the classes or identities of one or more of
the arguments to the generic function and by its method combination
type.
<!--l. 1160--><p class="indent" >   Ordinary functions and generic functions are called with identical function-call
syntax.
<!--l. 1163--><p class="indent" >   Generic functions are true functions that can be passed as arguments, returned
as values, used as the ﬁrst argument to <a 
href="clmse37.html#x49-95004r69">funcall</a> and <a 
href="clmse37.html#x49-95002r68">apply</a>, and otherwise used in
all the ways an ordinary function may be used.
<!--l. 1167--><p class="indent" >   A name can be given to an ordinary function in one of two ways: a <i>global</i> name
can be given to a function using the <a 
href="clmse30.html#x40-67002r13">defun</a> construct; a <i>local</i> name can be given
using the <a 
href="clmse39.html#x51-103002r77">ﬂet</a> or <a 
href="clmse39.html#x51-103004r78">labels</a> special forms. A generic function can be given a global
name using the <a 
href="clmse144.html#x177-414002r849">defmethod</a> or <a 
href="clmse144.html#x177-412002r846">defgeneric</a> construct. A generic function can be
given a local name using the <a 
href="clmse144.html#x177-415048r872">generic-ﬂet</a>, <a 
href="clmse144.html#x177-417002r874">generic-labels</a>, or <a 
href="clmse144.html#x177-419004r913">with-added-methods</a>
special forms. The name of a generic function, like the name of an ordinary
                                                                          

                                                                          
function, can be either a symbol or a two-element list whose ﬁrst element is <a 
href="clmse36.html#x48-90002r64">setf</a>
and whose second element is a symbol. This is true for both local and global
names.
<!--l. 1179--><p class="indent" >   The <a 
href="clmse144.html#x177-415048r872">generic-ﬂet</a> special form creates new local generic functions using the set
of methods speciﬁed by the method deﬁnitions in the <a 
href="clmse144.html#x177-415048r872">generic-ﬂet</a> form. The
scoping of generic function names within a <a 
href="clmse144.html#x177-415048r872">generic-ﬂet</a> form is the same as for
<a 
href="clmse39.html#x51-103002r77">ﬂet</a>.
<!--l. 1184--><p class="indent" >   The <a 
href="clmse144.html#x177-417002r874">generic-labels</a> special form creates a set of new mutually recursive local
generic functions using the set of methods speciﬁed by the method deﬁnitions in
the <a 
href="clmse144.html#x177-417002r874">generic-labels</a> form. The scoping of generic function names within a
<a 
href="clmse144.html#x177-417002r874">generic-labels</a> form is the same as for <a 
href="clmse39.html#x51-103004r78">labels</a>.
<!--l. 1190--><p class="indent" >   The <a 
href="clmse144.html#x177-419004r913">with-added-methods</a> special form creates new local generic functions by
adding the set of methods speciﬁed by the method deﬁnitions with a given name
in the <a 
href="clmse144.html#x177-419004r913">with-added-methods</a> form to copies of the methods of the lexically visible
generic function of the same name. If there is a lexically visible ordinary function
of the same name as one of the speciﬁed generic functions, that function becomes
the method function of the default method for the new generic function of that
name.
<!--l. 1199--><p class="indent" >   The <a 
href="clmse144.html#x177-416002r873">generic-function</a> macro creates an anonymous generic function with the
set of methods speciﬁed by the method deﬁnitions that appear in the
generic-function form.
<!--l. 1203--><p class="indent" >   When a <a 
href="clmse144.html#x177-412002r846">defgeneric</a> form is evaluated, one of three actions is taken:
      <ul class="itemize1">
      <li class="itemize">If a generic function of the given name already exists, the existing
      generic function object is modiﬁed. Methods speciﬁed by the current
      <a 
href="clmse144.html#x177-412002r846">defgeneric</a> form are added, and any methods in the existing generic
      function that were deﬁned by a previous <a 
href="clmse144.html#x177-412002r846">defgeneric</a> form are removed.
      Methods added by the current <a 
href="clmse144.html#x177-412002r846">defgeneric</a> form might replace methods
      deﬁned by <a 
href="clmse144.html#x177-414002r849">defmethod</a> or <a 
href="clmse144.html#x177-411022r845">defclass</a>. No other methods in the generic
      function are aﬀected or replaced.
      </li>
      <li class="itemize">If the given name names a non-generic function, a macro, or a special
      form, an error is signaled.
      </li>
      <li class="itemize">Otherwise a generic function is created with the methods speciﬁed by
                                                                          

                                                                          
      the method deﬁnitions in the <a 
href="clmse144.html#x177-412002r846">defgeneric</a> form.
      </li></ul>
<!--l. 1226--><p class="indent" >   Some forms specify the options of a generic function, such as the type of
method combination it uses or its argument precedence order. They will
be referred to as “forms that specify generic function options.” These
forms are <a 
href="clmse144.html#x177-412002r846">defgeneric</a>, <a 
href="clmse144.html#x177-416002r873">generic-function</a>, <a 
href="clmse144.html#x177-415048r872">generic-ﬂet</a>, <a 
href="clmse144.html#x177-417002r874">generic-labels</a>, and
<a 
href="clmse144.html#x177-419004r913">with-added-methods</a>.
<!--l. 1233--><p class="indent" >   Some forms deﬁne methods for a generic function. They will be referred to as
“method-deﬁning forms.” These forms are <a 
href="clmse144.html#x177-412002r846">defgeneric</a>, <a 
href="clmse144.html#x177-414002r849">defmethod</a>, <a 
href="clmse144.html#x177-416002r873">generic-function</a>,
<a 
href="clmse144.html#x177-415048r872">generic-ﬂet</a>, <a 
href="clmse144.html#x177-417002r874">generic-labels</a>, <a 
href="clmse144.html#x177-419004r913">with-added-methods</a>, and <a 
href="clmse144.html#x177-411022r845">defclass</a>. Note that all the
method-deﬁning forms except <a 
href="clmse144.html#x177-411022r845">defclass</a> and <a 
href="clmse144.html#x177-414002r849">defmethod</a> are also forms that specify
generic function options.
<!--l. 1241--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-37800028.1.6" id="x176-37800028.1.6">Introduction to Methods</a></h5>
<!--l. 1244--><p class="noindent" >A method object contains a method function, a sequence of <i> parameter
specializers</i> that specify when the given method is applicable, a lambda-list, and a
sequence of <i>qualiﬁers</i> that are used by the method combination facility to
distinguish among methods.
<!--l. 1250--><p class="indent" >   A method object is not a function and cannot be invoked as a function.
Various mechanisms in the Объектная система take a method object
and invoke its method function, as is the case when a generic function
is invoked. When this occurs it is said that the method is invoked or
called.
<!--l. 1255--><p class="indent" >   A method-deﬁning form contains the code that is to be run when the
arguments to the generic function cause the method that it deﬁnes to be invoked.
When a method-deﬁning form is evaluated, a method object is created and one of
four actions is taken:
      <ul class="itemize1">
      <li class="itemize">If a generic function of the given name already exists and if a method
      object  already  exists  that  agrees  with  the  new  one  on  parameter
      specializers and qualiﬁers, the new method object replaces the old one.
      For a deﬁnition of one method agreeing with another on parameter
      specializers and qualiﬁers, see section <a 
href="#x176-37900028.1.6">28.1.6<!--tex4ht:ref: Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION --></a>.
                                                                          

                                                                          
      </li>
      <li class="itemize">If a generic function of the given name already exists and if there is no
      method object that agrees with the new one on parameter specializers
      and qualiﬁers, the existing generic function object is modiﬁed to contain
      the new method object.
      </li>
      <li class="itemize">If the given name names a non-generic function, a macro, or a special
      form, an error is signaled.
      </li>
      <li class="itemize">Otherwise a generic function is created with the methods speciﬁed by
      the method-deﬁning form.
      </li></ul>
<!--l. 1282--><p class="indent" >   If the lambda-list of a new method is not congruent with the lambda-list of the
generic function, an error is signaled. If a method-deﬁning form that cannot
specify generic function options creates a new generic function, a lambda-list for
that generic function is derived from the lambda-lists of the methods in the
method-deﬁning form in such a way as to be congruent with them. For a
discussion of <i>congruence</i>, see section <a 
href="#x176-38000028.1.6">28.1.6<!--tex4ht:ref: Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION --></a>.
<!--l. 1291--><p class="indent" >   Each method has a <i>specialized lambda-list</i>, which determines when that
method can be applied. A specialized lambda-list is like an ordinary lambda-list
except that a <i>specialized parameter</i> may occur instead of the name of
a required parameter. A specialized parameter is a list (<i>variable-name
parameter-specializer-name</i>), where <i>parameter-specializer-name</i> is either a name
that names a class or a list (<a 
href="clmse33.html#x44-78004r45">eql</a> <i>form</i>). A parameter specializer name denotes a
parameter specializer as follows:
      <ul class="itemize1">
      <li class="itemize">A name that names a class denotes that class.
      </li>
      <li class="itemize">The list (<a 
href="clmse33.html#x44-78004r45">eql</a> <i>form</i>) denotes the type speciﬁer (<a 
href="clmse33.html#x44-78004r45">eql</a> <i>object</i>), where <i>object</i> is
      the result of evaluating <i>form</i>. The form <i>form</i> is evaluated in the lexical
      environment in which the method-deﬁning form is evaluated. Note that
      <i>form</i> is evaluated only once, at the time the method is deﬁned, not
      each time the generic function is called.</li></ul>
                                                                          

                                                                          
<!--l. 1311--><p class="indent" >   Parameter specializer names are used in macros intended as the user-level
interface (<a 
href="clmse144.html#x177-414002r849">defmethod</a>), while parameter specializers are used in the functional
interface.
<!--l. 1315--><p class="indent" >   [It is very important to understand clearly the distinction made in the
preceding paragraph. A parameter specializer name has the form of a type
speciﬁer but is semantically quite diﬀerent from a type speciﬁer: a parameter
specializer name of the form (<a 
href="clmse33.html#x44-78004r45">eql</a> <i>form</i>) is not a type speciﬁer, for it contains a
<i>form</i> to be evaluated. Type speciﬁers never contain forms to be evaluated.
All parameter specializers (as opposed to parameter specializer names)
are valid type speciﬁers, but not all type speciﬁers are valid parameter
specializers. Macros such as <a 
href="clmse144.html#x177-414002r849">defmethod</a> take parameter specializer names
and treat them as speciﬁcations for constructing certain type speciﬁers
(parameter specializers) that may then be used with such functions as
<a 
href="clmse144.html#x177-415042r869">ﬁnd-method</a>.—GLS]
<!--l. 1329--><p class="indent" >   Only required parameters may be specialized, and there must be a parameter
specializer for each required parameter. For notational simplicity, if some required
parameter in a specialized lambda-list in a method-deﬁning form is simply
a variable name, its parameter specializer defaults to the class named
<a 
href="clmse31.html#x42-74004r19">t</a>.
<!--l. 1335--><p class="indent" >   Given a generic function and a set of arguments, an <i>applicable method</i> is a
method for that generic function whose parameter specializers are satisﬁed by
their corresponding arguments. The following deﬁnition speciﬁes what it means
for a method to be applicable and for an argument to satisfy a parameter
specializer.
<!--l. 1341--><p class="indent" >   Let <span class="math">⟨A<sub>1</sub>,…,A<sub>n</sub>⟩</span> be the required arguments to a generic function in order. Let
<span class="math">⟨P<sub>1</sub>,…,P<sub>n</sub>⟩</span> be the parameter specializers corresponding to the required
parameters of the method <i>M</i> in order. The method <i>M</i> is <i>applicable</i> when each <span class="math">A<sub>i</sub></span>
<i>satisﬁes</i> <span class="math">P<sub>i</sub></span>. If <span class="math">P<sub>i</sub></span> is a class, and if <span class="math">A<sub>i</sub></span> is an instance of a class <i>C</i>, then it is said
that <span class="math">A<sub>i</sub></span> <i>satisﬁes</i> <span class="math">P<sub>i</sub></span> when <span class="math">C = P<sub>i</sub></span> or when C is a subclass of <span class="math">P<sub>i</sub></span>. If <span class="math">P<sub>i</sub></span> is of the
form (<a 
href="clmse33.html#x44-78004r45">eql</a> <i>object</i>), then it is said that <span class="math">A<sub>i</sub></span> satisﬁes <span class="math">P<sub>i</sub></span> when the function <a 
href="clmse33.html#x44-78004r45">eql</a> applied
to <span class="math">A<sub>i</sub></span> and <i>object</i> is true.
<!--l. 1357--><p class="indent" >   Because a parameter specializer is a type speciﬁer, the function <a 
href="clmse32.html#x43-76002r20">typep</a> can be
used during method selection to determine whether an argument satisﬁes a
parameter specializer. In general a parameter specializer cannot be a type speciﬁer
list, such as (vector single-ﬂoat). The only parameter specializer that can be a list
is (<a 
href="clmse33.html#x44-78004r45">eql</a> <i>object</i>). This requires that Common Lisp deﬁne the type speciﬁer <a 
href="clmse33.html#x44-78004r45">eql</a> as if
the following were evaluated:
<div class=lisp>
                                                                          

                                                                          
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deftype eql (<i>object</i>) ‘(member ,<i>object</i>))
</td></tr></table>
<!--l. 1368--><p class="indent" >
</div>
</div>
<!--l. 1369--><p class="noindent" >[See section <a 
href="clmse20.html#x29-470004.3">4.3<!--tex4ht:ref: PREDICATING-TYPE-SPECIFIERS-SECTION --></a>.—GLS]
<!--l. 1371--><p class="indent" >   A method all of whose parameter specializers are the class named <a 
href="clmse31.html#x42-74004r19">t</a> is called a
<i>default method</i>; it is always applicable but may be shadowed by a more speciﬁc
method.
<!--l. 1375--><p class="indent" >   Methods can have <i>qualiﬁers</i>, which give the method combination procedure a
way to distinguish among methods. A method that has one or more qualiﬁers is
called a <i>qualiﬁed</i> method. A method with no qualiﬁers is called an <i>unqualiﬁed
method</i>. A qualiﬁer is any object other than a list, that is, any non-<a 
href="clmse31.html#x42-74002r18">nil</a> atom. The
qualiﬁers deﬁned by standard method combination and by the built-in method
combination types are symbols.
<!--l. 1383--><p class="indent" >   In this speciﬁcation, the terms <i>primary method</i> and <i> auxiliary method</i> are used
to partition methods within a method combination type according to their
intended use. In standard method combination, primary methods are unqualiﬁed
methods, and auxiliary methods are methods with a single qualiﬁer that is one of
:around, :before, or :after. When a method combination type is deﬁned using the
short form of <a 
href="clmse144.html#x177-413005r848">deﬁne-method-combination</a>, primary methods are methods qualiﬁed
with the name of the type of method combination, and auxiliary methods
have the qualiﬁer :around. Thus the terms <i>primary method</i> and <i>auxiliary
method</i> have only a relative deﬁnition within a given method combination
type.
<!--l. 1396--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-37900028.1.6" id="x176-37900028.1.6">Agreement on Parameter Specializers and Qualiﬁers</a></h5>
<!--l. 1399--><p class="noindent" >Two methods are said to agree with each other on parameter specializers and
qualiﬁers if the following conditions hold:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">Both methods have the same number of required parameters. Suppose
      the  parameter  specializers  of  the  two  methods  are  <span class="math">P<sub>1,1</sub>…P<sub>1,n</sub></span>  and
      <span class="math">P<sub>2,1</sub>…P<sub>2,n</sub></span>.
      </li>
      <li class="itemize">For each <span class="math">1 ≤ i ≤ n</span>, <span class="math">P<sub>1,i</sub></span> agrees with <span class="math">P<sub>2,i</sub></span>. The parameter specializer
      <span class="math">P<sub>1,i</sub></span>  agrees  with  <span class="math">P<sub>2,i</sub></span>  if  <span class="math">P<sub>1,i</sub></span>  and  <span class="math">P<sub>2,i</sub></span>  are  the  same  class  or  if
      <span class="math">P<sub>1,i</sub> = <tt>(<a 
href="clmse33.html#x44-78004r45">eql</a> object<sub>1</sub>)</tt></span>, <span class="math">P<sub>2,i</sub> = <tt>(<a 
href="clmse33.html#x44-78004r45">eql</a> object<sub>2</sub>)</tt></span>, and (<a 
href="clmse33.html#x44-78004r45">eql</a> <span class="math">object<sub>1</sub></span> <span class="math">object<sub>2</sub></span>).
      Otherwise <span class="math">P<sub>1,i</sub></span> and <span class="math">P<sub>2,i</sub></span> do not agree.
      </li>
      <li class="itemize">The lists of qualiﬁers of both methods contain the same non-<a 
href="clmse31.html#x42-74002r18">nil</a> atoms
      in the same order. That is, the lists are <a 
href="clmse33.html#x44-78006r46">equal</a>.
      </li></ul>
<!--l. 1426--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-38000028.1.6" id="x176-38000028.1.6">Congruent Lambda-Lists for All Methods of a Generic Function</a></h5>
<!--l. 1429--><p class="noindent" >These rules deﬁne the congruence of a set of lambda-lists, including the
lambda-list of each method for a given generic function and the lambda-list
speciﬁed for the generic function itself, if given.
      <ul class="itemize1">
      <li class="itemize">Each lambda-list must have the same number of required parameters.
      </li>
      <li class="itemize">Each lambda-list must have the same number of optional parameters.
      Each method can supply its own default for an optional parameter.
      </li>
      <li class="itemize">If  any  lambda-list  mentions  &#x0026;rest  or  &#x0026;key,  each  lambda-list  must
      mention one or both of them.
      </li>
      <li class="itemize">If  the  generic  function  lambda-list  mentions  &#x0026;key,  each  method
      must accept all of the keyword names mentioned after &#x0026;key, either
      by accepting them explicitly, by specifying &#x0026;allow-other-keys, or by
                                                                          

                                                                          
      specifying &#x0026;rest but not &#x0026;key. Each method can accept additional
      keyword arguments of its own. The checking of the validity of keyword
      names  is  done  in  the  generic  function,  not  in  each  method.  A
      method is invoked as if the keyword argument pair whose keyword is
      :allow-other-keys and whose value is <a 
href="clmse31.html#x42-74004r19">t</a> were supplied, though no such
      argument pair will be passed.
      </li>
      <li class="itemize">The   use   of   &#x0026;allow-other-keys   need   not   be   consistent   across
      lambda-lists.  If  &#x0026;allow-other-keys  is  mentioned  in  the  lambda-list
      of  any  applicable  method  or  of  the  generic  function,  any  keyword
      arguments may be mentioned in the call to the generic function.
      </li>
      <li class="itemize">The use of &#x0026;aux need not be consistent across methods.</li></ul>
<!--l. 1465--><p class="indent" >   If a method-deﬁning form that cannot specify generic function options creates
a generic function, and if the lambda-list for the method mentions keyword
arguments, the lambda-list of the generic function will mention &#x0026;key (but no
keyword arguments).
<!--l. 1471--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-38100028.1.6" id="x176-38100028.1.6">Keyword Arguments in Generic Functions and Methods</a></h5>
<!--l. 1473--><p class="noindent" >When a generic function or any of its methods mentions &#x0026;key in a lambda-list,
the speciﬁc set of keyword arguments accepted by the generic function varies
according to the applicable methods. The set of keyword arguments accepted by
the generic function for a particular call is the union of the keyword arguments
accepted by all applicable methods and the keyword arguments mentioned after
&#x0026;key in the generic function deﬁnition, if any. A method that has &#x0026;rest but not
&#x0026;key does not aﬀect the set of acceptable keyword arguments. If the lambda-list
of any applicable method or of the generic function deﬁnition contains
&#x0026;allow-other-keys, all keyword arguments are accepted by the generic
function.
<!--l. 1485--><p class="indent" >   The lambda-list congruence rules require that each method accept all of the
keyword arguments mentioned after &#x0026;key in the generic function deﬁnition, by
accepting them explicitly, by specifying &#x0026;allow-other-keys, or by specifying &#x0026;rest
but not &#x0026;key. Each method can accept additional keyword arguments of its own,
in addition to the keyword arguments mentioned in the generic function
                                                                          

                                                                          
deﬁnition.
                                                                          

                                                                          
<!--l. 1495--><p class="indent" >   If a generic function is passed a keyword argument that no applicable method
accepts, an error is signaled.
<!--l. 1498--><p class="indent" >   For example, suppose there are two methods deﬁned for width as
follows:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod width ((c character-class) &#x0026;key font) ...)
</td></tr></table>
<!--l. 1502--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1503--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod width ((p picture-class) &#x0026;key pixel-size) ...)</td></tr></table>
<!--l. 1505--><p class="indent" >
</div>
</div>
<!--l. 1507--><p class="noindent" >Assume that there are no other methods and no generic function deﬁnition for
width. The evaluation of the following form will signal an error because the
keyword argument :pixel-size is not accepted by the applicable method.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(width (make-instance &#x2019;character-class :char #\Q)
</td></tr></table>
<!--l. 1513--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :font &#x2019;baskerville :pixel-size 10)</td></tr></table>
<!--l. 1515--><p class="indent" >
</div>
</div>
<!--l. 1517--><p class="indent" >   The evaluation of the following form will signal an error.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(width (make-instance &#x2019;picture-class :glyph (glyph #\Q))
</td></tr></table>
                                                                          

                                                                          
<!--l. 1520--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :font &#x2019;baskerville :pixel-size 10)</td></tr></table>
<!--l. 1522--><p class="indent" >
</div>
</div>
<!--l. 1524--><p class="indent" >   The evaluation of the following form will not signal an error if the
class named character-picture-class is a subclass of both picture-class and
character-class.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(width (make-instance &#x2019;character-picture-class :char #\Q)
</td></tr></table>
<!--l. 1529--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :font &#x2019;baskerville :pixel-size 10)</td></tr></table>
<!--l. 1531--><p class="indent" >
</div>
</div>
<!--l. 1534--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.7   </span> <a 
href="clmli1.html#QQ2-176-424" id="x176-38200028.1.7">Method Selection and Combination</a></h4>
<!--l. 1537--><p class="noindent" >When a generic function is called with particular arguments, it must determine
the code to execute. This code is called the <i>eﬀective method</i> for those
arguments. The eﬀective method is a <i> combination</i> of the applicable methods
in the generic function. A combination of methods is a Lisp expression
that contains calls to some or all of the methods. If a generic function is
called and no methods apply, the generic function <a 
href="clmse144.html#x177-418030r889">no-applicable-method</a> is
invoked.
<!--l. 1546--><p class="indent" >   When the eﬀective method has been determined, it is invoked with the same
arguments that were passed to the generic function. Whatever values it returns
are returned as the values of the generic function.
<!--l. 1550--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-38300028.1.7" id="x176-38300028.1.7">Determining the Eﬀective Method</a></h5>
                                                                          

                                                                          
<!--l. 1553--><p class="noindent" >The eﬀective method for a set of arguments is determined by the following
three-step procedure:
<!--l. 1556--><p class="indent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x176-383002x1">Select the applicable methods.
      </li>
      <li 
  class="enumerate" id="x176-383004x2">Sort the applicable methods by precedence order, putting the most
      speciﬁc method ﬁrst.
      </li>
      <li 
  class="enumerate" id="x176-383006x3">Apply method combination to the sorted list of applicable methods,
      producing the eﬀective method.
      </li></ol>
<b>
<!--l. 1568--><p class="indent" >   Selecting the Applicable Methods.</b> This step is described in
section <a 
href="#x176-37800028.1.6">28.1.6<!--tex4ht:ref: Introduction-to-Methods-SECTION --></a>.
<b>
<!--l. 1572--><p class="indent" >   Sorting the Applicable Methods by Precedence Order.</b> To
compare the precedence of two methods, their parameter specializers are
examined in order. The default examination order is from left to right, but an
alternative order may be speciﬁed by the :argument-precedence-order option
to <a 
href="clmse144.html#x177-412002r846">defgeneric</a> or to any of the other forms that specify generic function
options.
<!--l. 1579--><p class="indent" >   The corresponding parameter specializers from each method are compared.
When a pair of parameter specializers are equal, the next pair are compared for
equality. If all corresponding parameter specializers are equal, the two methods
must have diﬀerent qualiﬁers; in this case, either method can be selected to
precede the other.
<!--l. 1586--><p class="indent" >   If some corresponding parameter specializers are not equal, the ﬁrst pair of
parameter specializers that are not equal determines the precedence. If both
parameter specializers are classes, the more speciﬁc of the two methods
is the method whose parameter specializer appears earlier in the class
precedence list of the corresponding argument. Because of the way in which
the set of applicable methods is chosen, the parameter specializers are
guaranteed to be present in the class precedence list of the class of the
argument.
                                                                          

                                                                          
<!--l. 1595--><p class="indent" >   If just one parameter specializer is (<a 
href="clmse33.html#x44-78004r45">eql</a> object), the method with that
parameter specializer precedes the other method. If both parameter specializers
are <a 
href="clmse33.html#x44-78004r45">eql</a> forms, the specializers must be the same (otherwise the two methods
would not both have been applicable to this argument).
<!--l. 1602--><p class="indent" >   The resulting list of applicable methods has the most speciﬁc method ﬁrst and
the least speciﬁc method last.
<b>
<!--l. 1605--><p class="indent" >   Applying Method Combination to the Sorted List of Applicable
Methods.</b> In the simple case—if standard method combination is used and all
applicable methods are primary methods—the eﬀective method is the most
speciﬁc method. That method can call the next most speciﬁc method by using
the function <a 
href="clmse144.html#x177-411002r835">call-next-method</a>. The method that <a 
href="clmse144.html#x177-411002r835">call-next-method</a> will
call is referred to as the <i>next method</i>. The predicate <a 
href="clmse144.html#x177-418026r887">next-method-p</a> tests
whether a next method exists. If <a 
href="clmse144.html#x177-411002r835">call-next-method</a> is called and there is
no next most speciﬁc method, the generic function <a 
href="clmse144.html#x177-418034r891">no-next-method</a> is
invoked.
<!--l. 1616--><p class="indent" >   In general, the eﬀective method is some combination of the applicable
methods. It is deﬁned by a Lisp form that contains calls to some or all of the
applicable methods, returns the value or values that will be returned as the value
or values of the generic function, and optionally makes some of the methods
accessible by means of <a 
href="clmse144.html#x177-411002r835">call-next-method</a>. This Lisp form is the body of the
eﬀective method; it is augmented with an appropriate lambda-list to make it a
function.
<!--l. 1624--><p class="indent" >   The role of each method in the eﬀective method is determined by its method
qualiﬁers and the speciﬁcity of the method. A qualiﬁer serves to mark a method,
and the meaning of a qualiﬁer is determined by the way that these marks are used
by this step of the procedure. If an applicable method has an unrecognized
qualiﬁer, this step signals an error and does not include that method in the
eﬀective method.
<!--l. 1632--><p class="indent" >   When standard method combination is used together with qualiﬁed methods,
the eﬀective method is produced as described in section <a 
href="#x176-38400028.1.7">28.1.7<!--tex4ht:ref: Standard-Method-Combination-SECTION --></a>.
<!--l. 1636--><p class="indent" >   Another type of method combination can be speciﬁed by using the
:method-combination option of <a 
href="clmse144.html#x177-412002r846">defgeneric</a> or of any of the other forms that specify
generic function options. In this way this step of the procedure can be
customized.
<!--l. 1641--><p class="indent" >   New types of method combination can be deﬁned by using the
<a 
href="clmse144.html#x177-413005r848">deﬁne-method-combination</a> macro.
<!--l. 1645--><p class="indent" >   The meta-object level also oﬀers a mechanism for deﬁning new types of
                                                                          

                                                                          
method combination. The generic function compute-eﬀective-method receives as
arguments the generic function, the method combination object, and the sorted
list of applicable methods. It returns the Lisp form that deﬁnes the eﬀective
method. A method for compute-eﬀective-method can be deﬁned directly by using
<a 
href="clmse144.html#x177-414002r849">defmethod</a> or indirectly by using <a 
href="clmse144.html#x177-413005r848">deﬁne-method-combination</a>. A <i>method
combination object</i> is an object that encapsulates the method combination type
and options speciﬁed by the :method-combination option to forms that specify
generic function options.
<div class=implementation>
<!--l. 1661--><p class="noindent" ><b>Заметка для реализации:</b> In the simplest implementation, the generic function
would compute the eﬀective method each time it was called. In practice, this will be too
ineﬃcient for some implementations. Instead, these implementations might employ a
variety of optimizations of the three-step procedure. Some illustrative examples of such
optimizations are the following:
      <ul class="itemize1">
      <li class="itemize">Use a hash table keyed by the class of the arguments to store the eﬀective
      method.
      </li>
      <li class="itemize">Compile the eﬀective method and save the resulting compiled function in a
      table.
      </li>
      <li class="itemize">Recognize the Lisp form as an instance of a pattern of control structure and
      substitute a closure that implements that structure.
      </li>
      <li class="itemize">Examine the parameter specializers of all methods for the generic function
      and enumerate all possible eﬀective methods. Combine the eﬀective methods,
      together with code to select from among them, into a single function and
      compile that function. Call that function whenever the generic function is
      called.</li></ul>
</div>
<!--l. 1691--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-38400028.1.7" id="x176-38400028.1.7">Standard Method Combination</a></h5>
                                                                          

                                                                          
<!--l. 1694--><p class="noindent" >Standard method combination is supported by the class standard-generic-function. It
is used if no other type of method combination is speciﬁed or if the built-in
method combination type standard is speciﬁed.
<i>
<!--l. 1700--><p class="indent" >   Primary methods</i> deﬁne the main action of the eﬀective method, while
<i>auxiliary methods</i> modify that action in one of three ways. A primary method has
no method qualiﬁers.
<!--l. 1704--><p class="indent" >   An auxiliary method is a method whose method qualiﬁer is :before, :after, or
:around. Standard method combination allows no more than one qualiﬁer per
method; if a method deﬁnition speciﬁes more than one qualiﬁer per method, an
error is signaled.
      <ul class="itemize1">
      <li class="itemize">A :before method has the keyword :before as its only qualiﬁer. A :before
      method speciﬁes code that is to be run before any primary method.
      </li>
      <li class="itemize">An :after method has the keyword :after as its only qualiﬁer. An :after
      method speciﬁes code that is to be run after primary methods.
      </li>
      <li class="itemize">An  :around  method  has  the  keyword  :around  as  its  only  qualiﬁer.
      An :around method speciﬁes code that is to be run instead of other
      applicable methods but that is able to cause some of them to be run.
      </li></ul>
<!--l. 1728--><p class="noindent" >The semantics of standard method combination are as follows:
      <ul class="itemize1">
      <li class="itemize">If there are any :around methods, the most speciﬁc :around method is
      called. It supplies the value or values of the generic function.
      </li>
      <li class="itemize">Inside  the  body  of  an  :around  method,  <a 
href="clmse144.html#x177-411002r835">call-next-method</a>  can  be
      used to call the next method. When the next method returns, the
      :around method can execute more code, perhaps based on the returned
      value  or  values.  The  generic  function  <a 
href="clmse144.html#x177-418034r891">no-next-method</a>  is  invoked  if
                                                                          

                                                                          
      <a 
href="clmse144.html#x177-411002r835">call-next-method</a> is used and there is no applicable method to call.
      The function <a 
href="clmse144.html#x177-418026r887">next-method-p</a> may be used to determine whether a next
      method exists.
      </li>
      <li class="itemize">If an :around method invokes <a 
href="clmse144.html#x177-411002r835">call-next-method</a>, the next most speciﬁc
      :around method is called, if one is applicable. If there are no :around
      methods or if <a 
href="clmse144.html#x177-411002r835">call-next-method</a> is called by the least speciﬁc :around
      method, the other methods are called as follows:
           <ul class="itemize2">
           <li class="itemize">All  the  :before  methods  are  called,  in  most-speciﬁc-ﬁrst  order.
           Their values are ignored. An error is signaled if <a 
href="clmse144.html#x177-411002r835">call-next-method</a>
           is used in a :before method.
           </li>
           <li class="itemize">The  most  speciﬁc  primary  method  is  called.  Inside  the  body
           of  a  primary  method,  <a 
href="clmse144.html#x177-411002r835">call-next-method</a>  may  be  used  to  call
           the  next  most  speciﬁc  primary  method.  When  that  method
           returns,  the  previous  primary  method  can  execute  more  code,
           perhaps  based  on  the  returned  value  or  values.  The  generic
           function <a 
href="clmse144.html#x177-418034r891">no-next-method</a> is invoked if <a 
href="clmse144.html#x177-411002r835">call-next-method</a> is used
           and there are no more applicable primary methods. The function
           <a 
href="clmse144.html#x177-418026r887">next-method-p</a> may be used to determine whether a next method
           exists.  If  <a 
href="clmse144.html#x177-411002r835">call-next-method</a>  is  not  used,  only  the  most  speciﬁc
           primary method is called.
           </li>
           <li class="itemize">All the :after methods are called in most-speciﬁc-last order. Their
           values are ignored. An error is signaled if <a 
href="clmse144.html#x177-411002r835">call-next-method</a> is used
           in an :after method.</li></ul>
      </li>
      <li class="itemize">If no :around methods were invoked, the most speciﬁc primary method
      supplies the value or values returned by the generic function. The value or
      values returned by the invocation of <a 
href="clmse144.html#x177-411002r835">call-next-method</a> in the least speciﬁc
      :around method are those returned by the most speciﬁc primary
      method.
      </li></ul>
                                                                          

                                                                          
<!--l. 1783--><p class="indent" >   In standard method combination, if there is an applicable method but no
applicable primary method, an error is signaled.
<!--l. 1786--><p class="indent" >   The :before methods are run in most-speciﬁc-ﬁrst order and the :after methods
are run in least-speciﬁc-ﬁrst order. The design rationale for this diﬀerence can be
illustrated with an example. Suppose class <span class="math">C<sub>1</sub></span> modiﬁes the behavior of its
superclass, <span class="math">C<sub>2</sub></span>, by adding :before and :after methods. Whether the behavior of the
class <span class="math">C<sub>2</sub></span> is deﬁned directly by methods on <span class="math">C<sub>2</sub></span> or is inherited from its
superclasses does not aﬀect the relative order of invocation of methods on
instances of the class <span class="math">C<sub>1</sub></span>. Class <span class="math">C<sub>1</sub></span>&#x2019;s :before method runs before all of
class <span class="math">C<sub>2</sub></span>&#x2019;s methods. Class <span class="math">C<sub>1</sub></span>&#x2019;s :after method runs after all of class <span class="math">C<sub>2</sub></span>&#x2019;s
methods.
<!--l. 1798--><p class="indent" >   By contrast, all :around methods run before any other methods run.
Thus a less speciﬁc :around method runs before a more speciﬁc primary
method.
<!--l. 1802--><p class="indent" >   If only primary methods are used and if <a 
href="clmse144.html#x177-411002r835">call-next-method</a> is not used, only the
most speciﬁc method is invoked; that is, more speciﬁc methods shadow more
general ones.
<!--l. 1806--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-38500028.1.7" id="x176-38500028.1.7">Declarative Method Combination</a></h5>
<!--l. 1808--><p class="noindent" >The macro <a 
href="clmse144.html#x177-413005r848">deﬁne-method-combination</a> deﬁnes new forms of method combination.
It provides a mechanism for customizing the production of the eﬀective method.
The default procedure for producing an eﬀective method is described in
section <a 
href="#x176-38300028.1.7">28.1.7<!--tex4ht:ref: Determining-the-Effective-Method-SECTION --></a>. There are two forms of <a 
href="clmse144.html#x177-413005r848">deﬁne-method-combination</a>. The short form
is a simple facility; the long form is more powerful and more verbose. The long
form resembles <a 
href="clmse45.html#x58-144004r118">defmacro</a> in that the body is an expression that computes a Lisp
form; it provides mechanisms for implementing arbitrary control structures within
method combination and for arbitrary processing of method qualiﬁers. The syntax
and use of both forms of <a 
href="clmse144.html#x177-413005r848">deﬁne-method-combination</a> are explained in
section <a 
href="clmse144.html#x177-41000028.2">28.2<!--tex4ht:ref: Functions-in-the-Programmer-Interface-SECTION --></a>.
<!--l. 1824--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-38600028.1.7" id="x176-38600028.1.7">Built-in Method Combination Types</a></h5>
<!--l. 1827--><p class="noindent" >The Объектная система Common Lisp&#x2019;а provides a set of built-in method
combination types. To specify that a generic function is to use one of these
                                                                          

                                                                          
method combination types, the name of the method combination type is given as
the argument to the :method-combination option to <a 
href="clmse144.html#x177-412002r846">defgeneric</a> or to the
:method-combination option to any of the other forms that specify generic
function options.
<!--l. 1834--><p class="indent" >   The names of the built-in method combination types are <a 
href="clmse105.html#x130-238002r568">+</a>, <a 
href="clmse34.html#x45-79004r49">and</a>, <a 
href="clmse132.html#x163-331002r790">append</a>, <a 
href="clmse81.html#x101-202034r441">list</a>,
<a 
href="clmse63.html#x80-177014r179">max</a>, <a 
href="clmse63.html#x80-177016r180">min</a>, <a 
href="clmse132.html#x163-331006r792">nconc</a>, <a 
href="clmse34.html#x45-80002r50">or</a>, <a 
href="clmse38.html#x50-96002r71">progn</a>, and standard.
<!--l. 1838--><p class="indent" >   The semantics of the standard built-in method combination type were
described in section <a 
href="#x176-38400028.1.7">28.1.7<!--tex4ht:ref: Standard-Method-Combination-SECTION --></a>. The other built-in method combination types are
called <i>simple built-in method combination types.</i>
<!--l. 1843--><p class="indent" >   The simple built-in method combination types act as though they were deﬁned
by the short form of <a 
href="clmse144.html#x177-413005r848">deﬁne-method-combination</a>. They recognize two roles for
methods:
      <ul class="itemize1">
      <li class="itemize">An :around method has the keyword symbol :around as its sole qualiﬁer.
      The meaning of :around methods is the same as in standard method
      combination. Use of the functions <a 
href="clmse144.html#x177-411002r835">call-next-method</a> and <a 
href="clmse144.html#x177-418026r887">next-method-p</a>
      is supported in :around methods.
      </li>
      <li class="itemize">A primary method has the name of the method combination type as
      its sole qualiﬁer. For example, the built-in method combination type
      <a 
href="clmse34.html#x45-79004r49">and</a> recognizes methods whose sole qualiﬁer is <a 
href="clmse34.html#x45-79004r49">and</a>; these are primary
      methods. Use of the functions <a 
href="clmse144.html#x177-411002r835">call-next-method</a> and <a 
href="clmse144.html#x177-418026r887">next-method-p</a> is
      not supported in primary methods.
      </li></ul>
<!--l. 1863--><p class="noindent" >The semantics of the simple built-in method combination types are as follows:
      <ul class="itemize1">
      <li class="itemize">If there are any :around methods, the most speciﬁc :around method is
      called. It supplies the value or values of the generic function.
      </li>
      <li class="itemize">Inside the body of an :around method, the function <a 
href="clmse144.html#x177-411002r835">call-next-method</a>
      can   be   used   to   call   the   next   method.   The   generic   function
      <a 
href="clmse144.html#x177-418034r891">no-next-method</a> is invoked if <a 
href="clmse144.html#x177-411002r835">call-next-method</a> is used and there is no
                                                                          

                                                                          
      applicable method to call. The function <a 
href="clmse144.html#x177-418026r887">next-method-p</a> may be used
      to determine whether a next method exists. When the next method
      returns, the :around method can execute more code, perhaps based on
      the returned value or values.
      </li>
      <li class="itemize">If an :around method invokes <a 
href="clmse144.html#x177-411002r835">call-next-method</a>, the next most speciﬁc
      :around method is called, if one is applicable. If there are no :around
      methods or if <a 
href="clmse144.html#x177-411002r835">call-next-method</a> is called by the least speciﬁc :around
      method, a Lisp form derived from the name of the built-in method
      combination type and from the list of applicable primary methods is
      evaluated to produce the value of the generic function. Suppose the name of
      the method combination type is <i>operator</i> and the call to the generic function
      is of the form <div class=lisp><div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(<i>generic-function</i> <span class="math">a<sub>1</sub></span> ... <span class="math">a<sub>n</sub></span>)
</td></tr></table>
      <!--l. 1891--><p class="noindent" >
</div>
</div>
      <!--l. 1892--><p class="noindent" >Let <span class="math">M<sub>1</sub>,…,M<sub>k</sub></span> be the applicable primary methods in order; then the derived
      Lisp form is <div class=lisp><div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(<i>operator</i> <span class="math">⟨M<sub>1</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span> ... <span class="math">⟨M<sub>k</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span>)
</td></tr></table>
      <!--l. 1897--><p class="noindent" >
</div>
</div>
      <!--l. 1898--><p class="noindent" >If the expression <span class="math">⟨M<sub>i</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span> is evaluated, the method <span class="math">M<sub>i</sub></span> will be applied to
      the arguments <span class="math">a<sub>1</sub>…a<sub>n</sub></span>. For example, if <i>operator</i> is <a 
href="clmse34.html#x45-80002r50">or</a>, the expression
      <span class="math">⟨M<sub>i</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span> is evaluated only if <span class="math">⟨M<sub>j</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span>, <span class="math">1 ≤ j &#x003C; i</span>, returned
      <a 
href="clmse31.html#x42-74002r18">nil</a>.
                                                                          

                                                                          
      <!--l. 1908--><p class="noindent" >The default order for the primary methods is :most-speciﬁc-ﬁrst. However,
      the order can be reversed by supplying :most-speciﬁc-last as the second
      argument to the :method-combination option.
      </li></ul>
<!--l. 1915--><p class="indent" >   The simple built-in method combination types require exactly one qualiﬁer per
method. An error is signaled if there are applicable methods with no qualiﬁers or
with qualiﬁers that are not supported by the method combination type. An error
is signaled if there are applicable :around methods and no applicable primary
methods.
<!--l. 1922--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.8   </span> <a 
href="clmli1.html#QQ2-176-429" id="x176-38700028.1.8">Meta-objects</a></h4>
<!--l. 1924--><p class="noindent" >The implementation of the Объектная система manipulates classes,
methods, and generic functions. The meta-object protocol speciﬁes a set of
generic functions deﬁned by methods on classes; the behavior of those
generic functions deﬁnes the behavior of the Объектная система. The
instances of the classes on which those methods are deﬁned are called
<i>meta-objects</i>. Programming at the meta-object protocol level involves
deﬁning new classes of meta-objects along with methods specialized on these
classes.
                                                                          

                                                                          
<!--l. 1934--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-38800028.1.8" id="x176-38800028.1.8">Metaclasses</a></h5>
<!--l. 1936--><p class="noindent" >The <i>metaclass</i> of an object is the class of its class. The metaclass determines the
representation of instances of its instances and the forms of inheritance used by its
instances for slot descriptions and method inheritance. The metaclass
mechanism can be used to provide particular forms of optimization or to
tailor the Объектная система Common Lisp&#x2019;а for particular uses. The
protocol for deﬁning metaclasses is discussed in the third part of the CLOS
speciﬁcation, The Объектная система Common Lisp&#x2019;а Meta-Object
Protocol. [The third part has not yet been approved by X3J13 for inclusion
in the forthcoming Common Lisp standard and is not included in this
book.—GLS]
<!--l. 1948--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-38900028.1.8" id="x176-38900028.1.8">Standard Metaclasses</a></h5>
<!--l. 1950--><p class="noindent" >The Объектная система Common Lisp&#x2019;а provides a number of predeﬁned
metaclasses. These include the classes standard-class, built-in-class, and
structure-class:
      <ul class="itemize1">
      <li class="itemize">The  class  standard-class  is  the  default  class  of  classes  deﬁned  by
      <a 
href="clmse144.html#x177-411022r845">defclass</a>.
      </li>
      <li class="itemize">The class built-in-class is the class whose instances are classes that
      have  special  implementations  with  restricted  capabilities.  Any  class
      that corresponds to a standard Common Lisp type might be an instance
      of  built-in-class.  The  predeﬁned  Common  Lisp  type  speciﬁers  that
      are  required  to  have  corresponding  classes  are  listed  in  table <a 
href="#x176-3720021">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a>.
      It  is  implementation-dependent  whether  each  of  these  classes  is
      implemented as a built-in class.
      </li>
      <li class="itemize">All classes deﬁned by means of <a 
href="clmse98.html#x122-226002r561">defstruct</a> are instances of structure-class.</li></ul>
                                                                          

                                                                          
<!--l. 1975--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-39000028.1.8" id="x176-39000028.1.8">Standard Meta-objects</a></h5>
<!--l. 1977--><p class="noindent" >The Объектная система supplies a standard set of meta-objects, called <i>standard
meta-objects</i>. These include the class standard-object and instances of the classes
standard-method, standard-generic-function, and method-combination.
      <ul class="itemize1">
      <li class="itemize">The  class  standard-method  is  the  default  class  of  methods  that
      are  deﬁned  by  the  forms  <a 
href="clmse144.html#x177-414002r849">defmethod</a>,  <a 
href="clmse144.html#x177-412002r846">defgeneric</a>,  <a 
href="clmse144.html#x177-416002r873">generic-function</a>,
      <a 
href="clmse144.html#x177-415048r872">generic-ﬂet</a>, <a 
href="clmse144.html#x177-417002r874">generic-labels</a>, and <a 
href="clmse144.html#x177-419004r913">with-added-methods</a>.
      </li>
      <li class="itemize">The  class  standard-generic-function  is  the  default  class  of  generic
      functions deﬁned by the forms <a 
href="clmse144.html#x177-414002r849">defmethod</a>, <a 
href="clmse144.html#x177-412002r846">defgeneric</a>, <a 
href="clmse144.html#x177-416002r873">generic-function</a>,
      <a 
href="clmse144.html#x177-415048r872">generic-ﬂet</a>, <a 
href="clmse144.html#x177-417002r874">generic-labels</a>, <a 
href="clmse144.html#x177-419004r913">with-added-methods</a>, and <a 
href="clmse144.html#x177-411022r845">defclass</a>.
      </li>
      <li class="itemize">The   class   named   standard-object   is   an   instance   of   the   class
      standard-class and is a superclass of every class that is an instance of
      standard-class except itself.
      </li>
      <li class="itemize">Every method combination object is an instance of a subclass of the
      class method-combination.
      </li></ul>
<!--l. 2006--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.9   </span> <a 
href="clmli1.html#QQ2-176-433" id="x176-39100028.1.9">Object Creation and Initialization</a></h4>
<!--l. 2009--><p class="noindent" >The generic function <a 
href="clmse144.html#x177-418012r880">make-instance</a> creates and returns a new instance of a class.
The ﬁrst argument is a class or the name of a class, and the remaining arguments
form an <i>initialization argument</i> list.
<!--l. 2014--><p class="indent" >   The initialization of a new instance consists of several distinct steps, including
the following: combining the explicitly supplied initialization arguments with
default values for the unsupplied initialization arguments, checking the
validity of the initialization arguments, allocating storage for the instance,
ﬁlling slots with values, and executing user-supplied methods that perform
                                                                          

                                                                          
additional initialization. Each step of <a 
href="clmse144.html#x177-418012r880">make-instance</a> is implemented by a
generic function to provide a mechanism for customizing that step. In
addition, <a 
href="clmse144.html#x177-418012r880">make-instance</a> is itself a generic function and thus also can be
customized.
<!--l. 2025--><p class="indent" >   The Объектная система speciﬁes system-supplied primary methods for each
step and thus speciﬁes a well-deﬁned standard behavior for the entire initialization
process. The standard behavior provides four simple mechanisms for controlling
initialization:
      <ul class="itemize1">
      <li class="itemize">Declaring  a  symbol  to  be  an  initialization  argument  for  a  slot.  An
      initialization argument is declared by using the :initarg slot option to
      <a 
href="clmse144.html#x177-411022r845">defclass</a>. This provides a mechanism for supplying a value for a slot in
      a call to <a 
href="clmse144.html#x177-418012r880">make-instance</a>.
      </li>
      <li class="itemize">Supplying a default value form for an initialization argument. Default
      value  forms  for  initialization  arguments  are  deﬁned  by  using  the
      :default-initargs class option to <a 
href="clmse144.html#x177-411022r845">defclass</a>. If an initialization argument
      is not explicitly provided as an argument to <a 
href="clmse144.html#x177-418012r880">make-instance</a>, the default
      value form is evaluated in the lexical environment of the <a 
href="clmse144.html#x177-411022r845">defclass</a> form
      that deﬁned it, and the resulting value is used as the value of the
      initialization argument.
      </li>
      <li class="itemize">Supplying a default initial value form for a slot. A default initial value
      form for a slot is deﬁned by using the :initform slot option to <a 
href="clmse144.html#x177-411022r845">defclass</a>.
      If no initialization argument associated with that slot is given as an
      argument  to  <a 
href="clmse144.html#x177-418012r880">make-instance</a>  or  is  defaulted  by  :default-initargs,  this
      default initial value form is evaluated in the lexical environment of the
      <a 
href="clmse144.html#x177-411022r845">defclass</a> form that deﬁned it, and the resulting value is stored in the
      slot. The :initform form for a local slot may be used when creating an
      instance, when updating an instance to conform to a redeﬁned class, or
      when updating an instance to conform to the deﬁnition of a diﬀerent
      class. The :initform form for a shared slot may be used when deﬁning
      or re-deﬁning the class.
      </li>
                                                                          

                                                                          
      <li class="itemize">Deﬁning
      methods  for  <a 
href="clmse144.html#x177-418004r876">initialize-instance</a>  and  <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>.  The  slot-ﬁlling
      behavior described above is implemented by a system-supplied primary
      method  for  <a 
href="clmse144.html#x177-418004r876">initialize-instance</a>  which  invokes  <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>.  The
      generic function <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> implements the parts of initialization
      shared  by  these  four  situations:  when  making  an  instance,  when
      re-initializing an instance, when updating an instance to conform to
      a redeﬁned class, and when updating an instance to conform to the
      deﬁnition of a diﬀerent class. The system-supplied primary method for
      <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> directly implements the slot-ﬁlling behavior described
      above, and <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> simply invokes <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>.
      </li></ul>
<!--l. 2074--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-39200028.1.9" id="x176-39200028.1.9">Initialization Arguments</a></h5>
<!--l. 2076--><p class="noindent" >An initialization argument controls object creation and initialization. It is often
convenient to use keyword symbols to name initialization arguments, but the
name of an initialization argument can be any symbol, including <a 
href="clmse31.html#x42-74002r18">nil</a>. An
initialization argument can be used in two ways: to ﬁll a slot with a value or to
provide an argument for an initialization method. A single initialization argument
can be used for both purposes.
<!--l. 2084--><p class="indent" >   An <i>initialization argument list</i> is a list of alternating initialization argument
names and values. Its structure is identical to a property list and also to the
portion of an argument list processed for &#x0026;key parameters. As in those lists, if an
initialization argument name appears more than once in an initialization
argument list, the leftmost occurrence supplies the value and the remaining
occurrences are ignored. The arguments to <a 
href="clmse144.html#x177-418012r880">make-instance</a> (after the ﬁrst
argument) form an initialization argument list. Error checking of initialization
argument names is disabled if the keyword argument pair whose keyword is
:allow-other-keys and whose value is non-<a 
href="clmse31.html#x42-74002r18">nil</a> appears in the initialization argument
list.
<!--l. 2097--><p class="indent" >   An initialization argument can be associated with a slot. If the initialization
argument has a value in the initialization argument list, the value is stored into
the slot of the newly created object, overriding any :initform form associated with
the slot. A single initialization argument can initialize more than one slot. An
initialization argument that initializes a shared slot stores its value into the shared
                                                                          

                                                                          
slot, replacing any previous value.
<!--l. 2105--><p class="indent" >   An initialization argument can be associated with a method. When an object
is created and a particular initialization argument is supplied, the generic
functions <a 
href="clmse144.html#x177-418004r876">initialize-instance</a>, <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>, and allocate-instance are
called with that initialization argument&#x2019;s name and value as a keyword
argument pair. If a value for the initialization argument is not supplied in the
initialization argument list, the method&#x2019;s lambda-list supplies a default
value.
<!--l. 2114--><p class="indent" >   Initialization arguments are used in four situations: when making an instance,
when re-initializing an instance, when updating an instance to conform to a
redeﬁned class, and when updating an instance to conform to the deﬁnition of a
diﬀerent class.
<!--l. 2119--><p class="indent" >   Because initialization arguments are used to control the creation and
initialization of an instance of some particular class, we say that an initialization
argument is “an initialization argument for” that class.
<!--l. 2125--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-39300028.1.9" id="x176-39300028.1.9">Declaring the Validity of Initialization Arguments</a></h5>
<!--l. 2128--><p class="noindent" >Initialization arguments are checked for validity in each of the four situations that
use them. An initialization argument may be valid in one situation and not
another. For example, the system-supplied primary method for <a 
href="clmse144.html#x177-418012r880">make-instance</a>
deﬁned for the class standard-class checks the validity of its initialization
arguments and signals an error if an initialization argument is supplied that is not
declared valid in that situation.
<!--l. 2137--><p class="indent" >   There are two means of declaring initialization arguments valid.
      <ul class="itemize1">
      <li class="itemize">Initialization arguments that ﬁll slots are declared valid by the :initarg
      slot  option  to  <a 
href="clmse144.html#x177-411022r845">defclass</a>.  The  :initarg  slot  option  is  inherited  from
      superclasses.  Thus  the  set  of  valid  initialization  arguments  that  ﬁll
      slots for a class is the union of the initialization arguments that ﬁll
      slots declared valid by that class and its superclasses. Initialization
      arguments that ﬁll slots are valid in all four contexts.
      </li>
      <li class="itemize">Initialization  arguments  that  supply  arguments  to  methods  are
                                                                          

                                                                          
      declared valid by deﬁning those methods. The keyword name of each
      keyword  parameter  speciﬁed  in  the  method&#x2019;s  lambda-list  becomes
      an  initialization  argument  for  all  classes  for  which  the  method
      is  applicable.  Thus  method  inheritance  controls  the  set  of  valid
      initialization arguments that supply arguments to methods. The generic
      functions for which method deﬁnitions serve to declare initialization
      arguments valid are as follows:
           <ul class="itemize2">
           <li class="itemize">Making an instance of a class: allocate-instance, <a 
href="clmse144.html#x177-418004r876">initialize-instance</a>,
           and <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>. Initialization arguments declared valid by
           these methods are valid when making an instance of a class.
           </li>
           <li class="itemize">Re-initializing an instance: the functions <a 
href="clmse144.html#x177-418043r895">reinitialize-instance</a> and
           shared-initialize. Initialization arguments declared valid by these
           methods are valid when re-initializing an instance.
           </li>
           <li class="itemize">Updating                   an                   instance                   to
           conform to a redeﬁned class: <a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a>
           and <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>. Initialization arguments declared valid by
           these methods are valid when updating an instance to conform to
           a redeﬁned class.
           </li>
           <li class="itemize">Updating an instance to conform to the deﬁnition of a diﬀerent
           class:   <a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a>   and   <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>.
           Initialization arguments declared valid by these methods are valid
           when  updating  an  instance  to  conform  to  the  deﬁnition  of  a
           diﬀerent class.</li></ul>
      </li></ul>
<!--l. 2184--><p class="indent" >   The set of valid initialization arguments for a class is the set of valid
initialization arguments that either ﬁll slots or supply arguments to methods,
along with the predeﬁned initialization argument :allow-other-keys. The default
value for :allow-other-keys is <a 
href="clmse31.html#x42-74002r18">nil</a>. The meaning of :allow-other-keys is the same
here as when it is passed to an ordinary function.
                                                                          

                                                                          
<!--l. 2193--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-39400028.1.9" id="x176-39400028.1.9">Defaulting of Initialization Arguments</a></h5>
<!--l. 2195--><p class="noindent" >A <i>default value form</i> can be supplied for an initialization argument by using the
:default-initargs class option. If an initialization argument is declared valid by
some particular class, its default value form might be speciﬁed by a diﬀerent class.
In this case :default-initargs is used to supply a default value for an inherited
initialization argument.
<!--l. 2202--><p class="indent" >   The :default-initargs option is used only to provide default values for
initialization arguments; it does not declare a symbol as a valid initialization
argument name. Furthermore, the :default-initargs option is used only
to provide default values for initialization arguments when making an
instance.
<!--l. 2208--><p class="indent" >   The argument to the :default-initargs class option is a list of alternating
initialization argument names and forms. Each form is the default value form for
the corresponding initialization argument. The default value form of an
initialization argument is used and evaluated only if that initialization argument
does not appear in the arguments to <a 
href="clmse144.html#x177-418012r880">make-instance</a> and is not defaulted by a more
speciﬁc class. The default value form is evaluated in the lexical environment of the
<a 
href="clmse144.html#x177-411022r845">defclass</a> form that supplied it; the result is used as the initialization argument&#x2019;s
value.
<!--l. 2219--><p class="indent" >   The initialization arguments supplied to <a 
href="clmse144.html#x177-418012r880">make-instance</a> are combined with
defaulted initialization arguments to produce a <i> defaulted initialization argument
list</i>. A defaulted initialization argument list is a list of alternating initialization
argument names and values in which unsupplied initialization arguments are
defaulted and in which the explicitly supplied initialization arguments appear
earlier in the list than the defaulted initialization arguments. Defaulted
initialization arguments are ordered according to the order in the class precedence
list of the classes that supplied the default values.
<!--l. 2229--><p class="indent" >   There is a distinction between the purposes of the :default-initargs and the
:initform options with respect to the initialization of slots. The :default-initargs
class option provides a mechanism for the user to give a default value form for an
initialization argument without knowing whether the initialization argument
initializes a slot or is passed to a method. If that initialization argument is not
explicitly supplied in a call to <a 
href="clmse144.html#x177-418012r880">make-instance</a>, the default value form is used, just
as if it had been supplied in the call. In contrast, the :initform slot option provides
a mechanism for the user to give a default initial value form for a slot. An
:initform form is used to initialize a slot only if no initialization argument
associated with that slot is given as an argument to <a 
href="clmse144.html#x177-418012r880">make-instance</a> or is defaulted
                                                                          

                                                                          
by :default-initargs.
<!--l. 2244--><p class="indent" >   The order of evaluation of default value forms for initialization arguments and
the order of evaluation of :initform forms are undeﬁned. If the order of evaluation
matters, use <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> or <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> methods.
<!--l. 2250--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-39500028.1.9" id="x176-39500028.1.9">Rules for Initialization Arguments</a></h5>
<!--l. 2253--><p class="noindent" >The :initarg slot option may be speciﬁed more than once for a given slot. The
following rules specify when initialization arguments may be multiply
deﬁned:
      <ul class="itemize1">
      <li class="itemize">A given initialization argument can be used to initialize more than one
      slot if the same initialization argument name appears in more than one
      :initarg slot option.
      </li>
      <li class="itemize">A given initialization argument name can appear in the lambda-list of
      more than one initialization method.
      </li>
      <li class="itemize">A given initialization argument name can appear both in an :initarg
      slot option and in the lambda-list of an initialization method.
      </li></ul>
<!--l. 2273--><p class="indent" >   If two or more initialization arguments that initialize the same slot are given in
the arguments to <a 
href="clmse144.html#x177-418012r880">make-instance</a>, the leftmost of these initialization arguments in
the initialization argument list supplies the value, even if the initialization
arguments have diﬀerent names.
<!--l. 2279--><p class="indent" >   If two or more diﬀerent initialization arguments that initialize the same
slot have default values and none is given explicitly in the arguments to
<a 
href="clmse144.html#x177-418012r880">make-instance</a>, the initialization argument that appears in a :default-initargs class
option in the most speciﬁc of the classes supplies the value. If a single
:default-initargs class option speciﬁes two or more initialization arguments that
initialize the same slot and none is given explicitly in the arguments to
<a 
href="clmse144.html#x177-418012r880">make-instance</a>, the leftmost argument in the :default-initargs class option
supplies the value, and the values of the remaining default value forms are
                                                                          

                                                                          
ignored.
<!--l. 2290--><p class="indent" >   Initialization arguments given explicitly in the arguments to <a 
href="clmse144.html#x177-418012r880">make-instance</a>
appear to the left of defaulted initialization arguments. Suppose that the classes
<span class="math">C<sub>1</sub></span> and <span class="math">C<sub>2</sub></span> supply the values of defaulted initialization arguments for diﬀerent
slots, and suppose that <span class="math">C<sub>1</sub></span> is more speciﬁc than <span class="math">C<sub>2</sub></span>; then the defaulted
initialization argument whose value is supplied by <span class="math">C<sub>1</sub></span> is to the left of the defaulted
initialization argument whose value is supplied by <span class="math">C<sub>2</sub></span> in the defaulted
initialization argument list. If a single :default-initargs class option supplies the
values of initialization arguments for two diﬀerent slots, the initialization
argument whose value is speciﬁed farther to the left in the default-initargs class
option appears farther to the left in the defaulted initialization argument
list.
<!--l. 2304--><p class="indent" >   If a slot has both an :initform form and an :initarg slot option, and the
initialization argument is defaulted using :default-initargs or is supplied to
<a 
href="clmse144.html#x177-418012r880">make-instance</a>, the captured :initform form is neither used nor evaluated.
<!--l. 2309--><p class="indent" >   The following is an example of the preceding rules:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass q () ((x :initarg a)))
</td></tr></table>
<!--l. 2312--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2313--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass r (q) ((x :initarg b))</td></tr></table>
<!--l. 2314--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (:default-initargs a 1 b 2))</td></tr></table>
<!--l. 2316--><p class="indent" >
</div>
</div>
<div class="flushleft" 
>
<!--l. 2318--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >                                     </td><td align="left" >Defaulted Initialization</td><td align="left" >Contents</td></tr><tr><td align="left" >Form  </td> <td align="left" >Argument List </td> <td align="left" >of Slot</td>
</tr><tr><td align="left" >(make-instance &#x2019;r)             </td><td align="left" >(a 1 b 2)                   </td><td align="left" >1          </td>
</tr><tr><td align="left" >(make-instance &#x2019;r &#x2019;a 3)       </td><td align="left" >(a 3 b 2)                   </td><td align="left" >3          </td>
</tr><tr><td align="left" >(make-instance &#x2019;r &#x2019;b 4)       </td><td align="left" >(b 4 a 1)                   </td><td align="left" >4          </td>
</tr><tr><td align="left" >(make-instance &#x2019;r &#x2019;a 1 &#x2019;a 2) </td><td align="left" >(a 1 a 2 b 2)              </td><td align="left" >1          </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" >  </td></tr></table>
</div></div>
                                                                          

                                                                          
<!--l. 2331--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-39600028.1.9" id="x176-39600028.1.9">Shared-Initialize</a></h5>
<!--l. 2334--><p class="noindent" >The generic function <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> is used to ﬁll the slots of an instance using
initialization arguments and :initform forms when an instance is created, when an
instance is re-initialized, when an instance is updated to conform to a redeﬁned
class, and when an instance is updated to conform to a diﬀerent class. It
uses standard method combination. It takes the following arguments:
the instance to be initialized, a speciﬁcation of a set of names of slots
accessible in that instance, and any number of initialization arguments.
The arguments after the ﬁrst two must form an initialization argument
list.
<!--l. 2345--><p class="indent" >   The second argument to <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> may be one of the following:
      <ul class="itemize1">
      <li class="itemize">It can be a list of slot names, which speciﬁes the set of those slot names.
      </li>
      <li class="itemize">It can be <a 
href="clmse31.html#x42-74002r18">nil</a>, which speciﬁes the empty set of slot names.
      </li>
      <li class="itemize">It can be the symbol <a 
href="clmse31.html#x42-74004r19">t</a>, which speciﬁes the set of all of the slots.
      </li></ul>
<!--l. 2360--><p class="indent" >   There is a system-supplied primary method for <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> whose ﬁrst
parameter specializer is the class standard-object. This method behaves as follows
on each slot, whether shared or local:
      <ul class="itemize1">
      <li class="itemize">If an initialization argument in the initialization argument list speciﬁes
      a value for that slot, that value is stored into the slot, even if a value
      has  already  been  stored  in  the  slot  before  the  method  is  run.  The
      aﬀected slots are independent of which slots are indicated by the second
      argument to <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>.
                                                                          

                                                                          
      </li>
      <li class="itemize">Any slots indicated by the second argument that are still unbound at
      this point are initialized according to their :initform forms. For any such
      slot that has an :initform form, that form is evaluated in the lexical
      environment of its deﬁning <a 
href="clmse144.html#x177-411022r845">defclass</a> form and the result is stored into
      the slot. For example, if a :before method stores a value in the slot,
      the :initform form will not be used to supply a value for the slot. If
      the second argument speciﬁes a name that does not correspond to any
      slots accessible in the instance, the results are unspeciﬁed.
      </li>
      <li class="itemize">The rules mentioned in section <a 
href="#x176-39500028.1.9">28.1.9<!--tex4ht:ref: Rules-for-Initialization-Arguments-SECTION --></a> are obeyed.
      </li></ul>
<!--l. 2387--><p class="indent" >   The generic function <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> is called by the system-supplied primary
methods for the generic functions <a 
href="clmse144.html#x177-418004r876">initialize-instance</a>, <a 
href="clmse144.html#x177-418043r895">reinitialize-instance</a>,
<a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a>, and <a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a>. Thus
methods can be written for shared-initialize to specify actions that should be
taken in all of these contexts.
<!--l. 2398--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-39700028.1.9" id="x176-39700028.1.9">Initialize-Instance</a></h5>
<!--l. 2400--><p class="noindent" >The generic function <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> is called by <a 
href="clmse144.html#x177-418012r880">make-instance</a> to initialize a
newly created instance. It uses standard method combination. Methods for
<a 
href="clmse144.html#x177-418004r876">initialize-instance</a> can be deﬁned in order to perform any initialization that cannot
be achieved with the simple slot-ﬁlling mechanisms.
                                                                          

                                                                          
<!--l. 2409--><p class="indent" >   During initialization, <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> is invoked after the following actions
have been taken:
      <ul class="itemize1">
      <li class="itemize">The  defaulted  initialization  argument  list  has  been  computed  by
      combining the supplied initialization argument list with any default
      initialization arguments for the class.
      </li>
      <li class="itemize">The  validity  of  the  defaulted  initialization  argument  list  has  been
      checked. If any of the initialization arguments has not been declared
      valid, an error is signaled.
      </li>
      <li class="itemize">A new instance whose slots are unbound has been created.
      </li></ul>
<!--l. 2426--><p class="indent" >   The generic function <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> is called with the new instance and the
defaulted initialization arguments. There is a system-supplied primary
method for <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> whose parameter specializer is the class
standard-object. This method calls the generic function <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> to ﬁll
in the slots according to the initialization arguments and the :initform
forms for the slots; the generic function <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> is called with
the following arguments: the instance, <a 
href="clmse31.html#x42-74004r19">t</a>, and the defaulted initialization
arguments.
<!--l. 2436--><p class="indent" >   Note that <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> provides the defaulted initialization argument list
in its call to <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>, so the ﬁrst step performed by the system-supplied
primary method for <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> takes into account both the initialization
arguments provided in the call to <a 
href="clmse144.html#x177-418012r880">make-instance</a> and the defaulted initialization
argument list.
<!--l. 2443--><p class="indent" >   Methods for <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> can be deﬁned to specify actions to be taken
when an instance is initialized. If only :after methods for <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> are
deﬁned, they will be run after the system-supplied primary method for
initialization and therefore they will not interfere with the default behavior of
<a 
href="clmse144.html#x177-418004r876">initialize-instance</a>.
<!--l. 2450--><p class="indent" >   The Объектная система provides two functions that are useful in the bodies
of <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> methods. The function <a 
href="clmse144.html#x177-418053r900">slot-boundp</a> returns a boolean value
that indicates whether a speciﬁed slot has a value; this provides a mechanism for
                                                                          

                                                                          
writing :after methods for <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> that initialize slots only if they have
not already been initialized. The function <a 
href="clmse144.html#x177-418057r902">slot-makunbound</a> causes the slot to
have no value.
<!--l. 2459--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-39800028.1.9" id="x176-39800028.1.9">Deﬁnitions of Make-Instance and Initialize-Instance</a></h5>
<!--l. 2461--><p class="noindent" >The generic function <a 
href="clmse144.html#x177-418012r880">make-instance</a> behaves as if it were deﬁned as follows, except
that certain optimizations are permitted:
                                                                          

                                                                          
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod make-instance ((class standard-class) &#x0026;rest initargs)
</td></tr></table>
<!--l. 2467--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setq initargs (default-initargs class initargs))</td></tr></table>
<!--l. 2468--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 2469--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((instance (apply #&#x2019;allocate-instance class initargs)))</td></tr></table>
<!--l. 2470--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (apply #&#x2019;initialize-instance instance initargs)</td></tr></table>
<!--l. 2471--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    instance))</td></tr></table>
<!--l. 2472--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2473--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod make-instance ((class-name symbol) &#x0026;rest initargs)</td></tr></table>
<!--l. 2474--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (apply #&#x2019;make-instance (ﬁnd-class class-name) initargs))</td></tr></table>
<!--l. 2476--><p class="indent" >
</div>
</div>
<!--l. 2501--><p class="indent" >   The elided code in the deﬁnition of <a 
href="clmse144.html#x177-418012r880">make-instance</a> checks the supplied
initialization arguments to determine whether an initialization argument was
supplied that neither ﬁlled a slot nor supplied an argument to an applicable
method. This check could be implemented using the generic functions
class-prototype, <a 
href="clmse144.html#x177-411020r844">compute-applicable-methods</a>, <a 
href="clmse144.html#x177-415046r871">function-keywords</a>, and
class-slot-initargs. See the third part of the Объектная система Common
Lisp&#x2019;а speciﬁcation for a description of this initialization argument check. [The
third part has not yet been approved by X3J13 for inclusion in the forthcoming
Common Lisp standard and is not included in this book.—GLS]
<!--l. 2513--><p class="indent" >   The generic function <a 
href="clmse144.html#x177-418004r876">initialize-instance</a> behaves as if it were deﬁned as follows,
except that certain optimizations are permitted:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod initialize-instance
</td></tr></table>
<!--l. 2517--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           ((instance standard-object) &#x0026;rest initargs)</td></tr></table>
<!--l. 2518--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (apply #&#x2019;shared-initialize instance t initargs)))</td></tr></table>
                                                                          

                                                                          
<!--l. 2520--><p class="indent" >
</div>
</div>
<!--l. 2522--><p class="indent" >   These procedures can be customized at either the Programmer Interface level,
the meta-object level, or both.
<!--l. 2525--><p class="indent" >   Customizing at the Programmer Interface level includes using the
:initform, :initarg, and :default-initargs options to <a 
href="clmse144.html#x177-411022r845">defclass</a>, as well as
deﬁning methods for <a 
href="clmse144.html#x177-418012r880">make-instance</a> and <a 
href="clmse144.html#x177-418004r876">initialize-instance</a>. It is also possible
to deﬁne methods for <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>, which would be invoked by the
generic functions <a 
href="clmse144.html#x177-418043r895">reinitialize-instance</a>, <a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a>,
<a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a>, and <a 
href="clmse144.html#x177-418004r876">initialize-instance</a>. The meta-object level
supports additional customization by allowing methods to be deﬁned on
<a 
href="clmse144.html#x177-418012r880">make-instance</a>, default-initargs, and allocate-instance. Parts 2 and 3 of the
Объектная система Common Lisp&#x2019;а speciﬁcation document each of these generic
functions and the system-supplied primary methods. [The third part has not yet
been approved by X3J13 for inclusion in the forthcoming Common Lisp standard
and is not included in this book.—GLS]
<!--l. 2542--><p class="indent" >   Implementations are permitted to make certain optimizations to
<a 
href="clmse144.html#x177-418004r876">initialize-instance</a> and <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>. The description of shared-initialize in
section <a 
href="clmse144.html#x177-41000028.2">28.2<!--tex4ht:ref: Functions-in-the-Programmer-Interface-SECTION --></a> mentions the possible optimizations.
<!--l. 2549--><p class="indent" >   Because of optimization, the check for valid initialization arguments
might not be implemented using the generic functions class-prototype,
compute-applicable-methods, <a 
href="clmse144.html#x177-415046r871">function-keywords</a>, and class-slot-initargs.
In addition, methods for the generic function default-initargs and the
system-supplied primary methods for allocate-instance, <a 
href="clmse144.html#x177-418004r876">initialize-instance</a>, and
shared-initialize might not be called on every call to make-instance or might not
receive exactly the arguments that would be expected.
<!--l. 2561--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.10   </span> <a 
href="clmli1.html#QQ2-176-441" id="x176-39900028.1.10">Redeﬁning Classes</a></h4>
<!--l. 2564--><p class="noindent" >A class that is an instance of standard-class can be redeﬁned if the new class will
also be an instance of standard-class. Redeﬁning a class modiﬁes the existing class
object to reﬂect the new class deﬁnition; it does not create a new class
object for the class. Any method object created by a :reader, :writer, or
:accessor option speciﬁed by the old <a 
href="clmse144.html#x177-411022r845">defclass</a> form is removed from the
corresponding generic function. Methods speciﬁed by the new <a 
href="clmse144.html#x177-411022r845">defclass</a> form are
                                                                          

                                                                          
added.
<!--l. 2577--><p class="indent" >   When the class <i>C</i> is redeﬁned, changes are propagated to its instances and to
instances of any of its subclasses. Updating such an instance occurs at an
implementation-dependent time, but no later than the next time a slot of that
instance is read or written. Updating an instance does not change its identity as
deﬁned by the <a 
href="clmse33.html#x44-78002r44">eq</a> function. The updating process may change the slots of that
particular instance, but it does not create a new instance. Whether updating an
instance consumes storage is implementation-dependent.
<!--l. 2586--><p class="indent" >   Note that redeﬁning a class may cause slots to be added or deleted. If a class is
redeﬁned in a way that changes the set of local slots accessible in instances, the
instances will be updated. It is implementation-dependent whether instances are
updated if a class is redeﬁned in a way that does not change the set of local slots
accessible in instances.
<!--l. 2593--><p class="indent" >   The value of a slot that is speciﬁed as shared both in the old class and in the
new class is retained. If such a shared slot was unbound in the old class, it will be
unbound in the new class. Slots that were local in the old class and that
are shared in the new class are initialized. Newly added shared slots are
initialized.
<!--l. 2599--><p class="indent" >   Each newly added shared slot is set to the result of evaluating the captured
:initform form for the slot that was speciﬁed in the <a 
href="clmse144.html#x177-411022r845">defclass</a> form for the new class.
If there is no :initform form, the slot is unbound.
<!--l. 2604--><p class="indent" >   If a class is redeﬁned in such a way that the set of local slots accessible in an
instance of the class is changed, a two-step process of updating the instances of
the class takes place. The process may be explicitly started by invoking the
generic function <a 
href="clmse144.html#x177-418018r883">make-instances-obsolete</a>. This two-step process can happen
in other circumstances in some implementations. For example, in some
implementations this two-step process will be triggered if the order of slots in
storage is changed.
<!--l. 2613--><p class="indent" >   The ﬁrst step modiﬁes the structure of the instance by adding new local slots
and discarding local slots that are not deﬁned in the new version of the class. The
second step initializes the newly added local slots and performs any other
user-deﬁned actions. These steps are further speciﬁed in the next two
sections.
<!--l. 2620--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-40000028.1.10" id="x176-40000028.1.10">Modifying the Structure of Instances</a></h5>
                                                                          

                                                                          
<!--l. 2622--><p class="noindent" >The ﬁrst step modiﬁes the structure of instances of the redeﬁned class
to conform to its new class deﬁnition. Local slots speciﬁed by the new
class deﬁnition that are not speciﬁed as either local or shared by the
old class are added, and slots not speciﬁed as either local or shared by
the new class deﬁnition that are speciﬁed as local by the old class are
discarded. The names of these added and discarded slots are passed as
arguments to <a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a> as described in the next
section.
<!--l. 2631--><p class="indent" >   The values of local slots speciﬁed by both the new and old classes are retained.
If such a local slot was unbound, it remains unbound.
<!--l. 2634--><p class="indent" >   The value of a slot that is speciﬁed as shared in the old class and as local in
the new class is retained. If such a shared slot was unbound, the local slot will be
unbound.
<!--l. 2639--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-40100028.1.10" id="x176-40100028.1.10">Initializing Newly Added Local Slots</a></h5>
<!--l. 2641--><p class="noindent" >The second step initializes the newly added local slots and performs any other
user-deﬁned actions. This step is implemented by the generic function
<a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a>, which is called after completion of the ﬁrst
step of modifying the structure of the instance.
<!--l. 2647--><p class="indent" >   The generic function <a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a> takes four required
arguments: the instance being updated after it has undergone the ﬁrst step, a list
of the names of local slots that were added, a list of the names of local slots that
were discarded, and a property list containing the slot names and values of slots
that were discarded and had values. Included among the discarded slots
are slots that were local in the old class and that are shared in the new
class.
<!--l. 2656--><p class="indent" >   The generic function <a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a> also takes any number
of initialization arguments. When it is called by the system to update an
instance whose class has been redeﬁned, no initialization arguments are
provided.
<!--l. 2661--><p class="indent" >   There is a system-supplied primary method for the generic function
<a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a> whose parameter specializer for its instance
argument is the class standard-object. First this method checks the validity of
initialization arguments and signals an error if an initialization argument is
supplied that is not declared valid (see section <a 
href="#x176-39300028.1.9">28.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>.) Then it calls the generic
                                                                          

                                                                          
function <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> with the following arguments: the instance, the list
of names of the newly added slots, and the initialization arguments it
received.
<!--l. 2674--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-40200028.1.10" id="x176-40200028.1.10">Customizing Class Redeﬁnition</a></h5>
<!--l. 2676--><p class="noindent" >Methods for <a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a> may be deﬁned to specify
actions to be taken when an instance is updated. If only :after methods for
<a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a> are deﬁned, they will be run after the
system-supplied primary method for initialization and therefore will not interfere
with the default behavior of <a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a>. Because no
initialization arguments are passed to <a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a> when it
is called by the system, the :initform forms for slots that are ﬁlled by :before
methods for <a 
href="clmse144.html#x177-418075r911">update-instance-for-redeﬁned-class</a> will not be evaluated by
<a 
href="clmse144.html#x177-418051r899">shared-initialize</a>.
<!--l. 2688--><p class="indent" >   Methods for <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> may be deﬁned to customize class redeﬁnition
(see section <a 
href="#x176-39600028.1.9">28.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
<!--l. 2692--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-40300028.1.10" id="x176-40300028.1.10">Extensions</a></h5>
<!--l. 2694--><p class="noindent" >There are two allowed extensions to class redeﬁnition:
      <ul class="itemize1">
      <li class="itemize">The Объектная система may be extended to permit the new class to
      be an instance of a metaclass other than the metaclass of the old class.
      </li>
      <li class="itemize">The Объектная система may be extended to support an updating
      process when either the old or the new class is an instance of a class
      other than standard-class that is not a built-in class.
      </li></ul>
                                                                          

                                                                          
<!--l. 2709--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.11   </span> <a 
href="clmli1.html#QQ2-176-446" id="x176-40400028.1.11">Changing the Class of an Instance</a></h4>
<!--l. 2712--><p class="noindent" >The function <a 
href="clmse144.html#x177-411008r838">change-class</a> can be used to change the class of an instance from its
current class, <span class="math">C<sub>from</sub></span>, to a diﬀerent class, <span class="math">C<sub>to</sub></span>; it changes the structure of the
instance to conform to the deﬁnition of the class <span class="math">C<sub>to</sub></span>.
<!--l. 2718--><p class="indent" >   Note that changing the class of an instance may cause slots to be added or
deleted.
<!--l. 2721--><p class="indent" >   When <a 
href="clmse144.html#x177-411008r838">change-class</a> is invoked on an instance, a two-step updating process
takes place. The ﬁrst step modiﬁes the structure of the instance by adding new
local slots and discarding local slots that are not speciﬁed in the new version of
the instance. The second step initializes the newly added local slots and performs
any other user-deﬁned actions. These steps are further described in the following
two sections.
<!--l. 2729--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-40500028.1.11" id="x176-40500028.1.11">Modifying the Structure of an Instance</a></h5>
<!--l. 2731--><p class="noindent" >In order to make an instance conform to the class <span class="math">C<sub>to</sub></span>, local slots speciﬁed by the
class <span class="math">C<sub>to</sub></span> that are not speciﬁed by the class <span class="math">C<sub>from</sub></span> are added, and local slots
not speciﬁed by the class <span class="math">C<sub>to</sub></span> that are speciﬁed by the class <span class="math">C<sub>from</sub></span> are
discarded.
<!--l. 2738--><p class="indent" >   The values of local slots speciﬁed by both the class <span class="math">C<sub>to</sub></span> and the class <span class="math">C<sub>from</sub></span> are
retained. If such a local slot was unbound, it remains unbound.
<!--l. 2743--><p class="indent" >   The values of slots speciﬁed as shared in the class <span class="math">C<sub>from</sub></span> and as local in the
class <span class="math">C<sub>to</sub></span> are retained.
<!--l. 2747--><p class="indent" >   This ﬁrst step of the update does not aﬀect the values of any shared
slots.
<!--l. 2751--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-40600028.1.11" id="x176-40600028.1.11">Initializing Newly Added Local Slots</a></h5>
<!--l. 2753--><p class="noindent" >The second step of the update initializes the newly added slots and
performs any other user-deﬁned actions. This step is implemented by the
generic function <a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a>. The generic function
<a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a> is invoked by <a 
href="clmse144.html#x177-411008r838">change-class</a> after the ﬁrst step of
the update has been completed.
<!--l. 2760--><p class="indent" >   The generic function <a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a> is invoked on two
                                                                          

                                                                          
arguments computed by <a 
href="clmse144.html#x177-411008r838">change-class</a>. The ﬁrst argument passed is a copy of the
instance being updated and is an instance of the class <span class="math">C<sub>from</sub></span>; this copy has
dynamic extent within the generic function <a 
href="clmse144.html#x177-411008r838">change-class</a>. The second argument is
the instance as updated so far by <a 
href="clmse144.html#x177-411008r838">change-class</a> and is an instance of the class
<span class="math">C<sub>to</sub></span>.
<!--l. 2768--><p class="indent" >   The generic function <a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a> also takes any number
of initialization arguments. When it is called by <a 
href="clmse144.html#x177-411008r838">change-class</a>, no initialization
arguments are provided.
<!--l. 2772--><p class="indent" >   There is a system-supplied primary method for the generic function
<a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a> that has two parameter specializers, each of
which is the class standard-object. First this method checks the validity of
initialization arguments and signals an error if an initialization argument is
supplied that is not declared valid (see section <a 
href="#x176-39300028.1.9">28.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>). Then it calls the generic
function <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> with the following arguments: the instance, a list
of names of the newly added slots, and the initialization arguments it
received.
<!--l. 2784--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-40700028.1.11" id="x176-40700028.1.11">Customizing the Change of Class of an Instance</a></h5>
<!--l. 2786--><p class="noindent" >Methods for <a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a> may be deﬁned to specify
actions to be taken when an instance is updated. If only :after methods for
<a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a> are deﬁned, they will be run after the
system-supplied primary method for initialization and will not interfere with the
default behavior of <a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a>. Because no initialization
arguments are passed to <a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a> when it is called
by <a 
href="clmse144.html#x177-411008r838">change-class</a>, the :initform forms for slots that are ﬁlled by :before
methods for <a 
href="clmse144.html#x177-418071r909">update-instance-for-diﬀerent-class</a> will not be evaluated by
<a 
href="clmse144.html#x177-418051r899">shared-initialize</a>.
<!--l. 2798--><p class="indent" >   Methods for <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> may be deﬁned to customize class redeﬁnition
(see section <a 
href="#x176-39600028.1.9">28.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
<!--l. 2801--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.12   </span> <a 
href="clmli1.html#QQ2-176-450" id="x176-40800028.1.12">Reinitializing an Instance</a></h4>
<!--l. 2804--><p class="noindent" >The generic function <a 
href="clmse144.html#x177-418043r895">reinitialize-instance</a> may be used to change the values of slots
according to initialization arguments.
                                                                          

                                                                          
<!--l. 2807--><p class="indent" >   The process of reinitialization changes the values of some slots and performs
any user-deﬁned actions.
<!--l. 2810--><p class="indent" >   Reinitialization does not modify the structure of an instance to add or delete
slots, and it does not use any :initform forms to initialize slots.
<!--l. 2814--><p class="indent" >   The generic function <a 
href="clmse144.html#x177-418043r895">reinitialize-instance</a> may be called directly. It takes one
required argument, the instance. It also takes any number of initialization
arguments to be used by methods for <a 
href="clmse144.html#x177-418043r895">reinitialize-instance</a> or for <a 
href="clmse144.html#x177-418051r899">shared-initialize</a>.
The arguments after the required instance must form an initialization argument
list.
<!--l. 2821--><p class="indent" >   There is a system-supplied primary method for <a 
href="clmse144.html#x177-418043r895">reinitialize-instance</a> whose
parameter specializer is the class standard-object. First this method checks the
validity of initialization arguments and signals an error if an initialization
argument is supplied that is not declared valid (see section <a 
href="#x176-39300028.1.9">28.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>). Then it calls
the generic function <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> with the following arguments: the instance,
<a 
href="clmse31.html#x42-74002r18">nil</a>, and the initialization arguments it received.
                                                                          

                                                                          
<!--l. 2833--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x176-40900028.1.12" id="x176-40900028.1.12">Customizing Reinitialization</a></h5>
<!--l. 2835--><p class="noindent" >Methods for the generic function <a 
href="clmse144.html#x177-418043r895">reinitialize-instance</a> may be deﬁned to specify
actions to be taken when an instance is updated. If only :after methods for
<a 
href="clmse144.html#x177-418043r895">reinitialize-instance</a> are deﬁned, they will be run after the system-supplied
primary method for initialization and therefore will not interfere with the default
behavior of <a 
href="clmse144.html#x177-418043r895">reinitialize-instance</a>.
<!--l. 2842--><p class="indent" >   Methods for <a 
href="clmse144.html#x177-418051r899">shared-initialize</a> may be deﬁned to customize class redeﬁnition
(see section <a 
href="#x176-39600028.1.9">28.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
                                                                          

                                                                          
   <!--l. 2846--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse144.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html#tailclmch28.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse143.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html#clmse143.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 2846--><p class="indent" >   <a 
 id="tailclmse143.html"></a>   
</body></html> 
