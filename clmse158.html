<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Series Functions</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 119--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse159.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse157.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse157.html#tailclmse157.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse158.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmap1.html#clmse158.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">A.2   </span> <a 
 id="x193-349000A.2"></a>Series Functions</h3>
<!--l. 122--><p class="noindent" >Throughout this chapter the notation <i>S<sub>j</sub></i> is used to denote the jth element of the
series <i>S</i>. As in a list or vector, the ﬁrst element of a series has the subscript
zero.
<!--l. 126--><p class="indent" >   The <i>#</i> macro character syntax <i>#Zlist</i> denotes a series that contains
the elements of list. This syntax is also used when series are printed. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(choose-if #&#x2019;symbolp #Z(a 2 b))  ⇒ #Z(a b)
</td></tr></table>
<!--l. 130--><p class="indent" >
</div>
</div>
<!--l. 131--><p class="noindent" >Series are self-evaluating objects and the series data type is disjoint from all other
types.
<div class=defun>
<!--l. 135--><p class="noindent" > <i>[Type speciﬁer]</i>   <b>series</b> <a 
 id="dx193-349001"></a><a 
 id="x193-349002r1056"></a>   <i>element-type</i>
<!--l. 137--><p class="noindent" >The type speciﬁer <i>(series element-type)</i> denotes the set of series whose elements
are all members of the type element-type.
</div>
<div class=defun>
<!--l. 144--><p class="noindent" > <i>[Function]</i>   <b>series</b> <a 
 id="dx193-349003"></a><a 
 id="x193-349004r1057"></a>   <i>arg</i>  <b>&#x0026;rest</b>  args
<!--l. 146--><p class="noindent" >The function <i>series</i> returns an unbounded series that endlessly repeats the values
of the arguments. The second example below shows the preferred method for
constructing a bounded series. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(series &#x2019;b &#x2019;c)  ⇒ #Z(b c b c b c ...)
</td></tr></table>
<!--l. 151--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan (list &#x2019;a &#x2019;b &#x2019;c))  ⇒ #Z(a b c)</td></tr></table>
<!--l. 153--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<!--l. 156--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.1   </span> <a 
 id="x193-350000A.2.1"></a>Scanners</h4>
<!--l. 158--><p class="noindent" >Scanners create series outputs based on non-series inputs. Either they operate
based on some formula (for example, scanning a range of integers) or they
enumerate the elements in an aggregate data structure (for example, scanning the
elements in a list or array).
<div class=defun>
<!--l. 164--><p class="noindent" > <i>[Function]</i>   <b>scan-range</b> <a 
 id="dx193-350001"></a><a 
 id="x193-350002r1058"></a>   <b>&#x0026;key</b>  (<i>:start</i>  0) (<i>:by</i>  1) (<i>:type</i>  &#x2019;number) :upto
:below  :downto  :above  :length
<!--l. 167--><p class="noindent" >The function <i>scan-range</i> returns a series of numbers starting with the <i>:start</i>
argument (default integer <i>0</i>) and counting up by the <i>:by</i> argument (default
integer <i>1</i>). The <i>:type</i> argument (default <i>number</i>) is a type speciﬁer indicating the
type of numbers in the series produced. The <i>:type</i> argument must be a (not
necessarily proper) subtype of <i>number</i>. The <i>:start</i> and <i>:by</i> arguments must be of
that type.
<!--l. 176--><p class="indent" >   One of the last ﬁve arguments may be used to specify the kind of end test to
be used; these are called termination arguments. If <i>:upto</i> is speciﬁed,
counting continues only so long as the numbers generated are less than
or equal to <i>:upto</i>. If <i>:below</i> is speciﬁed, counting continues only so long
as the numbers generated are less than <i>:below</i>. If <i>:downto</i> is speciﬁed,
counting continues only so long as the numbers generated are greater
than or equal to <i>:downto</i>. If <i>:above</i> is speciﬁed, counting continues only
so long as the numbers generated are greater than <i>:above</i>. If <i>:length</i> is
speciﬁed, it must be a non-negative integer and the output series has this
length.
<!--l. 189--><p class="indent" >   If none of the termination arguments are speciﬁed, the output has
unbounded length. If more than one termination argument is speciﬁed, it is an
error.
<div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range :upto 4)  ⇒ #Z(0 1 2 3 4)
</td></tr></table>
<!--l. 194--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range :from 1 :by -1 :above -4)  ⇒ #Z(1 0 -1 -2 -3)</td></tr></table>
<!--l. 195--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range :from .5 :by .1 :type &#x2019;ﬂoat)  ⇒ #Z(.5 .6 .7 ...)</td></tr></table>
<!--l. 196--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range)  ⇒ #Z(0 1 2 3 4 5 6 ...)</td></tr></table>
<!--l. 198--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 201--><p class="noindent" > <i>[Function]</i>   <b>scan</b> <a 
 id="dx193-350003"></a><a 
 id="x193-350004r1059"></a>   <i>sequence</i> <br 
class="newline" /><i>[Function]</i>   <b>scan</b> <a 
 id="dx193-350005"></a><a 
 id="x193-350006r1060"></a>   <i>type</i>  <i>sequence</i>
<!--l. 204--><p class="noindent" ><i>scan</i> returns a series containing the elements of sequence in order. The type
argument is a type speciﬁer indicating the type of sequence to be scanned; it must
be a (not necessarily proper) subtype of <i>sequence</i>. If type is omitted, it defaults
to <i>list</i>. (This function exhibits an argument pattern that is unusual for
Common Lisp: an “optional” argument preceding a required argument. This
pattern cannot be expressed in the usual manner with <i>&#x0026;optional</i>. It is
indicated above by two deﬁnition lines, showing the two possible argument
patterns.)
<!--l. 215--><p class="indent" >   If the sequence is a list, it must be a proper list ending in <i>nil</i>. Scanning is
signiﬁcantly more eﬃcient if it can be determined at compile time whether type is
a subtype of <i>list</i> or <i>vector</i> and for vectors what the length of the vector is. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan &#x2019;(a b c))  ⇒ #Z(a b c)
</td></tr></table>
<!--l. 220--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan &#x2019;string &#x0022;BAR&#x0022;)  ⇒ #Z(#<tt>\</tt>B #<tt>\</tt>A #<tt>\</tt>R)</td></tr></table>
<!--l. 222--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 225--><p class="noindent" > <i>[Function]</i>   <b>scan-sublists</b> <a 
 id="dx193-350007"></a><a 
 id="x193-350008r1061"></a>   <i>list</i>
<!--l. 227--><p class="noindent" ><i>scan-sublists</i> returns a series containing the successive sublists of list. The list
must be a proper list ending in <i>nil</i>. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-sublists &#x2019;(a b c))  ⇒ #Z((a b c) (b c) (c))
</td></tr></table>
<!--l. 232--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 235--><p class="noindent" > <i>[Function]</i>   <b>scan-multiple</b> <a 
 id="dx193-350009"></a><a 
 id="x193-350010r1062"></a>   <i>type</i>  <i>ﬁrst-sequence</i>  <b>&#x0026;rest</b>  more-sequences
<!--l. 237--><p class="noindent" >Several sequences can be scanned at once by using several calls on <i>scan</i>. Each call
on <i>scan</i> will test to see when its sequence runs out of elements and execution will
stop as soon as any of the sequences are exhausted. Although very robust, this
approach to scanning can be ineﬃcient. In situations where it is known in advance
which sequence is the shortest, <i>scan-multiple</i> can be used to obtain the same
results more rapidly.
<i>
<!--l. 246--><p class="indent" >   scan-multiple</i> is similar to <i>scan</i> except that several sequences can be scanned
at once. If there are n sequence inputs, <i>scan-multiple</i> returns n series containing
the elements of these sequences. It must be the case that none of the sequence
inputs is shorter than the ﬁrst sequence. All of the output series are the same
length as the ﬁrst input sequence. Extra elements in the other input sequences are
ignored. Using <i>scan-multiple</i> is more eﬃcient than using multiple instances of
<i>scan</i>, because <i>scan-multiple</i> only has to check for the ﬁrst input running out of
elements.
<!--l. 256--><p class="indent" >   If type is of the form <i>(values t<sub>1</sub> … tx<sub>m</sub>)</i>, then there must be m sequence inputs
and the ith sequence must have type t<sub>i</sub>. Otherwise there can be any number of
sequence inputs, each of which must have type type. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(multiple-value-bind (data weights)
</td></tr></table>
<!--l. 261--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (scan-multiple &#x2019;list &#x2019;(1 6 3 2 8) &#x2019;(2 3 3 3 2))</td></tr></table>
<!--l. 262--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (collect (map-fn t #&#x2019;* data weights)))</td></tr></table>
<!--l. 263--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ (2 18 9 6 16)</td></tr></table>
<!--l. 265--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 268--><p class="noindent" > <i>[Function]</i>   <b>scan-lists-of-lists</b> <a 
 id="dx193-350011"></a><a 
 id="x193-350012r1063"></a>   <i>lists-of-lists</i>  <b>&#x0026;optional</b>  <i>leaf-test</i><br 
class="newline" /><i>[Function]</i>   <b>scan-lists-of-lists-fringe</b> <a 
 id="dx193-350013"></a><a 
 id="x193-350014r1064"></a>   <i>lists-of-lists</i>  <b>&#x0026;optional</b>  <i>leaf-test</i>
<!--l. 271--><p class="noindent" >The argument lists-of-lists is viewed as a tree where each internal node is a
non-empty list and the elements of the list are the children of the node.
<i>scan-lists-of-lists</i> and <i>scan-lists-of-lists-fringe</i> each scan lists-of-lists in preorder
and return a series of its nodes. <i>scan-lists-of-lists</i> returns every node in the tree.
<i>scan-lists-of-lists-fringe</i> returns only the leaf nodes.
<!--l. 280--><p class="indent" >   The scan proceeds as follows. The argument lists-of-lists can be any Lisp
object. If lists-of-lists is an atom or satisﬁes the predicate leaf-test (if present), it
is a leaf node. (The predicate can count on being applied only to conses.)
Otherwise, lists-of-lists is a (not necessarily proper) list. The ﬁrst element of
lists-of-lists is recursively scanned in full, followed by the second and so on until a
non-cons cdr is encountered. Whether or not this ﬁnal cdr is <i>nil</i>, it is ignored. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-lists-of-lists &#x2019;((2) (nil)))
</td></tr></table>
<!--l. 289--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(((2) (nil)) (2) 2 (nil) nil)</td></tr></table>
<!--l. 290--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-lists-of-lists-fringe &#x2019;((2) (nil)))  ⇒ #Z(2 nil)</td></tr></table>
<!--l. 291--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-lists-of-lists-fringe &#x2019;((2) (nil))</td></tr></table>
<!--l. 292--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                            #&#x2019;(lambda (e) (numberp (car e))))</td></tr></table>
<!--l. 293--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z((2) nil)</td></tr></table>
<!--l. 295--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 298--><p class="noindent" > <i>[Function]</i>   <b>scan-alist</b> <a 
 id="dx193-350015"></a><a 
 id="x193-350016r1065"></a>   <i>a-list</i>  <b>&#x0026;optional</b>  (<i>test</i> #&#x2019;eql)<br 
class="newline" /><i>[Function]</i>   <b>scan-plist</b> <a 
 id="dx193-350017"></a><a 
 id="x193-350018r1066"></a>   <i>plist</i> <br 
class="newline" /><i>[Function]</i>   <b>scan-hash</b> <a 
 id="dx193-350019"></a><a 
 id="x193-350020r1067"></a>   <i>table</i>
<!--l. 302--><p class="noindent" >When given an association list, a property list, or a hash table (respectively), each
of these functions produces two outputs: a series of keys K and a series of the
corresponding values V. Each key in the input appears exactly once in the output,
even if it appears more than once in the input. (The test argument of
                                                                          

                                                                          
<i>scan-alist</i> speciﬁes the equality test between keys; it defaults to <i>eql</i>.) The
two outputs have the same length. Each V<sub>j</sub> is the value returned by the
appropriate accessing function (<i>cdr</i> of <i>assoc</i>, <i>getf </i>, or <i>gethash</i>, respectively) when
given K<sub>j</sub>. <i>scan-alist</i> and <i>scan-plist</i> scan keys in the order they appear in
the underlying structure. <i>scan-hash</i> scans keys in no particular order. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-plist &#x2019;(a 1 b 3))  ⇒ #Z(a b) and #Z(1 3)
</td></tr></table>
<!--l. 317--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-alist &#x2019;((a . 1) nil (a . 3) (b . 2)))</td></tr></table>
<!--l. 318--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(a b) and #Z(1 2)</td></tr></table>
<!--l. 320--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 323--><p class="noindent" > <i>[Function]</i>   <b>scan-symbols</b> <a 
 id="dx193-350021"></a><a 
 id="x193-350022r1068"></a>   <b>&#x0026;optional</b>  (<i>package</i> *package*)
<!--l. 325--><p class="noindent" ><i>scan-symbols</i> returns a series, in no particular order, and possibly containing
duplicates, of the symbols accessible in package (which defaults to the current
package).
</div>
<div class=defun>
<!--l. 331--><p class="noindent" > <i>[Function]</i>   <b>scan-ﬁle</b> <a 
 id="dx193-350023"></a><a 
 id="x193-350024r1069"></a>   <i>ﬁle-name</i>  <b>&#x0026;optional</b>  (<i>reader</i> #&#x2019;read)
<!--l. 333--><p class="noindent" ><i>scan-ﬁle</i> opens the ﬁle named by the string ﬁle-name and applies the function
reader to it repeatedly until the end of the ﬁle is reached. Reader must accept the
standard input function arguments input-stream, eof-error-p, and eof-value as its
arguments. (For instance, reader can be <i>read</i>, <i>read-preserving-white-space</i>,
<i>read-line</i>, or <i>read-char</i>.) If omitted, reader defaults to <i>read</i>. <i>scan-ﬁle</i> returns a
series of the values returned by reader, up to but not including the value returned
when the end of the ﬁle is reached. The ﬁle is correctly closed, even if an abort
occurs.
</div>
<div class=defun>
<!--l. 346--><p class="noindent" > <i>[Function]</i>   <b>scan-fn</b> <a 
 id="dx193-350025"></a><a 
 id="x193-350026r1070"></a>   <i>type</i>  <i>init</i>  <i>step</i>  <b>&#x0026;optional</b>  <i>test</i>
<!--l. 348--><p class="noindent" >The higher-order function <i>scan-fn</i> supports the general concept of scanning. The
type argument is a type speciﬁer indicating the type of values returned by
                                                                          

                                                                          
init and step. The <i>values</i> type speciﬁer can be used for this argument to
indicate multiple types; however, type cannot indicate zero values. If type
indicates m types t<sub>1</sub>,…,t<sub>m</sub>, then <i>scan-fn</i> returns m series T1, … , Tm,
where Ti has the type <i>(series t<sub>i</sub>)</i>. The arguments init, step, and test are
functions.
<!--l. 361--><p class="indent" >   The init must be of type <i>(function () (values t<sub>1</sub> ... t<sub>m</sub>))</i>.
<!--l. 364--><p class="indent" >   The step must be of type <i>(function (t<sub>1</sub> ... t<sub>m</sub>) (values t<sub>1</sub> ... t<sub>m</sub>))</i>.
<!--l. 367--><p class="indent" >   The test (if present) must be of type <i>(function (t<sub>1</sub> ... t<sub>m</sub>) t)</i>.
<!--l. 370--><p class="indent" >   The elements of the Ti are computed as follows: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values T1<sub>0</sub> ... Tm<sub>0</sub>) = (funcall init)
</td></tr></table>
<!--l. 372--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values T1<sub>j</sub> ... Tm<sub>j</sub>) = (funcall step T1<sub>(j−1)</sub> ... Tm<sub>(j−1)</sub>)</td></tr></table>
<!--l. 374--><p class="indent" >
</div>
</div>
<!--l. 376--><p class="indent" >   The outputs all have the same length. If there is no test, the outputs have
unbounded length. If there is a test, the outputs consist of the elements up to, but
not including, the ﬁrst elements (with index j, say) for which the following
termination test is not <i>nil</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall test T1<sub>j</sub> ... Tm<sub>j</sub>)
</td></tr></table>
<!--l. 382--><p class="indent" >
</div>
</div>
<!--l. 383--><p class="noindent" >It is guaranteed that step will not be applied to the elements that pass this
termination test.
<!--l. 386--><p class="indent" >   If init, step, or test has side eﬀects when invoked, it can count on being called
in the order indicated by the equations above, with test called just before step on
each cycle. However, given the lazy evaluation nature of series, these functions will
not be called until their outputs are actually used (if ever). In addition, no
assumptions can be made about the relative order of evaluation of these
calls with regard to execution in other parts of a given series expression.
The ﬁrst example below scans down a list stepping two elements at a
                                                                          

                                                                          
time. The second example generates two unbounded series: the integers
counting up from 1 and the sequence of partial sums of the ﬁrst i integers. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-fn t #&#x2019;(lambda () &#x2019;(a b c d)) #&#x2019;cddr #&#x2019;null)
</td></tr></table>
<!--l. 398--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z((a b c d) (c d))</td></tr></table>
<!--l. 399--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 400--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-fn &#x2019;(values integer integer)</td></tr></table>
<!--l. 401--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         #&#x2019;(lambda () (values 1 0))</td></tr></table>
<!--l. 402--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         #&#x2019;(lambda (i sum) (values (+ i 1) (+ sum i))))</td></tr></table>
<!--l. 403--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(1 2 3 4 ...) and #Z(0 1 3 6 ...)</td></tr></table>
<!--l. 405--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 408--><p class="noindent" > <i>[Function]</i>   <b>scan-fn-inclusive</b> <a 
 id="dx193-350027"></a><a 
 id="x193-350028r1071"></a>   <i>type</i>  <i>init</i>  <i>step</i>  <i>test</i>
<!--l. 410--><p class="noindent" >The higher-order function <i>scan-fn-inclusive</i> is the same as <i>scan-fn</i> except that the
ﬁrst set of elements for which test returns a non-null value is included in the
output. As with <i>scan-fn</i>, it is guaranteed that step will not be applied to the
elements for which test is non-null.
</div>
<!--l. 418--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.2   </span> <a 
 id="x193-351000A.2.2"></a>Mapping</h4>
<!--l. 420--><p class="noindent" >By far the most common kind of series operation is mapping. In cognizance of this
fact, four diﬀerent ways are provided for specifying mapping: one fundamental
form (<i>map-fn</i>) and three shorthand forms that are more convenient in particular
common situations.
<div class=defun>
<!--l. 425--><p class="noindent" > <i>[Function]</i>   <b>map-fn</b> <a 
 id="dx193-351001"></a><a 
 id="x193-351002r1072"></a>   <i>type</i>  <i>function</i>  <b>&#x0026;rest</b>  series-inputs
<!--l. 427--><p class="noindent" >The higher-order function <i>map-fn</i> supports the general concept of mapping. The
type argument is a type speciﬁer indicating the type of values returned by
function. The <i>values</i> construct can be used to indicate multiple types; however,
                                                                          

                                                                          
type cannot indicate zero values. If type indicates m types t<sub>1</sub>,…,t<sub>m</sub>, then
<i>map-fn</i> returns m series T1, … , Tm, where Ti has the type <i>(series t<sub>i</sub>)</i>. The
argument function is a function. The remaining arguments (if any) are all
series. Let these series be S1, … , Sn and suppose that Si has the type
<i>(series s<sub>i</sub>)</i>.
<!--l. 442--><p class="indent" >   The function must be of type <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(function (s<sub>1</sub> ... s<sub>n</sub>) (values t<sub>1</sub> ... t<sub>m</sub>))
</td></tr></table>
<!--l. 445--><p class="indent" >
</div>
</div>
<!--l. 447--><p class="indent" >   The length of each output is the same as the length of the shortest input. If
there are no bounded series inputs, the outputs are unbounded. The elements of
the Ti are the results of applying function to the corresponding elements of the
series inputs. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values T1<sub>j</sub> ... Tm<sub>j</sub>)  ≡ (funcall function S1<sub>j</sub> ... Sn<sub>j</sub>)
</td></tr></table>
<!--l. 453--><p class="indent" >
</div>
</div>
<!--l. 455--><p class="indent" >   If function has side eﬀects, it can count on being called ﬁrst on the Si<sub>0</sub>, then
on the Si<sub>1</sub>, and so on. However, given the lazy evaluation nature of series, function
will not be called on any group of input elements until the result is actually used
(if ever). In addition, no assumptions can be made about the relative order of
evaluation of the calls on function with regard to execution in other parts of a
given series expression. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(map-fn &#x2019;integer #&#x2019;+ #Z(1 2 3) #Z(4 5))  ⇒ #Z(5 7)
</td></tr></table>
<!--l. 463--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(map-fn t #&#x2019;gensym)  ⇒ #Z(#:G3 #:G4 #:G5 ...)</td></tr></table>
<!--l. 464--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(map-fn &#x2019;(values integer rational) #&#x2019;ﬂoor #Z(1/4 9/5 12/3))</td></tr></table>
<!--l. 465--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(0 1 4) and #Z(1/4 4/5 0)</td></tr></table>
<!--l. 467--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 469--><p class="indent" >   The <i>#</i> macro character syntax <i>#M</i> makes it easy to specify uses of
<i>map-fn</i> where type is <i>t</i> and the function is a named function. The notation
<i>(#Mfunction ...)</i> is an abbreviation for <i>(map-fn t #&#x2019;function ...)</i>. The
form function can be the printed representation of any Lisp object. The
notation <i>#M</i>function can appear only in the function position of a list. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect (#M1+ (scan &#x2019;(1 2 3))))  ⇒ (2 3 4)
</td></tr></table>
<!--l. 478--><p class="indent" >
</div>
</div>
</div>
<div class=defmac>
<!--l. 482--><p class="noindent" ><div class=tabbing>
</div>
<!--l. 482--><p class="indent" >   }∗ )  {<i>declaration</i>}∗  {<i>form</i>}∗
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> mapping </b> <a 
 id="dx193-351003"></a><a 
 id="x193-351004r1073"></a>   ( {<i>( {<i>var|( {<i>var</i>}∗ )</div> }value)
</td></tr></table>
<!--l. 483--><p class="indent" >
</div>
   The macro <i>mapping</i> makes it easy to specify uses of <i>map-fn</i> where type is <i>t</i>
and the function is a literal <i>lambda</i>. The syntax of <i>mapping</i> is analogous to that of
<i>let</i>. The binding list speciﬁes zero or more variables that are bound in parallel to
successive values of series. The value part of each pair is an expression that must
produce a series. The declarations and forms are treated as the body of a <i>lambda</i>
expression that is mapped over the series values. A series of the ﬁrst values
returned by this <i>lambda</i> expression is returned as the result of <i>mapping</i>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping ((x r) (y s)) ...)  ≡
</td></tr></table>
                                                                          

                                                                          
<!--l. 496--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (map-fn t #&#x2019;(lambda (x y) ...) r s)</td></tr></table>
<!--l. 497--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 498--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping ((x (scan &#x2019;(2 -2 3))))</td></tr></table>
<!--l. 499--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (expt (abs x) 3))</td></tr></table>
<!--l. 500--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(8 8 27)</td></tr></table>
<!--l. 502--><p class="indent" >
</div>
</div>
<!--l. 504--><p class="noindent" >The form <i>mapping</i> supports a special syntax that facilitates the use of series
functions returning multiple values. Instead of being a single variable, the variable
part of a var-value pair can be a list of variables. This list is treated the
same way as the ﬁrst argument to <i>multiple-value-bind</i> and can be used
to access the elements of multiple series returned by a series function. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping (((i v) (scan-plist &#x2019;(a 1 b 2))))
</td></tr></table>
<!--l. 511--><p class="indent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (list i v))</td></tr></table>
<!--l. 512--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z((a 1) (b 2))</td></tr></table>
<!--l. 514--><p class="indent" >
</div>
</div>
<div class=defmac>
   <div class=tabbing>
</div>
<!--l. 518--><p class="indent" >   }∗ )  {<i>declaration</i>}∗  {<i>form</i>}∗
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> iterate </b> <a 
 id="dx193-351005"></a><a 
 id="x193-351006r1074"></a>   ( {<i>( {<i>var|( {<i>var</i>}∗ )</div> }value)
</td></tr></table>
<!--l. 519--><p class="indent" >
</div>
   The form <i>iterate</i> is the same as <i>mapping</i>, except that after mapping
the forms over the values, the results are discarded and <i>nil</i> is returned. <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((item (scan &#x2019;((1) (-2) (3)))))
</td></tr></table>
<!--l. 524--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (iterate ((x (#Mcar item)))</td></tr></table>
<!--l. 525--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (if (plusp x) (prin1 x))))</td></tr></table>
<!--l. 526--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ nil (after printing “<i>13</i>”)</td></tr></table>
<!--l. 528--><p class="indent" >
</div>
</div>
<!--l. 530--><p class="noindent" >To a ﬁrst approximation, <i>iterate</i> and <i>mapping</i> diﬀer in the same way as <i>mapc</i>
and <i>mapcar</i>. In particular, like <i>mapc</i>, <i>iterate</i> is intended to be used in
situations where the forms are being evaluated for side eﬀects rather than for
their results. However, given the lazy evaluation semantics of series, the
diﬀerence between <i>iterate</i> and <i>mapping</i> is more than just a question of
eﬃciency.
<!--l. 537--><p class="indent" >   If <i>mapcar</i> is used in a situation where the output is not used, time is wasted
unnecessarily creating the output list. However, if <i>mapping</i> is used in a situation
where the output is not used, no computation is performed, because series
elements are not computed until they are used. Thus <i>iterate</i> can be thought of as
a declaration that the indicated computation is to be performed even though the
output is not used for anything.
<!--l. 546--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.3   </span> <a 
 id="x193-352000A.2.3"></a>Truncation and Other Simple Transducers</h4>
<!--l. 548--><p class="noindent" >Transducers compute series from series and form the heart of most series
expressions. Mapping is by far the most common transducer. This section presents
a number of additional simple transducers.
<div class=defun>
<!--l. 553--><p class="noindent" > <i>[Function]</i>   <b>cotruncate</b> <a 
 id="dx193-352001"></a><a 
 id="x193-352002r1075"></a>   <b>&#x0026;rest</b>  series-inputs <br 
class="newline" /><i>[Function]</i>   <b>until</b> <a 
 id="dx193-352003"></a><a 
 id="x193-352004r1076"></a>   <i>bools</i>  <b>&#x0026;rest</b>  series-inputs <br 
class="newline" /><i>[Function]</i>   <b>until-if</b> <a 
 id="dx193-352005"></a><a 
 id="x193-352006r1077"></a>   <i>pred</i>  <b>&#x0026;rest</b>  series-inputs
<!--l. 557--><p class="noindent" >Each of these functions accepts one or more series inputs S1, … , Sn as its <i>&#x0026;rest</i>
argument and returns n series outputs T1, … , Tn that contain the same elements
in the same order—that is, Ti<sub>j</sub>=Si<sub>j</sub>. Let k be the length of the shortest input Si.
<i>cotruncate</i> truncates the series so that each output has length k. Let k′ be the
position of the ﬁrst element in the boolean series bools that is not <i>nil</i> or, if every
                                                                          

                                                                          
element is <i>nil</i>, the length of bools. <i>until</i> truncates the series so that each output
has length <i>(min k k′)</i>. Let itk′′ be the position of the ﬁrst element in S1 such that
<i>(pred S1<sub>k′′</sub>)</i> is not <i>nil</i> or, if there is no such element, the length of S1.
<i>until-if </i> truncates the series so that each output has length <i>(min k k′′)</i>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(cotruncate #Z(1 2 -3 4) #Z(a b c))
</td></tr></table>
<!--l. 574--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(1 2 -3) and #Z(a b c)</td></tr></table>
<!--l. 575--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(until #Z(nil nil t nil) #Z(1 2 -3 4) #Z(a b c))</td></tr></table>
<!--l. 576--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(1 2) and #Z(a b)</td></tr></table>
<!--l. 577--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(until-if #&#x2019;minusp #Z(1 2 -3 4) #Z(a b c))</td></tr></table>
<!--l. 578--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(1 2) and #Z(a b)</td></tr></table>
<!--l. 580--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 583--><p class="noindent" > <i>[Function]</i>   <b>previous</b> <a 
 id="dx193-352007"></a><a 
 id="x193-352008r1078"></a>   <i>items</i>  <b>&#x0026;optional</b>  (<i>default</i> nil) (<i>amount</i> 1)
<!--l. 585--><p class="noindent" >The series returned by <i>previous</i> is the same as the input series items except that it
is shifted to the right by the positive integer amount. The shifting is done by
inserting amount copies of default before items and discarding amount elements
from the end of items. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(previous #Z(10 11 12) 0)  ⇒ #Z(0 10 11)
</td></tr></table>
<!--l. 593--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 596--><p class="noindent" > <i>[Function]</i>   <b>latch</b> <a 
 id="dx193-352009"></a><a 
 id="x193-352010r1079"></a>   <i>items</i>  <b>&#x0026;key</b>  :after  :before  :pre  :post
<!--l. 598--><p class="noindent" >The series returned by <i>latch</i> is the same as the input series items except that some
of the elements are replaced by other values. <i>latch</i> acts like a latch electronic
circuit component. Each input element causes the creation of a corresponding
                                                                          

                                                                          
output element. After a speciﬁed number of non-null input elements have been
encountered, the latch is triggered and the output mode is permanently
changed.
<!--l. 607--><p class="indent" >   The <i>:after</i> and <i>:before</i> arguments specify the latch point. The latch point is
just after the <i>:after</i>-th non-null element in items or just before the <i>:before</i>-th
non-null element. If neither <i>:after</i> nor <i>:before</i> is speciﬁed, an <i>:after</i> of <i>1</i> is
assumed. If both are speciﬁed, it is an error.
<!--l. 613--><p class="indent" >   If a <i>:pre</i> is speciﬁed, every element prior to the latch point is replaced by
this value. If a <i>:post</i> is speciﬁed, every element after the latch point is
replaced by this value. If neither is speciﬁed, a <i>:post</i> of <i>nil</i> is assumed. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(latch #Z(nil c nil d e))  ⇒ #Z(nil c nil nil nil)
</td></tr></table>
<!--l. 618--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(latch #Z(nil c nil d e) :before 2 :post t)  ⇒ #Z(nil c nil t t)</td></tr></table>
<!--l. 620--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 623--><p class="noindent" > <i>[Function]</i>   <b>collecting-fn</b> <a 
 id="dx193-352011"></a><a 
 id="x193-352012r1080"></a>   <i>type</i>  <i>init</i>  <i>function</i>  <b>&#x0026;rest</b>  series-inputs
<!--l. 625--><p class="noindent" >The higher-order function <i>collecting-fn</i> supports the general concept of a
simple transducer with internal state. The type argument is a type speciﬁer
indicating the type of values returned by function. The <i>values</i> construct
can be used to indicate multiple types; however, type cannot indicate
zero values. If type indicates m types t<sub>1</sub>,…,t<sub>m</sub>, then <i>collecting-fn</i> returns
m series T1, … , Tm, where Ti has the type <i>(series t<sub>i</sub>)</i>. The arguments
init and function are functions. The remaining arguments (if any) are all
series. Let these series be S1, … , Sn and suppose that Si has the type
<i>(series s<sub>i</sub>)</i>.
<!--l. 640--><p class="indent" >   The init must be of type <i>(function () (values t<sub>1</sub> ... t<sub>m</sub>))</i>.
<!--l. 643--><p class="indent" >   The function must be of type <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(function (t<sub>1</sub> ... t<sub>m</sub> s<sub>1</sub> ... s<sub>n</sub>) (values t<sub>1</sub> ... t<sub>m</sub>))
</td></tr></table>
<!--l. 646--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 648--><p class="indent" >   The length of each output is the same as the length of the shortest input. If
there are no bounded series inputs, the outputs are unbounded. The elements of
the Ti are computed as follows: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values T1<sub>0</sub> ... Tm<sub>0</sub>)  ≡
</td></tr></table>
<!--l. 652--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-call function (funcall init) S1<sub>0</sub> ... Sn<sub>0</sub>)</td></tr></table>
<!--l. 653--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 654--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values T1<sub>j</sub> ... Tm<sub>j</sub>)  ≡</td></tr></table>
<!--l. 655--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (funcall function T1<sub>(j−1)</sub> ... Tm<sub>(j−1)</sub> S1<sub>j</sub> ... Sn<sub>j</sub>)</td></tr></table>
<!--l. 657--><p class="indent" >
</div>
</div>
<!--l. 659--><p class="indent" >   If init or function has side eﬀects, it can count on being called in the order
indicated by the equations above. However, given the lazy evaluation nature of
series, these functions will not be called until their outputs are actually used (if
ever). In addition, no assumptions can be made about the relative order of
evaluation of these calls with regard to execution in other parts of a given series
expression. The second example below computes a series of partial sums of the
numbers in an input series. The third example computes two output series: the
partial sums of its ﬁrst input and the partial products of its second input. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun running-averages (ﬂoat-list)
</td></tr></table>
<!--l. 670--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-call #&#x2019;map-fn</td></tr></table>
<!--l. 671--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    &#x2019;ﬂoat #&#x2019;/</td></tr></table>
<!--l. 672--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (collecting-fn &#x2019;(values ﬂoat integer)</td></tr></table>
<!--l. 673--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   #&#x2019;(lambda () (values 0.0 0)</td></tr></table>
<!--l. 674--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   #&#x2019;(lambda (s n x) (values (+ s x) (+ n 1))))</td></tr></table>
<!--l. 675--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   ﬂoat-list)))</td></tr></table>
<!--l. 677--><p class="indent" >
</div>
                                                                          

                                                                          
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collecting-fn &#x2019;integer #&#x2019;(lambda () 0) #&#x2019;+ #Z(1 2 3))
</td></tr></table>
<!--l. 679--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(1 3 6)</td></tr></table>
<!--l. 680--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 681--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collecting-fn &#x2019;(values integer integer)</td></tr></table>
<!--l. 682--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #&#x2019;(lambda () (values 0 1))</td></tr></table>
<!--l. 683--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #&#x2019;(lambda (sum prod x y)</td></tr></table>
<!--l. 684--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (values (+ sum x) (* prod y)))</td></tr></table>
<!--l. 685--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #Z(4 6 8)</td></tr></table>
<!--l. 686--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #Z(1 2 3))</td></tr></table>
<!--l. 687--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(4 10 18) and #Z(1 2 6)</td></tr></table>
<!--l. 689--><p class="indent" >
</div>
</div>
</div>
<!--l. 692--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.4   </span> <a 
 id="x193-353000A.2.4"></a>Conditional and Other Complex Transducers</h4>
<!--l. 695--><p class="noindent" >This section presents a number of complex transducers, including ones that
support conditional computation.
<div class=defun>
<!--l. 699--><p class="noindent" > <i>[Function]</i>   <b>choose</b> <a 
 id="dx193-353001"></a><a 
 id="x193-353002r1081"></a>   <i>bools</i>  <b>&#x0026;optional</b>  (<i>items</i> bools)<br 
class="newline" /><i>[Function]</i>   <b>choose-if</b> <a 
 id="dx193-353003"></a><a 
 id="x193-353004r1082"></a>   <i>pred</i>  <i>items</i>
<!--l. 702--><p class="noindent" >Each of these functions takes in a series of elements (items) and returns a series
containing the same elements in the same order, but with some elements removed.
<i>choose</i> removes items<sub>j</sub> if bools<sub>j</sub> is <i>nil</i> or j is beyond the end of bools. If items is
omitted, <i>choose</i> returns the non-null elements of bools. <i>choose-if </i> removes items<sub>j</sub> if
<i>(pred items<sub>j</sub>)</i> is <i>nil</i>. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(choose #Z(t nil t nil) #Z(a b c d))  ⇒ #Z(a c)
</td></tr></table>
<!--l. 711--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-sum (choose-if #&#x2019;plusp #Z(-1 2 -3 4)))  ⇒ 6</td></tr></table>
<!--l. 713--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 716--><p class="noindent" > <i>[Function]</i>   <b>expand</b> <a 
 id="dx193-353005"></a><a 
 id="x193-353006r1083"></a>   <i>bools</i>  <i>items</i>  <b>&#x0026;optional</b>  (<i>default</i> nil)
<!--l. 718--><p class="noindent" ><i>expand</i> is a quasi-inverse of <i>choose</i>. The output contains the elements of the input
series items spread out into the positions speciﬁed by the non-null elements in
bools—that is, items<sub>j</sub> is in the position occupied by the jth non-null element in
bools. The other positions in the output are occupied by default. The output
stops as soon as bools runs out of elements or a non-null element in bools
is encountered for which there is no corresponding element in items. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(expand #Z(nil t nil t t) #Z(a b c))  ⇒ #Z(nil a nil b c)
</td></tr></table>
<!--l. 729--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(expand #Z(nil t nil t t) #Z(a))  ⇒ #Z(nil a nil)</td></tr></table>
<!--l. 731--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 734--><p class="noindent" > <i>[Function]</i>   <b>split</b> <a 
 id="dx193-353007"></a><a 
 id="x193-353008r1084"></a>   <i>items</i>  <b>&#x0026;rest</b>  test-series-inputs <br 
class="newline" /><i>[Function]</i>   <b>split-if</b> <a 
 id="dx193-353009"></a><a 
 id="x193-353010r1085"></a>   <i>items</i>  <b>&#x0026;rest</b>  test-predicates
<!--l. 737--><p class="noindent" >These functions are like <i>choose</i> and <i>choose-if </i> except that instead of producing
one restricted output, they partition the input series items between several
outputs. If there are n test inputs following items, then there are n + 1 outputs.
Each input element is placed in exactly one output series, depending on the
outcome of a sequence of tests. If the element items<sub>j</sub> fails the ﬁrst k − 1 tests and
passes the kh test, it is put in the kth output. If items<sub>j</sub> fails every test, it is
placed in the last output. In addition, all output stops as soon as any
series input runs out of elements. The test inputs to <i>split</i> are series of
values; items<sub>j</sub> passes the kth test if the jth element of the kth test series is
not <i>nil</i>. The test inputs to <i>split-if </i> are predicates; items<sub>j</sub> passes the kth
                                                                          

                                                                          
test if the kth test predicate returns non-null when applied to items<sub>j</sub>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(split #Z(-1 2 3 -4) #Z(t nil nil t))
</td></tr></table>
<!--l. 754--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(-1 -4) and #Z(2 3)</td></tr></table>
<!--l. 755--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(multiple-value-bind (+x -x) (split-if #Z(-1 2 3 -4) #&#x2019;plusp)</td></tr></table>
<!--l. 756--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (values (collect-sum +x) (collect-sum -x)))</td></tr></table>
<!--l. 757--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ 5 and -5</td></tr></table>
<!--l. 759--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 762--><p class="noindent" > <i>[Function]</i>   <b>catenate</b> <a 
 id="dx193-353011"></a><a 
 id="x193-353012r1086"></a>   <b>&#x0026;rest</b>  series-inputs
<!--l. 764--><p class="noindent" ><i>catenate</i> combines two or more series into one long series by appending them end
to end. The length of the output is the sum of the lengths of the inputs. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(catenate #Z(b c) #Z() #Z(d))  ⇒ #Z(b c d)
</td></tr></table>
<!--l. 770--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 773--><p class="noindent" > <i>[Function]</i>   <b>subseries</b> <a 
 id="dx193-353013"></a><a 
 id="x193-353014r1087"></a>   <i>items</i>  <i>start</i>  <b>&#x0026;optional</b>  <i>below</i>
<!--l. 775--><p class="noindent" ><i>subseries</i> returns a series containing the elements of the input series items indexed
by the non-negative integers from start up to, but not including, below. If below is
omitted or greater than the length of items, the output goes all the way to the
end of items. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subseries #Z(a b c d) 1)  ⇒ #Z(b c d)
</td></tr></table>
<!--l. 782--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subseries #Z(a b c d) 1 3)  ⇒ #Z(b c)</td></tr></table>
<!--l. 784--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 787--><p class="noindent" > <i>[Function]</i>   <b>positions</b> <a 
 id="dx193-353015"></a><a 
 id="x193-353016r1088"></a>   <i>bools</i>
<!--l. 789--><p class="noindent" ><i>positions</i> returns a series of the indices of the non-null elements in the series input
bools. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(positions #Z(t nil t 44))  ⇒ #Z(0 2 3)
</td></tr></table>
<!--l. 794--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 797--><p class="noindent" > <i>[Function]</i>   <b>mask</b> <a 
 id="dx193-353017"></a><a 
 id="x193-353018r1089"></a>   <i>monotonic-indices</i>
<!--l. 799--><p class="noindent" ><i>mask</i> is a quasi-inverse of <i>positions</i>. The series input monotonic-indices must be a
strictly increasing series of non-negative integers. The output, which is always
unbounded, contains <i>t</i> in the positions speciﬁed by monotonic-indices and <i>nil</i>
everywhere else. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask #Z(0 2 3))  ⇒ #Z(t nil t t nil nil ...)
</td></tr></table>
<!--l. 805--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask #Z())  ⇒ #Z(nil nil ...)</td></tr></table>
<!--l. 806--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask (positions #Z(nil a nil b nil)))</td></tr></table>
<!--l. 807--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(nil t nil t nil ...)</td></tr></table>
<!--l. 809--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 813--><p class="noindent" > <i>[Function]</i>   <b>mingle</b> <a 
 id="dx193-353019"></a><a 
 id="x193-353020r1090"></a>   <i>items1</i>  <i>items2</i>  <i>comparator</i>
<!--l. 815--><p class="noindent" >The series returned by <i>mingle</i> contains all and only the elements of the two input
series. The length of the output is the sum of the lengths of the inputs and is
unbounded if either input is unbounded. The order of the elements remains
                                                                          

                                                                          
unchanged; however, the elements from the two inputs are stably intermixed
under the control of the comparator.
<!--l. 822--><p class="indent" >   The comparator must accept two arguments and return non-null if and only if
its ﬁrst argument is strictly less than its second argument (in some appropriate
sense). At each step, the comparator is used to compare the current elements in
the two series. If the current element from items2 is strictly less than the current
element from items1, the current element is removed from items2 and transferred
to the output. Otherwise, the next output element comes from items1. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mingle #Z(1 3 7 9) #Z(4 5 8) #&#x2019;&#x003C;)  ⇒ #Z(1 3 4 5 7 8 9)
</td></tr></table>
<!--l. 830--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mingle #Z(1 7 3 9) #Z(4 5 8) #&#x2019;&#x003C;)  ⇒ #Z(1 4 5 7 3 8 9)</td></tr></table>
<!--l. 832--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 835--><p class="noindent" > <i>[Function]</i>   <b>chunk</b> <a 
 id="dx193-353021"></a><a 
 id="x193-353022r1091"></a>   <i>m</i>  <i>n</i>  <i>items</i>
<!--l. 837--><p class="noindent" >This function has the eﬀect of breaking up the input series items into (possibly
overlapping) chunks of length m. The starting positions of successive chunks diﬀer
by n. The inputs m and n must both be positive integers.
<i>
<!--l. 842--><p class="indent" >   chunk</i> produces m output series. The ith chunk provides the ith element for
each of the m outputs. Suppose that the length of items is l. The length of each
output is ⌊1 + (l − m)∕n⌋. The ith element of the kth output is the (i ∗ n + k)th
element of items (i and k counting from zero).
<!--l. 850--><p class="indent" >   Note that if l &#x003C; m, there will be no output elements, and if l − m is not a
multiple of n, the last few input elements will not appear in the output. If m ≥ n,
one can guarantee that the last chunk will contain the last element of items by
catenating n − 1 copies of an appropriate padding value to the end of
items.
<!--l. 858--><p class="indent" >   The ﬁrst example below shows <i>chunk</i> being used to compute a moving
average. The second example shows <i>chunk</i> being used to convert a property list
into an association list. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping (((xi xi+1 xi+2) (chunk 3 1 #Z(1 5 3 4 5 6))))
</td></tr></table>
<!--l. 862--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (/ (+ xi xi+1 xi+2) 3))</td></tr></table>
<!--l. 863--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(3 4 4 5)</td></tr></table>
<!--l. 865--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect</td></tr></table>
<!--l. 866--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (mapping (((prop val) (chunk 2 2 (scan &#x2019;(a 2 b 5 c 8)))))</td></tr></table>
<!--l. 867--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (cons prop val)))</td></tr></table>
<!--l. 868--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ ((a . 2) (b . 5) (c . 8))</td></tr></table>
<!--l. 870--><p class="indent" >
</div>
</div>
</div>
<!--l. 873--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.5   </span> <a 
 id="x193-354000A.2.5"></a>Collectors</h4>
<!--l. 875--><p class="noindent" >Collectors produce non-series outputs based on series inputs. They either
create a summary value based on some formula (the sum, for example) or
collect the elements of a series in an aggregate data structure (such as a
list).
<div class=defun>
<!--l. 879--><p class="noindent" > <i>[Function]</i>   <b>collect-ﬁrst</b> <a 
 id="dx193-354001"></a><a 
 id="x193-354002r1092"></a>   <i>items</i>  <b>&#x0026;optional</b>  (<i>default</i> nil)<br 
class="newline" /><i>[Function]</i>   <b>collect-last</b> <a 
 id="dx193-354003"></a><a 
 id="x193-354004r1093"></a>   <i>items</i>  <b>&#x0026;optional</b>  (<i>default</i> nil)<br 
class="newline" /><i>[Function]</i>   <b>collect-nth</b> <a 
 id="dx193-354005"></a><a 
 id="x193-354006r1094"></a>   <i>n</i>  <i>items</i>  <b>&#x0026;optional</b>  (<i>default</i> nil)
<!--l. 883--><p class="noindent" >Given a series items, these functions return the ﬁrst element, the last element, and
the nth element, respectively. If items has no elements (or no nth element),
default is returned. If default is not speciﬁed, then <i>nil</i> is used for default. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-ﬁrst #Z() &#x2019;z)  ⇒ z
</td></tr></table>
<!--l. 889--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-last #Z(a b c))  ⇒ c</td></tr></table>
<!--l. 890--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-nth 1 #Z(a b c))  ⇒ b</td></tr></table>
<!--l. 892--><p class="indent" >
</div>
                                                                          

                                                                          
</div>
</div>
<div class=defun>
<!--l. 895--><p class="noindent" > <i>[Function]</i>   <b>collect-length</b> <a 
 id="dx193-354007"></a><a 
 id="x193-354008r1095"></a>   <i>items</i>
<!--l. 897--><p class="noindent" ><i>collect-length</i> returns the number of elements in a series. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-length #Z(a b c))  ⇒ 3
</td></tr></table>
<!--l. 901--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 905--><p class="noindent" > <i>[Function]</i>   <b>collect-sum</b> <a 
 id="dx193-354009"></a><a 
 id="x193-354010r1096"></a>   <i>numbers</i>  <b>&#x0026;optional</b>  (<i>type</i> &#x2019;number)
<!--l. 907--><p class="noindent" ><i>collect-sum</i> returns the sum of the elements in a series of numbers. The type is a
type speciﬁer that indicates the type of sum to be created. If type is not speciﬁed,
then <i>number</i> is used for the type. If there are no elements in the input, a zero (of
the appropriate type) is returned. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-sum #Z(1.1 1.2 1.3))  ⇒ 3.6
</td></tr></table>
<!--l. 915--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-sum #Z() &#x2019;complex)  ⇒ #C(0 0)</td></tr></table>
<!--l. 917--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 921--><p class="noindent" > <i>[Function]</i>   <b>collect-max</b> <a 
 id="dx193-354011"></a><a 
 id="x193-354012r1097"></a>   <i>numbers</i> <br 
class="newline" /><i>[Function]</i>   <b>collect-min</b> <a 
 id="dx193-354013"></a><a 
 id="x193-354014r1098"></a>   <i>numbers</i>
<!--l. 924--><p class="noindent" >Given a series of non-complex numbers, these functions compute the maximum
element and the minimum element, respectively. If there are no elements in the
input, <i>nil</i> is returned. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-max #Z(2 1 4 3))  ⇒ 4
</td></tr></table>
                                                                          

                                                                          
<!--l. 929--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-min #Z(1.2 1.1 1.4 1.3))  ⇒ 1.1</td></tr></table>
<!--l. 930--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-min #Z())  ⇒ nil</td></tr></table>
<!--l. 932--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 936--><p class="noindent" > <i>[Function]</i>   <b>collect-and</b> <a 
 id="dx193-354015"></a><a 
 id="x193-354016r1099"></a>   <i>bools</i>
<!--l. 938--><p class="noindent" ><i>collect-and</i> returns the <i>and</i> of the elements in a series. As with the macro <i>and</i>, <i>nil</i>
is returned if any element of bools is <i>nil</i>. Otherwise, the last element of bools
is returned. The value <i>t</i> is returned if there are no elements in bools. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-and #Z(a b c))  ⇒ c
</td></tr></table>
<!--l. 945--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-and #Z(a nil c))  ⇒ nil</td></tr></table>
<!--l. 947--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 950--><p class="noindent" > <i>[Function]</i>   <b>collect-or</b> <a 
 id="dx193-354017"></a><a 
 id="x193-354018r1100"></a>   <i>bools</i>
<!--l. 952--><p class="noindent" ><i>collect-or</i> returns the <i>or</i> of the elements in a series. As with the macro <i>or</i>, <i>nil</i> is
returned if every element of bools is <i>nil</i>. Otherwise, the ﬁrst non-null element of
bools is returned. The value <i>nil</i> is returned if there are no elements in bools. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-or #Z(nil b c))  ⇒ b
</td></tr></table>
<!--l. 959--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-or #Z())  ⇒ nil</td></tr></table>
<!--l. 961--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 964--><p class="noindent" > <i>[Function]</i>   <b>collect</b> <a 
 id="dx193-354019"></a><a 
 id="x193-354020r1101"></a>   <i>items</i> <br 
class="newline" /><i>[Function]</i>   <b>collect</b> <a 
 id="dx193-354021"></a><a 
 id="x193-354022r1102"></a>   <i>type</i>  <i>items</i>
<!--l. 967--><p class="noindent" ><i>collect</i> returns a sequence containing the elements of the series items. The type is a
type speciﬁer indicating the type of sequence to be created. It must be either a
proper subtype of <i>sequence</i> or the symbol <i>bag</i>. If type is omitted, it defaults
to <i>list</i>. (This function exhibits an argument pattern that is unusual for
Common Lisp: an “optional” argument preceding a required argument. This
pattern cannot be expressed in the usual manner with <i>&#x0026;optional</i>. It is
indicated above by two deﬁnition lines, showing the two possible argument
patterns.)
<!--l. 978--><p class="indent" >   If the type is <i>bag</i>, a list is created with the elements in whatever order can be
most eﬃciently obtained. Otherwise, the order of the elements in the
sequence is the same as the order in items. If type speciﬁes a length (that is,
of a vector) this length must be greater than or equal to the length of
items.
<!--l. 984--><p class="indent" >   The nth element of items is placed in the nth slot of the sequence produced.
Any unneeded slots are left in their initial state. Collecting is signiﬁcantly
more eﬃcient if it can be determined at compile time whether type is a
subtype of <i>list</i> or <i>vector</i> and for vectors what the length of the vector is. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect #Z(a b c))  ⇒ (a b c)
</td></tr></table>
<!--l. 990--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect &#x2019;bag #Z(a b c))  ⇒ (c a b) or (b a c) or …</td></tr></table>
<!--l. 991--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect &#x2019;(vector integer 3) #Z(1 2 3))  ⇒ #(1 2 3)</td></tr></table>
<!--l. 993--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 996--><p class="noindent" > <i>[Function]</i>   <b>collect-append</b> <a 
 id="dx193-354023"></a><a 
 id="x193-354024r1103"></a>   <i>sequences</i> <br 
class="newline" /><i>[Function]</i>   <b>collect-append</b> <a 
 id="dx193-354025"></a><a 
 id="x193-354026r1104"></a>   <i>type</i>  <i>sequences</i>
<!--l. 999--><p class="noindent" >Given a series of sequences, <i>collect-append</i> returns a new sequence by
concatenating these sequences together in order. The type is a type speciﬁer
indicating the type of sequence created and must be a proper subtype of <i>sequence</i>.
If type is omitted, it defaults to <i>list</i>. (This function exhibits an argument pattern
that is unusual for Common Lisp: an “optional” argument preceding a required
                                                                          

                                                                          
argument. This pattern cannot be expressed in the usual manner with <i>&#x0026;optional</i>.
It is indicated above by two deﬁnition lines, showing the two possible argument
patterns.)
<!--l. 1010--><p class="indent" >   It must be possible for every element of every sequence in the input series to
be an element of a sequence of type type. The result does not share any structure
with the sequences in the input. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-append #Z((a b) nil (c d)))  ⇒ (a b c d)
</td></tr></table>
<!--l. 1014--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-append &#x2019;string #Z(&#x0022;a &#x0022; &#x0022;big &#x0022; &#x0022;cat&#x0022;))  ⇒ &#x0022;a big cat&#x0022;</td></tr></table>
<!--l. 1016--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 1019--><p class="noindent" > <i>[Function]</i>   <b>collect-nconc</b> <a 
 id="dx193-354027"></a><a 
 id="x193-354028r1105"></a>   <i>lists</i>
<!--l. 1021--><p class="noindent" ><i>collect-nconc</i> <i>nconc</i>s the elements of the series lists together in order and returns
the result. This is the same as <i>collect-append</i> except that the input must be a
series of lists, the output is always a list, the concatenation is done rapidly by
destructively modifying the input elements, and therefore the output shares all of
its structure with the input elements.
</div>
<div class=defun>
<!--l. 1030--><p class="noindent" > <i>[Function]</i>   <b>collect-alist</b> <a 
 id="dx193-354029"></a><a 
 id="x193-354030r1106"></a>   <i>keys</i>  <i>values</i> <br 
class="newline" /><i>[Function]</i>   <b>collect-plist</b> <a 
 id="dx193-354031"></a><a 
 id="x193-354032r1107"></a>   <i>keys</i>  <i>values</i> <br 
class="newline" /><i>[Function]</i>   <b>collect-hash</b> <a 
 id="dx193-354033"></a><a 
 id="x193-354034r1108"></a>   <i>keys</i>  <i>values</i>  <b>&#x0026;key</b>  :test  :size  :rehash-size
:rehash-threshold
<!--l. 1034--><p class="noindent" >Given a series of keys and a series of corresponding values, these functions return
an association list, a property list, and a hash table, respectively. Following the
order of the input, each keys<sub>j</sub>-values<sub>j</sub> pair is entered into the output so that it
overrides all earlier associations. If one of the input series is longer than the other,
the extra elements are ignored. The keyword arguments of <i>collect-hash</i> specify
attributes of the hash table produced and have the same meanings as the
arguments to <i>make-hash-table</i>. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-alist #Z(a b c) #Z(1 2))  ⇒ ((b . 2) (a . 1))
</td></tr></table>
<!--l. 1044--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-plist #Z(a b c) #Z(1 2))  ⇒ (b 2 a 1)</td></tr></table>
<!--l. 1045--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-hash #Z() #Z(1 2) :test #&#x2019;eq)  ⇒⟨an empty hash table⟩</td></tr></table>
<!--l. 1047--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 1050--><p class="noindent" > <i>[Function]</i>   <b>collect-ﬁle</b> <a 
 id="dx193-354035"></a><a 
 id="x193-354036r1109"></a>   <i>ﬁle-name</i>  <i>items</i>  <b>&#x0026;optional</b>  (<i>printer</i> #&#x2019;print)
<!--l. 1052--><p class="noindent" >This creates a ﬁle named ﬁle-name and writes the elements of the series items into
it using the function printer. Printer must accept two inputs: an object and an
output stream. (For instance, printer can be <i>print</i>, <i>prin1</i>, <i>princ</i>, <i>pprint</i>,
<i>write-char</i>, <i>write-string</i>, or <i>write-line</i>.) If omitted, printer defaults to
<i>print</i>. The value <i>t</i> is returned. The ﬁle is correctly closed, even if an abort
occurs.
</div>
<div class=defun>
<!--l. 1064--><p class="noindent" > <i>[Function]</i>   <b>collect-fn</b> <a 
 id="dx193-354037"></a><a 
 id="x193-354038r1110"></a>   <i>type</i>  <i>init</i>  <i>function</i>  <b>&#x0026;rest</b>  series-inputs
<!--l. 1066--><p class="noindent" >The higher-order function <i>collect-fn</i> supports the general concept of collecting. It
is identical to <i>collecting-fn</i> except that it returns only the last element of each
series computed. If there are no elements in these series, the values returned by
init are passed on directly as the output of <i>collect-fn</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-fn &#x2019;integer #&#x2019;(lambda () 0) #&#x2019;+ #Z(1 2 3))  ⇒ 6
</td></tr></table>
<!--l. 1073--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-fn &#x2019;integer #&#x2019;(lambda () 0) #&#x2019;+ #Z())  ⇒ 0</td></tr></table>
<!--l. 1074--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-fn &#x2019;integer #&#x2019;(lambda () 1) #&#x2019;* #Z(1 2 3 4 5))  ⇒ 120</td></tr></table>
<!--l. 1076--><p class="indent" >
</div>
</div>
</div>
<!--l. 1079--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.6   </span> <a 
 id="x193-355000A.2.6"></a>Alteration of Series</h4>
                                                                          

                                                                          
<!--l. 1081--><p class="noindent" >Series that come from scanning data structures such as lists and vectors are
closely linked to these structures. The function <i>alter</i> can be used to modify the
underlying data structure with reference to the series derived from it. (Conversely,
it is possible to modify a series by destructively modifying the data structure it is
derived from. However, given the lazy evaluation nature of series, the eﬀects of
such modiﬁcations can be very hard to predict. As a result, this kind of
modiﬁcation is inadvisable.)
<div class=defun>
<!--l. 1090--><p class="noindent" > <i>[Function]</i>   <b>alter</b> <a 
 id="dx193-355001"></a><a 
 id="x193-355002r1111"></a>   <i>destinations</i>  <i>items</i>
<!--l. 1092--><p class="noindent" ><i>alter</i> changes the series destinations so that it contains the elements in the series
items. More importantly, in the manner of <i>setf </i>, the data structure that underlies
destinations is changed so that if the series destinations were to be regenerated,
the new values would be obtained. The alteration process stops as soon as
either input runs out of elements. The value <i>nil</i> is always returned. In the
example below each negative element in a list is replaced with its square. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let* ((data (list 1 -2 3 4 -5 6))
</td></tr></table>
<!--l. 1102--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (x (choose-if #&#x2019;minusp (scan data))))</td></tr></table>
<!--l. 1103--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (alter x (#M* x x))</td></tr></table>
<!--l. 1104--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  data)</td></tr></table>
<!--l. 1105--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ (1 4 3 4 25 6)</td></tr></table>
<!--l. 1107--><p class="indent" >
</div>
</div>
<i>
<!--l. 1109--><p class="indent" >   alter</i> can be applied only to series that are alterable. <i>scan</i>, <i>scan-alist</i>,
<i>scan-multiple</i>, <i>scan-plist</i>, and <i>scan-lists-of-lists-fringe</i> produce alterable series.
However, the alterability of the output of <i>scan-lists-of-lists-fringe</i> is incomplete. If
<i>scan-lists-of-lists-fringe</i> is applied to an object that is a leaf, altering the output
series does not change the object.
<!--l. 1120--><p class="indent" >   In general, the output of a transducer is alterable as long as the elements of
the output come directly from the elements of an input that is alterable. In
particular, the outputs of <i>choose</i>, <i>choose-if </i>, <i>split</i>, <i>split-if </i>, <i>cotruncate</i>, <i>until</i>,
<i>until-if </i>, and <i>subseries</i> are alterable as long as the corresponding inputs are
alterable.
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 1129--><p class="noindent" > <i>[Function]</i>   <b>to-alter</b> <a 
 id="dx193-355003"></a><a 
 id="x193-355004r1112"></a>   <i>items</i>  <i>alter-fn</i>  <b>&#x0026;rest</b>  args
<!--l. 1131--><p class="noindent" >Given a series items, <i>to-alter</i> returns an alterable series A containing the same
elements. The argument alter-fn is a function. The remaining arguments are all
series. Let these series be S1, … , Sn. If there are n arguments after alter-fn,
alter-fn must accept n + 1 inputs. If <i>(alter A B)</i> is later encountered, the
expression <i>(map-fn t alter-fn B S1 ... Sn)</i> is implicitly evaluated. For each
element in B, alter-fn should make appropriate changes in the data structure
underlying A.
<!--l. 1143--><p class="indent" >   As an example, consider the following deﬁnition of a series function that scans
the elements of a list. Alteration is performed by changing cons cells in the list
being scanned. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun scan-list (list)
</td></tr></table>
<!--l. 1147--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (optimizable-series-function))</td></tr></table>
<!--l. 1148--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((sublists (scan-sublists list)))</td></tr></table>
<!--l. 1149--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (to-alter (#Mcar sublists)</td></tr></table>
<!--l. 1150--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              #&#x2019;(lambda (new parent) (setf (car parent) new))</td></tr></table>
<!--l. 1151--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              sublists)))</td></tr></table>
<!--l. 1153--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
   <!--l. 1156--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse159.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse157.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse157.html#tailclmse157.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse158.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmap1.html#clmse158.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 1156--><p class="indent" >   <a 
 id="tailclmse158.html"></a>  
</body></html> 
