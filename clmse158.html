<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Series Functions</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-06 23:16:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 119--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse159.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse157.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse157.html#tailclmse157.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse158.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmap1.html#clmse158.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">A.2   </span> <a 
 id="x193-1464000A.2"></a>Series Functions</h3>
<!--l. 122--><p class="noindent" >Throughout this chapter the notation S<sub>j</sub> is used to denote the <i>j</i>th element of the
series S. As in a list or vector, the ﬁrst element of a series has the subscript
zero.
<!--l. 126--><p class="indent" >   The # macro character syntax #Z<i>list</i> denotes a series that contains
the elements of <i>list</i>. This syntax is also used when series are printed. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(choose-if #&#x2019;symbolp #Z(a 2 b))  ⇒ #Z(a b)
</td></tr></table>
<!--l. 130--><p class="indent" >
</div>
</div>
<!--l. 131--><p class="noindent" >Series are self-evaluating objects and the series data type is disjoint from all other
types.
<div class=defun>
<!--l. 135--><p class="noindent" ><i>[Type speciﬁer]</i><a 
 id="dx193-1464001"></a><a 
 id="x193-1464002r1057"></a><b> series</b>  <i>element-type</i>
<!--l. 137--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14650001057"></a></span>
   The type speciﬁer (series <i>element-type</i>) denotes the set of series whose
elements are all members of the type <i>element-type</i>.
</div>
<div class=defun>
<!--l. 144--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1465001"></a><a 
 id="x193-1465002r1058"></a><b> series</b>  <i>arg</i> &#x0026;rest  <i>args</i>
<!--l. 146--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14660001058"></a></span>
   The function <a 
href="#x193-1088002r1058">series</a> returns an unbounded series that endlessly repeats the
values of the arguments. The second example below shows the preferred method
for constructing a bounded series. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(series &#x2019;b &#x2019;c)  ⇒ #Z(b c b c b c ...)
</td></tr></table>
<!--l. 151--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan (list &#x2019;a &#x2019;b &#x2019;c))  ⇒ #Z(a b c)</td></tr></table>
<!--l. 153--><p class="indent" >
</div>
</div>
</div>
<!--l. 156--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.1   </span> <a 
 id="x193-1467000A.2.1"></a>Scanners</h4>
<!--l. 158--><p class="noindent" >Scanners create series outputs based on non-series inputs. Either they operate
based on some formula (for example, scanning a range of integers) or they
enumerate the elements in an aggregate data structure (for example, scanning the
elements in a list or array).
<div class=defun>
<!--l. 164--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1467001"></a><a 
 id="x193-1467002r1059"></a><b> scan-range</b>  &#x0026;key  (:start 0) (:by 1) (:type &#x2019;number) <i>:upto</i> <i>:below</i>
<i>:downto</i> <i>:above</i> <i>:length</i>
<!--l. 167--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14680001059"></a></span>
   The function <a 
href="#x193-1090002r1059">scan-range</a> returns a series of numbers starting with the :start
argument (default integer 0) and counting up by the :by argument (default integer
1). The :type argument (default number) is a type speciﬁer indicating the type of
numbers in the series produced. The :type argument must be a (not necessarily
proper) subtype of number. The :start and :by arguments must be of that
type.
<!--l. 176--><p class="indent" >   One of the last ﬁve arguments may be used to specify the kind of end test to
be used; these are called <i>termination arguments</i>. If :upto is speciﬁed,
counting continues only so long as the numbers generated are less than
or equal to :upto. If :below is speciﬁed, counting continues only so long
as the numbers generated are less than :below. If :downto is speciﬁed,
counting continues only so long as the numbers generated are greater
than or equal to :downto. If :above is speciﬁed, counting continues only
so long as the numbers generated are greater than :above. If :length is
speciﬁed, it must be a non-negative integer and the output series has this
length.
                                                                          

                                                                          
<!--l. 189--><p class="indent" >   If none of the termination arguments are speciﬁed, the output has
unbounded length. If more than one termination argument is speciﬁed, it is an
error.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range :upto 4)  ⇒ #Z(0 1 2 3 4)
</td></tr></table>
<!--l. 194--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range :from 1 :by -1 :above -4)  ⇒ #Z(1 0 -1 -2 -3)</td></tr></table>
<!--l. 195--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range :from .5 :by .1 :type &#x2019;ﬂoat)  ⇒ #Z(.5 .6 .7 ...)</td></tr></table>
<!--l. 196--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range)  ⇒ #Z(0 1 2 3 4 5 6 ...)</td></tr></table>
<!--l. 198--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 201--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1468001"></a><a 
 id="x193-1468002r1060"></a><b> scan</b>  <i>sequence</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1468003"></a><a 
 id="x193-1468004r1061"></a><b> scan</b>  <i>type</i> <i>sequence</i>
<!--l. 204--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14690001061"></a></span>
   <a 
href="#x193-1091004r1061">scan</a> returns a series containing the elements of <i>sequence</i> in order. The <i>type</i>
argument is a type speciﬁer indicating the type of sequence to be scanned; it must
be a (not necessarily proper) subtype of sequence. If <i>type</i> is omitted, it defaults
to <a 
href="clmse87.html#x107-472002r493">list</a>. (This function exhibits an argument pattern that is unusual for
Common Lisp: an “optional” argument preceding a required argument. This
pattern cannot be expressed in the usual manner with &#x0026;optional. It is
indicated above by two deﬁnition lines, showing the two possible argument
patterns.)
<!--l. 215--><p class="indent" >   If the <i>sequence</i> is a list, it must be a proper list ending in <a 
href="clmse31.html#x42-86002r19">nil</a>. Scanning is
signiﬁcantly more eﬃcient if it can be determined at compile time whether <i>type</i> is
a subtype of <a 
href="clmse87.html#x107-472002r493">list</a> or <a 
href="clmse94.html#x116-531002r562">vector</a> and for vectors what the length of the vector is. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan &#x2019;(a b c))  ⇒ #Z(a b c)
</td></tr></table>
                                                                          

                                                                          
<!--l. 220--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan &#x2019;string &#x0022;BAR&#x0022;)  ⇒ #Z(#\B #\A #\R)</td></tr></table>
<!--l. 222--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 225--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1469001"></a><a 
 id="x193-1469002r1062"></a><b> scan-sublists</b>  <i>list</i>
<!--l. 227--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14700001062"></a></span>
   <a 
href="#x193-1092002r1062">scan-sublists</a> returns a series containing the successive sublists of <i>list</i>. The <i>list</i>
must be a proper list ending in <a 
href="clmse31.html#x42-86002r19">nil</a>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-sublists &#x2019;(a b c))  ⇒ #Z((a b c) (b c) (c))
</td></tr></table>
<!--l. 232--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 235--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1470001"></a><a 
 id="x193-1470002r1063"></a><b> scan-multiple</b>  <i>type</i> <i>ﬁrst-sequence</i> &#x0026;rest  <i>more-sequences</i>
<!--l. 237--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14710001063"></a></span>
   Several sequences can be scanned at once by using several calls on <a 
href="#x193-1091004r1061">scan</a>. Each
call on <a 
href="#x193-1091004r1061">scan</a> will test to see when its sequence runs out of elements and execution
will stop as soon as any of the sequences are exhausted. Although very robust,
this approach to scanning can be ineﬃcient. In situations where it is known in
advance which sequence is the shortest, <a 
href="#x193-1093002r1063">scan-multiple</a> can be used to obtain the
same results more rapidly.
<!--l. 246--><p class="indent" >   <a 
href="#x193-1093002r1063">scan-multiple</a> is similar to <a 
href="#x193-1091004r1061">scan</a> except that several sequences can be scanned
at once. If there are <i>n</i> sequence inputs, <a 
href="#x193-1093002r1063">scan-multiple</a> returns <i>n</i> series containing
the elements of these sequences. It must be the case that none of the sequence
inputs is shorter than the ﬁrst sequence. All of the output series are the same
length as the ﬁrst input sequence. Extra elements in the other input sequences are
ignored. Using <a 
href="#x193-1093002r1063">scan-multiple</a> is more eﬃcient than using multiple instances of
<a 
href="#x193-1091004r1061">scan</a>, because <a 
href="#x193-1093002r1063">scan-multiple</a> only has to check for the ﬁrst input running out of
elements.
                                                                          

                                                                          
<!--l. 256--><p class="indent" >   If <i>type</i> is of the form (values <i>t</i><sub>1</sub> … <i>t</i>x<sub>m</sub>), then there must be <i>m</i> sequence inputs
and the <i>i</i>th sequence must have type <i>t</i><sub>i</sub>. Otherwise there can be any number of
sequence inputs, each of which must have type <i>type</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(multiple-value-bind (data weights)
</td></tr></table>
<!--l. 261--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (scan-multiple &#x2019;list &#x2019;(1 6 3 2 8) &#x2019;(2 3 3 3 2))</td></tr></table>
<!--l. 262--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (collect (map-fn t #&#x2019;* data weights)))</td></tr></table>
<!--l. 263--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ (2 18 9 6 16)</td></tr></table>
<!--l. 265--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 268--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1471001"></a><a 
 id="x193-1471002r1064"></a><b> scan-lists-of-lists</b>  <i>lists-of-lists</i> &#x0026;optional  <i>leaf-test</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1471003"></a><a 
 id="x193-1471004r1065"></a><b> scan-lists-of-lists-fringe</b>  <i>lists-of-lists</i> &#x0026;optional  <i>leaf-test</i>
<!--l. 271--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14720001065"></a></span>
   The argument <i>lists-of-lists</i> is viewed as a tree where each internal node is a
non-empty list and the elements of the list are the children of the node.
<a 
href="#x193-1094002r1064">scan-lists-of-lists</a> and <a 
href="#x193-1094004r1065">scan-lists-of-lists-fringe</a> each scan <i>lists-of-lists</i> in preorder
and return a series of its nodes. <a 
href="#x193-1094002r1064">scan-lists-of-lists</a> returns every node in the tree.
<a 
href="#x193-1094004r1065">scan-lists-of-lists-fringe</a> returns only the leaf nodes.
<!--l. 280--><p class="indent" >   The scan proceeds as follows. The argument <i>lists-of-lists</i> can be any Lisp
object. If <i>lists-of-lists</i> is an atom or satisﬁes the predicate <i>leaf-test</i> (if present), it
is a leaf node. (The predicate can count on being applied only to conses.)
Otherwise, <i>lists-of-lists</i> is a (not necessarily proper) list. The ﬁrst element of
<i>lists-of-lists</i> is recursively scanned in full, followed by the second and so on until a
non-cons <i>cdr</i> is encountered. Whether or not this ﬁnal <i>cdr</i> is <a 
href="clmse31.html#x42-86002r19">nil</a>, it is ignored. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-lists-of-lists &#x2019;((2) (nil)))
</td></tr></table>
<!--l. 289--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(((2) (nil)) (2) 2 (nil) nil)</td></tr></table>
<!--l. 290--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-lists-of-lists-fringe &#x2019;((2) (nil)))  ⇒ #Z(2 nil)</td></tr></table>
<!--l. 291--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-lists-of-lists-fringe &#x2019;((2) (nil))</td></tr></table>
                                                                          

                                                                          
<!--l. 292--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                            #&#x2019;(lambda (e) (numberp (car e))))</td></tr></table>
<!--l. 293--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z((2) nil)</td></tr></table>
<!--l. 295--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 298--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1472001"></a><a 
 id="x193-1472002r1066"></a><b> scan-alist</b>  <i>a-list</i> &#x0026;optional  (<i>test</i> #&#x2019;eql)<br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1472003"></a><a 
 id="x193-1472004r1067"></a><b> scan-plist</b>  <i>plist</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1472005"></a><a 
 id="x193-1472006r1068"></a><b> scan-hash</b>  <i>table</i>
<!--l. 302--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14730001068"></a></span>
   When given an association list, a property list, or a hash table (respectively),
each of these functions produces two outputs: a series of keys <i>K</i> and a series of
the corresponding values <i>V </i>. Each key in the input appears exactly once in the
output, even if it appears more than once in the input. (The <i>test</i> argument of
<a 
href="#x193-1095002r1066">scan-alist</a> speciﬁes the equality test between keys; it defaults to <a 
href="clmse33.html#x44-118003r47">eql</a>.) The
two outputs have the same length. Each <i>V </i><sub>j</sub> is the value returned by the
appropriate accessing function (<a 
href="clmse86.html#x106-459002r445">cdr</a> of <a 
href="clmse91.html#x111-508002r535">assoc</a>, <a 
href="clmse54.html#x69-253002r162">getf</a>, or <a 
href="clmse92.html#x113-516002r547">gethash</a>, respectively) when
given <i>K</i><sub>j</sub>. <a 
href="#x193-1095002r1066">scan-alist</a> and <a 
href="#x193-1095004r1067">scan-plist</a> scan keys in the order they appear in
the underlying structure. <a 
href="#x193-1095006r1068">scan-hash</a> scans keys in no particular order. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-plist &#x2019;(a 1 b 3))  ⇒ #Z(a b) and #Z(1 3)
</td></tr></table>
<!--l. 317--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-alist &#x2019;((a . 1) nil (a . 3) (b . 2)))</td></tr></table>
<!--l. 318--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(a b) and #Z(1 2)</td></tr></table>
<!--l. 320--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 323--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1473001"></a><a 
 id="x193-1473002r1069"></a><b> scan-symbols</b>  &#x0026;optional  (<i>package</i> *package*)
                                                                          

                                                                          
<!--l. 325--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14740001069"></a></span>
   <a 
href="#x193-1096002r1069">scan-symbols</a> returns a series, in no particular order, and possibly containing
duplicates, of the symbols accessible in <i>package</i> (which defaults to the current
package).
</div>
<div class=defun>
<!--l. 331--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1474001"></a><a 
 id="x193-1474002r1070"></a><b> scan-ﬁle</b>  <i>ﬁle-name</i> &#x0026;optional  (<i>reader</i> #&#x2019;read)
<!--l. 333--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14750001070"></a></span>
   <a 
href="#x193-1097002r1070">scan-ﬁle</a> opens the ﬁle named by the string <i>ﬁle-name</i> and applies the function
<i>reader</i> to it repeatedly until the end of the ﬁle is reached. <i>Reader</i> must accept the
standard input function arguments <i>input-stream</i>, <i>eof-error-p</i>, and <i>eof-value</i> as its
arguments. (For instance, <i>reader</i> can be <a 
href="clmse116.html#x143-664003r696">read</a>, read-preserving-white-space,
<a 
href="clmse116.html#x143-668003r700">read-line</a>, or <a 
href="clmse116.html#x143-669002r701">read-char</a>.) If omitted, <i>reader</i> defaults to <a 
href="clmse116.html#x143-664003r696">read</a>. <a 
href="#x193-1097002r1070">scan-ﬁle</a> returns a
series of the values returned by <i>reader</i>, up to but not including the value returned
when the end of the ﬁle is reached. The ﬁle is correctly closed, even if an abort
occurs.
</div>
<div class=defun>
<!--l. 346--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1475001"></a><a 
 id="x193-1475002r1071"></a><b> scan-fn</b>  <i>type</i> <i>init</i> <i>step</i> &#x0026;optional  <i>test</i>
<!--l. 348--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14760001071"></a></span>
   The higher-order function <a 
href="#x193-1098002r1071">scan-fn</a> supports the general concept of scanning.
The <i>type</i> argument is a type speciﬁer indicating the type of values returned by
<i>init</i> and <i>step</i>. The <a 
href="clmse44.html#x56-202002r123">values</a> type speciﬁer can be used for this argument to
indicate multiple types; however, <i>type</i> cannot indicate zero values. If <i>type</i>
indicates <i>m</i> types <i>t</i><sub>1</sub>,…,<i>t</i><sub>m</sub>, then <a 
href="#x193-1098002r1071">scan-fn</a> returns <i>m</i> series <i>T1</i>, … , <i>Tm</i>,
where <i>Ti</i> has the type (series <i>t</i><sub>i</sub>). The arguments <i>init</i>, <i>step</i>, and <i>test</i> are
functions.
<!--l. 361--><p class="indent" >   The <i>init</i> must be of type (function () (values <i>t</i><sub>1</sub> ... <i>t</i><sub>m</sub>)).
<!--l. 364--><p class="indent" >   The <i>step</i> must be of type (function (<i>t</i><sub>1</sub> ... <i>t</i><sub>m</sub>) (values <i>t</i><sub>1</sub> ... <i>t</i><sub>m</sub>)).
<!--l. 367--><p class="indent" >   The <i>test</i> (if present) must be of type (function (<i>t</i><sub>1</sub> ... <i>t</i><sub>m</sub>) t).
<!--l. 370--><p class="indent" >   The elements of the <i>Ti</i> are computed as follows: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values <i>T1</i><sub>0</sub> ... <i>Tm</i><sub>0</sub>) = (funcall <i>init</i>)
</td></tr></table>
<!--l. 372--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values <i>T1</i><sub>j</sub> ... <i>Tm</i><sub>j</sub>) = (funcall <i>step</i> <i>T1</i><sub>(j−1)</sub> ... <i>Tm</i><sub>(j−1)</sub>)</td></tr></table>
                                                                          

                                                                          
<!--l. 374--><p class="indent" >
</div>
</div>
<!--l. 376--><p class="indent" >   The outputs all have the same length. If there is no <i>test</i>, the outputs have
unbounded length. If there is a <i>test</i>, the outputs consist of the elements up to, but
not including, the ﬁrst elements (with index <i>j</i>, say) for which the following
termination test is not <a 
href="clmse31.html#x42-86002r19">nil</a>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall <i>test</i> <i>T1</i><sub>j</sub> ... <i>Tm</i><sub>j</sub>)
</td></tr></table>
<!--l. 382--><p class="indent" >
</div>
</div>
<!--l. 383--><p class="noindent" >It is guaranteed that <i>step</i> will not be applied to the elements that pass this
termination test.
<!--l. 386--><p class="indent" >   If <i>init</i>, <i>step</i>, or <i>test</i> has side eﬀects when invoked, it can count on being called
in the order indicated by the equations above, with <i>test</i> called just before <i>step</i> on
each cycle. However, given the lazy evaluation nature of series, these functions will
not be called until their outputs are actually used (if ever). In addition, no
assumptions can be made about the relative order of evaluation of these
calls with regard to execution in other parts of a given series expression.
The ﬁrst example below scans down a list stepping two elements at a
time. The second example generates two unbounded series: the integers
counting up from 1 and the sequence of partial sums of the ﬁrst <i>i</i> integers. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-fn t #&#x2019;(lambda () &#x2019;(a b c d)) #&#x2019;cddr #&#x2019;null)
</td></tr></table>
<!--l. 398--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z((a b c d) (c d))</td></tr></table>
<!--l. 399--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 400--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-fn &#x2019;(values integer integer)</td></tr></table>
<!--l. 401--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         #&#x2019;(lambda () (values 1 0))</td></tr></table>
<!--l. 402--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         #&#x2019;(lambda (i sum) (values (+ i 1) (+ sum i))))</td></tr></table>
<!--l. 403--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(1 2 3 4 ...) and #Z(0 1 3 6 ...)</td></tr></table>
<!--l. 405--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 408--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1476001"></a><a 
 id="x193-1476002r1072"></a><b> scan-fn-inclusive</b>  <i>type</i> <i>init</i> <i>step</i> <i>test</i>
<!--l. 410--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14770001072"></a></span>
   The higher-order function <a 
href="#x193-1099002r1072">scan-fn-inclusive</a> is the same as <a 
href="#x193-1098002r1071">scan-fn</a> except that
the ﬁrst set of elements for which <i>test</i> returns a non-null value is included in the
output. As with <a 
href="#x193-1098002r1071">scan-fn</a>, it is guaranteed that <i>step</i> will not be applied to the
elements for which <i>test</i> is non-null.
</div>
<!--l. 418--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.2   </span> <a 
 id="x193-1478000A.2.2"></a>Mapping</h4>
<!--l. 420--><p class="noindent" >By far the most common kind of series operation is mapping. In cognizance of this
fact, four diﬀerent ways are provided for specifying mapping: one fundamental
form (<a 
href="#x193-1101002r1073">map-fn</a>) and three shorthand forms that are more convenient in particular
common situations.
<div class=defun>
<!--l. 425--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1478001"></a><a 
 id="x193-1478002r1073"></a><b> map-fn</b>  <i>type</i> <i>function</i> &#x0026;rest  <i>series-inputs</i>
<!--l. 427--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14790001073"></a></span>
   The higher-order function <a 
href="#x193-1101002r1073">map-fn</a> supports the general concept of mapping.
The <i>type</i> argument is a type speciﬁer indicating the type of values returned by
<i>function</i>. The <a 
href="clmse44.html#x56-202002r123">values</a> construct can be used to indicate multiple types; however,
<i>type</i> cannot indicate zero values. If <i>type</i> indicates m types t<sub>1</sub>,…,t<sub>m</sub>, then
<a 
href="#x193-1101002r1073">map-fn</a> returns m series <i>T1</i>, … , <i>Tm</i>, where <i>Ti</i> has the type (series t<sub>i</sub>). The
argument <i>function</i> is a function. The remaining arguments (if any) are all
series. Let these series be <i>S1</i>, … , <i>Sn</i> and suppose that <i>Si</i> has the type
(series <i>s</i><sub>i</sub>).
<!--l. 442--><p class="indent" >   The <i>function</i> must be of type <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(function (<i>s</i><sub>1</sub> ... <i>s</i><sub>n</sub>) (values <i>t</i><sub>1</sub> ... <i>t</i><sub>m</sub>))
</td></tr></table>
<!--l. 445--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 447--><p class="indent" >   The length of each output is the same as the length of the shortest input. If
there are no bounded series inputs, the outputs are unbounded. The elements of
the <i>Ti</i> are the results of applying <i>function</i> to the corresponding elements of the
series inputs. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values <i>T1</i><sub>j</sub> ... <i>Tm</i><sub>j</sub>)  ≡ (funcall <i>function</i> <i>S1</i><sub>j</sub> ... <i>Sn</i><sub>j</sub>)
</td></tr></table>
<!--l. 453--><p class="indent" >
</div>
</div>
<!--l. 455--><p class="indent" >   If <i>function</i> has side eﬀects, it can count on being called ﬁrst on the <i>Si</i><sub>0</sub>, then
on the <i>Si</i><sub>1</sub>, and so on. However, given the lazy evaluation nature of series,
<i>function</i> will not be called on any group of input elements until the result is
actually used (if ever). In addition, no assumptions can be made about the
relative order of evaluation of the calls on <i>function</i> with regard to execution in
other parts of a given series expression. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(map-fn &#x2019;integer #&#x2019;+ #Z(1 2 3) #Z(4 5))  ⇒ #Z(5 7)
</td></tr></table>
<!--l. 463--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(map-fn t #&#x2019;gensym)  ⇒ #Z(#:G3 #:G4 #:G5 ...)</td></tr></table>
<!--l. 464--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(map-fn &#x2019;(values integer rational) #&#x2019;ﬂoor #Z(1/4 9/5 12/3))</td></tr></table>
<!--l. 465--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(0 1 4) and #Z(1/4 4/5 0)</td></tr></table>
<!--l. 467--><p class="indent" >
</div>
</div>
<!--l. 469--><p class="indent" >   The # macro character syntax #M makes it easy to specify uses of
<a 
href="#x193-1101002r1073">map-fn</a> where <i>type</i> is <a 
href="clmse31.html#x42-87002r20">t</a> and the <i>function</i> is a named function. The notation
(#M<i>function</i> ...) is an abbreviation for (map-fn t #&#x2019;<i>function</i> ...). The
form <i>function</i> can be the printed representation of any Lisp object. The
notation #M<i>function</i> can appear only in the function position of a list. <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect (#M1+ (scan &#x2019;(1 2 3))))  ⇒ (2 3 4)
</td></tr></table>
<!--l. 478--><p class="indent" >
</div>
</div>
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> mapping </b><a 
 id="dx193-1479001"></a><a 
 id="x193-1479002r1074"></a> ( {( {var | ( {var}* )} value)}* )  {declaration}*  { form}*
</td></tr></table>
<!--l. 483--><p class="indent" >
</div>
<!--l. 483--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-1480000A.2.2"></a></span>
   The macro <a 
href="#x193-1102002r1074">mapping</a> makes it easy to specify uses of <a 
href="#x193-1101002r1073">map-fn</a> where <i>type</i> is <a 
href="clmse31.html#x42-87002r20">t</a>
and the <i>function</i> is a literal lambda. The syntax of <a 
href="#x193-1102002r1074">mapping</a> is analogous to that
of <a 
href="clmse39.html#x51-163003r84">let</a>. The binding list speciﬁes zero or more variables that are bound in parallel
to successive values of series. The <i>value</i> part of each pair is an expression that
must produce a series. The <i>declarations</i> and <i>forms</i> are treated as the body of a
lambda expression that is mapped over the series values. A series of the ﬁrst
values returned by this lambda expression is returned as the result of <a 
href="#x193-1102002r1074">mapping</a>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping ((x r) (y s)) ...)  ≡
</td></tr></table>
<!--l. 496--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (map-fn t #&#x2019;(lambda (x y) ...) r s)</td></tr></table>
<!--l. 497--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 498--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping ((x (scan &#x2019;(2 -2 3))))</td></tr></table>
<!--l. 499--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (expt (abs x) 3))</td></tr></table>
<!--l. 500--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(8 8 27)</td></tr></table>
<!--l. 502--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 504--><p class="indent" >   The form <a 
href="#x193-1102002r1074">mapping</a> supports a special syntax that facilitates the use of series
functions returning multiple values. Instead of being a single variable, the variable
part of a <i>var-value</i> pair can be a list of variables. This list is treated the
same way as the ﬁrst argument to <a 
href="clmse44.html#x56-208002r129">multiple-value-bind</a> and can be used
to access the elements of multiple series returned by a series function. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping (((i v) (scan-plist &#x2019;(a 1 b 2))))
</td></tr></table>
<!--l. 511--><p class="indent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (list i v))</td></tr></table>
<!--l. 512--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z((a 1) (b 2))</td></tr></table>
<!--l. 514--><p class="indent" >
</div>
</div>
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> iterate </b><a 
 id="dx193-1480001"></a><a 
 id="x193-1480002r1075"></a> ( {( {var | ( {var}* )} value)}* )  {declaration}*  { form}*
</td></tr></table>
<!--l. 519--><p class="indent" >
</div>
<!--l. 519--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-1481000A.2.2"></a></span>
   The form <a 
href="#x193-1103002r1075">iterate</a> is the same as <a 
href="#x193-1102002r1074">mapping</a>, except that after mapping
the <i>forms</i> over the <i>values</i>, the results are discarded and <a 
href="clmse31.html#x42-86002r19">nil</a> is returned. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((item (scan &#x2019;((1) (-2) (3)))))
</td></tr></table>
                                                                          

                                                                          
<!--l. 524--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (iterate ((x (#Mcar item)))</td></tr></table>
<!--l. 525--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (if (plusp x) (prin1 x))))</td></tr></table>
<!--l. 526--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ nil (after printing “13”)</td></tr></table>
<!--l. 528--><p class="indent" >
</div>
</div>
<!--l. 530--><p class="indent" >   To a ﬁrst approximation, <a 
href="#x193-1103002r1075">iterate</a> and <a 
href="#x193-1102002r1074">mapping</a> diﬀer in the same way as <a 
href="clmse42.html#x54-194007r115">mapc</a>
and <a 
href="clmse42.html#x54-194003r113">mapcar</a>. In particular, like <a 
href="clmse42.html#x54-194007r115">mapc</a>, <a 
href="#x193-1103002r1075">iterate</a> is intended to be used in
situations where the <i>forms</i> are being evaluated for side eﬀects rather than for
their results. However, given the lazy evaluation semantics of series, the
diﬀerence between <a 
href="#x193-1103002r1075">iterate</a> and <a 
href="#x193-1102002r1074">mapping</a> is more than just a question of
eﬃciency.
<!--l. 537--><p class="indent" >   If <a 
href="clmse42.html#x54-194003r113">mapcar</a> is used in a situation where the output is not used, time is wasted
unnecessarily creating the output list. However, if <a 
href="#x193-1102002r1074">mapping</a> is used in a situation
where the output is not used, no computation is performed, because series
elements are not computed until they are used. Thus <a 
href="#x193-1103002r1075">iterate</a> can be thought of as
a declaration that the indicated computation is to be performed even though the
output is not used for anything.
</div>
<!--l. 546--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.3   </span> <a 
 id="x193-1482000A.2.3"></a>Truncation and Other Simple Transducers</h4>
<!--l. 548--><p class="noindent" >Transducers compute series from series and form the heart of most series
expressions. Mapping is by far the most common transducer. This section presents
a number of additional simple transducers.
<div class=defun>
<!--l. 553--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1482001"></a><a 
 id="x193-1482002r1076"></a><b> cotruncate</b>  &#x0026;rest  <i>series-inputs</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1482003"></a><a 
 id="x193-1482004r1077"></a><b> until</b>  <i>bools</i> &#x0026;rest  <i>series-inputs</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1482005"></a><a 
 id="x193-1482006r1078"></a><b> until-if</b>  <i>pred</i> &#x0026;rest  <i>series-inputs</i>
<!--l. 557--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14830001078"></a></span>
   Each of these functions accepts one or more series inputs S1, … , <i>Sn</i> as its
&#x0026;rest argument and returns <i>n</i> series outputs <i>T1</i>, … , <i>Tn</i> that contain the same
elements in the same order—that is, <i>Ti<sub>j</sub>=Si<sub>j</sub></i>. Let <i>k</i> be the length of the shortest
input <i>Si</i>. <a 
href="#x193-1105002r1076">cotruncate</a> truncates the series so that each output has length <i>k</i>. Let <i>k</i>′
                                                                          

                                                                          
be the position of the ﬁrst element in the boolean series <i>bools</i> that is not <a 
href="clmse31.html#x42-86002r19">nil</a> or, if
every element is <a 
href="clmse31.html#x42-86002r19">nil</a>, the length of <i>bools</i>. <a 
href="#x193-1105004r1077">until</a> truncates the series so that each
output has length (min <i>k</i> <i>k</i>′). Let itk′′ be the position of the ﬁrst element in <i>S1</i>
such that (<i>pred</i> <i>S1<sub>k′′</sub></i>) is not <a 
href="clmse31.html#x42-86002r19">nil</a> or, if there is no such element, the length of <i>S1</i>.
<a 
href="#x193-1105006r1078">until-if</a> truncates the series so that each output has length (min <i>k</i> <i>k</i>′′). <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(cotruncate #Z(1 2 -3 4) #Z(a b c))
</td></tr></table>
<!--l. 574--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(1 2 -3) and #Z(a b c)</td></tr></table>
<!--l. 575--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(until #Z(nil nil t nil) #Z(1 2 -3 4) #Z(a b c))</td></tr></table>
<!--l. 576--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(1 2) and #Z(a b)</td></tr></table>
<!--l. 577--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(until-if #&#x2019;minusp #Z(1 2 -3 4) #Z(a b c))</td></tr></table>
<!--l. 578--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(1 2) and #Z(a b)</td></tr></table>
<!--l. 580--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 583--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1483001"></a><a 
 id="x193-1483002r1079"></a><b> previous</b>  <i>items</i> &#x0026;optional  (<i>default</i> nil) (<i>amount</i> 1)
<!--l. 585--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14840001079"></a></span>
   The series returned by <a 
href="#x193-1106002r1079">previous</a> is the same as the input series <i>items</i> except
that it is shifted to the right by the positive integer <i>amount</i>. The shifting is done
by inserting <i>amount</i> copies of <i>default</i> before <i>items</i> and discarding <i>amount</i>
elements from the end of <i>items</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(previous #Z(10 11 12) 0)  ⇒ #Z(0 10 11)
</td></tr></table>
<!--l. 593--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 596--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1484001"></a><a 
 id="x193-1484002r1080"></a><b> latch</b>  <i>items</i> &#x0026;key  <i>:after</i> <i>:before</i> <i>:pre</i> <i>:post</i>
                                                                          

                                                                          
<!--l. 598--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14850001080"></a></span>
   The series returned by <a 
href="#x193-1107002r1080">latch</a> is the same as the input series <i>items</i> except that
some of the elements are replaced by other values. <a 
href="#x193-1107002r1080">latch</a> acts like a <i>latch</i> electronic
circuit component. Each input element causes the creation of a corresponding
output element. After a speciﬁed number of non-null input elements have been
encountered, the latch is triggered and the output mode is permanently
changed.
<!--l. 607--><p class="indent" >   The :after and :before arguments specify the latch point. The latch point is
just after the :after-th non-null element in <i>items</i> or just before the :before-th
non-null element. If neither :after nor :before is speciﬁed, an :after of 1 is assumed.
If both are speciﬁed, it is an error.
<!--l. 613--><p class="indent" >   If a :pre is speciﬁed, every element prior to the latch point is replaced by
this value. If a :post is speciﬁed, every element after the latch point is
replaced by this value. If neither is speciﬁed, a :post of <a 
href="clmse31.html#x42-86002r19">nil</a> is assumed. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(latch #Z(nil c nil d e))  ⇒ #Z(nil c nil nil nil)
</td></tr></table>
<!--l. 618--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(latch #Z(nil c nil d e) :before 2 :post t)  ⇒ #Z(nil c nil t t)</td></tr></table>
<!--l. 620--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 623--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1485001"></a><a 
 id="x193-1485002r1081"></a><b> collecting-fn</b>  <i>type</i> <i>init</i> <i>function</i> &#x0026;rest  <i>series-inputs</i>
<!--l. 625--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14860001081"></a></span>
   The higher-order function <a 
href="#x193-1108002r1081">collecting-fn</a> supports the general concept of a
simple transducer with internal state. The <i>type</i> argument is a type speciﬁer
indicating the type of values returned by <i>function</i>. The <a 
href="clmse44.html#x56-202002r123">values</a> construct can
be used to indicate multiple types; however, <i>type</i> cannot indicate zero
values. If <i>type</i> indicates <i>m</i> types <i>t</i><sub>1</sub>,…,<i>t</i><sub>m</sub>, then <a 
href="#x193-1108002r1081">collecting-fn</a> returns <i>m</i>
series T1, … , <i>Tm</i>, where <i>Ti</i> has the type (series <i>t</i><sub>i</sub>). The arguments <i>init</i>
and <i>function</i> are functions. The remaining arguments (if any) are all
series. Let these series be S1, … , <i>Sn</i> and suppose that <i>Si</i> has the type
(series <i>s</i><sub>i</sub>).
                                                                          

                                                                          
<!--l. 640--><p class="indent" >   The <i>init</i> must be of type (function () (values <i>t</i><sub>1</sub> ... <i>t</i><sub>m</sub>)).
<!--l. 643--><p class="indent" >   The <i>function</i> must be of type <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(function (<i>t</i><sub>1</sub> ... <i>t</i><sub>m</sub> <i>s</i><sub>1</sub> ... <i>s</i><sub>n</sub>) (values <i>t</i><sub>1</sub> ... <i>t</i><sub>m</sub>))
</td></tr></table>
<!--l. 646--><p class="indent" >
</div>
</div>
<!--l. 648--><p class="indent" >   The length of each output is the same as the length of the shortest input. If
there are no bounded series inputs, the outputs are unbounded. The elements of
the <i>Ti</i> are computed as follows: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values <i>T1</i><sub>0</sub> ... <i>Tm</i><sub>0</sub>)  ≡
</td></tr></table>
<!--l. 652--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-call <i>function</i> (funcall <i>init</i>) <i>S1</i><sub>0</sub> ... <i>Sn</i><sub>0</sub>)</td></tr></table>
<!--l. 653--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 654--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values <i>T1</i><sub>j</sub> ... <i>Tm</i><sub>j</sub>)  ≡</td></tr></table>
<!--l. 655--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (funcall <i>function</i> <i>T1</i><sub>(j−1)</sub> ... <i>Tm</i><sub>(j−1)</sub> <i>S1</i><sub>j</sub> ... <i>Sn</i><sub>j</sub>)</td></tr></table>
<!--l. 657--><p class="indent" >
</div>
</div>
<!--l. 659--><p class="indent" >   If <i>init</i> or <i>function</i> has side eﬀects, it can count on being called in the order
indicated by the equations above. However, given the lazy evaluation nature of
series, these functions will not be called until their outputs are actually used (if
ever). In addition, no assumptions can be made about the relative order of
evaluation of these calls with regard to execution in other parts of a given series
expression. The second example below computes a series of partial sums of the
numbers in an input series. The third example computes two output series: the
partial sums of its ﬁrst input and the partial products of its second input. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun running-averages (ﬂoat-list)
</td></tr></table>
<!--l. 670--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-call #&#x2019;map-fn</td></tr></table>
<!--l. 671--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    &#x2019;ﬂoat #&#x2019;/</td></tr></table>
                                                                          

                                                                          
<!--l. 672--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (collecting-fn &#x2019;(values ﬂoat integer)</td></tr></table>
<!--l. 673--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   #&#x2019;(lambda () (values 0.0 0)</td></tr></table>
<!--l. 674--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   #&#x2019;(lambda (s n x) (values (+ s x) (+ n 1))))</td></tr></table>
<!--l. 675--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   ﬂoat-list)))</td></tr></table>
<!--l. 677--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collecting-fn &#x2019;integer #&#x2019;(lambda () 0) #&#x2019;+ #Z(1 2 3))
</td></tr></table>
<!--l. 679--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(1 3 6)</td></tr></table>
<!--l. 680--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 681--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collecting-fn &#x2019;(values integer integer)</td></tr></table>
<!--l. 682--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #&#x2019;(lambda () (values 0 1))</td></tr></table>
<!--l. 683--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #&#x2019;(lambda (sum prod x y)</td></tr></table>
<!--l. 684--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (values (+ sum x) (* prod y)))</td></tr></table>
<!--l. 685--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #Z(4 6 8)</td></tr></table>
<!--l. 686--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #Z(1 2 3))</td></tr></table>
<!--l. 687--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(4 10 18) and #Z(1 2 6)</td></tr></table>
<!--l. 689--><p class="indent" >
</div>
</div>
</div>
<!--l. 692--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.4   </span> <a 
 id="x193-1487000A.2.4"></a>Conditional and Other Complex Transducers</h4>
<!--l. 695--><p class="noindent" >This section presents a number of complex transducers, including ones that
support conditional computation.
<div class=defun>
<!--l. 699--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1487001"></a><a 
 id="x193-1487002r1082"></a><b> choose</b>  <i>bools</i> &#x0026;optional  (<i>items</i> bools)<br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1487003"></a><a 
 id="x193-1487004r1083"></a><b> choose-if</b>  <i>pred</i> <i>items</i>
                                                                          

                                                                          
<!--l. 702--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14880001083"></a></span>
   Each of these functions takes in a series of elements (<i>items</i>) and returns a
series containing the same elements in the same order, but with some elements
removed. <a 
href="#x193-1110002r1082">choose</a> removes <i>items</i><sub>j</sub> if bools<sub>j</sub> is <a 
href="clmse31.html#x42-86002r19">nil</a> or <i>j</i> is beyond the end of <i>bools</i>. If
items is omitted, <a 
href="#x193-1110002r1082">choose</a> returns the non-null elements of bools. <a 
href="#x193-1110004r1083">choose-if</a> removes
<i>items</i><sub>j</sub> if (<i>pred</i> <i>items</i><sub>j</sub>) is <a 
href="clmse31.html#x42-86002r19">nil</a>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(choose #Z(t nil t nil) #Z(a b c d))  ⇒ #Z(a c)
</td></tr></table>
<!--l. 711--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-sum (choose-if #&#x2019;plusp #Z(-1 2 -3 4)))  ⇒ 6</td></tr></table>
<!--l. 713--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 716--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1488001"></a><a 
 id="x193-1488002r1084"></a><b> expand</b>  <i>bools</i> <i>items</i> &#x0026;optional  (<i>default</i> nil)
<!--l. 718--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14890001084"></a></span>
   <a 
href="#x193-1111002r1084">expand</a> is a quasi-inverse of <a 
href="#x193-1110002r1082">choose</a>. The output contains the elements of the
input series <i>items</i> spread out into the positions speciﬁed by the non-null elements
in <i>bools</i>—that is, <i>items</i><sub>j</sub> is in the position occupied by the <i>j</i>th non-null element in
<i>bools</i>. The other positions in the output are occupied by <i>default</i>. The output
stops as soon as <i>bools</i> runs out of elements or a non-null element in <i>bools</i>
is encountered for which there is no corresponding element in <i>items</i>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(expand #Z(nil t nil t t) #Z(a b c))  ⇒ #Z(nil a nil b c)
</td></tr></table>
<!--l. 729--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(expand #Z(nil t nil t t) #Z(a))  ⇒ #Z(nil a nil)</td></tr></table>
<!--l. 731--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 734--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1489001"></a><a 
 id="x193-1489002r1085"></a><b> split</b>  <i>items</i> &#x0026;rest  <i>test-series-inputs</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1489003"></a><a 
 id="x193-1489004r1086"></a><b> split-if</b>  <i>items</i> &#x0026;rest  <i>test-predicates</i>
                                                                          

                                                                          
<!--l. 737--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14900001086"></a></span>
   These functions are like <a 
href="#x193-1110002r1082">choose</a> and <a 
href="#x193-1110004r1083">choose-if</a> except that instead of producing
one restricted output, they partition the input series <i>items</i> between several
outputs. If there are <i>n</i> test inputs following <i>items</i>, then there are <i>n</i> + 1 outputs.
Each input element is placed in exactly one output series, depending on the
outcome of a sequence of tests. If the element <i>items</i><sub>j</sub> fails the ﬁrst <i>k</i> − 1 tests and
passes the <i>k</i>h test, it is put in the <i>k</i>th output. If <i>items</i><sub>j</sub> fails every test, it is
placed in the last output. In addition, all output stops as soon as any
series input runs out of elements. The test inputs to <a 
href="#x193-1112002r1085">split</a> are series of
values; <i>items</i><sub>j</sub> passes the <i>k</i>th test if the <i>j</i>th element of the <i>k</i>th test series is
not <a 
href="clmse31.html#x42-86002r19">nil</a>. The test inputs to <a 
href="#x193-1112004r1086">split-if</a> are predicates; <i>items</i><sub>j</sub> passes the <i>k</i>th
test if the <i>k</i>th test predicate returns non-null when applied to items<sub>j</sub>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(split #Z(-1 2 3 -4) #Z(t nil nil t))
</td></tr></table>
<!--l. 754--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(-1 -4) and #Z(2 3)</td></tr></table>
<!--l. 755--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(multiple-value-bind (+x -x) (split-if #Z(-1 2 3 -4) #&#x2019;plusp)</td></tr></table>
<!--l. 756--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (values (collect-sum +x) (collect-sum -x)))</td></tr></table>
<!--l. 757--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ 5 and -5</td></tr></table>
<!--l. 759--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 762--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1490001"></a><a 
 id="x193-1490002r1087"></a><b> catenate</b>  &#x0026;rest  <i>series-inputs</i>
<!--l. 764--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14910001087"></a></span>
   <a 
href="#x193-1113002r1087">catenate</a> combines two or more series into one long series by appending them
end to end. The length of the output is the sum of the lengths of the inputs. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(catenate #Z(b c) #Z() #Z(d))  ⇒ #Z(b c d)
</td></tr></table>
<!--l. 770--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 773--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1491001"></a><a 
 id="x193-1491002r1088"></a><b> subseries</b>  <i>items</i> <i>start</i> &#x0026;optional  <i>below</i>
<!--l. 775--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14920001088"></a></span>
   <a 
href="#x193-1114002r1088">subseries</a> returns a series containing the elements of the input series <i>items</i>
indexed by the non-negative integers from <i>start</i> up to, but not including, <i>below</i>. If
<i>below</i> is omitted or greater than the length of <i>items</i>, the output goes all the way
to the end of <i>items</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subseries #Z(a b c d) 1)  ⇒ #Z(b c d)
</td></tr></table>
<!--l. 782--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subseries #Z(a b c d) 1 3)  ⇒ #Z(b c)</td></tr></table>
<!--l. 784--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 787--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1492001"></a><a 
 id="x193-1492002r1089"></a><b> positions</b>  <i>bools</i>
<!--l. 789--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14930001089"></a></span>
   <a 
href="#x193-1115002r1089">positions</a> returns a series of the indices of the non-null elements in the series
input <i>bools</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(positions #Z(t nil t 44))  ⇒ #Z(0 2 3)
</td></tr></table>
<!--l. 794--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 797--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1493001"></a><a 
 id="x193-1493002r1090"></a><b> mask</b>  <i>monotonic-indices</i>
                                                                          

                                                                          
<!--l. 799--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14940001090"></a></span>
   <a 
href="#x193-1116002r1090">mask</a> is a quasi-inverse of <a 
href="#x193-1115002r1089">positions</a>. The series input monotonic-indices must
be a strictly increasing series of non-negative integers. The output, which is
always unbounded, contains <a 
href="clmse31.html#x42-87002r20">t</a> in the positions speciﬁed by <i>monotonic-indices</i> and
<a 
href="clmse31.html#x42-86002r19">nil</a> everywhere else. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask #Z(0 2 3))  ⇒ #Z(t nil t t nil nil ...)
</td></tr></table>
<!--l. 805--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask #Z())  ⇒ #Z(nil nil ...)</td></tr></table>
<!--l. 806--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask (positions #Z(nil a nil b nil)))</td></tr></table>
<!--l. 807--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(nil t nil t nil ...)</td></tr></table>
<!--l. 809--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 813--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1494001"></a><a 
 id="x193-1494002r1091"></a><b> mingle</b>  <i>items1</i> <i>items2</i> <i>comparator</i>
<!--l. 815--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14950001091"></a></span>
   The series returned by <a 
href="#x193-1117002r1091">mingle</a> contains all and only the elements of the two
input series. The length of the output is the sum of the lengths of the inputs and
is unbounded if either input is unbounded. The order of the elements remains
unchanged; however, the elements from the two inputs are stably intermixed
under the control of the <i>comparator</i>.
<!--l. 822--><p class="indent" >   The <i>comparator</i> must accept two arguments and return non-null if and only if
its ﬁrst argument is strictly less than its second argument (in some appropriate
sense). At each step, the <i>comparator</i> is used to compare the current elements in
the two series. If the current element from items2 is strictly less than the current
element from <i>items1</i>, the current element is removed from <i>items2</i> and transferred
to the output. Otherwise, the next output element comes from <i>items1</i>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mingle #Z(1 3 7 9) #Z(4 5 8) #&#x2019;&#x003C;)  ⇒ #Z(1 3 4 5 7 8 9)
</td></tr></table>
<!--l. 830--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mingle #Z(1 7 3 9) #Z(4 5 8) #&#x2019;&#x003C;)  ⇒ #Z(1 4 5 7 3 8 9)</td></tr></table>
<!--l. 832--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 835--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1495001"></a><a 
 id="x193-1495002r1092"></a><b> chunk</b>  <i>m</i> <i>n</i> <i>items</i>
<!--l. 837--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14960001092"></a></span>
   This function has the eﬀect of breaking up the input series <i>items</i> into (possibly
overlapping) chunks of length <i>m</i>. The starting positions of successive chunks diﬀer
by <i>n</i>. The inputs <i>m</i> and <i>n</i> must both be positive integers.
<!--l. 842--><p class="indent" >   <a 
href="#x193-1118002r1092">chunk</a> produces <i>m</i> output series. The <i>i</i>th chunk provides the <i>i</i>th element for
each of the <i>m</i> outputs. Suppose that the length of <i>items</i> is <i>l</i>. The length of each
output is ⌊1 + (<i>l</i> −<i>m</i>)∕<i>n</i>⌋. The <i>i</i>th element of the <i>k</i>th output is the (<i>i</i> ∗<i>n</i> + <i>k</i>)th
element of <i>items</i> (<i>i</i> and <i>k</i> counting from zero).
<!--l. 850--><p class="indent" >   Note that if <i>l</i> &#x003C; <i>m</i>, there will be no output elements, and if <i>l</i> −<i>m</i> is not a
multiple of <i>n</i>, the last few input elements will not appear in the output. If <i>m</i> ≥<i>n</i>,
one can guarantee that the last chunk will contain the last element of <i>items</i> by
catenating <i>n</i> − 1 copies of an appropriate padding value to the end of
<i>items</i>.
<!--l. 858--><p class="indent" >   The ﬁrst example below shows <a 
href="#x193-1118002r1092">chunk</a> being used to compute a moving average.
The second example shows <a 
href="#x193-1118002r1092">chunk</a> being used to convert a property list into an
association list. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping (((xi xi+1 xi+2) (chunk 3 1 #Z(1 5 3 4 5 6))))
</td></tr></table>
<!--l. 862--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (/ (+ xi xi+1 xi+2) 3))</td></tr></table>
<!--l. 863--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #Z(3 4 4 5)</td></tr></table>
<!--l. 865--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect</td></tr></table>
<!--l. 866--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (mapping (((prop val) (chunk 2 2 (scan &#x2019;(a 2 b 5 c 8)))))</td></tr></table>
<!--l. 867--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (cons prop val)))</td></tr></table>
<!--l. 868--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ ((a . 2) (b . 5) (c . 8))</td></tr></table>
<!--l. 870--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
<!--l. 873--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.5   </span> <a 
 id="x193-1497000A.2.5"></a>Collectors</h4>
<!--l. 875--><p class="noindent" >Collectors produce non-series outputs based on series inputs. They either
create a summary value based on some formula (the sum, for example) or
collect the elements of a series in an aggregate data structure (such as a
list).
<div class=defun>
<!--l. 879--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1497001"></a><a 
 id="x193-1497002r1093"></a><b> collect-ﬁrst</b>  <i>items</i> &#x0026;optional  (<i>default</i> nil)<br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1497003"></a><a 
 id="x193-1497004r1094"></a><b> collect-last</b>  <i>items</i> &#x0026;optional  (<i>default</i> nil)<br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1497005"></a><a 
 id="x193-1497006r1095"></a><b> collect-nth</b>  <i>n</i> <i>items</i> &#x0026;optional  (<i>default</i> nil)
<!--l. 883--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14980001095"></a></span>
   Given a series <i>items</i>, these functions return the ﬁrst element, the last element,
and the <i>n</i>th element, respectively. If <i>items</i> has no elements (or no <i>n</i>th element),
<i>default</i> is returned. If <i>default</i> is not speciﬁed, then <a 
href="clmse31.html#x42-86002r19">nil</a> is used for <i>default</i>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-ﬁrst #Z() &#x2019;z)  ⇒ z
</td></tr></table>
<!--l. 889--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-last #Z(a b c))  ⇒ c</td></tr></table>
<!--l. 890--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-nth 1 #Z(a b c))  ⇒ b</td></tr></table>
<!--l. 892--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 895--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1498001"></a><a 
 id="x193-1498002r1096"></a><b> collect-length</b>  <i>items</i>
<!--l. 897--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-14990001096"></a></span>
   <a 
href="#x193-1121002r1096">collect-length</a> returns the number of elements in a series. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-length #Z(a b c))  ⇒ 3
</td></tr></table>
<!--l. 901--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 905--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1499001"></a><a 
 id="x193-1499002r1097"></a><b> collect-sum</b>  <i>numbers</i> &#x0026;optional  (<i>type</i> &#x2019;number)
<!--l. 907--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15000001097"></a></span>
   <a 
href="#x193-1122002r1097">collect-sum</a> returns the sum of the elements in a series of numbers.
The <i>type</i> is a type speciﬁer that indicates the type of sum to be created.
If <i>type</i> is not speciﬁed, then number is used for the <i>type</i>. If there are
no elements in the input, a zero (of the appropriate type) is returned. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-sum #Z(1.1 1.2 1.3))  ⇒ 3.6
</td></tr></table>
<!--l. 915--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-sum #Z() &#x2019;complex)  ⇒ #C(0 0)</td></tr></table>
<!--l. 917--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 921--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1500001"></a><a 
 id="x193-1500002r1098"></a><b> collect-max</b>  <i>numbers</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1500003"></a><a 
 id="x193-1500004r1099"></a><b> collect-min</b>  <i>numbers</i>
<!--l. 924--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15010001099"></a></span>
   Given a series of non-complex numbers, these functions compute the maximum
element and the minimum element, respectively. If there are no elements in the
input, <a 
href="clmse31.html#x42-86002r19">nil</a> is returned. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-max #Z(2 1 4 3))  ⇒ 4
</td></tr></table>
<!--l. 929--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-min #Z(1.2 1.1 1.4 1.3))  ⇒ 1.1</td></tr></table>
<!--l. 930--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-min #Z())  ⇒ nil</td></tr></table>
<!--l. 932--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 936--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1501001"></a><a 
 id="x193-1501002r1100"></a><b> collect-and</b>  <i>bools</i>
<!--l. 938--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15020001100"></a></span>
   <a 
href="#x193-1124002r1100">collect-and</a> returns the <a 
href="clmse34.html#x45-123002r51">and</a> of the elements in a series. As with the macro <a 
href="clmse34.html#x45-123002r51">and</a>,
<a 
href="clmse31.html#x42-86002r19">nil</a> is returned if any element of bools is <a 
href="clmse31.html#x42-86002r19">nil</a>. Otherwise, the last element of <i>bools</i>
is returned. The value <a 
href="clmse31.html#x42-87002r20">t</a> is returned if there are no elements in bools. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-and #Z(a b c))  ⇒ c
</td></tr></table>
<!--l. 945--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-and #Z(a nil c))  ⇒ nil</td></tr></table>
<!--l. 947--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 950--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1502001"></a><a 
 id="x193-1502002r1101"></a><b> collect-or</b>  <i>bools</i>
<!--l. 952--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15030001101"></a></span>
   <a 
href="#x193-1125002r1101">collect-or</a> returns the <a 
href="clmse34.html#x45-124002r52">or</a> of the elements in a series. As with the macro <a 
href="clmse34.html#x45-124002r52">or</a>, <a 
href="clmse31.html#x42-86002r19">nil</a> is
returned if every element of bools is <a 
href="clmse31.html#x42-86002r19">nil</a>. Otherwise, the ﬁrst non-null element of
<i>bools</i> is returned. The value <a 
href="clmse31.html#x42-86002r19">nil</a> is returned if there are no elements in <i>bools</i>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-or #Z(nil b c))  ⇒ b
</td></tr></table>
<!--l. 959--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-or #Z())  ⇒ nil</td></tr></table>
<!--l. 961--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
<div class=defun>
<!--l. 964--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1503001"></a><a 
 id="x193-1503002r1102"></a><b> collect</b>  <i>items</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1503003"></a><a 
 id="x193-1503004r1103"></a><b> collect</b>  <i>type</i> <i>items</i>
<!--l. 967--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15040001103"></a></span>
   <a 
href="#x193-1126004r1103">collect</a> returns a sequence containing the elements of the series items. The <i>type</i>
is a type speciﬁer indicating the type of sequence to be created. It must be either
a proper subtype of sequence or the symbol bag. If <i>type</i> is omitted, it defaults
to <a 
href="clmse87.html#x107-472002r493">list</a>. (This function exhibits an argument pattern that is unusual for
Common Lisp: an “optional” argument preceding a required argument. This
pattern cannot be expressed in the usual manner with &#x0026;optional. It is
indicated above by two deﬁnition lines, showing the two possible argument
patterns.)
<!--l. 978--><p class="indent" >   If the <i>type</i> is bag, a list is created with the elements in whatever order can be
most eﬃciently obtained. Otherwise, the order of the elements in the
sequence is the same as the order in <i>items</i>. If <i>type</i> speciﬁes a length (that is,
of a vector) this length must be greater than or equal to the length of
<i>items</i>.
<!--l. 984--><p class="indent" >   The <i>n</i>th element of <i>items</i> is placed in the <i>n</i>th slot of the sequence produced.
Any unneeded slots are left in their initial state. Collecting is signiﬁcantly
more eﬃcient if it can be determined at compile time whether <i>type</i> is a
subtype of <a 
href="clmse87.html#x107-472002r493">list</a> or <a 
href="clmse94.html#x116-531002r562">vector</a> and for vectors what the length of the vector is. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect #Z(a b c))  ⇒ (a b c)
</td></tr></table>
<!--l. 990--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect &#x2019;bag #Z(a b c))  ⇒ (c a b) or (b a c) or …</td></tr></table>
<!--l. 991--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect &#x2019;(vector integer 3) #Z(1 2 3))  ⇒ #(1 2 3)</td></tr></table>
<!--l. 993--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 996--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1504001"></a><a 
 id="x193-1504002r1104"></a><b> collect-append</b>  <i>sequences</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1504003"></a><a 
 id="x193-1504004r1105"></a><b> collect-append</b>  <i>type</i> <i>sequences</i>
                                                                          

                                                                          
<!--l. 999--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15050001105"></a></span>
   Given a series of sequences, <a 
href="#x193-1127004r1105">collect-append</a> returns a new sequence by
concatenating these sequences together in order. The <i>type</i> is a type speciﬁer
indicating the type of sequence created and must be a proper subtype of sequence.
If <i>type</i> is omitted, it defaults to <a 
href="clmse87.html#x107-472002r493">list</a>. (This function exhibits an argument pattern
that is unusual for Common Lisp: an “optional” argument preceding a required
argument. This pattern cannot be expressed in the usual manner with &#x0026;optional.
It is indicated above by two deﬁnition lines, showing the two possible argument
patterns.)
<!--l. 1010--><p class="indent" >   It must be possible for every element of every sequence in the input series to
be an element of a sequence of type <i>type</i>. The result does not share any structure
with the sequences in the input. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-append #Z((a b) nil (c d)))  ⇒ (a b c d)
</td></tr></table>
<!--l. 1014--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-append &#x2019;string #Z(&#x0022;a &#x0022; &#x0022;big &#x0022; &#x0022;cat&#x0022;))  ⇒ &#x0022;a big cat&#x0022;</td></tr></table>
<!--l. 1016--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 1019--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1505001"></a><a 
 id="x193-1505002r1106"></a><b> collect-nconc</b>  <i>lists</i>
<!--l. 1021--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15060001106"></a></span>
   <a 
href="#x193-1128002r1106">collect-nconc</a> <a 
href="clmse139.html#x170-846006r867">nconc</a>s the elements of the series lists together in order and
returns the result. This is the same as <a 
href="#x193-1127004r1105">collect-append</a> except that the input must
be a series of lists, the output is always a list, the concatenation is done rapidly by
destructively modifying the input elements, and therefore the output shares all of
its structure with the input elements.
</div>
<div class=defun>
<!--l. 1030--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1506001"></a><a 
 id="x193-1506002r1107"></a><b> collect-alist</b>  <i>keys</i> <i>values</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1506003"></a><a 
 id="x193-1506004r1108"></a><b> collect-plist</b>  <i>keys</i> <i>values</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx193-1506005"></a><a 
 id="x193-1506006r1109"></a><b> collect-hash</b>  <i>keys</i> <i>values</i> &#x0026;key  <i>:test</i> <i>:size</i> <i>:rehash-size</i>
<i>:rehash-threshold</i>
                                                                          

                                                                          
<!--l. 1034--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15070001109"></a></span>
   Given a series of keys and a series of corresponding values, these functions
return an association list, a property list, and a hash table, respectively. Following
the order of the input, each <i>keys</i><sub>j</sub>-values<sub>j</sub> pair is entered into the output so that it
overrides all earlier associations. If one of the input series is longer than the other,
the extra elements are ignored. The keyword arguments of <a 
href="#x193-1129006r1109">collect-hash</a> specify
attributes of the hash table produced and have the same meanings as the
arguments to <a 
href="clmse92.html#x113-514002r545">make-hash-table</a>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-alist #Z(a b c) #Z(1 2))  ⇒ ((b . 2) (a . 1))
</td></tr></table>
<!--l. 1044--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-plist #Z(a b c) #Z(1 2))  ⇒ (b 2 a 1)</td></tr></table>
<!--l. 1045--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-hash #Z() #Z(1 2) :test #&#x2019;eq)  ⇒⟨an empty hash table⟩</td></tr></table>
<!--l. 1047--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 1050--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1507001"></a><a 
 id="x193-1507002r1110"></a><b> collect-ﬁle</b>  <i>ﬁle-name</i> <i>items</i> &#x0026;optional  (<i>printer</i> #&#x2019;print)
<!--l. 1052--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15080001110"></a></span>
   This creates a ﬁle named <i>ﬁle-name</i> and writes the elements of the series <i>items</i>
into it using the function printer. <i>Printer</i> must accept two inputs: an object and
an output stream. (For instance, <i>printer</i> can be <a 
href="clmse117.html#x144-683004r713">print</a>, prin1, <a 
href="clmse117.html#x144-683008r715">princ</a>, <a 
href="clmse117.html#x144-683006r714">pprint</a>,
<a 
href="clmse117.html#x144-686004r720">write-char</a>, <a 
href="clmse117.html#x144-687002r721">write-string</a>, or <a 
href="clmse117.html#x144-687004r722">write-line</a>.) If omitted, <i>printer</i> defaults to
<a 
href="clmse117.html#x144-683004r713">print</a>. The value <a 
href="clmse31.html#x42-87002r20">t</a> is returned. The ﬁle is correctly closed, even if an abort
occurs.
</div>
<div class=defun>
<!--l. 1064--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1508001"></a><a 
 id="x193-1508002r1111"></a><b> collect-fn</b>  <i>type</i> <i>init</i> <i>function</i> &#x0026;rest  <i>series-inputs</i>
<!--l. 1066--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15090001111"></a></span>
   The higher-order function <a 
href="#x193-1131002r1111">collect-fn</a> supports the general concept of
collecting. It is identical to <a 
href="#x193-1108002r1081">collecting-fn</a> except that it returns only the last
element of each series computed. If there are no elements in these series, the
values returned by <i>init</i> are passed on directly as the output of <a 
href="#x193-1131002r1111">collect-fn</a>. <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-fn &#x2019;integer #&#x2019;(lambda () 0) #&#x2019;+ #Z(1 2 3))  ⇒ 6
</td></tr></table>
<!--l. 1073--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-fn &#x2019;integer #&#x2019;(lambda () 0) #&#x2019;+ #Z())  ⇒ 0</td></tr></table>
<!--l. 1074--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-fn &#x2019;integer #&#x2019;(lambda () 1) #&#x2019;* #Z(1 2 3 4 5))  ⇒ 120</td></tr></table>
<!--l. 1076--><p class="indent" >
</div>
</div>
</div>
<!--l. 1079--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.6   </span> <a 
 id="x193-1510000A.2.6"></a>Alteration of Series</h4>
<!--l. 1081--><p class="noindent" >Series that come from scanning data structures such as lists and vectors are
closely linked to these structures. The function <a 
href="#x193-1133002r1112">alter</a> can be used to modify the
underlying data structure with reference to the series derived from it. (Conversely,
it is possible to modify a series by destructively modifying the data structure it is
derived from. However, given the lazy evaluation nature of series, the eﬀects of
such modiﬁcations can be very hard to predict. As a result, this kind of
modiﬁcation is inadvisable.)
<div class=defun>
<!--l. 1090--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1510001"></a><a 
 id="x193-1510002r1112"></a><b> alter</b>  <i>destinations</i> <i>items</i>
<!--l. 1092--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15110001112"></a></span>
   <a 
href="#x193-1133002r1112">alter</a> changes the series <i>destinations</i> so that it contains the elements in the
series <i>items</i>. More importantly, in the manner of <a 
href="clmse36.html#x48-142002r66">setf</a>, the data structure that
underlies destinations is changed so that if the series <i>destinations</i> were to be
regenerated, the new values would be obtained. The alteration process stops as
soon as either input runs out of elements. The value <a 
href="clmse31.html#x42-86002r19">nil</a> is always returned. In the
example below each negative element in a list is replaced with its square. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let* ((data (list 1 -2 3 4 -5 6))
</td></tr></table>
<!--l. 1102--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (x (choose-if #&#x2019;minusp (scan data))))</td></tr></table>
<!--l. 1103--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (alter x (#M* x x))</td></tr></table>
                                                                          

                                                                          
<!--l. 1104--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  data)</td></tr></table>
<!--l. 1105--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ (1 4 3 4 25 6)</td></tr></table>
<!--l. 1107--><p class="indent" >
</div>
</div>
<!--l. 1109--><p class="indent" >   <a 
href="#x193-1133002r1112">alter</a> can be applied only to series that are <i>alterable</i>. <a 
href="#x193-1091004r1061">scan</a>, <a 
href="#x193-1095002r1066">scan-alist</a>,
<a 
href="#x193-1093002r1063">scan-multiple</a>, <a 
href="#x193-1095004r1067">scan-plist</a>, and scan-lists-of-lists-fringe produce alterable series.
However, the alterability of the output of scan-lists-of-lists-fringe is incomplete. If
scan-lists-of-lists-fringe is applied to an object that is a leaf, altering the output
series does not change the object.
<!--l. 1120--><p class="indent" >   In general, the output of a transducer is alterable as long as the elements of
the output come directly from the elements of an input that is alterable. In
particular, the outputs of <a 
href="#x193-1110002r1082">choose</a>, <a 
href="#x193-1110004r1083">choose-if</a>, <a 
href="#x193-1112002r1085">split</a>, <a 
href="#x193-1112004r1086">split-if</a>, <a 
href="#x193-1105002r1076">cotruncate</a>, <a 
href="#x193-1105004r1077">until</a>,
<a 
href="#x193-1105006r1078">until-if</a>, and <a 
href="#x193-1114002r1088">subseries</a> are alterable as long as the corresponding inputs are
alterable.
</div>
<div class=defun>
<!--l. 1129--><p class="noindent" ><i>[Function]</i><a 
 id="dx193-1511001"></a><a 
 id="x193-1511002r1113"></a><b> to-alter</b>  <i>items</i> <i>alter-fn</i> &#x0026;rest  <i>args</i>
<!--l. 1131--><p class="noindent" ><span class="paragraphHead"><a 
 id="x193-15120001113"></a></span>
   Given a series <i>items</i>, <a 
href="#x193-1134002r1113">to-alter</a> returns an alterable series A containing the same
elements. The argument <i>alter-fn</i> is a function. The remaining arguments are all
series. Let these series be <i>S1</i>, … , <i>Sn</i>. If there are <i>n</i> arguments after <i>alter-fn</i>,
<i>alter-fn</i> must accept <i>n</i> + 1 inputs. If (alter <i>A</i> <i>B</i>) is later encountered, the
expression (map-fn t <i>alter-fn</i> <i>B</i> <i>S1</i> ... <i>Sn</i>) is implicitly evaluated. For each
element in <i>B</i>, <i>alter-fn</i> should make appropriate changes in the data structure
underlying <i>A</i>.
<!--l. 1143--><p class="indent" >   As an example, consider the following deﬁnition of a series function that scans
the elements of a list. Alteration is performed by changing cons cells in the list
being scanned. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun scan-list (list)
</td></tr></table>
<!--l. 1147--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (optimizable-series-function))</td></tr></table>
<!--l. 1148--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((sublists (scan-sublists list)))</td></tr></table>
<!--l. 1149--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (to-alter (#Mcar sublists)</td></tr></table>
                                                                          

                                                                          
<!--l. 1150--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              #&#x2019;(lambda (new parent) (setf (car parent) new))</td></tr></table>
<!--l. 1151--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              sublists)))</td></tr></table>
<!--l. 1153--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
   <!--l. 1156--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse159.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse157.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse157.html#tailclmse157.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse158.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmap1.html#clmse158.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 1156--><p class="indent" >   <a 
 id="tailclmse158.html"></a>   
</body></html> 
