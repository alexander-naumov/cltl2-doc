<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Уточняющие спецификаторы типов</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1125--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse23.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse21.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse21.html#tailclmse21.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse22.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch4.html#clmse22.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">4.5   </span> <a 
href="clm.html#QQ2-31-168" id="x31-1610004.5">Уточняющие
спецификаторы типов</a></h3>
<!--l. 1128--><p class="noindent" >Некоторые списки, представляющие типы, с помощью символов могут быть
более специализированы. Такие подробности могут быть отражены, как
более эффективная реализация. Например, предположим что <tt>(array
short-float)</tt>. Реализация A, может выбрать специализированное
представление для массива коротких с плавающей точкой, а реализация B
может выбрать более общее представление.
<!--l. 1134--><p class="indent" >   Если вы хотите создать массив в целях хранения только коротких с
плавающей точкой, вы можете опционально указать для <tt><a 
href="clmse90.html#x112-1460002r518">make-array</a></tt> тип
элементов <tt>short-float</tt>. Это <i>не потребует</i> от <tt><a 
href="clmse90.html#x112-1460002r518">make-array</a></tt> создать
объект типа <tt>(array short-float)</tt>, но это просто позволит ей выбрать
родственный тип. Запрос можно объяснить так: «Предоставь наиболее
специализированный массив, который может хранить короткие с плавающей
точкой, который только может предоставить реализация». Реализация A
тогда предоставит специализированный массив типа <tt>(array short-float)</tt>, а
реализация B — простой массив типа <tt>(array t)</tt>.
<!--l. 1143--><p class="indent" >   На вопрос, действительно ли тип созданного массива <tt>(array short-float)</tt>,
реализация A ответит «да», но реализация B ответит «нет». Это свойство
<tt><a 
href="clmse90.html#x112-1460002r518">make-array</a></tt> и подобных ей функций: то, что вы просите, необязательно
является тем, что вы получите.
<div class="new">
<!--l. 1149--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx31-161001"></a>to eliminate the diﬀering treatment of types
when used “for discrimination” rather than “for declaration” on the grounds that
implementors have not treated the distinction consistently and (which is more
important) users have found the distinction confusing.
<!--l. 1156--><p class="indent" >   As a consequence of this change, the behavior of <tt><a 
href="clmse32.html#x43-316002r20">typep</a></tt> and <tt><a 
href="clmse32.html#x43-319002r21">subtypep</a></tt> on
<tt>array</tt> and <tt><a 
href="clmse68.html#x85-1068002r253">complex</a></tt> type speciﬁers must be modiﬁed. See the descriptions of
those functions. In particular, under their new behavior, implementation
B would say “yes,” agreeing with implementation A, in the discussion
above.
<!--l. 1162--><p class="indent" >   Note that the distinction between declaration and discrimination remains
useful, if only so that we may remark that the specialized (list) form of the
                                                                          

                                                                          
<tt><a 
href="clmse35.html#x47-433005r52">function</a></tt> type speciﬁer may still be used only for declaration and not for
discrimination.
</div>
<div class="new">
<!--l. 1170--><p class="indent" >   X3J13 voted in June 1988 <a 
 id="dx31-161002"></a>to clarify that while the specialized form
of the <tt><a 
href="clmse35.html#x47-433005r52">function</a></tt> type speciﬁer (a list of the symbol <tt><a 
href="clmse35.html#x47-433005r52">function</a></tt> possibly
followed by argument and value type speciﬁers) may be used only for
declaration, the symbol form (simply the name <tt><a 
href="clmse35.html#x47-433005r52">function</a></tt>) may be used for
discrimination.
</div>
<!--l. 1178--><p class="indent" >   Далее перечислены возможные имена типов, которые задаются
списком:
<div class="flushdesc">
<!--l. 1181--><p class="indent" >
      <ul><li><b>
<tt>(array <i>element-type</i> <i>size</i>)</tt> </b></li>Такая запись обозначает множество
      специализированных массивов, элементы которых принадлежат типу
      <i>element-type</i> и размер которых равен <i>size</i>. <i>element-type</i> должен быть
      корректным спецификатором типа или не уточнён с помощью
      <tt>*</tt>. <i>size</i> может быть неотрицательным целым, определяющим
      размер массива, может быть списком неотрицательных целых,
      определяющих размер каждого измерения (размер какого-либо
      измерения может быть не указан, <tt>*</tt>) или может быть не указан <tt>*</tt>.
      Например, <div class="lisp"><div class="tabbing">
      (array integer 3)           ;Трёхэлементный массив целых
      <br>                 (array integer (* * *))     ;Трёхмерный массив целых<br>
           (array * (4 5 6))           ;Трёхмерный массив, размеры измерений 4,5,6<br>
           (array character (3 *))     ;Двумерный массив символов<br>
                                       ; у которого только три строки<br>
           (array short-ﬂoat ())      ;Ранг массива равен нулю, массив содержит<br>
                                       ; короткие с плавающие точкой<br>
      <!--l. 1200--><p class="noindent" ></div>
                                                                          

                                                                          
      <!--l. 1200--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1620004.5" id="x31-1620004.5"></a></span>
      <!--l. 1200--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1630004.5" id="x31-1630004.5"></a></span>
</div>
      <!--l. 1201--><p class="noindent" >Следует отметить, что <tt>(array t)</tt> является правильным подмножеством
      <tt>(array *)</tt>. Причиной тому является то. что <tt>(array t)</tt> это множество
      массивов, которые могут содержать любой Common Lisp объект
      (элементы типа <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt>, которые включают все элементы). С другой
      стороны, <tt>(array *)</tt> является множеством всех массивов, включая,
      например, массивы, которые могут хранить только строковые
      символы. Сейчас <tt>(array character)</tt> не является подмножеством
      <tt>(array t)</tt>; два множества фактически непересекаются, потому
      что <tt>(array character)</tt> не является множеством всех массивов,
      которые могут хранить строковые символы, а является множеством
      массивов, которые специализированы хранить именно символы и
      никакие другие объекты FIXME. Поэтому проверка, может ли
      массив <tt>foo</tt> хранить строковые символы, не может быть такой:
      <div class="lisp"><div class="tabbing">
      (typep foo &#x2019;(array character))
      <br>
      <!--l. 1215--><p class="noindent" ></div>
      <!--l. 1215--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1640004.5" id="x31-1640004.5"></a></span>
      <!--l. 1215--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1650004.5" id="x31-1650004.5"></a></span>
</div>
      <!--l. 1216--><p class="noindent" >, а должна быть такой: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
      (subtypep &#x2019;character (array-element-type foo))
      <br>
      <!--l. 1219--><p class="noindent" ></div>
      <!--l. 1219--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1660004.5" id="x31-1660004.5"></a></span>
      <!--l. 1219--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1670004.5" id="x31-1670004.5"></a></span>
</div>
      <!--l. 1220--><p class="noindent" >Смотрите <tt><a 
href="clmse92.html#x114-1479002r525">array-element-type</a></tt>. <div class="new"> X3J13 voted in January 1989 <a 
 id="dx31-167001"></a>to change
      <tt><a 
href="clmse32.html#x43-316002r20">typep</a></tt> and <tt><a 
href="clmse32.html#x43-319002r21">subtypep</a></tt> so that the specialized <tt>array</tt> type speciﬁer means the
      same thing for discrimination as for declaration: it encompasses those
      arrays that can result by specifying <i>element-type</i> as the element
      type to the function <tt><a 
href="clmse90.html#x112-1460002r518">make-array</a></tt>. Under this interpretation <tt>(array
      character)</tt> might be the same type as <tt>(array t)</tt> (although it also might
      not be the same). See <tt><a 
href="clmse27.html#x36-217002r9">upgraded-array-element-type</a></tt>. However,
      <div class="lisp"><div class="tabbing">
      (typep foo &#x2019;(array character))
      <br>
      <!--l. 1237--><p class="noindent" ></div>
      <!--l. 1237--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1680004.5" id="x31-1680004.5"></a></span>
                                                                          

                                                                          
      <!--l. 1237--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1690004.5" id="x31-1690004.5"></a></span>
</div>
      <!--l. 1238--><p class="noindent" >is still not a legitimate test of whether the array <tt>foo</tt> can hold a character;
      one must still say <div class="lisp"><div class="tabbing">
      (subtypep &#x2019;character (array-element-type foo))
      <br>
      <!--l. 1242--><p class="noindent" ></div>
      <!--l. 1242--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1700004.5" id="x31-1700004.5"></a></span>
      <!--l. 1242--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1710004.5" id="x31-1710004.5"></a></span>
</div>
      <!--l. 1243--><p class="noindent" >to determine that question.
      <!--l. 1245--><p class="noindent" >X3J13 also voted in January 1989 <a 
 id="dx31-171001"></a>to specify that within the lexical scope of
      an array type declaration, it is an error for an array element, when
      referenced, not to be of the exact declared element type. A compiler may, for
      example, treat every reference to an element of a declared array as if the
      reference were surrounded by a <tt><a 
href="clmse52.html#x66-851002r143">the</a></tt> form mentioning the declared
      array element type (<i>not</i> the upgraded array element type). Thus
      <div class="lisp"><div class="tabbing">
      (defun snarf-hex-digits (the-array)
      <br>                     (declare (type (array (unsigned-byte 4) 1) the-array))<br>
             (do ((j (- (length array) 1) (- j 1))<br>
                  (val 0 (logior (ash val 4)<br>
                                 (aref the-array j))))<br>
                 ((&#x003C; j 0) val)))<br>
      <!--l. 1260--><p class="noindent" ></div>
                                                                          

                                                                          
      <!--l. 1260--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1720004.5" id="x31-1720004.5"></a></span>
      <!--l. 1260--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1730004.5" id="x31-1730004.5"></a></span>
</div>
      <!--l. 1261--><p class="noindent" >may be treated as <div class="lisp"><div class="tabbing">
      (defun snarf-hex-digits (the-array)
      <br>                     (declare (type (array (unsigned-byte 4) 1) the-array))<br>
             (do ((j (- (length array) 1) (- j 1))<br>
                  (val 0 (logior (ash val 4)<br>
                                 (the (unsigned-byte 4)<br>
                                      (aref the-array j)))))<br>
                 ((&#x003C; j 0) val)))<br>
      <!--l. 1270--><p class="noindent" ></div>
      <!--l. 1270--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1740004.5" id="x31-1740004.5"></a></span>
      <!--l. 1270--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1750004.5" id="x31-1750004.5"></a></span>
</div>
      <!--l. 1271--><p class="noindent" >The declaration amounts to a promise by the user that the <tt><a 
href="clmse91.html#x113-1472002r523">aref</a></tt> will never
      produce a value outside the interval 0 to 15, even if in that particular
      implementation the array element type <tt>(unsigned-byte 4)</tt> is upgraded to,
      say, <tt>(unsigned-byte 8)</tt>. If such upgrading does occur, then values outside
      that range may in fact be stored in <tt>the-array</tt>, as long as the code in
      <tt>snarf-hex-digits</tt> never sees them.
      <!--l. 1279--><p class="noindent" >As a general rule, a compiler would be justiﬁed in transforming
      <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
      (aref (the (array <i>elt-type</i> ...) <i>a</i>) ...)
      <br>
      <!--l. 1282--><p class="noindent" ></div>
      <!--l. 1282--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1760004.5" id="x31-1760004.5"></a></span>
      <!--l. 1282--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1770004.5" id="x31-1770004.5"></a></span>
</div>
      <!--l. 1283--><p class="noindent" >into <div class="lisp"><div class="tabbing">
      (the <i>elt-type</i> (aref (the (array <i>elt-type</i> ...) <i>a</i>) ...)
      <br>
      <!--l. 1286--><p class="noindent" ></div>
      <!--l. 1286--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1780004.5" id="x31-1780004.5"></a></span>
      <!--l. 1286--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1790004.5" id="x31-1790004.5"></a></span>
</div>
      <!--l. 1287--><p class="noindent" >It may also make inferences involving more complex functions, such as
      <tt><a 
href="clmse80.html#x99-1240002r399">position</a></tt> or <tt><a 
href="clmse80.html#x99-1239002r396">find</a></tt>. For example, <tt><a 
href="clmse80.html#x99-1239002r396">find</a></tt> applied to an array always
      returns either <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> or an object whose type is the element type of the
      array.
      </div>
<div class="new">
                                                                          

                                                                          
      <!--l. 1294--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx31-179001"></a>to change <tt><a 
href="clmse32.html#x43-316002r20">typep</a></tt> and <tt><a 
href="clmse32.html#x43-319002r21">subtypep</a></tt> so that the
      specialized <tt>array</tt> type speciﬁer means the same thing for discrimination
      as for declaration: it encompasses those arrays that can result by
      specifying <i>element-type</i> as the element type to the function <tt><a 
href="clmse90.html#x112-1460002r518">make-array</a></tt>.
      Under this interpretation <tt>(array character)</tt> might be the same
      type as <tt>(array t)</tt> (although it also might not be the same). See
      <tt><a 
href="clmse27.html#x36-217002r9">upgraded-array-element-type</a></tt>. However, <div class="lisp"><div class="tabbing">
      (typep foo &#x2019;(array character))
      <br>
      <!--l. 1309--><p class="noindent" ></div>
      <!--l. 1309--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1800004.5" id="x31-1800004.5"></a></span>
      <!--l. 1309--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1810004.5" id="x31-1810004.5"></a></span>
</div>
      <!--l. 1310--><p class="noindent" >is still not a legitimate test of whether the array <tt>foo</tt> can hold a character;
      one must still say <div class="lisp"><div class="tabbing">
      (subtypep &#x2019;character (array-element-type foo))
      <br>
      <!--l. 1314--><p class="noindent" ></div>
      <!--l. 1314--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1820004.5" id="x31-1820004.5"></a></span>
                                                                          

                                                                          
      <!--l. 1314--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1830004.5" id="x31-1830004.5"></a></span>
</div>
      <!--l. 1315--><p class="noindent" >to determine that question.
      <!--l. 1317--><p class="noindent" >As a general rule, a compiler would be justiﬁed in transforming
      <div class="lisp"><div class="tabbing">
      (aref (the (array <i>elt-type</i> ...) <i>a</i>) ...)
      <br>
      <!--l. 1320--><p class="noindent" ></div>
      <!--l. 1320--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1840004.5" id="x31-1840004.5"></a></span>
      <!--l. 1320--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1850004.5" id="x31-1850004.5"></a></span>
</div>
      <!--l. 1321--><p class="noindent" >into <div class="lisp"><div class="tabbing">
      (the <i>elt-type</i> (aref (the (array <i>elt-type</i> ...) <i>a</i>) ...)
      <br>
      <!--l. 1324--><p class="noindent" ></div>
      <!--l. 1324--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1860004.5" id="x31-1860004.5"></a></span>
                                                                          

                                                                          
      <!--l. 1324--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1870004.5" id="x31-1870004.5"></a></span>
</div>
      <!--l. 1325--><p class="noindent" >It may also make inferences involving more complex functions, such as
      <tt><a 
href="clmse80.html#x99-1240002r399">position</a></tt> or <tt><a 
href="clmse80.html#x99-1239002r396">find</a></tt>. For example, <tt><a 
href="clmse80.html#x99-1239002r396">find</a></tt> applied to an array always
      returns either <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> or an object whose type is the element type of the
      array.
      </div>
      <li><b>
<tt>(simple-array <i>element-type</i> <i>sizes</i>)</tt> </b></li>Данная запись эквивалентна <tt>(array
      <i>element-type</i> <i>sizes</i>)</tt> за исключением того, что дополнительно
      определяет, что объекты будут <i>простыми</i> массивами (смотрите
      раздел <a 
href="clmse7.html#x14-950002.5">2.5<!--tex4ht:ref: ARRAY-TYPE-SECTION --></a>).
      <li><b>
<tt>(vector <i>element-type</i> <i>size</i>)</tt> </b></li>Такой тип обозначает множество
      специализированный одномерных массивов, все элементы которых
      принадлежат типу <tt>element-type</tt> и size которого равен <tt>size</tt>. Такой тип
      полностью эквивалентен <tt>(array <i>element-type</i> (<i>size</i>))</tt>. Например:
      <div class="lisp"><div class="tabbing">
      (vector double-ﬂoat)     ;Векторы двойных
      <br>                                      ; чисел с плавающей точкой<br>
           (vector * 5)              ;Векторы длинной пять элементов<br>
           (vector t 5)              ;Общие векторы длинной пять элементов FIXME<br>
           (vector (mod 32) *)       ;Вектора целых чисел между 0 и 31<br>
      <!--l. 1348--><p class="noindent" ></div>
      <!--l. 1348--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1880004.5" id="x31-1880004.5"></a></span>
                                                                          

                                                                          
      <!--l. 1348--><p class="noindent" ><span class="paragraphHead"><a 
href="#x31-1890004.5" id="x31-1890004.5"></a></span>
</div>
      <!--l. 1350--><p class="noindent" >Тип <tt><a 
href="clmse98.html#x121-1556002r578">string</a></tt> является объединение одно или более специализированных
      типов векторов, а именно всех векторов, тип элементов которых
      является подтипом <tt><a 
href="clmse76.html#x94-1173002r358">character</a></tt>.
      <li><b>
<tt>(simple-vector <i>size</i>)</tt> </b></li>Такая запись означает то же, что и <tt>(vector t
      <i>size</i>)</tt>.
      <li><b>
<tt>(complex <i>type</i>)</tt> </b></li>Каждый элемент такого типа является комплексным
      числом, у которого действительная и мнимая части принадлежат типу
      <i>type</i>. For declaration purposes, this type encompasses those complex
      numbers that can result by giving numbers of the speciﬁed type to the
      function <tt><a 
href="clmse68.html#x85-1068002r253">complex</a></tt>; this may be diﬀerent from what the type means for
      discrimination purposes. As an example, Gaussian integers might be
      described as <tt>(complex integer)</tt>, even in implementations where giving two
      integers to the function <tt><a 
href="clmse68.html#x85-1068002r253">complex</a></tt> results in an object of type <tt>(complex
      rational)</tt>.
<div class="new">
      <!--l. 1369--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx31-189001"></a>to change <tt><a 
href="clmse32.html#x43-316002r20">typep</a></tt> and <tt><a 
href="clmse32.html#x43-319002r21">subtypep</a></tt> so that the
      specialized <tt><a 
href="clmse68.html#x85-1068002r253">complex</a></tt> type speciﬁer means the same thing for discrimination
      purposes as for declaration purposes. See <tt><a 
href="clmse27.html#x36-220002r10">upgraded-complex-part-type</a></tt>.
      </div>
      <li><b>
<tt>(function (<i>argument-type-1</i> <i>argument-type-2</i> ...) <i>value-type</i>)</tt> </b></li>Этот
      тип может использоваться только для декларации и не может для
      распознавания; <tt><a 
href="clmse32.html#x43-316002r20">typep</a></tt> будет сигнализировать ошибку, если ей
      будет передан такой спецификатор типа. Каждый элемент такого
      типа является функцией, которая принимает аргументы типов
      перечисленных с помощью форм <i>argument-type-j</i> и возвращает значение
      типа <i>value-type</i>. В форме типов аргументов могут использоваться
      маркеры <tt>&#x0026;optional</tt>, <tt>&#x0026;rest</tt> и <tt>&#x0026;key</tt>. <i>value-type</i> может быть
      спецификатором типа <tt><a 
href="clmse43.html#x55-707002r111">values</a></tt> в случае, если функция возвращает
      несколько значений.
                                                                          

                                                                          
      <li><b>
<tt>(values <i>value-type-1</i> <i>value-type-2</i> ...)</tt> </b></li>Данный тип используется
      только в двух случаях: только как <i>value-type</i> для спецификатора типа
      <i>функции</i> и в специальной форме <tt><a 
href="clmse52.html#x66-851002r143">the</a></tt>. Данный спецификатор
      используется для задания типов в случаях возврата нескольких
      значений. В списке с типами могут использоваться маркеры <tt>&#x0026;optional</tt>,
      <tt>&#x0026;rest</tt> и <tt>&#x0026;key</tt>.</ul>
</div>
                                                                          

                                                                          
<!--l. 1398--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse23.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse21.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse21.html#tailclmse21.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse22.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch4.html#clmse22.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse22.html"></a>   </div> </div> 
</body></html> 
