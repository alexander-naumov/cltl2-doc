<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Константы и переменные</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 4453--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse36.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#tailclmch7.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse35.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse35.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">7.1   </span> <a 
href="clm.html#QQ2-47-433" id="x47-4250007.1">Константы и
переменные</a></h3>
<!--l. 4456--><p class="noindent" >Так как некоторые Lisp&#x2019;овые объекты данных используются для отображения
программ, можно всегда обозначить константный объект данных
с помощью записи без приукрашательств формы данного объекта.
Однако порождается двусмысленность: константный это объект или
фрагмент кода. Эту двусмысленность разрешает специальная форма
<tt><a 
href="#x47-426002r51">quote</a></tt>.
<!--l. 4462--><p class="indent" >   В Common Lisp&#x2019;е присутствуют два вида переменных, а именно: обычные
                                                                          

                                                                          
переменные и имена функций. Между этими типами есть несколько сходств,
и в некоторых случаях для взаимодействия с ними используются похожие
функции, например <tt><a 
href="#x47-457002r56">boundp</a></tt> и <tt><a 
href="#x47-458002r57">fboundp</a></tt>. Однако для в большинстве случаев
два вида переменных используются для совсем разных целей: один указывает
на функции, макросы и специальные формы, и другие на объекты
данных.
<div class="newer">
<!--l. 4471--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-425001"></a>to introduce the concept of a <i>function-name</i>,
which may be either a symbol or a two-element list whose ﬁrst element is the
symbol <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> and whose second element is a symbol. The primary purpose of this
is to allow <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> expander functions to be CLOS generic functions with
user-deﬁned methods. Many places in Common Lisp that used to require a symbol
for a function name are changed to allow 2-lists as well; for example, <tt><a 
href="clmse30.html#x40-261002r13">defun</a></tt>
is changed so that one may write <tt>(defun (setf foo) ...)</tt>, and the
<tt><a 
href="#x47-433005r52">function</a></tt> special operator is changed to accept any function-name. See also
<tt><a 
href="#x47-456003r55">fdefinition</a></tt>.
<!--l. 4482--><p class="indent" >   By convention, any function named <tt>(setf <i>f</i>)</tt> should return its ﬁrst argument
as its only value, in order to preserve the speciﬁcation that <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> returns its
<i>newvalue</i>. See <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>.
<!--l. 4486--><p class="indent" >   Implementations are free to extend the syntax of function-names to include
lists beginning with additional symbols other than <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> or <tt><a 
href="clmse123.html#x152-2249002r780">lambda</a></tt>.
</div>
<!--l. 4491--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.1.1   </span> <a 
href="clmli1.html#QQ2-47-434" id="x47-4260007.1.1">Ссылки на переменные</a></h4>
<!--l. 4493--><p class="noindent" >Значение обычной переменной может быть получено просто с помощью
записи его имени как формы, которая будет выполнена. Будет ли данное имя
распознано как имя специальной или лексической переменной зависит от
наличия или отсутствия соответствующей декларации <tt>special</tt>. Смотрите
главу <a 
href="clmch9.html#x63-8170009">9<!--tex4ht:ref: DECLAR --></a>.
<!--l. 4498--><p class="indent" >   Следующие функции и специальные формы позволяют ссылаться на
значения констант и переменных.
<div class="defspec">
<div class="defmacheader">
<!--l. 4502--><p class="indent" >   <div class="tabbing">
                                                                          

                                                                          
 <i>[Специальный оператор]</i><b> quote </b><a 
 id="dx47-426001"></a><a 
 id="x47-426002r51"></a> object
   <br>
<!--l. 4503--><p class="noindent" ></div>
<!--l. 4503--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4270007.1.1" id="x47-4270007.1.1"></a></span>
</div>
<tt>
<!--l. 4504--><p class="indent" >   (quote <i>x</i>)</tt> возвращает <i>x</i>. <i>object</i> не выполняется и может быть любым
объектом Lisp&#x2019;а. Конструкция позволяет записать в программе любой объект,
как константное значение. Например: <div class="lisp"><div class="tabbing">
(setq a 43)
   <br>                                                  (list a (cons a 3)) <span class="math"> ⇒</span> (43 (43 . 3))<br>
(list (quote a) (quote (cons a 3)) <span class="math"> ⇒</span> (a (cons a 3))<br>
<!--l. 4513--><p class="noindent" ></div>
<!--l. 4513--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4280007.1.1" id="x47-4280007.1.1"></a></span>
<!--l. 4513--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4290007.1.1" id="x47-4290007.1.1"></a></span>
</div>
<!--l. 4514--><p class="indent" >   Так как <tt><a 
href="#x47-426002r51">quote</a></tt> форма так полезна, но записывать её трудоёмко, для неё
определена стандартная аббревиатура: любая форма <i>f </i> с предшествующей
одинарной кавычкой (<tt> &#x2019; </tt>) оборачивается формой <tt>(quote  )</tt> для создания
<tt>(quote <i>f</i>)</tt>. Например: <div class="lisp"><div class="tabbing">
(setq x &#x2019;(the magic quote hack))
   <br>
<!--l. 4521--><p class="noindent" ></div>
<!--l. 4521--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4300007.1.1" id="x47-4300007.1.1"></a></span>
                                                                          

                                                                          
<!--l. 4521--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4310007.1.1" id="x47-4310007.1.1"></a></span>
</div>
<!--l. 4522--><p class="indent" >   обычно интерпретируется функцией <tt><a 
href="clmse112.html#x139-1882002r652">read</a></tt>, как <div class="lisp"><div class="tabbing">
(setq x (quote (the magic quote hack)))
   <br>
<!--l. 4525--><p class="noindent" ></div>
<!--l. 4525--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4320007.1.1" id="x47-4320007.1.1"></a></span>
<!--l. 4525--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4330007.1.1" id="x47-4330007.1.1"></a></span>
</div>
<!--l. 4526--><p class="indent" >   Смотрите раздел <a 
href="clmse111.html#x138-171800022.1.3">22.1.3<!--tex4ht:ref: MACRO-CHARACTERS-SECTION --></a>.
<!--l. 4529--><p class="indent" >   It is an error to destructively modify any object that appears as a constant in
executable code, whether within a <tt><a 
href="#x47-426002r51">quote</a></tt> special operator or as a self-evaluating
form.
<!--l. 4533--><p class="indent" >   See section <a 
href="clmse120.html#x149-217700024.1">24.1<!--tex4ht:ref: COMPILER-SECTION --></a> for a discussion of how quoted constants are treated by the
compiler.
<!--l. 4536--><p class="indent" >   Деструктивная модификация любого объекта, который представлен как
константа в выполняемом коде с помощью специального оператора <tt><a 
href="#x47-426002r51">quote</a></tt> или
как самовычисляемая форма, является ошибкой.
<!--l. 4540--><p class="indent" >   Смотрите раздел <a 
href="clmse120.html#x149-217700024.1">24.1<!--tex4ht:ref: COMPILER-SECTION --></a> для обсуждения того, как заквоченные константы
обрабатываются компилятором.
<div class="newer">
<!--l. 4544--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-433001"></a>to clarify that <tt><a 
href="clmse106.html#x131-1633002r580">eval</a></tt> and <tt><a 
href="clmse120.html#x149-2177002r736">compile</a></tt> are not
permitted either to copy or to coalesce (“collapse”) constants (see <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt>) appearing
in the code they process; the resulting program behavior must refer to
objects that are <tt><a 
href="clmse33.html#x44-402003r45">eql</a></tt> to the corresponding objects in the source code.
Moreover, the constraints introduced by the votes on issues <a 
 id="dx47-433002"></a>and <a 
 id="dx47-433003"></a>on what kinds
of objects may appear as constants apply only to <tt><a 
href="clmse120.html#x149-2180004r737">compile-file</a></tt> (see
section <a 
href="clmse120.html#x149-217700024.1">24.1<!--tex4ht:ref: COMPILER-SECTION --></a>).
</div>
</div>
<div class="defspec">
                                                                          

                                                                          
<div class="defmacheader">
<!--l. 4559--><p class="indent" >   <div class="tabbing">
 <i>[Специальный оператор]</i><b> function </b><a 
 id="dx47-433004"></a><a 
 id="x47-433005r52"></a> fn
   <br>
<!--l. 4560--><p class="noindent" ></div>
<!--l. 4560--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4340007.1.1" id="x47-4340007.1.1"></a></span>
</div>
<!--l. 4561--><p class="indent" >   Значением <tt><a 
href="#x47-433005r52">function</a></tt> всегда является функциональной интерпретацией <i>fn</i>.
<i>fn</i> интерпретируется как, если бы она была использована на позиции
функции в форме вызова функции. В частности, если <i>fn</i> является символом,
возвращается определение функции, связанное с этим символом, смотрите
<tt><a 
href="#x47-455002r54">symbol-function</a></tt>. Если <i>fn</i> является лямбда-выражением, тогда возвращается
«лексическое замыкание», это значит функция, которая при вызове
выполняет тело лямбда-выражения таким образом, чтобы правила
лексического контекста выполнялись правильно.
<div class="newer">
<!--l. 4572--><p class="indent" >   X3J13 voted in June 1988 <a 
 id="dx47-434001"></a>to specify that the result of a <tt><a 
href="#x47-433005r52">function</a></tt> special
operator is always of type <tt><a 
href="#x47-433005r52">function</a></tt>. This implies that a form <tt>(function <i>fn</i>)</tt>
may be interpreted as <tt>(the (function <i>fn</i>))</tt>.
<!--l. 4577--><p class="indent" >   It is an error to use the <tt><a 
href="#x47-433005r52">function</a></tt> special operator on a symbol that does not
denote a function in the lexical or global environment in which the special
operator appears. Speciﬁcally, it is an error to use the <tt><a 
href="#x47-433005r52">function</a></tt> special operator
on a symbol that denotes a macro or special operator. Some implementations may
choose not to signal this error for performance reasons, but implementations are
forbidden to extend the semantics of <tt><a 
href="#x47-433005r52">function</a></tt> in this respect; that is, an
implementation is not allowed to deﬁne the failure to signal an error to be a
“useful” behavior.
</div>
<!--l. 4588--><p class="indent" >   Функция <tt><a 
href="#x47-433005r52">function</a></tt> принимает любое имя функции (символ или
список, <i>car</i> элементы которого является <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>—смотрите раздел <a 
href="#x47-4250007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>)
Также принимает принимает лямбда-выражение. Так можно записать
<tt>(function (setf cadr))</tt> для ссылки на функцию раскрытия <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> для
<tt><a 
href="clmse82.html#x102-1273004r413">cadr</a></tt>.
                                                                          

                                                                          
<a 
 id="dx47-434002"></a>
<!--l. 4596--><p class="indent" >   Например: <div class="lisp"><div class="tabbing">
(defun adder (x) (function (lambda (y) (+ x y))))
   <br>
<!--l. 4599--><p class="noindent" ></div>
<!--l. 4599--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4350007.1.1" id="x47-4350007.1.1"></a></span>
<!--l. 4599--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4360007.1.1" id="x47-4360007.1.1"></a></span>
</div>
<!--l. 4600--><p class="indent" >   Результат <tt>(adder 3)</tt> является функцией, которая добавляет <tt>3</tt> к её
аргументу: <div class="lisp"><div class="tabbing">
(setq add3 (adder 3))
   <br>                                                                  (funcall add3 5) <span class="math"> ⇒</span> 8<br>
<!--l. 4605--><p class="noindent" ></div>
<!--l. 4605--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4370007.1.1" id="x47-4370007.1.1"></a></span>
<!--l. 4605--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4380007.1.1" id="x47-4380007.1.1"></a></span>
</div>
<!--l. 4606--><p class="indent" >   Это работает, потому что <tt><a 
href="#x47-433005r52">function</a></tt> создаёт замыкание над внутренним
лямбда-выражением, которое может ссылаться на значение <tt>3</tt> переменной <tt>x</tt>
даже после того, как выполнение вышло из функции <tt>adder</tt>.
<!--l. 4610--><p class="indent" >   Если посмотреть глубже, то лексическое замыкание обладает возможностью
ссылаться на лексически видимые <i>связывание</i>, а не просто на значения.
Рассмотрим такой код: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(defun two-funs (x)
   <br>                                                        (list (function (lambda () x))<br>
        (function (lambda (y) (setq x y)))))<br>       (setq funs (two-funs 6))<br>
(funcall (car funs)) <span class="math"> ⇒</span> 6<br>                    (funcall (cadr funs) 43) <span class="math"> ⇒</span> 43<br>
(funcall (car funs)) <span class="math"> ⇒</span> 43<br>
<!--l. 4621--><p class="noindent" ></div>
<!--l. 4621--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4390007.1.1" id="x47-4390007.1.1"></a></span>
<!--l. 4621--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4400007.1.1" id="x47-4400007.1.1"></a></span>
</div>
<!--l. 4622--><p class="indent" >   Функция <tt>two-funs</tt> возвращает список двух функций, каждая из которых
ссылается на <i>связывание</i> переменной <tt>x</tt>, созданной в момент входа в
функцию <tt>two-funs</tt>, когда она была вызвана с аргументом <tt>6</tt>. Это
связывание сначала имеет значение <tt>6</tt>, но <tt><a 
href="#x47-461002r59">setq</a></tt> может изменить связывание.
Лексическое замыкание для первого лямбда-выражения не является
«создаёт снимок» значения <tt>6</tt> для <tt>x</tt> при создании замыкания. Вторая
функция может использоваться для изменения связывания (на <tt>43</tt>
например), и это изменённое значение станет доступным в первой
функции.
<!--l. 4631--><p class="indent" >   В ситуации, когда замыкание лямбда-выражения над одним и тем же
множеством связываний может создаваться несколько раз, эти полученные
разные замыкания могут быть равны или не равны <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> в зависимости от
реализации. Например: <div class="lisp"><div class="tabbing">
(let ((x 5) (funs &#x2019;()))
   <br>                     (dotimes (j 10)<br>                       (push #&#x2019;(lambda (z)<br>
              (if (null z) (setq x 0) (+ x z)))<br>                    funs))<br>
  funs)<br>
<!--l. 4642--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 4642--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4410007.1.1" id="x47-4410007.1.1"></a></span>
<!--l. 4642--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4420007.1.1" id="x47-4420007.1.1"></a></span>
</div>
<!--l. 4643--><p class="indent" >   Результат данного выражения является списком десяти замыканий.
Каждое логически требует только связывания <tt>x</tt>. В любом случае это одно
и то же связывание, но десять замыканий могут быть равны или
не равны <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> друг другу. С другой стороны, результат выражения
<div class="lisp"><div class="tabbing">
(let ((funs &#x2019;()))
   <br>                                                                          (dotimes (j 10)<br>
    (let ((x 5))<br>                              (push (function (lambda (z)<br>
                        (if (null z) (setq x 0) (+ x z))))<br>
            funs)))<br>                                                funs)<br>
<!--l. 4656--><p class="noindent" ></div>
<!--l. 4656--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4430007.1.1" id="x47-4430007.1.1"></a></span>
<!--l. 4656--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4440007.1.1" id="x47-4440007.1.1"></a></span>
</div>
<!--l. 4657--><p class="indent" >   также является списком из десяти замыканий. Однако в этом случае, но
одна из пар замыканий не будет равна <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt>, потому что каждое замыкание
имеет своё связывание <tt>x</tt> отличное от другого. Связывания отличаются, так
как в замыкании используется <tt><a 
href="#x47-461002r59">setq</a></tt>.
<!--l. 4662--><p class="indent" >   Вопрос различного поведения важен, поэтому рассмотрим следующее
простое выражение: <div class="lisp"><div class="tabbing">
(let ((funs &#x2019;()))
   <br>                            (dotimes (j 10)<br>                              (let ((x 5))<br>
      (push (function (lambda (z) (+ x z)))<br>                     funs)))<br>
  funs)<br>
                                                                          

                                                                          
<!--l. 4670--><p class="noindent" ></div>
<!--l. 4670--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4450007.1.1" id="x47-4450007.1.1"></a></span>
<!--l. 4670--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4460007.1.1" id="x47-4460007.1.1"></a></span>
</div>
<!--l. 4671--><p class="indent" >   Результатом является десять замыканий, которые <i>могут</i> быть равны <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt>
попарно. Однако, можно подумать что связывания <tt>x</tt> для каждого замыкания
разные, так как создаются в цикле, но связывания не могут различаться,
потому что их значения идентичны и неизменяемы (иммутабельны), в
замыканиях отсутствует <tt><a 
href="#x47-461002r59">setq</a></tt> для <tt>x</tt>. Компилятор может в таких случаях
оптимизировать выражение так: <div class="lisp"><div class="tabbing">
(let ((funs &#x2019;()))
   <br>                                                                          (dotimes (j 10)<br>
    (push (function (lambda (z) (+ 5 z)))<br>                         funs))<br>
  funs)<br>
<!--l. 4683--><p class="noindent" ></div>
<!--l. 4683--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4470007.1.1" id="x47-4470007.1.1"></a></span>
<!--l. 4683--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4480007.1.1" id="x47-4480007.1.1"></a></span>
</div>
<!--l. 4684--><p class="indent" >   после чего, в конце концов, замыкания точно могут быть равны. Общее
правило такое, что реализация может в двух различных случаях выполнения
формы <tt><a 
href="#x47-433005r52">function</a></tt> вернуть идентичные (<tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt>) замыкания, если она может
доказать, что два концептуально различающихся замыкания по факту ведут
себя одинаково при одинаковых параметрах вызова. Это просто разрешается
для оптимизации. Полностью корректная реализация может каждый раз при
выполнении формы <tt><a 
href="#x47-433005r52">function</a></tt> возвращать новое замыкание не равное <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt>
другим.
<!--l. 4693--><p class="indent" >   Часто компилятор может сделать вывод, что замыкание по факту не
нуждается в замыкании над какими-либо связываниями переменных.
Например, в фрагменте кода <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(mapcar (function (lambda (x) (+ x 2))) y)
   <br>
<!--l. 4698--><p class="noindent" ></div>
<!--l. 4698--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4490007.1.1" id="x47-4490007.1.1"></a></span>
<!--l. 4698--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4500007.1.1" id="x47-4500007.1.1"></a></span>
</div>
<!--l. 4699--><p class="indent" >   функция <tt>(lambda (x) (+ x 2))</tt> не содержит ссылок на какие-либо
внешние сущности. В этом важном случае, одно и то же «замыкание» может
быть использовано в качестве результата всех выполнений специальной
формы <tt><a 
href="#x47-433005r52">function</a></tt>. Несомненно, данное значение может и не быть объектом
замыкания. Оно может быть просто скомпилированной функцией,
не содержащей информации об окружении. Данный пример просто
является частным случаем предыдущего разговора и включён в качестве
подсказки для разработчиков знакомых с предыдущими методами
реализации Lisp&#x2019;а. Различие между замыканиями и другими видами
функций слегка размыто, Common Lisp не определяет отображения
для замыканий и метода различия замыканий и простых функций.
Все что имеет значение, это соблюдение правил лексической области
видимости.
<!--l. 4712--><p class="indent" >   Так как форма <tt><a 
href="#x47-433005r52">function</a></tt> используются часто, но её запись длинная,
для неё определена стандартная аббревиатура: любая форма <i>f </i> с
предшествующими #&#x2019; разворачивается в форму <tt>(function <i>f</i>)</tt>. Например,
<div class="lisp"><div class="tabbing">
(remove-if #&#x2019;numberp &#x2019;(1 a b 3))
   <br>
<!--l. 4718--><p class="noindent" ></div>
<!--l. 4718--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4510007.1.1" id="x47-4510007.1.1"></a></span>
                                                                          

                                                                          
<!--l. 4718--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4520007.1.1" id="x47-4520007.1.1"></a></span>
</div>
<!--l. 4719--><p class="indent" >   обычно интерпретируется функцией <tt><a 
href="clmse112.html#x139-1882002r652">read</a></tt> как <div class="lisp"><div class="tabbing">
(remove-if (function numberp) &#x2019;(1 a b 3))
   <br>
<!--l. 4722--><p class="noindent" ></div>
<!--l. 4722--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4530007.1.1" id="x47-4530007.1.1"></a></span>
<!--l. 4722--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4540007.1.1" id="x47-4540007.1.1"></a></span>
</div>
<!--l. 4723--><p class="indent" >   Смотрите раздел <a 
href="clmse111.html#x138-175300022.1.4">22.1.4<!--tex4ht:ref: SHARP-SIGN-MACRO-CHARACTER-SECTION --></a>.
</div>
<div class="defun">
<!--l. 4726--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx47-454001"></a><a 
 id="x47-454002r53"></a><b> symbol-value</b>  <i>symbol</i>
</div>
<!--l. 4728--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4550007.1.1" id="x47-4550007.1.1"></a></span>
<tt>
   <a 
href="#x47-454002r53">symbol-value</a></tt> возвращает текущее значение динамической (специальной)
переменной с именем <i>symbol</i>. Если символ не имеет значения, возникает
ошибка. Смотрите <tt><a 
href="#x47-457002r56">boundp</a></tt> и <tt><a 
href="#x47-470002r62">makunbound</a></tt>. Следует отметить, что константные
символы являются переменными, которые не могут быть изменены, таким
образом <tt><a 
href="#x47-454002r53">symbol-value</a></tt> может использоваться для получения значения
именованной константы. <tt><a 
href="#x47-454002r53">symbol-value</a></tt> от ключевого символа будет
возвращать этот ключевой символ.
<tt>
<!--l. 4738--><p class="indent" >   <a 
href="#x47-454002r53">symbol-value</a></tt> не может получить доступ к значению лексической
переменной.
<!--l. 4740--><p class="indent" >   В частности, эта функция полезна для реализации интерпретаторов для
встраиваемых языков в Lisp&#x2019;е. Соответствующая функция присваивания <tt><a 
href="#x47-467002r61">set</a></tt>.
Кроме того, можно пользоваться конструкцией <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> с <tt><a 
href="#x47-454002r53">symbol-value</a></tt>.
</div>
                                                                          

                                                                          
<div class="defun">
<!--l. 4746--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx47-455001"></a><a 
 id="x47-455002r54"></a><b> symbol-function</b>  <i>symbol</i>
</div>
<!--l. 4748--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4560007.1.1" id="x47-4560007.1.1"></a></span>
<tt>
   <a 
href="#x47-455002r54">symbol-function</a></tt> возвращает текущее глобальное определение функции с
именем <i>symbol</i>. В случае если символ не имеет определения функции
сигнализируется ошибка, смотрите <tt><a 
href="#x47-458002r57">fboundp</a></tt>. Следует отметить что
определение может быть функцией или объектом отображающим
специальную форму или макрос. Однако, в последнем случае, попытка
вызова объекта как функции будет является ошибкой. Лучше всего заранее
проверить символ с помощью <tt><a 
href="clmse45.html#x58-753002r123">macro-function</a></tt> и <tt><a 
href="#x47-459002r58">special-operator-p</a></tt> и
только затем вызвать функциональное значение, если оба предыдущих теста
вернули ложь.
<!--l. 4759--><p class="indent" >   Эта функция полезна, в частности, для реализации интерпретаторов
языков встроенных в Lisp.
<tt>
<!--l. 4762--><p class="indent" >   <a 
href="#x47-455002r54">symbol-function</a></tt> не может получить доступ к значению имени
лексической функции, созданной с помощью <tt><a 
href="clmse39.html#x51-599002r82">flet</a></tt> или <tt><a 
href="clmse39.html#x51-600002r83">labels</a></tt>. Она может
получать только глобальное функциональное значение.
<!--l. 4766--><p class="indent" >   Глобальное определение функции для некоторого символа может быть
изменено с помощью <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> и <tt><a 
href="#x47-455002r54">symbol-function</a></tt>. При использовании этой
операции символ будет иметь <i>только</i> заданное определение в качестве
своего глобального функционального значения. Любое предыдущее
определение, было ли оно макросом или функцией, будет потеряно. Попытка
переопределения специальной формы (смотрите таблицу <a 
href="clmse28.html#x38-2260011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>) будет является
ошибкой.
<div class="newer">
<!--l. 4775--><p class="indent" >   X3J13 voted in June 1988 <a 
 id="dx47-456001"></a>to clarify the behavior of <tt><a 
href="#x47-455002r54">symbol-function</a></tt> in the
light of the redeﬁnition of the type <tt><a 
href="#x47-433005r52">function</a></tt>.
      <ul class="itemize1">
      <li class="itemize">It is permissible to call <tt><a 
href="#x47-455002r54">symbol-function</a></tt> on any symbol for which
      <tt><a 
href="#x47-458002r57">fboundp</a></tt> returns true. Note that <tt><a 
href="#x47-458002r57">fboundp</a></tt> must return true for a symbol
      naming a macro or a special operator.
      </li>
                                                                          

                                                                          
      <li class="itemize">If <tt><a 
href="#x47-458002r57">fboundp</a></tt> returns true for a symbol but the symbol denotes a macro
      or special operator, then the value returned by <tt><a 
href="#x47-455002r54">symbol-function</a></tt> is
      not well-deﬁned but <tt><a 
href="#x47-455002r54">symbol-function</a></tt> will not signal an error.
      </li>
      <li class="itemize">When <tt><a 
href="#x47-455002r54">symbol-function</a></tt> is used with <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> the new value must be of
      type <tt><a 
href="#x47-433005r52">function</a></tt>. It is an error to set the <tt><a 
href="#x47-455002r54">symbol-function</a></tt> of a symbol
      to a symbol, a list, or the value returned by <tt><a 
href="#x47-455002r54">symbol-function</a></tt> on the
      name of a macro or a special operator.</li></ul>
</div>
</div>
<div class="defun">
<!--l. 4797--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx47-456002"></a><a 
 id="x47-456003r55"></a><b> fdeﬁnition</b>  <i>function-name</i>
</div>
<!--l. 4799--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4570007.1.1" id="x47-4570007.1.1"></a></span>
   Функция похожа на <tt><a 
href="#x47-455002r54">symbol-function</a></tt> за исключением того, что её
аргументы может быть любым именем функции (символ или списка, у
которого <i>car</i> элемент равен <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>—смотрите раздел <a 
href="#x47-4250007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). Функция
возвращает текущее глобальное значение определения функции с именем
<i>function-name</i>. Можно использовать <tt><a 
href="#x47-456003r55">fdefinition</a></tt> вместе с <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> для
изменения глобального определения функции связанной с переданным в
параметре именем.
</div>
<div class="defun">
<!--l. 4809--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx47-457001"></a><a 
 id="x47-457002r56"></a><b> boundp</b>  <i>symbol</i>
</div>
<!--l. 4811--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4580007.1.1" id="x47-4580007.1.1"></a></span>
<tt>
   <a 
href="#x47-457002r56">boundp</a></tt> является истиной, если динамическая (специальная) переменная с
именем <i>symbol</i> имеет значение, иначе возвращает <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>.
<!--l. 4815--><p class="indent" >   Смотрите также <tt><a 
href="#x47-467002r61">set</a></tt> и <tt><a 
href="#x47-470002r62">makunbound</a></tt>.
</div>
<div class="defun">
<!--l. 4818--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx47-458001"></a><a 
 id="x47-458002r57"></a><b> fboundp</b>  <i>symbol</i>
</div>
                                                                          

                                                                          
<!--l. 4820--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4590007.1.1" id="x47-4590007.1.1"></a></span>
<tt>
   <a 
href="#x47-458002r57">fboundp</a></tt> является истиной, если символ имеет глобальное определение
функции. Следует отметить, что <tt><a 
href="#x47-458002r57">fboundp</a></tt> является истиной, если символ
указывает на специальную форму или макрос. <tt><a 
href="clmse45.html#x58-753002r123">macro-function</a></tt>
и <tt><a 
href="#x47-459002r58">special-operator-p</a></tt> могут использоваться для проверки таких
случаев.
<!--l. 4827--><p class="indent" >   Смотрите также <tt><a 
href="#x47-455002r54">symbol-function</a></tt> и <tt><a 
href="#x47-470004r63">fmakunbound</a></tt>.
<!--l. 4829--><p class="indent" >   Функция <tt><a 
href="#x47-458002r57">fboundp</a></tt> принимает любое имя функции (символ или список, <i>car</i>
элементы которого является <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>—смотрите раздел <a 
href="#x47-4250007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>) Так можно записать
<tt>(fboundp &#x2019;(setf cadr))</tt> для определения существует ли функция <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> для
<tt><a 
href="clmse82.html#x102-1273004r413">cadr</a></tt>.
</div>
<div class="defun">
<!--l. 4836--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx47-459001"></a><a 
 id="x47-459002r58"></a><b> special-operator-p</b>  <i>symbol</i>
</div>
<!--l. 4838--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4600007.1.1" id="x47-4600007.1.1"></a></span>
   Функция <tt><a 
href="#x47-459002r58">special-operator-p</a></tt> принимает символ. Если символ указывает
на специальную форму, тогда возвращается значение не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, иначе
возвращается <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. Возвращённое не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> значение является функцией,
которая может быть использована для интерпретации (вычисления)
специальной формы. FIXME
<!--l. 4845--><p class="indent" >   Возможно также то, что <i>обе</i> функции <tt><a 
href="#x47-459002r58">special-operator-p</a></tt> и
<tt><a 
href="clmse45.html#x58-753002r123">macro-function</a></tt> будут истинными для одного и того же символа. Это
потому, что реализация может иметь любой макрос как специальную
форму для скорости. С другой стороны, определение макроса должно
быть доступно для использования программами, которые понимают
только стандартные специальные формы, перечисленные в таблице <a 
href="clmse28.html#x38-2260011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>.
FIXME
</div>
<!--l. 4853--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.1.2   </span> <a 
href="clmli1.html#QQ2-47-469" id="x47-4610007.1.2">Присваивание</a></h4>
<!--l. 4855--><p class="noindent" >Следующая функциональность позволяет изменять значение переменной
(если быть точнее, значению соединённому с текущим связыванием
                                                                          

                                                                          
переменной). Такое изменение отличается от создания нового связывания.
Конструкции для создания новых связываний переменных описаны в
разделе <a 
href="clmse39.html#x51-5900007.5">7.5<!--tex4ht:ref: VAR-BINDING-SECTION --></a>.
<div class="defspec">
<div class="defmacheader">
<!--l. 4862--><p class="indent" >   <div class="tabbing">
 <i>[Специальный оператор]</i><b> setq </b><a 
 id="dx47-461001"></a><a 
 id="x47-461002r59"></a> {var form}*
   <br>
<!--l. 4863--><p class="noindent" ></div>
<!--l. 4863--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4620007.1.2" id="x47-4620007.1.2"></a></span>
</div>
<!--l. 4864--><p class="indent" >   Специальная форма <tt>(setq <i>var1</i> <i>form1</i> <i>var2</i> <i>form2</i> ...)</tt> является
«конструкцией присваивания простых переменных» Lisp&#x2019;а. Вычисляется
первая форма <i>form1</i> и результат сохраняется в переменной <i>var1</i>,
затем вычисляется <i>form2</i> и результат сохраняется в переменной <i>var2</i>,
и так далее. Переменные, конечно же, представлены символами, и
интерпретируются как ссылки к динамическим или статическим переменным
в соответствии с обычными правилами. Таким образов <tt><a 
href="#x47-461002r59">setq</a></tt> может быть
использована для присваивания как лексических, так и специальных
переменных.
<tt>
<!--l. 4874--><p class="indent" >   <a 
href="#x47-461002r59">setq</a></tt> возвращает последнее присваиваемое значение, другими словами,
результат вычисления последнего аргумента. В другом случае, форма <tt>(setq)</tt>
является корректной и возвращает <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. В форме должно быть чётное
количество форм аргументов. Например, в <div class="lisp"><div class="tabbing">
(setq x (+ 3 2 1) y (cons x nil))
   <br>
<!--l. 4881--><p class="noindent" ></div>
<!--l. 4881--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4630007.1.2" id="x47-4630007.1.2"></a></span>
                                                                          

                                                                          
<!--l. 4881--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4640007.1.2" id="x47-4640007.1.2"></a></span>
</div>
<tt>
<!--l. 4882--><p class="indent" >   x</tt> устанавливается в <tt>6</tt>, <tt>y</tt> в <tt>(6)</tt>, и <tt><a 
href="#x47-461002r59">setq</a></tt> возвращает <tt>(6)</tt>. Следует отметить,
что первое присваивание выполняется перед тем, как будет выполнено
второе, тем самым каждое следующее присваивание может использовать
значение предыдущих.
<!--l. 4887--><p class="indent" >   Смотрите также описание <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>, «общая конструкция присваивания»
Common Lisp&#x2019;а, которая позволяет присваивать значения переменным,
элементам массива, и другим местам.
<!--l. 4891--><p class="indent" >   Некоторые программисты выбирают путь отречения от <tt><a 
href="#x47-461002r59">setq</a></tt>, и всегда
используют <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>. Другие используют <tt><a 
href="#x47-461002r59">setq</a></tt> для простых переменных и <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>
для всех остальных.
<!--l. 4895--><p class="indent" >   Если любая <i>var</i> ссылается не на обычную переменную, а на связывание
сделанное с помощью <tt><a 
href="clmse39.html#x51-610005r85">symbol-macrolet</a></tt>, тогда <i>var</i> обрабатывается как если
<tt><a 
href="clmse36.html#x48-503002r65">psetf</a></tt> использовалось вместо <tt><a 
href="#x47-461002r59">setq</a></tt>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 4901--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> psetq </b><a 
 id="dx47-464001"></a><a 
 id="x47-464002r60"></a> {var form}*
   <br>
<!--l. 4902--><p class="noindent" ></div>
<!--l. 4902--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4650007.1.2" id="x47-4650007.1.2"></a></span>
</div>
<!--l. 4903--><p class="indent" >   Форма <tt><a 
href="#x47-464002r60">psetq</a></tt> похожа на форму <tt><a 
href="#x47-461002r59">setq</a></tt> за исключением того, что выполняет
присваивание параллельно. Сначала выполняются все формы, а затем
переменные получают значения этих форм. Значение формы <tt><a 
href="#x47-464002r60">psetq</a></tt> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>.
Например: <div class="lisp"><div class="tabbing">
(setq a 1)
                                                                          

                                                                          
   <br>                                                                                  (setq b 2)<br>
(psetq a b b a)<br>                                                     a <span class="math"> ⇒</span> 2<br>
b <span class="math"> ⇒</span> 1<br>
<!--l. 4913--><p class="noindent" ></div>
<!--l. 4913--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4660007.1.2" id="x47-4660007.1.2"></a></span>
<!--l. 4913--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4670007.1.2" id="x47-4670007.1.2"></a></span>
</div>
<!--l. 4914--><p class="indent" >   В этом примере, значения <tt>a</tt> и <tt>b</tt> меняются местами с помощью
параллельного присваивания. (Если несколько переменных должны быть
присвоены параллельно в рамках цикла, целесообразнее использовать
конструкцию <tt><a 
href="clmse134.html#x164-2410002r820">do</a></tt>.)
<!--l. 4919--><p class="indent" >   Смотрите также описание <tt><a 
href="clmse36.html#x48-503002r65">psetf</a></tt>, «общая конструкция параллельного
присваивания» Common Lisp&#x2019;а, которая позволяет присваивать переменным,
элементам массива, и другим местам.
<!--l. 4923--><p class="indent" >   Если любая <i>var</i> ссылается не на обычную переменную, а на связывание
сделанное с помощью <tt><a 
href="clmse39.html#x51-610005r85">symbol-macrolet</a></tt>, тогда <i>var</i> обрабатывается как если
<tt><a 
href="clmse36.html#x48-503002r65">psetf</a></tt> использовалось вместо <tt><a 
href="#x47-464002r60">psetq</a></tt>.
</div>
<div class="defun">
<!--l. 4928--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx47-467001"></a><a 
 id="x47-467002r61"></a><b> set</b>  <i>symbol</i> <i>value</i>
</div>
<!--l. 4930--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4680007.1.2" id="x47-4680007.1.2"></a></span>
<tt>
   <a 
href="#x47-467002r61">set</a></tt> позволяет изменить значение динамической (специальной)
переменной. <tt><a 
href="#x47-467002r61">set</a></tt> устанавливает динамической переменной с именем <i>symbol</i>
значение <i>value</i>.
<!--l. 4935--><p class="indent" >   Изменено будет только значение текущего динамического связывания.
Если такого связывания нет, будет изменено наиболее глобальное значение.
Например, <div class="lisp"><div class="tabbing">
(set (if (eq a b) &#x2019;c &#x2019;d) &#x2019;foo)
                                                                          

                                                                          
   <br>
<!--l. 4940--><p class="noindent" ></div>
<!--l. 4940--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4690007.1.2" id="x47-4690007.1.2"></a></span>
<!--l. 4940--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4700007.1.2" id="x47-4700007.1.2"></a></span>
</div>
<!--l. 4941--><p class="indent" >   установит значение <tt>с</tt> в <tt>foo</tt> или <tt><a 
href="clmse42.html#x54-650002r98">do*</a></tt> в <tt>foo</tt>, в зависимости от результата
проверки <tt>(eq a b)</tt>.
<tt>
<!--l. 4944--><p class="indent" >   <a 
href="#x47-467002r61">set</a></tt> в качестве результата возвращает значение <i>value</i>.
<tt>
<!--l. 4946--><p class="indent" >   <a 
href="#x47-467002r61">set</a></tt> не может изменить значение локальной (лексически связанной)
переменной. Обычно для изменения переменных (лексических или
динамических) используется специальная форма <tt><a 
href="#x47-461002r59">setq</a></tt>. <tt><a 
href="#x47-467002r61">set</a></tt> полезна в
частности для реализации интерпретаторов языков встроенных в Lisp.
Смотрите также <tt><a 
href="clmse39.html#x51-598002r81">progv</a></tt>, конструкция, которая создаёт связывания, а не
присваивания динамических переменных.
</div>
<div class="defun">
<!--l. 4956--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx47-470001"></a><a 
 id="x47-470002r62"></a><b> makunbound</b>  <i>symbol</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx47-470003"></a><a 
 id="x47-470004r63"></a><b> fmakunbound</b>  <i>symbol</i>
</div>
<!--l. 4959--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4710007.1.2" id="x47-4710007.1.2"></a></span>
<tt>
   <a 
href="#x47-470002r62">makunbound</a></tt> упраздняет связывание динамической (специальной)
переменной заданной символом <i>symbol</i> (упраздняет значение). <tt><a 
href="#x47-470004r63">fmakunbound</a></tt>
аналогично упраздняет связь символа с глобальным определением функции.
Например: <div class="lisp"><div class="tabbing">
(setq a 1)
   <br>                                                                                      a <span class="math"> ⇒</span> 1<br>
(makunbound &#x2019;a)<br>                                            a <span class="math"> ⇒</span> ошибка<br>
                                                                          

                                                                          
<br>                                                    (defun foo (x) (+ x 1))<br>
(foo 4) <span class="math"> ⇒</span> 5<br>                                          (fmakunbound &#x2019;foo)<br>
(foo 4) <span class="math"> ⇒</span> ошибка<br>
<!--l. 4974--><p class="noindent" ></div>
<!--l. 4974--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4720007.1.2" id="x47-4720007.1.2"></a></span>
<!--l. 4974--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4730007.1.2" id="x47-4730007.1.2"></a></span>
</div>
<!--l. 4975--><p class="indent" >   Обе функции возвращают символ <i>symbol</i> в качестве результата.
<!--l. 4977--><p class="indent" >   Функция <tt><a 
href="#x47-470004r63">fmakunbound</a></tt> принимает любое имя функции (символ или список,
<i>car</i> элементы которого является <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>—смотрите раздел <a 
href="#x47-4250007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>) Так можно
записать <tt>(fmakunbound &#x2019;(setf cadr))</tt> для удаления функции <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> для
<tt><a 
href="clmse82.html#x102-1273004r413">cadr</a></tt>.
</div>
                                                                          

                                                                          
<!--l. 4984--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse36.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#tailclmch7.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse35.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse35.html"></a>   </div> </div> 
</body></html> 
