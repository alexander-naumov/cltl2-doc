<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Constants and Variables Константы и переменные</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-09 00:03:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 110--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse36.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#tailclmch7.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse35.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse35.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">7.1   </span> <a 
 id="x47-860007.1"></a>Constants and Variables Константы и переменные</h3>
<!--l. 113--><p class="noindent" >Because some Lisp data objects are used to represent programs, one cannot
always notate a constant data object in a program simply by writing the notation
for the object unadorned; it would be ambiguous whether a constant object or a
program fragment was intended. The <a 
href="#x47-87002r53">quote</a> special form resolves this
ambiguity.
<!--l. 119--><p class="indent" >   Так как некоторые Lisp&#x2019;овые объекты данных используются для
отображения программ, можно всегда обозначить константный объект
данных с помощью записи без приукрашательств формы данного объекта.
                                                                          

                                                                          
Однако порождается двусмысленность: константный это объект или
фрагмент кода. Эту двусмысленность разрешает специальная форма
<a 
href="#x47-87002r53">quote</a>.
<!--l. 125--><p class="indent" >   There are two kinds of variables in Common Lisp, in eﬀect: ordinary
variables and function names. There are some similarities between the
two kinds, and in a few cases there are similar functions for dealing with
them, for example <a 
href="#x47-89013r58">boundp</a> and <a 
href="#x47-89015r59">fboundp</a>. However, for the most part the
two kinds of variables are used for very diﬀerent purposes: one to name
deﬁned functions, macros, and special forms, and the other to name data
objects.
<!--l. 133--><p class="indent" >   В Common Lisp&#x2019;е присутствуют два вида переменных, а именно: обычные
переменные и имена функций. Между этипи типами есть несколько сходств,
и в некоторых случаях для взаимодействия с ними используются похожие
функции, например <a 
href="#x47-89013r58">boundp</a> и <a 
href="#x47-89015r59">fboundp</a>. Однако для в большинстве случаев
два вида переменных используются для совсем разных целей: один указывает
на функции, макросы и специальные формы, и другие на объекты
данных.
<div class=newer>
<!--l. 142--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-86001"></a>to introduce the concept of a <i>function-name</i>,
which may be either a symbol or a two-element list whose ﬁrst element is the
symbol <a 
href="clmse36.html#x48-93002r66">setf</a> and whose second element is a symbol. The primary purpose of this is
to allow <a 
href="clmse36.html#x48-93002r66">setf</a> expander functions to be CLOS generic functions with user-deﬁned
methods. Many places in Common Lisp that used to require a symbol
for a function name are changed to allow 2-lists as well; for example,
<a 
href="clmse30.html#x40-69002r13">defun</a> is changed so that one may write (defun (setf foo) ...), and the
<a 
href="#x47-88006r54">function</a> special form is changed to accept any function-name. See also
<a 
href="#x47-89010r57">fdeﬁnition</a>.
<!--l. 153--><p class="indent" >   By convention, any function named (setf <i>f </i>) should return its ﬁrst argument as
its only value, in order to preserve the speciﬁcation that <a 
href="clmse36.html#x48-93002r66">setf</a> returns its <i>newvalue</i>.
See <a 
href="clmse36.html#x48-93002r66">setf</a>.
<!--l. 157--><p class="indent" >   Implementations are free to extend the syntax of function-names to include
lists beginning with additional symbols other than <a 
href="clmse36.html#x48-93002r66">setf</a> or lambda.
</div>
<!--l. 162--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.1.1   </span> <a 
 id="x47-870007.1.1"></a>Reference Использование переменных</h4>
                                                                          

                                                                          
<!--l. 164--><p class="noindent" >The value of an ordinary variable may be obtained simply by writing the name of
the variable as a form to be executed. Whether this is treated as the name of a
special variable or a lexical variable is determined by the presence or absence of
an applicable special declaration; see chapter <a 
href="clmch9.html#x64-1660009">9<!--tex4ht:ref: DECLAR --></a>.
<!--l. 171--><p class="indent" >   Значение обычной переменной может быть получено просто с помощью
записи его имени как формы, которая будет выполнена. Будет ли данное имя
распознано как имя специальной или лексической переменной зависит от
наличия или отсутствия соответствующей декларации special. Смотрите
главу <a 
href="clmch9.html#x64-1660009">9<!--tex4ht:ref: DECLAR --></a>.
<!--l. 176--><p class="indent" >   The following functions and special forms allow reference to the values of
constants and variables in other ways.
<!--l. 179--><p class="indent" >   Следующие функции и специальные формы позволяют ссылаться на
значения констант и переменных.
<div class=defspec>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> quote </b><a 
 id="dx47-87001"></a><a 
 id="x47-87002r53"></a> object
</td></tr></table>
<!--l. 184--><p class="indent" >
</div>
<!--l. 184--><p class="noindent" ><span class="paragraphHead"><a 
 id="x47-880007.1.1"></a></span>
   (quote <i>x</i>) simply returns <i>x</i>. The <i>object</i> is not evaluated and may be any Lisp
object whatsoever. This construct allows any Lisp object to be written as a
constant value in a program. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a 43)
</td></tr></table>
<!--l. 191--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list a (cons a 3))  ⇒ (43 (43 . 3))</td></tr></table>
<!--l. 192--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list (quote a) (quote (cons a 3))  ⇒ (a (cons a 3))</td></tr></table>
<!--l. 194--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 195--><p class="noindent" >Since <a 
href="#x47-87002r53">quote</a> forms are so frequently useful but somewhat cumbersome to type, a
standard abbreviation is deﬁned for them: any form <i>f </i> preceded by a single quote
( &#x2019; ) character is assumed to have (quote  ) wrapped around it to make (quote
<i>f </i>). For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x &#x2019;(the magic quote hack))
</td></tr></table>
<!--l. 203--><p class="indent" >
</div>
</div>
<!--l. 204--><p class="noindent" >is normally interpreted by <a 
href="clmse116.html#x143-281003r696">read</a> to mean <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x (quote (the magic quote hack)))
</td></tr></table>
<!--l. 207--><p class="indent" >
</div>
</div>
<!--l. 208--><p class="noindent" >See section <a 
href="clmse115.html#x142-27500022.1.3">22.1.3<!--tex4ht:ref: MACRO-CHARACTERS-SECTION --></a>.
<!--l. 210--><p class="indent" >   (quote <i>x</i>) возвращает <i>x</i>. <i>object</i> не выполняется и может быть любым
объектом Lisp&#x2019;а. Конструкция позволяет записать в программе любой объект,
как константное значение. Например: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a 43)
</td></tr></table>
<!--l. 216--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list a (cons a 3))  ⇒ (43 (43 . 3))</td></tr></table>
<!--l. 217--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list (quote a) (quote (cons a 3))  ⇒ (a (cons a 3))</td></tr></table>
<!--l. 219--><p class="indent" >
</div>
</div>
<!--l. 220--><p class="noindent" >Так как <a 
href="#x47-87002r53">quote</a> форма так полезна, но записывать ее трудоемко, для нее
определена стандартная аббревиатура: любая форма <i>f </i> с предшествующей
одинарной кавычкой ( &#x2019; ) оборачивается формой (quote  ) для создания
(quote <i>f </i>). Например: <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x &#x2019;(the magic quote hack))
</td></tr></table>
<!--l. 227--><p class="indent" >
</div>
</div>
<!--l. 228--><p class="noindent" >обычно интерпретируется функцией <a 
href="clmse116.html#x143-281003r696">read</a>, как <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x (quote (the magic quote hack)))
</td></tr></table>
<!--l. 231--><p class="indent" >
</div>
</div>
<!--l. 232--><p class="noindent" >Смотрите раздел <a 
href="clmse115.html#x142-27500022.1.3">22.1.3<!--tex4ht:ref: MACRO-CHARACTERS-SECTION --></a>.
<div class=newer>
<!--l. 235--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx47-88001"></a>to clarify that it is an error to destructively
modify any object that appears as a constant in executable code, whether within
a <a 
href="#x47-87002r53">quote</a> special form or as a self-evaluating form.
<!--l. 240--><p class="indent" >   See section <a 
href="clmse127.html#x157-31800025.1">25.1<!--tex4ht:ref: COMPILER-SECTION --></a> for a discussion of how quoted constants are treated by the
compiler.
</div>
<div class=newer>
<!--l. 245--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-88002"></a>to clarify that <a 
href="clmse110.html#x135-261002r620">eval</a> and <a 
href="clmse127.html#x157-318003r797">compile</a> are not
permitted either to copy or to coalesce (“collapse”) constants (see <a 
href="clmse33.html#x44-81002r46">eq</a>)
appearing in the code they process; the resulting program behavior must refer
to objects that are <a 
href="clmse33.html#x44-81005r47">eql</a> to the corresponding objects in the source code.
Moreover, the constraints introduced by the votes on issues <a 
 id="dx47-88003"></a>and <a 
 id="dx47-88004"></a>on what
kinds of objects may appear as constants apply only to <a 
href="clmse127.html#x157-318011r799">compile-ﬁle</a> (see
section <a 
href="clmse127.html#x157-31800025.1">25.1<!--tex4ht:ref: COMPILER-SECTION --></a>).
</div>
</div>
<div class=defspec>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> function </b><a 
 id="dx47-88005"></a><a 
 id="x47-88006r54"></a> fn
</td></tr></table>
<!--l. 261--><p class="indent" >
</div>
<!--l. 261--><p class="noindent" ><span class="paragraphHead"><a 
 id="x47-890007.1.1"></a></span>
   The value of <a 
href="#x47-88006r54">function</a> is always the functional interpretation of <i>fn</i>; <i>fn</i> is
interpreted as if it had appeared in the functional position of a function
invocation. In particular, if <i>fn</i> is a symbol, the functional deﬁnition associated
with that symbol is returned; see <a 
href="#x47-89007r56">symbol-function</a>. If <i>fn</i> is a lambda-expression,
then a “lexical closure” is returned, that is, a function that when invoked will
execute the body of the lambda-expression in such a way as to observe the rules of
lexical scoping properly.
<!--l. 273--><p class="indent" >   Значение <a 
href="#x47-88006r54">function</a> всегда является функциональной интерпретацией <i>fn</i>. <i>fn</i>
интерпретируется как, если бы она была использована на позиции функции в
форме вызова функции. В частности, если <i>fn</i> является символом,
возвращается определение функции, связанное с этим символом, смотрите
<a 
href="#x47-89007r56">symbol-function</a>. Если <i>fn</i> является лямбда-выражением, тогда возвращается
«лексическое замыкание», это значит функция, которая при вызове
выполняет тело лямбда-выражения таким образом, чтобы правила
лексического контекста выполнялись правильно.
<div class=newer>
<!--l. 284--><p class="indent" >   X3J13 voted in June 1988 <a 
 id="dx47-89001"></a>to specify that the result of a <a 
href="#x47-88006r54">function</a> special form
is always of type <a 
href="#x47-88006r54">function</a>. This implies that a form (function <i>fn</i>) may be
interpreted as (the (function <i>fn</i>)).
<!--l. 289--><p class="indent" >   It is an error to use the <a 
href="#x47-88006r54">function</a> special form on a symbol that does not
denote a function in the lexical or global environment in which the special form
appears. Speciﬁcally, it is an error to use the <a 
href="#x47-88006r54">function</a> special form on a symbol
that denotes a macro or special form. Some implementations may choose not
to signal this error for performance reasons, but implementations are
forbidden to extend the semantics of <a 
href="#x47-88006r54">function</a> in this respect; that is, an
implementation is not allowed to deﬁne the failure to signal an error to be a
“useful” behavior.
</div>
<div class=newer>
<!--l. 301--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-89002"></a>to extend <a 
href="#x47-88006r54">function</a> to accept any function-name (a
symbol or a list whose <i>car</i> is <a 
href="clmse36.html#x48-93002r66">setf</a>—see section <a 
href="#x47-860007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>) as well as lambda-expressions.
                                                                          

                                                                          
Thus one may write (function (setf cadr)) to refer to the <a 
href="clmse36.html#x48-93002r66">setf</a> expansion function
for <a 
href="clmse86.html#x106-224008r447">cadr</a>.
</div>
<a 
 id="dx47-89003"></a>
<!--l. 310--><p class="indent" >   For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun adder (x) (function (lambda (y) (+ x y))))
</td></tr></table>
<!--l. 313--><p class="indent" >
</div>
</div>
<!--l. 314--><p class="noindent" >The result of (adder 3) is a function that will add 3 to its argument: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq add3 (adder 3))
</td></tr></table>
<!--l. 317--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall add3 5)  ⇒ 8</td></tr></table>
<!--l. 319--><p class="indent" >
</div>
</div>
<!--l. 320--><p class="noindent" >This works because <a 
href="#x47-88006r54">function</a> creates a closure of the inner lambda-expression that is
able to refer to the value 3 of the variable x even after control has returned from
the function adder.
<!--l. 325--><p class="indent" >   Например: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun adder (x) (function (lambda (y) (+ x y))))
</td></tr></table>
<!--l. 328--><p class="indent" >
</div>
</div>
<!--l. 329--><p class="noindent" >Результат (adder 3) является функцией, которая добавляет 3 к ее аргументу: <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq add3 (adder 3))
</td></tr></table>
<!--l. 332--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall add3 5)  ⇒ 8</td></tr></table>
<!--l. 334--><p class="indent" >
</div>
</div>
<!--l. 335--><p class="noindent" >Это работает, потому что <a 
href="#x47-88006r54">function</a> создает замыкание над внутренним
лямбда-выражением, которое может ссылаться на значение 3 переменной x
даже после того, как выполнение вышло из функции adder.
<!--l. 339--><p class="indent" >   More generally, a lexical closure in eﬀect retains the ability to refer to lexically
visible <i>bindings</i>, not just values. Consider this code: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun two-funs (x)
</td></tr></table>
<!--l. 343--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (list (function (lambda () x))</td></tr></table>
<!--l. 344--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (function (lambda (y) (setq x y)))))</td></tr></table>
<!--l. 345--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq funs (two-funs 6))</td></tr></table>
<!--l. 346--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall (car funs))  ⇒ 6</td></tr></table>
<!--l. 347--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall (cadr funs) 43)  ⇒ 43</td></tr></table>
<!--l. 348--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall (car funs))  ⇒ 43</td></tr></table>
<!--l. 350--><p class="indent" >
</div>
</div>
<!--l. 351--><p class="noindent" >The function two-funs returns a list of two functions, each of which refers to the
<i>binding</i> of the variable x created on entry to the function two-funs when it was
called with argument 6. This binding has the value 6 initially, but <a 
href="#x47-90002r61">setq</a> can alter a
binding. The lexical closure created for the ﬁrst lambda-expression does not
“snapshot” the value 6 for x when the closure is created. The second function can
be used to alter the binding (to 43, in the example), and this altered value then
becomes accessible to the ﬁrst function.
<!--l. 361--><p class="indent" >   Если посмотреть глубже, то лексическое замыкание обладает возможностью
ссылаться на лексически видимые <i>связывание</i>, а не просто на значения.
Рассмотрим такой код: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun two-funs (x)
</td></tr></table>
                                                                          

                                                                          
<!--l. 365--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (list (function (lambda () x))</td></tr></table>
<!--l. 366--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (function (lambda (y) (setq x y)))))</td></tr></table>
<!--l. 367--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq funs (two-funs 6))</td></tr></table>
<!--l. 368--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall (car funs))  ⇒ 6</td></tr></table>
<!--l. 369--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall (cadr funs) 43)  ⇒ 43</td></tr></table>
<!--l. 370--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall (car funs))  ⇒ 43</td></tr></table>
<!--l. 372--><p class="indent" >
</div>
</div>
<!--l. 373--><p class="noindent" >Функция two-funs возвращает список двух функций, каждая из которых
ссылается на <i>связывание</i> переменной x, созданной в момент входа
в функцию two-funs, когда она была вызвана с аргументом 6. Это
связывание счначала имеет значение 6, но <a 
href="#x47-90002r61">setq</a> может изменить связывание.
Лексическое замыкание для первого лямбда-выражения не является
«создает снимок» значения 6 для x при создании замыкания. Вторая
функция может использоваться для изменения связывания (на 43
например), и это измененное значение станет доступным в первой
функции.
<!--l. 382--><p class="indent" >   In situations where a closure of a lambda-expression over the same set of
bindings may be produced more than once, the various resulting closures may or
may not be <a 
href="clmse33.html#x44-81002r46">eq</a>, at the discretion of the implementation. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((x 5) (funs &#x2019;()))
</td></tr></table>
<!--l. 387--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 388--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (push #&#x2019;(lambda (z)</td></tr></table>
<!--l. 389--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (if (null z) (setq x 0) (+ x z)))</td></tr></table>
<!--l. 390--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          funs))</td></tr></table>
<!--l. 391--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 393--><p class="indent" >
</div>
</div>
<!--l. 394--><p class="noindent" >The result of the above expression is a list of ten closures. Each logically requires only
the binding of x. It is the same binding in each case, so the ten closures may or
may not be the same identical (<a 
href="clmse33.html#x44-81002r46">eq</a>) object. On the other hand, the result of the
expression <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((funs &#x2019;()))
</td></tr></table>
<!--l. 400--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 401--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((x 5))</td></tr></table>
<!--l. 402--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (push (function (lambda (z)</td></tr></table>
<!--l. 403--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                        (if (null z) (setq x 0) (+ x z))))</td></tr></table>
<!--l. 404--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            funs)))</td></tr></table>
<!--l. 405--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 407--><p class="indent" >
</div>
</div>
<!--l. 408--><p class="noindent" >is also a list of ten closures. However, in this case no two of the closures may be <a 
href="clmse33.html#x44-81002r46">eq</a>,
because each closure is over a distinct binding of x, and these bindings can be
behaviorally distinguished because of the use of <a 
href="#x47-90002r61">setq</a>.
<!--l. 413--><p class="indent" >   В ситуации, когда замыкание лямбда-выражения над одним и тем же
множеством связываний может создаваться несколько раз, эти полученные
разные замыкания могут быть равны или не равны <a 
href="clmse33.html#x44-81002r46">eq</a> в зависимости от
реализации. Например: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((x 5) (funs &#x2019;()))
</td></tr></table>
<!--l. 418--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 419--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (push #&#x2019;(lambda (z)</td></tr></table>
<!--l. 420--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (if (null z) (setq x 0) (+ x z)))</td></tr></table>
<!--l. 421--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          funs))</td></tr></table>
<!--l. 422--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 424--><p class="indent" >
</div>
</div>
<!--l. 425--><p class="noindent" >Результат данного выражения является списом десяти замыканий. Каждое
логически требует только связывания x. В любом случае это одно
и то же связывание, но десять замыканий могут быть равны или
не равны <a 
href="clmse33.html#x44-81002r46">eq</a> друг другу. С другой стороны, результат выражения <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((funs &#x2019;()))
</td></tr></table>
<!--l. 431--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 432--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((x 5))</td></tr></table>
<!--l. 433--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (push (function (lambda (z)</td></tr></table>
<!--l. 434--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                        (if (null z) (setq x 0) (+ x z))))</td></tr></table>
<!--l. 435--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            funs)))</td></tr></table>
<!--l. 436--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 438--><p class="indent" >
</div>
</div>
<!--l. 439--><p class="noindent" >также является списком из десяти замыканий. Однако в этом случае, но одна из
пар замыканий не будет равна <a 
href="clmse33.html#x44-81002r46">eq</a>, потому что каждое замыкание имеет свое
связывание x отличное от другого. Свзяывания отличаются, так как в
замыкании используется <a 
href="#x47-90002r61">setq</a>.
<!--l. 444--><p class="indent" >   The question of distinguishable behavior is important; the result of the simpler
expression <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((funs &#x2019;()))
</td></tr></table>
<!--l. 447--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 448--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((x 5))</td></tr></table>
<!--l. 449--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (push (function (lambda (z) (+ x z)))</td></tr></table>
<!--l. 450--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            funs)))</td></tr></table>
<!--l. 451--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 453--><p class="indent" >
</div>
</div>
<!--l. 454--><p class="noindent" >is a list of ten closures that <i>may</i> be pairwise <a 
href="clmse33.html#x44-81002r46">eq</a>. Although one might think that a
diﬀerent binding of x is involved for each closure (which is indeed the case), the
bindings cannot be distinguished because their values are identical and
immutable, there being no occurrence of <a 
href="#x47-90002r61">setq</a> on x. A compiler would therefore be
justiﬁed in transforming the expression to <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((funs &#x2019;()))
</td></tr></table>
<!--l. 461--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 462--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (push (function (lambda (z) (+ 5 z)))</td></tr></table>
<!--l. 463--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          funs))</td></tr></table>
<!--l. 464--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 466--><p class="indent" >
</div>
</div>
<!--l. 467--><p class="noindent" >where clearly the closures may be the same after all. The general rule, then, is that
the implementation is free to have two distinct evaluations of the same <a 
href="#x47-88006r54">function</a>
form produce identical (<a 
href="clmse33.html#x44-81002r46">eq</a>) closures if it can prove that the two conceptually
distinct resulting closures must in fact be behaviorally identical with respect to
invocation. This is merely a permitted optimization; a perfectly valid
implementation might simply cause every distinct evaluation of a <a 
href="#x47-88006r54">function</a> form to
produce a new closure object not <a 
href="clmse33.html#x44-81002r46">eq</a> to any other.
<!--l. 477--><p class="indent" >   Вопрос различного поведения важен, поэтому рассмотрим следующее
простое выражение: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((funs &#x2019;()))
</td></tr></table>
<!--l. 479--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 480--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((x 5))</td></tr></table>
<!--l. 481--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (push (function (lambda (z) (+ x z)))</td></tr></table>
<!--l. 482--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            funs)))</td></tr></table>
<!--l. 483--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 485--><p class="indent" >
</div>
</div>
<!--l. 486--><p class="noindent" >Результатом является десять замыканий, которые <i>могут</i> быть равны <a 
href="clmse33.html#x44-81002r46">eq</a>
попарно. Однако, можно подумать что связывания x для каждого замыкания
разные, так как создаются в цикле, но связывания не могут различатся,
потому что их значения идентичны и неизменяемы (иммутабельны), в
замыканиях отсутствует <a 
href="#x47-90002r61">setq</a> для x. Компилятор может в таких случаях
оптимизировать выражение так: <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((funs &#x2019;()))
</td></tr></table>
<!--l. 493--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 494--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (push (function (lambda (z) (+ 5 z)))</td></tr></table>
<!--l. 495--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          funs))</td></tr></table>
<!--l. 496--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 498--><p class="indent" >
</div>
</div>
<!--l. 499--><p class="noindent" >после чего, в конце концов, замыкания точно могут быть равны. Общее правило
такое, что реализация может в двух различных случаях выполнения формы
<a 
href="#x47-88006r54">function</a> вернуть идентичные (<a 
href="clmse33.html#x44-81002r46">eq</a>) замыкания, если она может доказать, что
два концептуально различающихся замыкания по факту ведут себя
одинаково при одинаковых параметрах вызова. Это просто разрешается для
оптимизации. Полностью корректная реализация может каждый раз при
выполнении формы <a 
href="#x47-88006r54">function</a> возвращать новое замыкание не равное <a 
href="clmse33.html#x44-81002r46">eq</a>
другим.
<!--l. 508--><p class="indent" >   Frequently a compiler can deduce that a closure in fact does not need
to close over any variable bindings. For example, in the code fragment <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapcar (function (lambda (x) (+ x 2))) y)
</td></tr></table>
<!--l. 513--><p class="indent" >
</div>
</div>
<!--l. 514--><p class="noindent" >the function (lambda (x) (+ x 2)) contains no references to any outside entity. In this
important special case, the same “closure” may be used as the value for all
evaluations of the <a 
href="#x47-88006r54">function</a> special form. Indeed, this value need not be a closure
object at all; it may be a simple compiled function containing no environment
information. This example is simply a special case of the foregoing discussion and
is included as a hint to implementors familiar with previous methods of
implementing Lisp. The distinction between closures and other kinds of functions
is somewhat pointless, actually, as Common Lisp deﬁnes no particular
representation for closures and no way to distinguish between closures and
non-closure functions. All that matters is that the rules of lexical scoping be
obeyed.
                                                                          

                                                                          
<!--l. 527--><p class="indent" >   Часто компилятор может сделать вывод, что замыкание по факту не
нуждается в замыкании над какими-либо связываниями переменных.
Например, в фрагменте кода <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapcar (function (lambda (x) (+ x 2))) y)
</td></tr></table>
<!--l. 532--><p class="indent" >
</div>
</div>
<!--l. 533--><p class="noindent" >функция (lambda (x) (+ x 2)) не содержит ссылок на какие-либо внешние
сущности. В этом важном специальном случае, одно и то же «замыкание»
может быть использовано в качестве результата всех выполнений
специальной формы <a 
href="#x47-88006r54">function</a>. Несомненно, данное значение может и не быть
объектом замыкания. Оно может быть просто скомпилированной функцией,
не содержащей информации об окружении. Данный пример просто
является частным случаем предыдущего разговора и включен в качестве
подсказки для разработчиков знакомых с предыдущими методами
реализации Lisp&#x2019;а. Различие между замыканиями и другими видами
функций слегка размыто, Common Lisp не определяет отображения
для замыканий и метода различия замыканий и простых функций.
Все что имеет значение, это соблюдение правил лексической области
видимости.
<!--l. 546--><p class="indent" >   Since <a 
href="#x47-88006r54">function</a> forms are so frequently useful but somewhat cumbersome to
type, a standard abbreviation is deﬁned for them: any form <i>f </i> preceded by #&#x2019; (#
followed by an apostrophe) is assumed to have (function ) wrapped around it to
make (function <i>f </i>). For example, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-if #&#x2019;numberp &#x2019;(1 a b 3))
</td></tr></table>
<!--l. 553--><p class="indent" >
</div>
</div>
<!--l. 554--><p class="noindent" >is normally interpreted by <a 
href="clmse116.html#x143-281003r696">read</a> to mean <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-if (function numberp) &#x2019;(1 a b 3))
</td></tr></table>
<!--l. 557--><p class="indent" >
</div>
</div>
<!--l. 558--><p class="noindent" >See section <a 
href="clmse115.html#x142-27600022.1.4">22.1.4<!--tex4ht:ref: SHARP-SIGN-MACRO-CHARACTER-SECTION --></a>.
<!--l. 560--><p class="indent" >   Так как форма <a 
href="#x47-88006r54">function</a> используются часто, но ее запись длинная,
для нее определена стандартная аббревиатура: любая форма <i>f </i> с
предшествующими #&#x2019; разворачивается в форму (function <i>f </i>). Например, <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-if #&#x2019;numberp &#x2019;(1 a b 3))
</td></tr></table>
<!--l. 566--><p class="indent" >
</div>
</div>
<!--l. 567--><p class="noindent" >обычно интерпретируется функцией <a 
href="clmse116.html#x143-281003r696">read</a> как <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-if (function numberp) &#x2019;(1 a b 3))
</td></tr></table>
<!--l. 570--><p class="indent" >
</div>
</div>
<!--l. 571--><p class="noindent" >Смотрите раздел <a 
href="clmse115.html#x142-27600022.1.4">22.1.4<!--tex4ht:ref: SHARP-SIGN-MACRO-CHARACTER-SECTION --></a>.
</div>
<div class=defun>
<!--l. 575--><p class="noindent" ><i>[Function]</i><a 
 id="dx47-89004"></a><a 
 id="x47-89005r55"></a><b> symbol-value</b>  <i>symbol</i>
<!--l. 577--><p class="noindent" ><a 
href="#x47-89005r55">symbol-value</a> returns the current value of the dynamic (special) variable
named by <i>symbol</i>. An error occurs if the symbol has no value; see <a 
href="#x47-89013r58">boundp</a>
and <a 
href="#x47-92006r64">makunbound</a>. Note that constant symbols are really variables that
cannot be changed, and so <a 
href="#x47-89005r55">symbol-value</a> may be used to get the value of a
named constant. In particular, <a 
href="#x47-89005r55">symbol-value</a> of a keyword will return that
keyword.
<!--l. 587--><p class="indent" >   <a 
href="#x47-89005r55">symbol-value</a> возвращает текущее значение динамической (специальной)
переменной с именем <i>symbol</i>. Если символ не имеет значения, возникает ошибка.
Смотрите boudnp и <a 
href="#x47-92006r64">makunbound</a>. Следует отметить, что константные
                                                                          

                                                                          
символы являются переменными, которые не могут быть изменены, таким
образом <a 
href="#x47-89005r55">symbol-value</a> может использоваться для получения значения
именованной константы. <a 
href="#x47-89005r55">symbol-value</a> от ключевого символа будет
возвращать этот ключевой символ.
<!--l. 596--><p class="indent" >   <a 
href="#x47-89005r55">symbol-value</a> cannot access the value of a lexical variable.
<!--l. 598--><p class="indent" >   <a 
href="#x47-89005r55">symbol-value</a> не может получить доступ к значению лексической
переменной.
<!--l. 600--><p class="indent" >   This function is particularly useful for implementing interpreters for languages
embedded in Lisp. The corresponding assignment primitive is <a 
href="#x47-92003r63">set</a>; alternatively,
<a 
href="#x47-89005r55">symbol-value</a> may be used with <a 
href="clmse36.html#x48-93002r66">setf</a>.
<!--l. 605--><p class="indent" >   В частности, эта функция полезна для реализации интерпретаторов для
встраиваемых языков в Lisp&#x2019;е. Соответствующая функция присваивания <a 
href="#x47-92003r63">set</a>.
Кроме того, можно пользоваться конструкцией <a 
href="clmse36.html#x48-93002r66">setf</a> с <a 
href="#x47-89005r55">symbol-value</a>.
</div>
<div class=defun>
<!--l. 611--><p class="noindent" ><i>[Function]</i><a 
 id="dx47-89006"></a><a 
 id="x47-89007r56"></a><b> symbol-function</b>  <i>symbol</i>
<!--l. 613--><p class="noindent" ><a 
href="#x47-89007r56">symbol-function</a> returns the current global function deﬁnition named by
<i>symbol</i>. An error is signalled if the symbol has no function deﬁnition; see
<a 
href="#x47-89015r59">fboundp</a>. Note that the deﬁnition may be a function or may be an object
representing a special form or macro. In the latter case, however, it is an error to
attempt to invoke the object as a function. If it is desired to process macros,
special forms, and functions equally well, as when writing an interpreter, it
is best ﬁrst to test the symbol with <a 
href="clmse46.html#x59-157005r136">macro-function</a> and <a 
href="#x47-89019r60">special-form-p</a>
and then to invoke the functional value only if these two tests both yield
false.
<!--l. 627--><p class="indent" >   <a 
href="#x47-89007r56">symbol-function</a> возвращает текущее глобальное определение функции с
именем <i>symbol</i>. В случае если символ не имеет определения функции
сигнализируется ошибка, смотрите <a 
href="#x47-89015r59">fboundp</a>. Следует отметить что
определение может быть функцией или объектом отображающим
специальную форму или макрос. Однако, в последнем случае, попытка
вызова объекта как функции будет является ошибкой. Лучше всего заранее
проверить символ с помощью <a 
href="clmse46.html#x59-157005r136">macro-function</a> и <a 
href="#x47-89019r60">special-form-p</a> и только затем
вызвать функциональное значение, если оба предыдущих теста вернули
ложь.
<!--l. 637--><p class="indent" >   This function is particularly useful for implementing interpreters for languages
embedded in Lisp.
<!--l. 640--><p class="indent" >   Эта функция полезна, в частности, для реализации интерпретаторов
языков встроенных в Lisp.
                                                                          

                                                                          
<!--l. 643--><p class="indent" >   <a 
href="#x47-89007r56">symbol-function</a> cannot access the value of a lexical function name produced
by <a 
href="clmse39.html#x51-114006r93">ﬂet</a> or <a 
href="clmse39.html#x51-114008r94">labels</a>; it can access only the global function value.
<!--l. 647--><p class="indent" >   <a 
href="#x47-89007r56">symbol-function</a> не может получить доступ к значению имени лексической
функции, созданной с помощью <a 
href="clmse39.html#x51-114006r93">ﬂet</a> или <a 
href="clmse39.html#x51-114008r94">labels</a>. Она может получать только
глобальное функциональное значение.
<!--l. 651--><p class="indent" >   The global function deﬁnition of a symbol may be altered by using <a 
href="clmse36.html#x48-93002r66">setf</a> with
<a 
href="#x47-89007r56">symbol-function</a>. Performing this operation causes the symbol to have <i>only</i> the
speciﬁed deﬁnition as its global function deﬁnition; any previous deﬁnition,
whether as a macro or as a function, is lost. It is an error to attempt to redeﬁne
the name of a special form (see table <a 
href="clmse28.html#x38-620011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>).
<!--l. 659--><p class="indent" >   Глобальное определение функции для некоторого символа может быть
изменено с помощью <a 
href="clmse36.html#x48-93002r66">setf</a> и <a 
href="#x47-89007r56">symbol-function</a>. При использовании этой
опреации символ будет иметь <i>только</i> заданное определение в качестве
своего глобального функционального значения. Любое предыдущее
определение, было ли оно макросом или функцией, будет потеряно. Попытка
переопределения специальной формы (смотрите таблицу <a 
href="clmse28.html#x38-620011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>) будет является
ошибкой.
<div class=newer>
<!--l. 668--><p class="indent" >   X3J13 voted in June 1988 <a 
 id="dx47-89008"></a>to clarify the behavior of <a 
href="#x47-89007r56">symbol-function</a> in the
light of the redeﬁnition of the type <a 
href="#x47-88006r54">function</a>.
      <ul class="itemize1">
      <li class="itemize">It  is  permissible  to  call  <a 
href="#x47-89007r56">symbol-function</a>  on  any  symbol  for  which
      <a 
href="#x47-89015r59">fboundp</a> returns true. Note that <a 
href="#x47-89015r59">fboundp</a> must return true for a symbol
      naming a macro or a special form.
      </li>
      <li class="itemize">If <a 
href="#x47-89015r59">fboundp</a> returns true for a symbol but the symbol denotes a macro
      or  special  form,  then  the  value  returned  by  <a 
href="#x47-89007r56">symbol-function</a>  is  not
      well-deﬁned but <a 
href="#x47-89007r56">symbol-function</a> will not signal an error.
      </li>
      <li class="itemize">When <a 
href="#x47-89007r56">symbol-function</a> is used with <a 
href="clmse36.html#x48-93002r66">setf</a> the new value must be of type
      <a 
href="#x47-88006r54">function</a>. It is an error to set the <a 
href="#x47-89007r56">symbol-function</a> of a symbol to a
      symbol, a list, or the value returned by <a 
href="#x47-89007r56">symbol-function</a> on the name
      of a macro or a special form.</li></ul>
</div>
</div>
                                                                          

                                                                          
<div class=newer>
<div class=defun>
<!--l. 691--><p class="noindent" ><i>[Function]</i><a 
 id="dx47-89009"></a><a 
 id="x47-89010r57"></a><b> fdeﬁnition</b>  <i>function-name</i>
<!--l. 693--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx47-89011"></a>to add the function <a 
href="#x47-89010r57">fdeﬁnition</a> to the language. It is
exactly like <a 
href="#x47-89007r56">symbol-function</a> except that its argument may be any function-name
(a symbol or a list whose <i>car</i> is <a 
href="clmse36.html#x48-93002r66">setf</a>—see section <a 
href="#x47-860007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>); it returns the current global
function deﬁnition named by the argument <i>function-name</i>. One may use
<a 
href="#x47-89010r57">fdeﬁnition</a> with <a 
href="clmse36.html#x48-93002r66">setf</a> to change the current global function deﬁnition associated
with a function-name.
</div>
</div>
<div class=defun>
<!--l. 707--><p class="noindent" ><i>[Function]</i><a 
 id="dx47-89012"></a><a 
 id="x47-89013r58"></a><b> boundp</b>  <i>symbol</i>
<!--l. 709--><p class="noindent" ><a 
href="#x47-89013r58">boundp</a> is true if the dynamic (special) variable named by <i>symbol</i> has a value;
otherwise, it returns <a 
href="clmse31.html#x42-77002r19">nil</a>.
<!--l. 713--><p class="indent" >   See also <a 
href="#x47-92003r63">set</a> and <a 
href="#x47-92006r64">makunbound</a>.
<!--l. 715--><p class="indent" >   <a 
href="#x47-89013r58">boundp</a> является истиной, если динамическая (специальная) переменная с
именем <i>symbol</i> имеет значение, иначе возвращает <a 
href="clmse31.html#x42-77002r19">nil</a>.
<!--l. 718--><p class="indent" >   Смотрите также <a 
href="#x47-92003r63">set</a> и <a 
href="#x47-92006r64">makunbound</a>.
</div>
<div class=defun>
<!--l. 721--><p class="noindent" ><i>[Function]</i><a 
 id="dx47-89014"></a><a 
 id="x47-89015r59"></a><b> fboundp</b>  <i>symbol</i>
<!--l. 723--><p class="noindent" ><a 
href="#x47-89015r59">fboundp</a> is true if the symbol has a global function deﬁnition. Note that <a 
href="#x47-89015r59">fboundp</a>
is true when the symbol names a special form or macro. <a 
href="clmse46.html#x59-157005r136">macro-function</a> and
<a 
href="#x47-89019r60">special-form-p</a> may be used to test for these cases.
<!--l. 729--><p class="indent" >   <a 
href="#x47-89015r59">fboundp</a> является истиной, если символ имеет глобальное определение
функции. Следует отметить, что <a 
href="#x47-89015r59">fboundp</a> является истиной, если символ
указывает на специальную форму или макрос. <a 
href="clmse46.html#x59-157005r136">macro-function</a> и <a 
href="#x47-89019r60">special-form-p</a>
могут использоваться для проверки таких случаев.
<div class=newer>
<!--l. 736--><p class="indent" >   X3J13 voted in June 1988 <a 
 id="dx47-89016"></a>to emphasize that, despite the tightening of the
deﬁnition of the type <a 
href="#x47-88006r54">function</a>, <a 
href="#x47-89015r59">fboundp</a> must return true when the argument
names a special form or macro.
</div>
<!--l. 742--><p class="indent" >   See also <a 
href="#x47-89007r56">symbol-function</a> and <a 
href="#x47-92008r65">fmakunbound</a>.
<!--l. 744--><p class="indent" >   Смотрите также <a 
href="#x47-89007r56">symbol-function</a> и <a 
href="#x47-92008r65">fmakunbound</a>.
<div class=newer>
<!--l. 747--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-89017"></a>to extend <a 
href="#x47-89015r59">fboundp</a> to accept any function-name (a
                                                                          

                                                                          
symbol or a list whose <i>car</i> is <a 
href="clmse36.html#x48-93002r66">setf</a>—see section <a 
href="#x47-860007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). Thus one may write (fboundp
&#x2019;(setf cadr)) to determine whether a <a 
href="clmse36.html#x48-93002r66">setf</a> expansion function has been globally
deﬁned for <a 
href="clmse86.html#x106-224008r447">cadr</a>.
</div>
</div>
<div class=defun>
<!--l. 756--><p class="noindent" ><i>[Function]</i><a 
 id="dx47-89018"></a><a 
 id="x47-89019r60"></a><b> special-form-p</b>  <i>symbol</i>
<!--l. 758--><p class="noindent" >The function <a 
href="#x47-89019r60">special-form-p</a> takes a symbol. If the symbol globally names a
special form, then a non-<a 
href="clmse31.html#x42-77002r19">nil</a> value is returned; otherwise <a 
href="clmse31.html#x42-77002r19">nil</a> is returned. A
returned non-<a 
href="clmse31.html#x42-77002r19">nil</a> value is typically a function of implementation-dependent nature
that can be used to interpret (evaluate) the special form.
<!--l. 766--><p class="indent" >   It is possible for <i>both</i> <a 
href="#x47-89019r60">special-form-p</a> and <a 
href="clmse46.html#x59-157005r136">macro-function</a> to be true of a
symbol. This is possible because an implementation is permitted to implement
any macro also as a special form for speed. On the other hand, the macro
deﬁnition must be available for use by programs that understand only the
standard special forms listed in table <a 
href="clmse28.html#x38-620011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>.
<!--l. 773--><p class="indent" >   Функция <a 
href="#x47-89019r60">special-form-p</a> принимает символ. Если символ указывает на
специальную форму, тогда возвращается значение не-<a 
href="clmse31.html#x42-77002r19">nil</a>, иначе возвращается
<a 
href="clmse31.html#x42-77002r19">nil</a>. Возвращенное не-<a 
href="clmse31.html#x42-77002r19">nil</a> значение является функцией, которая может быть
использована для интепретации (вычисления) специальной формы.
FIXME
<!--l. 779--><p class="indent" >   Возможно также то, что <i>обе</i> функции <a 
href="#x47-89019r60">special-form-p</a> и <a 
href="clmse46.html#x59-157005r136">macro-function</a>
будут истинными для одного и того же символа. Это потому, что реализация
может иметь любой макрос как специальную форму для скорости. С другой
стороны, определение макроса должно быть доступно для использования
программами, которые понимают только стандартные специальные формы,
перечисленные в таблице <a 
href="clmse28.html#x38-620011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>. FIXME
</div>
<!--l. 787--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.1.2   </span> <a 
 id="x47-900007.1.2"></a>Assignment Присваивание</h4>
<!--l. 789--><p class="noindent" >The following facilities allow the value of a variable (more speciﬁcally, the value
associated with the current binding of the variable) to be altered. Such alteration
is diﬀerent from establishing a new binding. Constructs for establishing new
bindings of variables are described in section <a 
href="clmse39.html#x51-1060007.5">7.5<!--tex4ht:ref: VAR-BINDING-SECTION --></a>.
<!--l. 795--><p class="indent" >   Следующая функциональность позволяет изменять значение переменной
                                                                          

                                                                          
(если быть точнее, значению соединенному с текущим связыванием
переменной). Такое изменение отличается от создания нового связывания.
Конструкции для создания новых связываний переменных описаны в
разделе <a 
href="clmse39.html#x51-1060007.5">7.5<!--tex4ht:ref: VAR-BINDING-SECTION --></a>.
<div class=defspec>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> setq </b><a 
 id="dx47-90001"></a><a 
 id="x47-90002r61"></a> {var form}*
</td></tr></table>
<!--l. 803--><p class="indent" >
</div>
<!--l. 803--><p class="noindent" ><span class="paragraphHead"><a 
 id="x47-910007.1.2"></a></span>
   The special form (setq <i>var1</i> <i>form1</i> <i>var2</i> <i>form2</i> ...) is the “simple variable
assignment statement” of Lisp. First <i>form1</i> is evaluated and the result is stored in
the variable <i>var1</i>, then <i>form2</i> is evaluated and the result stored in <i>var2</i>, and so
forth. The variables are represented as symbols, of course, and are interpreted
as referring to static or dynamic instances according to the usual rules.
Therefore <a 
href="#x47-90002r61">setq</a> may be used for assignment of both lexical and special
variables.
<!--l. 814--><p class="indent" >   Специальная форма (setq <i>var1</i> <i>form1</i> <i>var2</i> <i>form2</i> ...) является
«конструкцией присваивания простых переменных» Lisp&#x2019;а. Вычисляется
первая форма <i>form1</i> и результат сохраняется в переменной <i>var1</i>,
затем вычисляется <i>form2</i> и результат сохраняется в переменной <i>var2</i>,
и так далее. Переменные, конечно же, представлены символами, и
интерпретируются как ссылки к динамическим или статическим переменным
в соответствии с обычными правилами. Таким образов <a 
href="#x47-90002r61">setq</a> может быть
использована для присваивания как лексических, так и специальных
переменных.
<!--l. 824--><p class="indent" >   <a 
href="#x47-90002r61">setq</a> returns the last value assigned, that is, the result of the evaluation of its
last argument. As a boundary case, the form (setq) is legal and returns
<a 
href="clmse31.html#x42-77002r19">nil</a>. There must be an even number of argument forms. For example, in <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x (+ 3 2 1) y (cons x nil))
</td></tr></table>
<!--l. 831--><p class="indent" >
</div>
</div>
<!--l. 832--><p class="noindent" >x is set to 6, y is set to (6), and the <a 
href="#x47-90002r61">setq</a> returns (6). Note that the ﬁrst assignment is
performed before the second form is evaluated, allowing that form to use the new
value of x.
<!--l. 837--><p class="indent" >   <a 
href="#x47-90002r61">setq</a> возвращает последнее присваиваемое значение, другими словами,
результат вычисления последнего аргумента. В другом случае, форма (setq)
является корректной и возвращает <a 
href="clmse31.html#x42-77002r19">nil</a>. В форме должно быть четное
количество форм аргументов. Например, в <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x (+ 3 2 1) y (cons x nil))
</td></tr></table>
<!--l. 844--><p class="indent" >
</div>
</div>
<!--l. 845--><p class="noindent" >x устанавливается в 6, y в (6), и <a 
href="#x47-90002r61">setq</a> возвращает (6). Следует отметить, что
первое присваивание выполняется перед тем, как будет выполнено второе,
тем самым каждое следующее присваивание может использовать значение
предыдущих.
<!--l. 850--><p class="indent" >   See also the description of <a 
href="clmse36.html#x48-93002r66">setf</a>, the Common Lisp “general assignment
statement” that is capable of assigning to variables, array elements, and other
locations.
<!--l. 854--><p class="indent" >   Смотрите также описание <a 
href="clmse36.html#x48-93002r66">setf</a>, «общая конструкция присваивания»
Common Lisp&#x2019;а, которая позволяет присваивать значения переменным,
элементам массива, и другим местам.
<div class=newer>
<!--l. 859--><p class="indent" >   Some programmers choose to avoid <a 
href="#x47-90002r61">setq</a> as a matter of style, always using <a 
href="clmse36.html#x48-93002r66">setf</a>
for any kind of structure modiﬁcation. Others use <a 
href="#x47-90002r61">setq</a> with simple variable names
and <a 
href="clmse36.html#x48-93002r66">setf</a> with all other generalized variables.
<!--l. 864--><p class="indent" >   Некоторые программисы выбирают путь отречения от <a 
href="#x47-90002r61">setq</a>, и всегда
используют <a 
href="clmse36.html#x48-93002r66">setf</a>. Другие используют <a 
href="#x47-90002r61">setq</a> для простых переменных и <a 
href="clmse36.html#x48-93002r66">setf</a> для
всех остальных.
                                                                          

                                                                          
</div>
<div class=new>
<!--l. 870--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-91001"></a>to specify that if any <i>var</i> refers not to an ordinary
variable but to a binding made by <a 
href="clmse39.html#x51-115002r96">symbol-macrolet</a>, then that <i>var</i> is handled as if
<a 
href="clmse36.html#x48-93002r66">setf</a> had been used instead of <a 
href="#x47-90002r61">setq</a>.
</div>
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> psetq </b><a 
 id="dx47-91002"></a><a 
 id="x47-91003r62"></a> {var form}*
</td></tr></table>
<!--l. 880--><p class="indent" >
</div>
<!--l. 880--><p class="noindent" ><span class="paragraphHead"><a 
 id="x47-920007.1.2"></a></span>
   A <a 
href="#x47-91003r62">psetq</a> form is just like a <a 
href="#x47-90002r61">setq</a> form, except that the assignments happen in
parallel. First all of the forms are evaluated, and then the variables are set to
the resulting values. The value of the <a 
href="#x47-91003r62">psetq</a> form is <a 
href="clmse31.html#x42-77002r19">nil</a>. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a 1)
</td></tr></table>
<!--l. 887--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq b 2)</td></tr></table>
<!--l. 888--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(psetq a b b a)</td></tr></table>
<!--l. 889--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">a  ⇒ 2</td></tr></table>
<!--l. 890--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">b  ⇒ 1</td></tr></table>
<!--l. 892--><p class="indent" >
</div>
</div>
<!--l. 893--><p class="noindent" >In this example, the values of a and b are exchanged by using parallel assignment. (If
several variables are to be assigned in parallel in the context of a loop, the <a 
href="clmse142.html#x173-366002r881">do</a>
construct may be appropriate.)
                                                                          

                                                                          
<!--l. 898--><p class="indent" >   Форма <a 
href="#x47-91003r62">psetq</a> похожа на форму <a 
href="#x47-90002r61">setq</a> за исключением того, что выполняет
присваивание параллельно. Сначала выполняются все формы, а затем
переменные получают значения этих форм. Значение формы <a 
href="#x47-91003r62">psetq</a> <a 
href="clmse31.html#x42-77002r19">nil</a>.
Например: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a 1)
</td></tr></table>
<!--l. 903--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq b 2)</td></tr></table>
<!--l. 904--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(psetq a b b a)</td></tr></table>
<!--l. 905--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">a  ⇒ 2</td></tr></table>
<!--l. 906--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">b  ⇒ 1</td></tr></table>
<!--l. 908--><p class="indent" >
</div>
</div>
<!--l. 909--><p class="noindent" >В этом примере, значения a и b меняются местами с помощью параллельного
присваивания. (Если несколько переменных должны быть присвоены
параллельно в рамках цикла, целесообразнее использовать конструкцию
<a 
href="clmse142.html#x173-366002r881">do</a>.)
<!--l. 914--><p class="indent" >   See also the description of <a 
href="clmse36.html#x48-94016r67">psetf</a>, the Common Lisp “general parallel
assignment statement” that is capable of assigning to variables, array elements,
and other locations.
<!--l. 919--><p class="indent" >   Смотрите также описание <a 
href="clmse36.html#x48-94016r67">psetf</a>, «общая конструкция параллельного
присваивания» Common Lisp&#x2019;а, которая позволяет присваивать переменным,
элементам массива, и другим местам.
<div class=newer>
<!--l. 924--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-92001"></a>to specify that if any <i>var</i> refers not to an ordinary
variable but to a binding made by <a 
href="clmse39.html#x51-115002r96">symbol-macrolet</a>, then that <i>var</i> is handled as if
<a 
href="clmse36.html#x48-94016r67">psetf</a> had been used instead of <a 
href="#x47-91003r62">psetq</a>.
</div>
</div>
<div class=defun>
<!--l. 932--><p class="noindent" ><i>[Function]</i><a 
 id="dx47-92002"></a><a 
 id="x47-92003r63"></a><b> set</b>  <i>symbol</i> <i>value</i>
<!--l. 934--><p class="noindent" ><a 
href="#x47-92003r63">set</a> allows alteration of the value of a dynamic (special) variable. <a 
href="#x47-92003r63">set</a> causes the
dynamic variable named by <i>symbol</i> to take on <i>value</i> as its value.
<!--l. 939--><p class="indent" >   <a 
href="#x47-92003r63">set</a> позвляет изменить значение динамической (специальной) переменной.
<a 
href="#x47-92003r63">set</a> устанавливает динамической переменной с именем <i>symbol</i> значение
<i>value</i>.
                                                                          

                                                                          
<div class=new>
<!--l. 944--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx47-92004"></a>to clarify that the <i>value</i> may be any Lisp datum
whatsoever.
</div>
<!--l. 950--><p class="indent" >   Only the value of the current dynamic binding is altered; if there are no
bindings in eﬀect, the most global value is altered. For example, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set (if (eq a b) &#x2019;c &#x2019;d) &#x2019;foo)
</td></tr></table>
<!--l. 955--><p class="indent" >
</div>
</div>
<!--l. 956--><p class="noindent" >will either set c to foo or set d to foo, depending on the outcome of the test
(eq a b).
<!--l. 959--><p class="indent" >   Изменено будет только значение текущего динамического связывания.
Если такого связывания нет, будет изменено наиболее глобальное значение.
Например, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set (if (eq a b) &#x2019;c &#x2019;d) &#x2019;foo)
</td></tr></table>
<!--l. 964--><p class="indent" >
</div>
</div>
<!--l. 965--><p class="noindent" >установит значение с в foo или <a 
href="clmse42.html#x54-132005r110">do*</a> в foo, в зависимости от результата проверки
(eq a b).
<!--l. 968--><p class="indent" >   <a 
href="#x47-92003r63">set</a> returns <i>value</i> as its result.
<!--l. 970--><p class="indent" >   <a 
href="#x47-92003r63">set</a> в качестве результата возвращает значение <i>value</i>.
<!--l. 972--><p class="indent" >   <a 
href="#x47-92003r63">set</a> cannot alter the value of a local (lexically bound) variable. The special
form <a 
href="#x47-90002r61">setq</a> is usually used for altering the values of variables (lexical or dynamic) in
programs. <a 
href="#x47-92003r63">set</a> is particularly useful for implementing interpreters for languages
embedded in Lisp. See also <a 
href="clmse39.html#x51-112003r89">progv</a>, a construct that performs binding rather than
assignment of dynamic variables.
<!--l. 982--><p class="indent" >   <a 
href="#x47-92003r63">set</a> не может изменить значение локальной (лексически связанной)
переменной. Обычно для изменеия переменных (лексических или
динамических) используется специальная форма <a 
href="#x47-90002r61">setq</a>. <a 
href="#x47-92003r63">set</a> полезна в частности
                                                                          

                                                                          
для реализации интерпретаторов языков встроенных в Lisp. Смотрите также
<a 
href="clmse39.html#x51-112003r89">progv</a>, конструкция, которая создает связывания, а не присваивания
динамических переменных.
</div>
<div class=defun>
<!--l. 992--><p class="noindent" ><i>[Function]</i><a 
 id="dx47-92005"></a><a 
 id="x47-92006r64"></a><b> makunbound</b>  <i>symbol</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx47-92007"></a><a 
 id="x47-92008r65"></a><b> fmakunbound</b>  <i>symbol</i>
<!--l. 995--><p class="noindent" ><a 
href="#x47-92006r64">makunbound</a> causes the dynamic (special) variable named by <i>symbol</i>
to become unbound (have no value). <a 
href="#x47-92008r65">fmakunbound</a> does the analogous
thing for the global function deﬁnition named by <i>symbol</i>. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a 1)
</td></tr></table>
<!--l. 1002--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">a  ⇒ 1</td></tr></table>
<!--l. 1003--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(makunbound &#x2019;a)</td></tr></table>
<!--l. 1004--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">a  ⇒ causes an error</td></tr></table>
<!--l. 1005--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1006--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun foo (x) (+ x 1))</td></tr></table>
<!--l. 1007--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(foo 4)  ⇒ 5</td></tr></table>
<!--l. 1008--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(fmakunbound &#x2019;foo)</td></tr></table>
<!--l. 1009--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(foo 4)  ⇒ causes an error</td></tr></table>
<!--l. 1011--><p class="indent" >
</div>
</div>
<!--l. 1012--><p class="noindent" >Both functions return <i>symbol</i> as the result value.
<!--l. 1014--><p class="indent" >   <a 
href="#x47-92006r64">makunbound</a> упраздняет связывание динамической (специальной)
переменной заданной символом <i>symbol</i> (упраздняет значение). <a 
href="#x47-92008r65">fmakunbound</a>
аналогично упраздняет связь символа с глобальным определением функции.
Например: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a 1)
</td></tr></table>
<!--l. 1019--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">a  ⇒ 1</td></tr></table>
<!--l. 1020--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(makunbound &#x2019;a)</td></tr></table>
<!--l. 1021--><p class="indent" >                                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">a  ⇒ ошибка</td></tr></table>
                                                                          

                                                                          
<!--l. 1022--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1023--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun foo (x) (+ x 1))</td></tr></table>
<!--l. 1024--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(foo 4)  ⇒ 5</td></tr></table>
<!--l. 1025--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(fmakunbound &#x2019;foo)</td></tr></table>
<!--l. 1026--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(foo 4)  ⇒ ошибка</td></tr></table>
<!--l. 1028--><p class="indent" >
</div>
</div>
<!--l. 1029--><p class="noindent" >Обе функции возвращают символ <i>symbol</i> в качестве результата.
<div class=newer>
<!--l. 1032--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-92009"></a>to extend <a 
href="#x47-92008r65">fmakunbound</a> to accept any
function-name (a symbol or a list whose <i>car</i> is <a 
href="clmse36.html#x48-93002r66">setf</a>—see section <a 
href="#x47-860007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). Thus one
may write (fmakunbound &#x2019;(setf cadr)) to remove any global deﬁnition of a <a 
href="clmse36.html#x48-93002r66">setf</a>
expansion function for <a 
href="clmse86.html#x106-224008r447">cadr</a>.
</div>
</div>
                                                                          

                                                                          
   <!--l. 1040--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse36.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#tailclmch7.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse35.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 1040--><p class="indent" >   <a 
 id="tailclmse35.html"></a>   
</body></html> 
