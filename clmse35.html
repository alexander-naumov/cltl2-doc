<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Constants and Variables</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-22 17:23:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 65--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse36.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#tailclmch7.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse35.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse35.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">7.1   </span> <a 
 id="x47-770007.1"></a>Constants and Variables</h3>
<!--l. 68--><p class="noindent" >Because some Lisp data objects are used to represent programs, one cannot
always notate a constant data object in a program simply by writing the notation
for the object unadorned; it would be ambiguous whether a constant object or a
program fragment was intended. The <a 
href="#x47-78002r53">quote</a> special form resolves this
ambiguity.
<!--l. 74--><p class="indent" >   There are two kinds of variables in Common Lisp, in eﬀect: ordinary
variables and function names. There are some similarities between the
two kinds, and in a few cases there are similar functions for dealing with
them, for example <a 
href="#x47-78013r58">boundp</a> and <a 
href="#x47-78015r59">fboundp</a>. However, for the most part the
                                                                          

                                                                          
two kinds of variables are used for very diﬀerent purposes: one to name
deﬁned functions, macros, and special forms, and the other to name data
objects.
<div class=newer>
<!--l. 83--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to introduce the concept of a <i>function-name</i>,
which may be either a symbol or a two-element list whose ﬁrst element is the
symbol <a 
href="clmse36.html#x48-80002r66">setf</a> and whose second element is a symbol. The primary purpose of this is
to allow <a 
href="clmse36.html#x48-80002r66">setf</a> expander functions to be CLOS generic functions with user-deﬁned
methods. Many places in Common Lisp that used to require a symbol
for a function name are changed to allow 2-lists as well; for example,
<a 
href="clmse30.html#x40-66002r13">defun</a> is changed so that one may write <i>(defun (setf foo) ...)</i>, and the
<a 
href="#x47-78004r54">function</a> special form is changed to accept any function-name. See also
<a 
href="#x47-78011r57">fdeﬁnition</a>.
<!--l. 94--><p class="indent" >   By convention, any function named <i>(setf <i>f </i>)</i> should return its ﬁrst argument as
its only value, in order to preserve the speciﬁcation that <a 
href="clmse36.html#x48-80002r66">setf</a> returns its <i>newvalue</i>.
See <a 
href="clmse36.html#x48-80002r66">setf</a>.
<!--l. 98--><p class="indent" >   Implementations are free to extend the syntax of function-names to include
lists beginning with additional symbols other than <a 
href="clmse36.html#x48-80002r66">setf</a> or lambda.
</div>
<!--l. 103--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.1.1   </span> <a 
 id="x47-780007.1.1"></a>Reference</h4>
<!--l. 105--><p class="noindent" >The value of an ordinary variable may be obtained simply by writing the name of
the variable as a form to be executed. Whether this is treated as the name of a
special variable or a lexical variable is determined by the presence or absence of
an applicable special declaration; see chapter <a 
href="clmch9.html#x64-1030009">9<!--tex4ht:ref: DECLAR --></a>.
<!--l. 112--><p class="indent" >   The following functions and special forms allow reference to the values of
constants and variables in other ways.
<div class=defspec>
<!--l. 116--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> quote </b> <a 
 id="dx47-78001"></a><a 
 id="x47-78002r53"></a>   object
</td></tr></table>
<!--l. 117--><p class="indent" >
</div>
                                                                          

                                                                          
   <i>(quote <i>x</i>)</i> simply returns <i>x</i>. The <i>object</i> is not evaluated and may be any Lisp
object whatsoever. This construct allows any Lisp object to be written as a
constant value in a program. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a 43)
</td></tr></table>
<!--l. 124--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list a (cons a 3))  ⇒ (43 (43 . 3))</td></tr></table>
<!--l. 125--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list (quote a) (quote (cons a 3))  ⇒ (a (cons a 3))</td></tr></table>
<!--l. 127--><p class="indent" >
</div>
</div>
<!--l. 128--><p class="noindent" >Since <a 
href="#x47-78002r53">quote</a> forms are so frequently useful but somewhat cumbersome to type, a
standard abbreviation is deﬁned for them: any form <i>f </i> preceded by a single quote
(<i> &#x2019; </i>) character is assumed to have <i>(quote  )</i> wrapped around it to make <i>(quote <i>f</i>)</i>.
For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x &#x2019;(the magic quote hack))
</td></tr></table>
<!--l. 136--><p class="indent" >
</div>
</div>
<!--l. 137--><p class="noindent" >is normally interpreted by <a 
href="clmse116.html#x143-195002r694">read</a> to mean <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x (quote (the magic quote hack)))
</td></tr></table>
<!--l. 140--><p class="indent" >
</div>
</div>
<!--l. 141--><p class="noindent" >See section <a 
href="clmse115.html#x142-19000022.1.3">22.1.3<!--tex4ht:ref: MACRO-CHARACTERS-SECTION --></a>.
<div class=newer>
<!--l. 144--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to clarify that it is an error to destructively
modify any object that appears as a constant in executable code, whether within
a <a 
href="#x47-78002r53">quote</a> special form or as a self-evaluating form.
                                                                          

                                                                          
<!--l. 149--><p class="indent" >   See section <a 
href="clmse127.html#x157-22400025.1">25.1<!--tex4ht:ref: COMPILER-SECTION --></a> for a discussion of how quoted constants are treated by the
compiler.
</div>
<div class=newer>
<!--l. 154--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that <a 
href="clmse110.html#x135-180002r618">eval</a> and <a 
href="clmse127.html#x157-224002r795">compile</a> are not
permitted either to copy or to coalesce (“collapse”) constants (see <a 
href="clmse33.html#x44-74002r46">eq</a>) appearing in
the code they process; the resulting program behavior must refer to objects
that are <a 
href="clmse33.html#x44-74004r47">eql</a> to the corresponding objects in the source code. Moreover,
the constraints introduced by the votes on issues ⟨<b>?</b>⟩ and ⟨<b>?</b>⟩ on what
kinds of objects may appear as constants apply only to <a 
href="clmse127.html#x157-224006r797">compile-ﬁle</a> (see
section <a 
href="clmse127.html#x157-22400025.1">25.1<!--tex4ht:ref: COMPILER-SECTION --></a>).
</div>
</div>
<div class=defspec>
<!--l. 169--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> function </b> <a 
 id="dx47-78003"></a><a 
 id="x47-78004r54"></a>   fn
</td></tr></table>
<!--l. 170--><p class="indent" >
</div>
   The value of <a 
href="#x47-78004r54">function</a> is always the functional interpretation of <i>fn</i>; <i>fn</i> is
interpreted as if it had appeared in the functional position of a function
invocation. In particular, if <i>fn</i> is a symbol, the functional deﬁnition associated
with that symbol is returned; see <a 
href="#x47-78009r56">symbol-function</a>. If <i>fn</i> is a lambda-expression,
then a “lexical closure” is returned, that is, a function that when invoked will
execute the body of the lambda-expression in such a way as to observe the rules of
lexical scoping properly.
<div class=newer>
   X3J13 voted in June 1988 ⟨<b>?</b>⟩ to specify that the result of a <a 
href="#x47-78004r54">function</a> special
form is always of type <a 
href="#x47-78004r54">function</a>. This implies that a form <i>(function <i>fn</i>)</i> may be
interpreted as <i>(the (function <i>fn</i>))</i>.
   It is an error to use the <a 
href="#x47-78004r54">function</a> special form on a symbol that does not
denote a function in the lexical or global environment in which the special form
appears. Speciﬁcally, it is an error to use the <a 
href="#x47-78004r54">function</a> special form on a symbol
that denotes a macro or special form. Some implementations may choose not
to signal this error for performance reasons, but implementations are
forbidden to extend the semantics of <a 
href="#x47-78004r54">function</a> in this respect; that is, an
                                                                          

                                                                          
implementation is not allowed to deﬁne the failure to signal an error to be a
“useful” behavior.
</div>
<div class=newer>
   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to extend <a 
href="#x47-78004r54">function</a> to accept any function-name (a
symbol or a list whose <i>car</i> is <a 
href="clmse36.html#x48-80002r66">setf</a>—see section <a 
href="#x47-770007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>) as well as lambda-expressions.
Thus one may write <i>(function (setf cadr))</i> to refer to the <a 
href="clmse36.html#x48-80002r66">setf</a> expansion function
for <a 
href="clmse86.html#x106-148008r445">cadr</a>.
</div>
<a 
 id="dx47-78005"></a>
   For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun adder (x) (function (lambda (y) (+ x y))))
</td></tr></table>
<!--l. 212--><p class="indent" >
</div>
</div>
<!--l. 213--><p class="noindent" >The result of <i>(adder 3)</i> is a function that will add <i>3</i> to its argument: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq add3 (adder 3))
</td></tr></table>
<!--l. 216--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall add3 5)  ⇒ 8</td></tr></table>
<!--l. 218--><p class="indent" >
</div>
</div>
<!--l. 219--><p class="noindent" >This works because <a 
href="#x47-78004r54">function</a> creates a closure of the inner lambda-expression that is
able to refer to the value <i>3</i> of the variable x even after control has returned from
the function adder.
<!--l. 224--><p class="indent" >   More generally, a lexical closure in eﬀect retains the ability to refer to lexically
visible <i>bindings</i>, not just values. Consider this code: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun two-funs (x)
</td></tr></table>
<!--l. 228--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (list (function (lambda () x))</td></tr></table>
<!--l. 229--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (function (lambda (y) (setq x y)))))</td></tr></table>
                                                                          

                                                                          
<!--l. 230--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq funs (two-funs 6))</td></tr></table>
<!--l. 231--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall (car funs))  ⇒ 6</td></tr></table>
<!--l. 232--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall (cadr funs) 43)  ⇒ 43</td></tr></table>
<!--l. 233--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall (car funs))  ⇒ 43</td></tr></table>
<!--l. 235--><p class="indent" >
</div>
</div>
<!--l. 236--><p class="noindent" >The function two-funs returns a list of two functions, each of which refers to the
<i>binding</i> of the variable x created on entry to the function two-funs when it was
called with argument <i>6</i>. This binding has the value <i>6</i> initially, but <a 
href="#x47-79002r61">setq</a> can alter a
binding. The lexical closure created for the ﬁrst lambda-expression does not
“snapshot” the value <i>6</i> for x when the closure is created. The second function can
be used to alter the binding (to <i>43</i>, in the example), and this altered value then
becomes accessible to the ﬁrst function.
<!--l. 246--><p class="indent" >   In situations where a closure of a lambda-expression over the same set of
bindings may be produced more than once, the various resulting closures may or
may not be <a 
href="clmse33.html#x44-74002r46">eq</a>, at the discretion of the implementation. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((x 5) (funs &#x2019;()))
</td></tr></table>
<!--l. 251--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 252--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (push #&#x2019;(lambda (z)</td></tr></table>
<!--l. 253--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (if (null z) (setq x 0) (+ x z)))</td></tr></table>
<!--l. 254--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          funs))</td></tr></table>
<!--l. 255--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 257--><p class="indent" >
</div>
</div>
<!--l. 258--><p class="noindent" >The result of the above expression is a list of ten closures. Each logically requires only
the binding of x. It is the same binding in each case, so the ten closures may or
may not be the same identical (<a 
href="clmse33.html#x44-74002r46">eq</a>) object. On the other hand, the result of the
expression <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((funs &#x2019;()))
</td></tr></table>
<!--l. 264--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 265--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((x 5))</td></tr></table>
<!--l. 266--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (push (function (lambda (z)</td></tr></table>
<!--l. 267--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                        (if (null z) (setq x 0) (+ x z))))</td></tr></table>
<!--l. 268--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            funs)))</td></tr></table>
<!--l. 269--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 271--><p class="indent" >
</div>
</div>
<!--l. 272--><p class="noindent" >is also a list of ten closures. However, in this case no two of the closures may be <a 
href="clmse33.html#x44-74002r46">eq</a>,
because each closure is over a distinct binding of x, and these bindings can be
behaviorally distinguished because of the use of <a 
href="#x47-79002r61">setq</a>.
<!--l. 277--><p class="indent" >   The question of distinguishable behavior is important; the result of the simpler
expression <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((funs &#x2019;()))
</td></tr></table>
<!--l. 280--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
<!--l. 281--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((x 5))</td></tr></table>
<!--l. 282--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (push (function (lambda (z) (+ x z)))</td></tr></table>
<!--l. 283--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            funs)))</td></tr></table>
<!--l. 284--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 286--><p class="indent" >
</div>
</div>
<!--l. 287--><p class="noindent" >is a list of ten closures that <i>may</i> be pairwise <a 
href="clmse33.html#x44-74002r46">eq</a>. Although one might think that a
diﬀerent binding of x is involved for each closure (which is indeed the case), the
bindings cannot be distinguished because their values are identical and
immutable, there being no occurrence of <a 
href="#x47-79002r61">setq</a> on x. A compiler would therefore be
justiﬁed in transforming the expression to <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((funs &#x2019;()))
</td></tr></table>
<!--l. 294--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dotimes (j 10)</td></tr></table>
                                                                          

                                                                          
<!--l. 295--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (push (function (lambda (z) (+ 5 z)))</td></tr></table>
<!--l. 296--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          funs))</td></tr></table>
<!--l. 297--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  funs)</td></tr></table>
<!--l. 299--><p class="indent" >
</div>
</div>
<!--l. 300--><p class="noindent" >where clearly the closures may be the same after all. The general rule, then, is that
the implementation is free to have two distinct evaluations of the same <a 
href="#x47-78004r54">function</a>
form produce identical (<a 
href="clmse33.html#x44-74002r46">eq</a>) closures if it can prove that the two conceptually
distinct resulting closures must in fact be behaviorally identical with respect to
invocation. This is merely a permitted optimization; a perfectly valid
implementation might simply cause every distinct evaluation of a <a 
href="#x47-78004r54">function</a> form to
produce a new closure object not <a 
href="clmse33.html#x44-74002r46">eq</a> to any other.
<!--l. 310--><p class="indent" >   Frequently a compiler can deduce that a closure in fact does not need
to close over any variable bindings. For example, in the code fragment <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapcar (function (lambda (x) (+ x 2))) y)
</td></tr></table>
<!--l. 315--><p class="indent" >
</div>
</div>
<!--l. 316--><p class="noindent" >the function <i>(lambda (x) (+ x 2))</i> contains no references to any outside entity. In this
important special case, the same “closure” may be used as the value for all
evaluations of the <a 
href="#x47-78004r54">function</a> special form. Indeed, this value need not be a closure
object at all; it may be a simple compiled function containing no environment
information. This example is simply a special case of the foregoing discussion and
is included as a hint to implementors familiar with previous methods of
implementing Lisp. The distinction between closures and other kinds of functions
is somewhat pointless, actually, as Common Lisp deﬁnes no particular
representation for closures and no way to distinguish between closures and
non-closure functions. All that matters is that the rules of lexical scoping be
obeyed.
<!--l. 329--><p class="indent" >   Since <a 
href="#x47-78004r54">function</a> forms are so frequently useful but somewhat cumbersome to
type, a standard abbreviation is deﬁned for them: any form <i>f </i> preceded by <i>#&#x2019;</i> (<i>#</i>
followed by an apostrophe) is assumed to have <i>(function )</i> wrapped around it to
make <i>(function <i>f</i>)</i>. For example, <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-if #&#x2019;numberp &#x2019;(1 a b 3))
</td></tr></table>
<!--l. 336--><p class="indent" >
</div>
</div>
<!--l. 337--><p class="noindent" >is normally interpreted by <a 
href="clmse116.html#x143-195002r694">read</a> to mean <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-if (function numberp) &#x2019;(1 a b 3))
</td></tr></table>
<!--l. 340--><p class="indent" >
</div>
</div>
<!--l. 341--><p class="noindent" >See section <a 
href="clmse115.html#x142-19100022.1.4">22.1.4<!--tex4ht:ref: SHARP-SIGN-MACRO-CHARACTER-SECTION --></a>.
</div>
<div class=defun>
<!--l. 344--><p class="noindent" > <i>[Function]</i>   <b>symbol-value</b> <a 
 id="dx47-78006"></a><a 
 id="x47-78007r55"></a>   <i>symbol</i>
<!--l. 346--><p class="noindent" ><a 
href="#x47-78007r55">symbol-value</a> returns the current value of the dynamic (special) variable
named by <i>symbol</i>. An error occurs if the symbol has no value; see <a 
href="#x47-78013r58">boundp</a>
and <a 
href="#x47-79008r64">makunbound</a>. Note that constant symbols are really variables that
cannot be changed, and so <a 
href="#x47-78007r55">symbol-value</a> may be used to get the value of a
named constant. In particular, <a 
href="#x47-78007r55">symbol-value</a> of a keyword will return that
keyword.
<!--l. 356--><p class="indent" >   <a 
href="#x47-78007r55">symbol-value</a> cannot access the value of a lexical variable.
<!--l. 358--><p class="indent" >   This function is particularly useful for implementing interpreters for languages
embedded in Lisp. The corresponding assignment primitive is <a 
href="#x47-79006r63">set</a>; alternatively,
<a 
href="#x47-78007r55">symbol-value</a> may be used with <a 
href="clmse36.html#x48-80002r66">setf</a>.
</div>
<div class=defun>
<!--l. 364--><p class="noindent" > <i>[Function]</i>   <b>symbol-function</b> <a 
 id="dx47-78008"></a><a 
 id="x47-78009r56"></a>   <i>symbol</i>
<!--l. 366--><p class="noindent" ><a 
href="#x47-78009r56">symbol-function</a> returns the current global function deﬁnition named by
<i>symbol</i>. An error is signalled if the symbol has no function deﬁnition; see
<a 
href="#x47-78015r59">fboundp</a>. Note that the deﬁnition may be a function or may be an object
representing a special form or macro. In the latter case, however, it is an error to
attempt to invoke the object as a function. If it is desired to process macros,
special forms, and functions equally well, as when writing an interpreter, it
                                                                          

                                                                          
is best ﬁrst to test the symbol with <a 
href="clmse46.html#x59-98004r134">macro-function</a> and <a 
href="#x47-78017r60">special-form-p</a>
and then to invoke the functional value only if these two tests both yield
false.
<!--l. 380--><p class="indent" >   This function is particularly useful for implementing interpreters for languages
embedded in Lisp.
<!--l. 383--><p class="indent" >   <a 
href="#x47-78009r56">symbol-function</a> cannot access the value of a lexical function name produced
by ﬂet or <a 
href="clmse39.html#x51-83022r93">labels</a>; it can access only the global function value.
<!--l. 387--><p class="indent" >   The global function deﬁnition of a symbol may be altered by using <a 
href="clmse36.html#x48-80002r66">setf</a> with
<a 
href="#x47-78009r56">symbol-function</a>. Performing this operation causes the symbol to have <i>only</i> the
speciﬁed deﬁnition as its global function deﬁnition; any previous deﬁnition,
whether as a macro or as a function, is lost. It is an error to attempt to redeﬁne
the name of a special form (see table <a 
href="clmse28.html#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>). <div class=newer> X3J13 voted in June 1988 ⟨<b>?</b>⟩ to
clarify the behavior of <a 
href="#x47-78009r56">symbol-function</a> in the light of the redeﬁnition of the type
<a 
href="#x47-78004r54">function</a>.
      <ul class="itemize1">
      <li class="itemize">It  is  permissible  to  call  <a 
href="#x47-78009r56">symbol-function</a>  on  any  symbol  for  which
      <a 
href="#x47-78015r59">fboundp</a> returns true. Note that <a 
href="#x47-78015r59">fboundp</a> must return true for a symbol
      naming a macro or a special form.
      </li>
      <li class="itemize">If <a 
href="#x47-78015r59">fboundp</a> returns true for a symbol but the symbol denotes a macro
      or  special  form,  then  the  value  returned  by  <a 
href="#x47-78009r56">symbol-function</a>  is  not
      well-deﬁned but <a 
href="#x47-78009r56">symbol-function</a> will not signal an error.
      </li>
      <li class="itemize">When <a 
href="#x47-78009r56">symbol-function</a> is used with <a 
href="clmse36.html#x48-80002r66">setf</a> the new value must be of type
      <a 
href="#x47-78004r54">function</a>. It is an error to set the <a 
href="#x47-78009r56">symbol-function</a> of a symbol to a
      symbol, a list, or the value returned by <a 
href="#x47-78009r56">symbol-function</a> on the name
      of a macro or a special form.</li></ul>
</div>
</div>
<div class=newer>
<div class=defun>
<!--l. 418--><p class="noindent" > <i>[Function]</i>   <b>fdeﬁnition</b> <a 
 id="dx47-78010"></a><a 
 id="x47-78011r57"></a>   <i>function-name</i>
<!--l. 420--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to add the function <a 
href="#x47-78011r57">fdeﬁnition</a> to the language.
It is exactly like <a 
href="#x47-78009r56">symbol-function</a> except that its argument may be any
function-name (a symbol or a list whose <i>car</i> is <a 
href="clmse36.html#x48-80002r66">setf</a>—see section <a 
href="#x47-770007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>); it returns
                                                                          

                                                                          
the current global function deﬁnition named by the argument <i>function-name</i>. One
may use <a 
href="#x47-78011r57">fdeﬁnition</a> with <a 
href="clmse36.html#x48-80002r66">setf</a> to change the current global function deﬁnition
associated with a function-name.
</div>
</div>
<div class=defun>
<!--l. 434--><p class="noindent" > <i>[Function]</i>   <b>boundp</b> <a 
 id="dx47-78012"></a><a 
 id="x47-78013r58"></a>   <i>symbol</i>
<!--l. 436--><p class="noindent" ><a 
href="#x47-78013r58">boundp</a> is true if the dynamic (special) variable named by <i>symbol</i> has a value;
otherwise, it returns <a 
href="clmse31.html#x42-70002r19">nil</a>.
<!--l. 440--><p class="indent" >   See also <a 
href="#x47-79006r63">set</a> and <a 
href="#x47-79008r64">makunbound</a>.
</div>
<div class=defun>
<!--l. 443--><p class="noindent" > <i>[Function]</i>   <b>fboundp</b> <a 
 id="dx47-78014"></a><a 
 id="x47-78015r59"></a>   <i>symbol</i>
<!--l. 445--><p class="noindent" ><a 
href="#x47-78015r59">fboundp</a> is true if the symbol has a global function deﬁnition. Note that <a 
href="#x47-78015r59">fboundp</a>
is true when the symbol names a special form or macro. <a 
href="clmse46.html#x59-98004r134">macro-function</a> and
<a 
href="#x47-78017r60">special-form-p</a> may be used to test for these cases.
<div class=newer>
<!--l. 452--><p class="indent" >   X3J13 voted in June 1988 ⟨<b>?</b>⟩ to emphasize that, despite the tightening of the
deﬁnition of the type <a 
href="#x47-78004r54">function</a>, <a 
href="#x47-78015r59">fboundp</a> must return true when the argument
names a special form or macro.
</div>
<!--l. 458--><p class="indent" >   See also <a 
href="#x47-78009r56">symbol-function</a> and <a 
href="#x47-79010r65">fmakunbound</a>.
<div class=newer>
<!--l. 461--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to extend <a 
href="#x47-78015r59">fboundp</a> to accept any function-name
(a symbol or a list whose <i>car</i> is <a 
href="clmse36.html#x48-80002r66">setf</a>—see section <a 
href="#x47-770007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). Thus one may write
<i>(fboundp &#x2019;(setf cadr))</i> to determine whether a <a 
href="clmse36.html#x48-80002r66">setf</a> expansion function has been
globally deﬁned for <a 
href="clmse86.html#x106-148008r445">cadr</a>.
</div>
</div>
<div class=defun>
<!--l. 470--><p class="noindent" > <i>[Function]</i>   <b>special-form-p</b> <a 
 id="dx47-78016"></a><a 
 id="x47-78017r60"></a>   <i>symbol</i>
<!--l. 472--><p class="noindent" >The function <a 
href="#x47-78017r60">special-form-p</a> takes a symbol. If the symbol globally names a
special form, then a non-<a 
href="clmse31.html#x42-70002r19">nil</a> value is returned; otherwise <a 
href="clmse31.html#x42-70002r19">nil</a> is returned. A
returned non-<a 
href="clmse31.html#x42-70002r19">nil</a> value is typically a function of implementation-dependent nature
that can be used to interpret (evaluate) the special form.
<!--l. 480--><p class="indent" >   It is possible for <i>both</i> <a 
href="#x47-78017r60">special-form-p</a> and <a 
href="clmse46.html#x59-98004r134">macro-function</a> to be true of a
symbol. This is possible because an implementation is permitted to implement
any macro also as a special form for speed. On the other hand, the macro
                                                                          

                                                                          
deﬁnition must be available for use by programs that understand only the
standard special forms listed in table <a 
href="clmse28.html#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>.
</div>
<!--l. 488--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.1.2   </span> <a 
 id="x47-790007.1.2"></a>Assignment</h4>
<!--l. 490--><p class="noindent" >The following facilities allow the value of a variable (more speciﬁcally, the value
associated with the current binding of the variable) to be altered. Such alteration
is diﬀerent from establishing a new binding. Constructs for establishing new
bindings of variables are described in section <a 
href="clmse39.html#x51-830007.5">7.5<!--tex4ht:ref: VAR-BINDING-SECTION --></a>.
<div class=defspec>
<!--l. 497--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> setq </b> <a 
 id="dx47-79001"></a><a 
 id="x47-79002r61"></a>   {<i>varform</i>}∗
</td></tr></table>
<!--l. 498--><p class="indent" >
</div>
   The special form <i>(setq <i>var1</i> <i>form1</i> <i>var2</i> <i>form2</i> ...)</i> is the “simple variable
assignment statement” of Lisp. First <i>form1</i> is evaluated and the result is stored in
the variable <i>var1</i>, then <i>form2</i> is evaluated and the result stored in <i>var2</i>, and so
forth. The variables are represented as symbols, of course, and are interpreted
as referring to static or dynamic instances according to the usual rules.
Therefore <a 
href="#x47-79002r61">setq</a> may be used for assignment of both lexical and special
variables.
   <a 
href="#x47-79002r61">setq</a> returns the last value assigned, that is, the result of the evaluation of its
last argument. As a boundary case, the form <i>(setq)</i> is legal and returns
<a 
href="clmse31.html#x42-70002r19">nil</a>. There must be an even number of argument forms. For example, in <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x (+ 3 2 1) y (cons x nil))
</td></tr></table>
<!--l. 516--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 517--><p class="noindent" >x is set to <i>6</i>, y is set to <i>(6)</i>, and the <a 
href="#x47-79002r61">setq</a> returns <i>(6)</i>. Note that the ﬁrst assignment is
performed before the second form is evaluated, allowing that form to use the new
value of x.
<!--l. 522--><p class="indent" >   See also the description of <a 
href="clmse36.html#x48-80002r66">setf</a>, the Common Lisp “general assignment
statement” that is capable of assigning to variables, array elements, and other
locations.
<div class=newer>
<!--l. 527--><p class="indent" >   Some programmers choose to avoid <a 
href="#x47-79002r61">setq</a> as a matter of style, always using <a 
href="clmse36.html#x48-80002r66">setf</a>
for any kind of structure modiﬁcation. Others use <a 
href="#x47-79002r61">setq</a> with simple variable names
and <a 
href="clmse36.html#x48-80002r66">setf</a> with all other generalized variables.
</div>
<div class=new>
<!--l. 534--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to specify that if any <i>var</i> refers not to an
ordinary variable but to a binding made by <a 
href="clmse39.html#x51-83024r94">symbol-macrolet</a>, then that <i>var</i> is
handled as if <a 
href="clmse36.html#x48-80002r66">setf</a> had been used instead of <a 
href="#x47-79002r61">setq</a>.
</div>
</div>
<div class=defmac>
<!--l. 543--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> psetq </b> <a 
 id="dx47-79003"></a><a 
 id="x47-79004r62"></a>   {<i>varform</i>}∗
</td></tr></table>
<!--l. 544--><p class="indent" >
</div>
   A <a 
href="#x47-79004r62">psetq</a> form is just like a <a 
href="#x47-79002r61">setq</a> form, except that the assignments happen in
parallel. First all of the forms are evaluated, and then the variables are set to
the resulting values. The value of the <a 
href="#x47-79004r62">psetq</a> form is <a 
href="clmse31.html#x42-70002r19">nil</a>. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a 1)
</td></tr></table>
<!--l. 551--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq b 2)</td></tr></table>
<!--l. 552--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(psetq a b b a)</td></tr></table>
<!--l. 553--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">a  ⇒ 2</td></tr></table>
<!--l. 554--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">b  ⇒ 1</td></tr></table>
<!--l. 556--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 557--><p class="noindent" >In this example, the values of a and b are exchanged by using parallel assignment. (If
several variables are to be assigned in parallel in the context of a loop, the <a 
href="clmse142.html#x173-249002r879">do</a>
construct may be appropriate.)
<!--l. 562--><p class="indent" >   See also the description of <a 
href="clmse36.html#x48-80004r67">psetf</a>, the Common Lisp “general parallel
assignment statement” that is capable of assigning to variables, array elements,
and other locations.
<div class=newer>
<!--l. 568--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to specify that if any <i>var</i> refers not to an
ordinary variable but to a binding made by <a 
href="clmse39.html#x51-83024r94">symbol-macrolet</a>, then that <i>var</i> is
handled as if <a 
href="clmse36.html#x48-80004r67">psetf</a> had been used instead of <a 
href="#x47-79004r62">psetq</a>.
</div>
</div>
<div class=defun>
<!--l. 576--><p class="noindent" > <i>[Function]</i>   <b>set</b> <a 
 id="dx47-79005"></a><a 
 id="x47-79006r63"></a>   <i>symbol</i>  <i>value</i>
<!--l. 578--><p class="noindent" ><a 
href="#x47-79006r63">set</a> allows alteration of the value of a dynamic (special) variable. <a 
href="#x47-79006r63">set</a> causes the
dynamic variable named by <i>symbol</i> to take on <i>value</i> as its value.
<div class=new>
<!--l. 584--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to clarify that the <i>value</i> may be any Lisp
datum whatsoever.
</div>
<!--l. 590--><p class="indent" >   Only the value of the current dynamic binding is altered; if there are no
bindings in eﬀect, the most global value is altered. For example, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set (if (eq a b) &#x2019;c &#x2019;d) &#x2019;foo)
</td></tr></table>
<!--l. 595--><p class="indent" >
</div>
</div>
<!--l. 596--><p class="noindent" >will either set c to foo or set d to foo, depending on the outcome of the test
<i>(eq a b)</i>.
<!--l. 599--><p class="indent" >   <a 
href="#x47-79006r63">set</a> returns <i>value</i> as its result.
<!--l. 601--><p class="indent" >   <a 
href="#x47-79006r63">set</a> cannot alter the value of a local (lexically bound) variable. The special
form <a 
href="#x47-79002r61">setq</a> is usually used for altering the values of variables (lexical or dynamic) in
programs. <a 
href="#x47-79006r63">set</a> is particularly useful for implementing interpreters for languages
                                                                          

                                                                          
embedded in Lisp. See also <a 
href="clmse39.html#x51-83014r89">progv</a>, a construct that performs binding rather than
assignment of dynamic variables.
</div>
<div class=defun>
<!--l. 612--><p class="noindent" > <i>[Function]</i>   <b>makunbound</b> <a 
 id="dx47-79007"></a><a 
 id="x47-79008r64"></a>   <i>symbol</i> <br 
class="newline" /><i>[Function]</i>   <b>fmakunbound</b> <a 
 id="dx47-79009"></a><a 
 id="x47-79010r65"></a>   <i>symbol</i>
<!--l. 615--><p class="noindent" ><a 
href="#x47-79008r64">makunbound</a> causes the dynamic (special) variable named by <i>symbol</i>
to become unbound (have no value). <a 
href="#x47-79010r65">fmakunbound</a> does the analogous
thing for the global function deﬁnition named by <i>symbol</i>. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a 1)
</td></tr></table>
<!--l. 622--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">a  ⇒ 1</td></tr></table>
<!--l. 623--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(makunbound &#x2019;a)</td></tr></table>
<!--l. 624--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">a  ⇒ causes an error</td></tr></table>
<!--l. 625--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 626--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun foo (x) (+ x 1))</td></tr></table>
<!--l. 627--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(foo 4)  ⇒ 5</td></tr></table>
<!--l. 628--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(fmakunbound &#x2019;foo)</td></tr></table>
<!--l. 629--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(foo 4)  ⇒ causes an error</td></tr></table>
<!--l. 631--><p class="indent" >
</div>
</div>
<!--l. 632--><p class="noindent" >Both functions return <i>symbol</i> as the result value.
<div class=newer>
<!--l. 635--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to extend <a 
href="#x47-79010r65">fmakunbound</a> to accept any
function-name (a symbol or a list whose <i>car</i> is <a 
href="clmse36.html#x48-80002r66">setf</a>—see section <a 
href="#x47-770007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). Thus one
may write <i>(fmakunbound &#x2019;(setf cadr))</i> to remove any global deﬁnition of a <a 
href="clmse36.html#x48-80002r66">setf</a>
expansion function for <a 
href="clmse86.html#x106-148008r445">cadr</a>.
</div>
</div>
                                                                          

                                                                          
   <!--l. 643--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse36.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#tailclmch7.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse35.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 643--><p class="indent" >   <a 
 id="tailclmse35.html"></a>  
</body></html> 
