<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Precision, Contagion, and Coercion Точность, неявное приведение и явное
приведение</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-11 23:15:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 73--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse61.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#tailclmch12.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse60.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse60.html" >Вверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">12.1   </span> <a 
href="clm.html#QQ2-77-182" id="x77-17400012.1">Precision, Contagion,
and Coercion Точность, неявное приведение и явное приведение</a></h3>
<!--l. 76--><p class="noindent" >In general, computations with ﬂoating-point numbers are only approximate. The
<i>precision</i> of a ﬂoating-point number is not necessarily correlated at all with the
<i>accuracy</i> of that number. For instance, 3.142857142857142857 is a more precise
approximation to <span class="math">π</span> than 3.14159, but the latter is more accurate. The
precision refers to the number of bits retained in the representation. When an
operation combines a short ﬂoating-point number with a long one, the result
will be a long ﬂoating-point number. This rule is made to ensure that
as much accuracy as possible is preserved; however, it is by no means a
guarantee. Common Lisp numerical routines do assume, however, that the
accuracy of an argument does not exceed its precision. Therefore when two
small ﬂoating-point numbers are combined, the result will always be a
small ﬂoating-point number. This assumption can be overridden by ﬁrst
explicitly converting a small ﬂoating-point number to a larger representation.
(Common Lisp never converts automatically from a larger size to a smaller
one.)
<!--l. 95--><p class="indent" >   Вычисления с числами с плавающей точкой являются приблизительными.
<i>Точность</i> чисел с плавающей точкой не обязательно коррелирует с
<i>«аккуратностью»</i> числа. Например, 3.142857142857142857 имеет более точное
приближение к <span class="math">pi</span> чем 3.14159, но последнее число более «аккуратно».
Точность указывает на количество бит используемых при представлении
числа. Если операция объединяла числа с плавающей точкой короткого
формата и длинного, то результат будет иметь длинный формат. Это
правило создано для уверенности, что при вычислениях аккуратности
будет как можно больше. Однако это не гарантированно. Однако,
численные процедуры Common Lisp&#x2019;а предполагают, что аккуратность
аргумента не превыщает его точность. Поэтому, когда объединяются
два числа с плавающей точкой небольшой точности, результатом
всегда будет число с плавающей точкой небольшой точности. Это
предположение может быть изменено первым же явным преобразованием
число с плавающей точкой в более точное представление. (Common
Lisp никогда не преобразует числа из более точного формата в менее
                                                                          

                                                                          
точный.)
<!--l. 113--><p class="indent" >   Rational computations cannot overﬂow in the usual sense (though of course
there may not be enough storage to represent one), as integers and ratios may in
principle be of any magnitude. Floating-point computations may get exponent
overﬂow or underﬂow; this is an error.
<!--l. 119--><p class="indent" >   Вычисления рациональных чисел не может вызвать переполнения в
обычном смысле этого слова (хотя, конечно, может быть возникнуть
недостаток места для представления), целые и дробные числа в принципе
могут быть любой величины. Вычисления с плавающей точкой могут вызвать
переполнение экспоненты. Это является ошибкой.
<div class=newer>
<!--l. 128--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx77-174001"></a>to address certain problems relating to ﬂoating-point
overﬂow and underﬂow, but certain parts of the proposed solution were not
adopted, namely to add the macro <tt>without-floating-underflow-traps</tt> to the
language and to require certain behavior of ﬂoating-point overﬂow and underﬂow.
The committee agreed that this area of the language requires more discussion
before a solution is standardized.
<!--l. 136--><p class="indent" >   For the record, the proposal that was considered and rejected (for the nonce)
introduced a macro <tt>without-floating-underflow-traps</tt> that would execute its
body in such a way that, within its dynamic extent, a ﬂoating-point underﬂow
must not signal an error but instead must produce either a denormalized number
or zero as the result. The rejected proposal also speciﬁed the following treatment
of overﬂow and underﬂow:
      <ul class="itemize1">
      <li class="itemize">A ﬂoating-point computation that overﬂows should signal an error of
      type <tt><a 
href="clmse145.html#x178-459069r970">floating-point-overflow</a></tt>.
      </li>
      <li class="itemize">Unless
      the dynamic extent of a use of <tt>without-floating-underflow-traps</tt>,
      a ﬂoating-point computation that underﬂows should signal an error
      of type <tt><a 
href="clmse145.html#x178-459071r971">floating-point-underflow</a></tt>. A result that can be represented
      only  in  denormalized  form  must  be  considered  an  underﬂow  in
      implementations that support denormalized ﬂoating-point numbers.</li></ul>
<!--l. 154--><p class="noindent" >These points refer to conditions <tt><a 
href="clmse145.html#x178-459069r970">floating-point-overflow</a></tt> and
<tt><a 
href="clmse145.html#x178-459071r971">floating-point-underflow</a></tt> that were approved by X3J13 and are described in
section <a 
href="clmse145.html#x178-45900028.5">28.5<!--tex4ht:ref: PREDEFINED-CONDITIONS-SECTION --></a>.
                                                                          

                                                                          
</div>
<!--l. 160--><p class="indent" >   When rational and ﬂoating-point numbers are compared or combined by a
numerical function, the rule of <i>ﬂoating-point contagion</i> is followed: when a
rational meets a ﬂoating-point number, the rational is ﬁrst converted to a
ﬂoating-point number of the same format. For functions such as <tt><a 
href="clmse104.html#x129-237002r568">+</a></tt> that take
more than two arguments, it may be that part of the operation is carried
out exactly using rationals and then the rest is done using ﬂoating-point
arithmetic.
<!--l. 169--><p class="indent" >   Когда числовой функцией между собой сравниваются или объединяются
рациональное и число с плавающей точкой, то вступает в силу правило
<i>заражения плавающей точкой</i>. Когда рациональное встречает число с
плавающей точкой, то рациональное преобразуется в тот же формат второго
числа. Для функций, например <tt><a 
href="clmse104.html#x129-237002r568">+</a></tt>, которые принимает более двух аргументов,
может быть, что все рациональные будут вычислены и результат будет
преобразован в число с плавающей точкой.
<div class=new>
<!--l. 179--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx77-174002"></a>to apply the rule of ﬂoating-point contagion
stated above to the case of <i>combining</i> rational and ﬂoating-point numbers. For
<i>comparing</i>, the following rule is to be used instead: When a rational number and a
ﬂoating-point number are to be compared by a numerical function, in eﬀect the
ﬂoating-point number is ﬁrst converted to a rational number as if by the function
<tt><a 
href="clmse65.html#x82-183004r215">rational</a></tt>, and then an exact comparison of two rational numbers is performed. It
is of course valid to use a more eﬃcient implementation than actually calling the
function <tt><a 
href="clmse65.html#x82-183004r215">rational</a></tt>, as long as the result of the comparison is the same. In
the case of complex numbers, the real and imaginary parts are handled
separately.
<div class=rationale>
<!--l. 194--><p class="noindent" ><b>Обоснование:</b> In general, accuracy cannot be preserved in combining operations, but
it can be preserved in comparisons, and preserving it makes that part of Common Lisp
algebraically a bit more tractable. In particular, this change prevents the breakdown of
transitivity. Let <tt>a</tt> be the result of <tt>(/ 10.0 single-float-epsilon)</tt>, and let <tt>j</tt> be the
result of <tt>(floor a)</tt>. (Note that <tt>(= a (+ a 1.0))</tt> is true, by the deﬁnition of
<tt><a 
href="clmse69.html#x86-187059r311">single-float-epsilon</a></tt>.) Under the old rules, all of <tt>(&#x003C;= a j)</tt>, <tt>(&#x003C; j (+ j 1))</tt>, and
<tt>(&#x003C;= (+ j 1) a)</tt> would be true; transitivity would then imply that <tt>(&#x003C; a a)</tt> ought to be
true, but of course it is false, and therefore transitivity fails. Under the new rule,
however, <tt>(&#x003C;= (+ j 1) a)</tt> is false.
</div>
</div>
                                                                          

                                                                          
<!--l. 211--><p class="indent" >   For functions that are mathematically associative (and possibly commutative),
a Common Lisp implementation may process the arguments in any manner
consistent with associative (and possibly commutative) rearrangement. This does
not aﬀect the order in which the argument forms are evaluated, of course; that
order is always left to right, as in all Common Lisp function calls. What is left
loose is the order in which the argument values are processed. The point of all this
is that implementations may diﬀer in which automatic coercions are applied
because of diﬀering orders of argument processing. As an example, consider this
expression: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(+ 1/3 2/3 1.0D0 1.0 1.0E-15)
</td></tr></table>
<!--l. 224--><p class="indent" >
</div>
</div>
<!--l. 225--><p class="noindent" >One implementation might process the arguments from left to right, ﬁrst adding <tt>1/3</tt>
and <tt>2/3</tt> to get <tt>1</tt>, then converting that to a double-precision ﬂoating-point number
for combination with <tt>1.0D0</tt>, then successively converting and adding <tt>1.0</tt> and
<tt>1.0E-15</tt>. Another implementation might process the arguments from right to left,
ﬁrst performing a single-precision ﬂoating-point addition of <tt>1.0</tt> and <tt>1.0E-15</tt> (and
probably losing some accuracy in the process!), then converting the sum to
double precision and adding <tt>1.0D0</tt>, then converting <tt>2/3</tt> to double-precision
ﬂoating-point and adding it, and then converting <tt>1/3</tt> and adding that. A third
implementation might ﬁrst scan all the arguments, process all the rationals ﬁrst to
keep that part of the computation exact, then ﬁnd an argument of the
largest ﬂoating-point format among all the arguments and add that, and
then add in all other arguments, converting each in turn (all in a perhaps
misguided attempt to make the computation as accurate as possible). In any
case, all three strategies are legitimate. The user can of course control
the order of processing explicitly by writing several calls; for example:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(+ (+ 1/3 2/3) (+ 1.0D0 1.0E-15) 1.0)
</td></tr></table>
<!--l. 245--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 246--><p class="noindent" >The user can also control all coercions simply by writing calls to coercion functions
explicitly.
<!--l. 249--><p class="indent" >   Для функций, которые математически ассоциативны (и возможно
коммутативны), реализация Common Lisp&#x2019;а может обрабатывать аргументы
любым подходящим методом с ассоциативной (и возможно коммутативной)
перестановкой. Это конечно не влияет на порядок вычисления форм, данный
порядок всегда слева направо, как и во всех Common Lisp&#x2019;овых вызовах
функций. Порядок, который может быть изменен, это обработка значений
аргументов. Смысл всего этого в том, что реализация может различатся
в том, какие автоматические приведения типов и в каком порядке
производятся. Например, рассмотрим выражение: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(+ 1/3 2/3 1.0D0 1.0 1.0E-15)
</td></tr></table>
<!--l. 260--><p class="indent" >
</div>
</div>
<!--l. 261--><p class="noindent" >Одна реализация может обрабатывать аргументы слева нарпаво, складывая
сначала <tt>1/3</tt> и <tt>2/3</tt> для получения <tt>1</tt>, затем преобразовывая результат в число
с плавающей точкой двойной точности для сложения с <tt>1.0D0</tt>, затем
преобразовывая и добавляя <tt>1.0</tt> и <tt>1.0E-15</tt>. Другая реализация может
обрабатывать значения аргументов справа налево, сначала выполняя
сложение чисел с плавающей точкой <tt>1.0</tt> и <tt>1.0E-15</tt> (и возможно теряя
аккуратность в процессе!), затем преобразовывая результат в часле двойной
точности и прибавляя <tt>1.0D0</tt>, затем преобразовывая <tt>2/3</tt> к числу с
плавающей точкой двойной точности, и затем преобразовывая <tt>1/3</tt>
и добавляя его. Третья реализация может сначала просканировать
все аргументы, и сгруппировав их по типам, выполнить сложения
сначала одинаковых типов, затем преобразовать результаты к наиболее
точному типу и сложить их. В этом случае все три стратегии являются
допустимыми. Пользователь конечно может контролировать порядок
обработки аргументов явно задавая вызовы вычислений, например:
<div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(+ (+ 1/3 2/3) (+ 1.0D0 1.0E-15) 1.0)
</td></tr></table>
<!--l. 277--><p class="indent" >
</div>
</div>
<!--l. 278--><p class="noindent" >Пользовать может также контролировать приведения, явно используя для этого
функцию.
<!--l. 281--><p class="indent" >   In general, then, the type of the result of a numerical function is a
ﬂoating-point number of the largest format among all the ﬂoating-point
arguments to the function; but if the arguments are all rational, then the
result is rational (except for functions that can produce mathematically
irrational results, in which case a single-format ﬂoating-point number may
result).
<!--l. 288--><p class="indent" >   В целом, тип результата числовой функции является числом с плавающей
точкой наиболее точного формата, который был в аргументах данной
функции. Но если все аргументы были рационального типа, тогда результат
будет рациональным (за исключением функций, который математически
возвращают иррациональные результаты, в случае который используется
одинарная точность с плавающей точкой)
<!--l. 295--><p class="indent" >   There is a separate rule of complex contagion. As a rule, complex numbers
never result from a numerical function unless one or more of the arguments is
complex. (Exceptions to this rule occur among the irrational and transcendental
functions, speciﬁcally <tt><a 
href="clmse64.html#x81-180004r193">expt</a></tt>, <tt><a 
href="clmse64.html#x81-180007r194">log</a></tt>, <tt><a 
href="clmse64.html#x81-180010r195">sqrt</a></tt>, <tt><a 
href="clmse64.html#x81-181017r204">asin</a></tt>, <tt><a 
href="clmse64.html#x81-181019r205">acos</a></tt>, <tt><a 
href="clmse64.html#x81-181033r212">acosh</a></tt>, and <tt><a 
href="clmse64.html#x81-181035r213">atanh</a></tt>; see
section <a 
href="clmse64.html#x81-17900012.5">12.5<!--tex4ht:ref: TRANSCENDENTAL-SECTION --></a>.) When a non-complex number meets a complex number, the
non-complex number is in eﬀect ﬁrst converted to a complex number by providing
an imaginary part of zero.
<!--l. 307--><p class="indent" >   Другое правило для комплексных чисел. Комплексные числа никогда не
возвращаются из числовых функций, если только в аргументах не было
использовано хоть одно комплексное число. (Исключением из этого правила
являются иррациональные и трансцендентальные функции, в частности
<tt><a 
href="clmse64.html#x81-180004r193">expt</a></tt>, <tt><a 
href="clmse64.html#x81-180007r194">log</a></tt>, <tt><a 
href="clmse64.html#x81-180010r195">sqrt</a></tt>, <tt><a 
href="clmse64.html#x81-181017r204">asin</a></tt>, <tt><a 
href="clmse64.html#x81-181019r205">acos</a></tt>, <tt><a 
href="clmse64.html#x81-181033r212">acosh</a></tt> и <tt><a 
href="clmse64.html#x81-181035r213">atanh</a></tt>. Смотрите раздел <a 
href="clmse64.html#x81-17900012.5">12.5<!--tex4ht:ref: TRANSCENDENTAL-SECTION --></a>.)
Когда некомплексное число встречает комплексно, то первое сначала
конвертируется во второе с нулевой мнимой частью, а потом вычисляется
результат.
<!--l. 316--><p class="indent" >   If any computation produces a result that is a ratio of two integers such that
the denominator evenly divides the numerator, then the result is immediately
converted to the equivalent integer. This is called the rule of <i>rational
                                                                          

                                                                          
canonicalization</i>.
<!--l. 321--><p class="indent" >   Если любое вычисление привело к дробному результату, в котором
числительно нацело делится на знаменатель, то результат немедленно
преобразуется к эквивалентному целому числу. Это правило называется
<i>канонизацией дробей</i>.
<!--l. 325--><p class="indent" >   If the result of any computation would be a complex rational with a zero
imaginary part, the result is immediately converted to a non-complex
rational number by taking the real part. This is called the rule of <i>complex
canonicalization</i>. Note that this rule does <i>not</i> apply to complex numbers whose
components are ﬂoating-point numbers. Whereas <tt>#C(5 0)</tt> and <tt>5</tt> are not distinct
values in Common Lisp (they are always <tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt>), <tt>#C(5.0 0.0)</tt> and <tt>5.0</tt> are always
distinct values in Common Lisp (they are never <tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt>, although they are
<tt><a 
href="clmse32.html#x43-77008r47">equalp</a></tt>).
<!--l. 335--><p class="indent" >   Если результат любого вычисления должен быть комлексным числом с
рациональными частями и нулевой мнимой частью, то результат немедленно
преобразуется в некомплексное рациональное число и равен действительной
части исходного. Это называется правилом <i>канонизации комлексного числа</i>.
Следует отметить, что это правило <i>не</i> применяется к комплексным числам
с компонентами из чисел с плавающими точками. Таким образом
<tt>#C(5 0)</tt> и <tt>5</tt> равны <tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt>, а <tt>#C(5.0 0.0)</tt> и <tt>5.0</tt> не равны <tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt>, но равны
<tt><a 
href="clmse32.html#x43-77008r47">equalp</a></tt>.
                                                                          

                                                                          
<!--l. 344--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse61.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#tailclmch12.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse60.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse60.html" >Вверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse60.html"></a>  </div> </div> 
</body></html> 
