%Part{CLOS, Root = "CLM.MSS"}
%%% Chapter of Common Lisp Manual.  Copyright 1984, 1987, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}


%\begingroup

\def\CLOS{Common Lisp Object System}
\def\OS{Object System}
\def\bit{\it}                             % NOT \let\bit\it !!!
\def\sub{_}

\chapterauthor{Daniel G.~Bobrow, Linda G.~DeMichiel,
Richard P.~Gabriel,\hfil\break Sonya E.~Keene, Gregor Kiczales,
and David A.~Moon}
\chapter{Common Lisp Object System}
\label{CLOS}

\prefaceword
\begin{new}
X3J13 voted in June 1988
\issue{CLOS}
to adopt the first two chapters (of three) of the
Common Lisp Object System specification
as a part of the forthcoming draft Common Lisp standard.
\end{new}
This chapter presents the bulk of the first two chapters of the
Common Lisp Object System specification; it is substantially
identical to these two specification chapters as previously published elsewhere
\cite{SIGPLAN-CLOS,LASC-CLOS-PART-1,LASC-CLOS-PART-2}.
I have edited the material only very lightly
to conform to the overall style of this book and to save a substantial
number of pages by using a typographically condensed presentation.
I have inserted a small
number of bracketed remarks, identified by the initials GLS.
The chapter divisions of the original specification have become
section divisions in this chapter; references to the three chapters
of the original specification now refer to the three ``parts'' of the
specification.
(See the Acknowledgments to this second edition for
acknowledgments to others who contributed to the Common Lisp Object System specification.)
This is not the last word on CLOS;
X3J13 may well refine this material further.
Keene has written a good tutorial introduction to CLOS~\cite{KEENE}.

\noindent\hbox to \textwidth{\hss---Guy L. Steele Jr.}
\vskip 8pt plus 3pt minus 2pt

\section{Programmer Interface Concepts}

The \CLOS\ (CLOS) is an object-oriented extension to Common Lisp. It is based on
generic functions, multiple inheritance, declarative method
combination, and a meta-object protocol.

The first two parts of this specification describe
the standard Programmer Interface for the \CLOS.  The first part,
Programmer Interface Concepts,
contains a description of the concepts of the \CLOS, and the second part,
Functions in the Programmer Interface,
contains a description of the functions and macros in the \CLOS\
Programmer Interface.  The third part, The \CLOS\ Meta-Object
Protocol, explains how the \CLOS\ can be customized.  [The third part
has not yet been approved by X3J13 for inclusion in the forthcoming
Common Lisp standard and is not included in this book.---GLS]

The fundamental objects of the \CLOS\ are classes, instances,
generic functions, and methods. 

A {\bit class\/} object determines the structure and behavior of a set
of other objects, which are called its {\bit instances}. 
Every Common Lisp object is an {\bit
instance\/} of a class.  The class of an object determines the set of
operations that can be performed on the object.

A {\bit generic function\/} is a function whose behavior depends on the
classes or identities of the arguments supplied to it.  A generic
function object contains a set of methods, a lambda-list, a
method combination type, and other information.  The {\bit methods} define
the class-specific behavior and operations of the generic function; a
method is said to {\bit specialize\/} a generic function.  When invoked,
a generic function executes a subset of its methods based on the
classes of its arguments.

A generic function can be used in 
the same ways as an ordinary function in Common Lisp; in
particular, a generic function can be used as an argument to 
\cdf{funcall} and \cdf{apply} and can be given a global or a local name.

A {\bit method\/} is an object that contains a method function, a sequence of
{\bit parameter specializers\/} that specify when the given method is
applicable, and a sequence of {\bit qualifiers\/} that is used by the
{\bit method combination\/} facility to distinguish among methods.  Each
required formal parameter of each method has an associated parameter
specializer, and the method will be invoked only on arguments that
satisfy its parameter specializers.

The method combination facility controls the selection of methods, the
order in which they are run, and the values that are returned by the
generic function.  The \CLOS\ offers a default method combination type
and provides a facility for declaring new types of method combination.


\subsection{Error Terminology}
\label{Error-Terminology-SECTION}

The terminology used in this chapter to describe erroneous
situations differs from the terminology used in the first edition.
The new terminology involves {\bit situations};
a situation is the evaluation of an expression in some
specific context. For example, a situation might be the invocation of
a function on arguments that fail to satisfy some specified
constraints.

In the specification of the \CLOS, the behavior of programs in all situations
is described, and the options available to the implementor are defined. No
implementation is allowed to extend the syntax or semantics of the \OS\ except
as explicitly defined in the \OS\ specification. In particular, no
implementation is allowed to extend the syntax of the \OS\ in such a way that
ambiguity between the specified syntax of the \OS\ and those extensions is
possible.

\begin{flushdesc}
\item[``When situation \emph{S} occurs, an error is signaled.'']

This terminology has the following meaning:

\begin{itemize}

\item  If this situation occurs, an error will be signaled in
the interpreter and in code compiled under all compiler safety
optimization levels.

\item  Valid programs may rely on the fact that an error will be
signaled in the interpreter and in code compiled under all compiler
safety optimization levels.

\item  Every implementation is required to detect such an error
in the interpreter and in code compiled under all compiler safety
optimization levels.

\end{itemize}

\item[``When situation \emph{S} occurs, an error should be signaled.'']

This terminology has the following meaning:

\begin{itemize}

\item  If this situation occurs, an error will be signaled at
least in the interpreter and in code compiled under the safest
compiler safety optimization level.

\item  Valid programs may not rely on the fact that an error will be
signaled.

\item  Every implementation is required to detect such an error
at least in the interpreter and in code compiled under the safest
compiler safety optimization level.

\item  When an error is not signaled, the results are undefined (see
below).

\end{itemize}

\item[``When situation \emph{S} occurs, the results are undefined.'']

This terminology has the following meaning:

\begin{itemize}

\item  If this situation occurs, the results are unpredictable.  The
results may range from harmless to fatal.

\item  Implementations are allowed to detect this situation and
signal an error, but no implementation is required to detect the
situation.

\item  No valid program may depend on the effects of this
situation, and all valid programs are required to treat the effects 
of this situation as unpredictable.

\end{itemize}

\item[``When situation \emph{S} occurs, the results are unspecified.'']

This terminology has the following meaning:

\nobreak
\begin{itemize}

\item  The effects of this situation are not specified in
the \OS, but the effects are harmless.

\item  Implementations are allowed to specify the effects of
this situation.

\item  No portable program can depend on the effects of this
situation, and all portable programs are required to treat the situation
as unpredictable but harmless.

\end{itemize}

\item[``The \CLOS\ may be extended to cover situation \emph{S}.'']

The meaning of this terminology is that an implementation is free to treat
situation \emph{S} in one of three ways:

\begin{itemize}

\item  When situation \emph{S} occurs, an error is signaled at least
in the interpreter and in code compiled under the safest compiler
safety optimization level.

\item  When situation \emph{S} occurs, the results are undefined.

\item  When situation \emph{S} occurs, the results are defined and
specified.

\end{itemize}

\noindent
In addition, this terminology has the following meaning:

\begin{itemize}

\item  No portable program can depend on the effects of this
situation, and all portable programs are required to treat the situation
as undefined.

\end{itemize}

\item[``Implementations are free to extend the syntax \emph{S}.'']

This terminology has the following meaning:

\begin{itemize}

\item  Implementations are allowed to define unambiguous extensions
to syntax \emph{S}.

\item  No portable program can depend on this extension, and
all portable programs are required to treat the syntax
as meaningless.

\end{itemize}
\end{flushdesc}

The \CLOS\ specification may disallow certain extensions while allowing others.


\subsection{Classes}
\label{Classes-SECTION}

A {\bit class\/} is an object that determines the structure and behavior 
of a set of other objects, which are called its {\bit instances}.   

A class can inherit structure and behavior from other classes.  
A class whose definition refers to other classes for the purpose of
inheriting from them is said to be a {\bit subclass\/} of each of
those classes.  The classes that are designated for purposes of
inheritance are said to be {\bit superclasses\/}
of the inheriting class.

A class can have a {\bit name}. The function \cdf{class-name} takes a
class object and returns its name. The name of an anonymous class is
\cdf{nil}.  A symbol can {\bit name\/} a class.  The function 
\cdf{find-class} takes a symbol and returns the class that the symbol
names. A class has a {\bit proper name\/} if the name is a symbol
and if the name of the class
names that class.  That is, a class~\emph{C} has the {\bit proper
name\/}~\emph{S} if \emph{S}~$=$ \cd{(class-name \emph{C})} and \emph{C}~$=$ \cd{(find-class
\emph{S})}.  Notice that it is possible for \cd{(find-class $S\sub 1$)}
$=$ \cd{(find-class $S\sub 2$)} and $S\sub 1\neq \emph{S}\sub 2$.
If \emph{C}~$=$ \cd{(find-class \emph{S})}, we say that \emph{C} is the {\bit class named}
\emph{S}.

A class $C\sub{1}$ is a {\bit direct superclass\/} of a class
$C\sub{2}$ if $C\sub{2}$ explicitly designates $C\sub{1}$ as a
superclass in its definition.  In this case, $C\sub{2}$ is a {\bit
direct subclass\/} of $C\sub{1}$.  A class $C\sub{\hbox{\scriptsize\it n}}$ is a {\bit
superclass\/} of a class $C\sub{1}$ if there exists a series of
classes $C\sub{2},\ldots,C\sub{\hbox{\scriptsize\it n}-1}$
such that $C\sub{\hbox{\scriptsize\it i}+1}$ is a
direct superclass of $C\sub{\hbox{\scriptsize\it i}}$ for $1 \leq \emph{i} < \emph{n}$.  In this case, 
$C\sub{1}$ is a {\bit subclass\/} of $C\sub{\hbox{\scriptsize\it n}}$.  A class is
considered neither a superclass nor a subclass of itself.  That is, if
$C\sub{1}$ is a superclass of $C\sub{2}$, then $C\sub{1} \neq
C\sub{2}$.  The set of classes consisting of some given
class \emph{C} along with all of its superclasses is called ``\emph{C} and its
superclasses.''

Each class has a {\bit class precedence list}, which is a total ordering
on the set of the given class and its superclasses.  The total ordering
is expressed as a list ordered from most specific to least specific.
The class precedence list is used in several ways.  In general, more
specific classes can {\bit shadow}, or override, features that would
otherwise be inherited from less specific classes.  The method selection
and combination process uses the class precedence list to order methods
from most specific to least specific. 
 
When a class is defined, the order in which its direct superclasses
are mentioned in the defining form is important.  Each class has a
{\bit local precedence order\/}, which is a list consisting of the
class followed by its direct superclasses in the order mentioned
in the defining form.

A class precedence list is always consistent with the local precedence
order of each class in the list.  The classes in each local precedence
order appear within the class precedence list in the same order.  If
the local precedence orders are inconsistent with each other, no class
precedence list can be constructed, and an error is signaled.
The class precedence list and its computation is discussed
in section \ref{Determining-the-Class-Precedence-List-SECTION}.

Classes are organized into a {\bit directed acyclic graph}.  There are
two distinguished classes, named \cdf{t} and \cdf{standard-object}.
The class named \cdf{t} has no superclasses.  It is a superclass of
every class except itself.  The class named \cdf{standard-object} is
an instance of the class \cdf{standard-class} and is a superclass of
every class that is an instance of \cdf{standard-class} except itself.

There is a mapping from the Common Lisp Object System class space into
the Common Lisp type space.  Many of the standard Common Lisp types
have a corresponding
class that has the same name as the type.  Some Common Lisp types do
not have a corresponding class.  The integration of the type and class
systems is discussed in section~\ref{Integrating-Types-and-Classes-SECTION}.

Classes are represented by objects that are themselves
instances of classes.  The class of the class of an object is termed
the {\bit metaclass\/} of that object.  When no misinterpretation is
possible, the term {\bit metaclass\/} will be used to refer to a class
that has instances that are themselves classes.  The metaclass
determines the form of inheritance used by the classes that are its
instances and the representation of the instances of those classes.
The \CLOS\ provides a default metaclass, \cdf{standard-class}, that is
appropriate for most programs.  The meta-object protocol provides
mechanisms for defining and using new metaclasses.

Except where otherwise specified, all classes mentioned in this
chapter are instances of the class \cdf{standard-class}, all generic
functions are instances of the class \cdf{standard-generic-function},
and all methods are instances of the class \cdf{standard-method}.

\subsubsection{Defining Classes}

The macro \cdf{defclass} is used to define a new named class.
The definition of a class includes the following:

\begin{itemize}

\item  The name of the new class. For newly defined classes
this is a proper name.

\item  The list of the direct superclasses of the new class. 

\item  A set of {\bit slot specifiers}.  Each slot specifier
includes the name of the slot and zero or more {\bit slot options}.  A
slot option pertains only to a single slot. If a class definition
contains two slot specifiers with the same name, an error is signaled.

\item  A set of {\bit class options}.  Each class option pertains 
to the class as a whole.  
\end{itemize}
The slot options and class options of the \cdf{defclass} form provide
mechanisms for the following:

\begin{itemize}

\item  Supplying a default initial value form for a given slot.  

\item  Requesting that methods for generic functions
be automatically generated for reading or writing slots. 

\item  Controlling whether a given slot is shared by instances
of the class or whether each instance of the class has its own slot.

\item  Supplying a set of initialization arguments and initialization
argument defaults to be used in instance creation.

%\item  Requesting that a constructor function be automatically
%generated for making instances of the new class.

\item  Indicating that the metaclass is to be other than the default.

\item  Indicating the expected type for the value stored in the slot.

\item  Indicating the documentation string for the slot.

\end{itemize} 

\subsubsection{Creating Instances of Classes}

The generic function \cdf{make-instance} creates and returns a new
instance of a class.  The \OS\ provides several mechanisms for
specifying how a new instance is to be initialized.  For example, it
is possible to specify the initial values for slots in newly created
instances either by giving arguments to \cdf{make-instance} or by
providing default initial values.

Further initialization activities
can be performed by methods written for generic functions that are
part of the initialization protocol.  The complete initialization
protocol is described in section~\ref{Object-Creation-and-Initialization-SECTION}.

\subsubsection{Slots}

An object that has \cdf{standard-class} as its metaclass has zero or
more named slots.  The slots of an object are determined by the class
of the object.  Each slot can hold one value.  The name of a slot is a
symbol that is syntactically valid for use as a variable
name.

When a slot does not have a value, the slot is said to be {\bit
unbound}.  When an unbound slot is read, the generic
function \cdf{slot-unbound} is invoked. The system-supplied primary method
for \cdf{slot-unbound} signals an error.

The default initial value form for a slot is defined by the \hbox{
\cd{:initform}} slot option. When the \cd{:initform} form is used to
supply a value, it is evaluated in the lexical environment in which
the \cdf{defclass} form was evaluated. The \cd{:initform} along with
the lexical environment in which the \cdf{defclass} form was evaluated
is called a {\bit captured\/} \cd{:initform}.
See section~\ref{Object-Creation-and-Initialization-SECTION}.

A {\bit local slot\/} is defined to be a slot that is visible to exactly
one instance, namely the one in which the slot is allocated.  A {\bit
shared slot\/} is defined to be a slot that is visible to more than one
instance of a given class and its subclasses.

A class is said to {\bit define\/} a slot with a given name when
the \cdf{defclass} form for that class contains a slot specifier with
that name.  Defining a local slot does not immediately create a slot;
it causes a slot to be created each time an instance of the class is
created.  Defining a shared slot immediately creates a slot.

The \cd{:allocation} slot option to \cdf{defclass} controls the kind
of slot that is defined.  If the value of the \cd{:allocation} slot
option is \cd{:instance}, a local slot is created.  If the value of
\cd{:allocation} is \cd{:class}, a shared slot is created.

A slot is said to be {\bit accessible\/} in an instance of a class if
the slot is defined by the class of the instance or is inherited from\vadjust{\penalty-10000}
a superclass of that class.  At most one slot of a given name can be
accessible in an instance.  A shared slot defined by a class is
accessible in all instances of that class.  A detailed explanation of
the inheritance of slots is given in
section~\ref{Inheritance-of-Slots-and-Slot-Options-SECTION}.

\subsubsection{Accessing Slots}

Slots can be accessed in two ways: by use of the primitive function
\cdf{slot-value} and by use of generic functions generated by the 
\cdf{defclass} form.

The function \cdf{slot-value} can be used with any slot name
specified in the \cdf{defclass} form to access a specific slot
accessible in an instance of the given class.

The macro \cdf{defclass} provides syntax for generating methods to
read and write slots.  If a {\bit reader\/} is requested, a method is
automatically generated for reading the value of the slot, but no
method for storing a value into it is generated.  If a {\bit writer\/}
is requested, a method is automatically generated for storing a value
into the slot, but no method for reading its value is generated.  If
an {\bit accessor\/} is requested, a method for reading the value of
the slot and a method for storing a value into the slot are
automatically generated.  Reader and writer methods are implemented
using \cdf{slot-value}.

When a reader or writer is specified for a slot, the name of the
generic function to which the generated method belongs is directly
specified.  If the name specified for the writer option is the symbol
\emph{name}, the name of the generic function for writing the slot
is the symbol \emph{name}, and the generic function takes two
arguments: the new value and the instance, in that order.  If the name
specified for the accessor option is the symbol \emph{name}, the
name of the generic function for reading the slot is the symbol {\it
name\/}, and the name of the generic function for writing the slot is
the list \cd{(setf \emph{name\/})}.

A generic function created or modified by supplying reader, writer, or
accessor slot options can be treated exactly as an ordinary generic
function.

Note that \cdf{slot-value} can be used to read or write the value of a
slot whether or not reader or writer methods exist for that slot.
When \cdf{slot-value} is used, no reader or writer methods are
invoked.

The macro \cdf{with-slots} can be used to establish a lexical
environment in which specified slots are lexically available as if they
were variables.  The macro \cdf{with-slots} invokes the function 
\cdf{slot-value} to access the specified slots.

The macro \cdf{with-accessors} can be used to establish a lexical
environment in which specified slots are lexically available through
their accessors as if they were variables.  The macro 
\cdf{with-accessors} invokes the appropriate accessors to access the
specified slots. Any accessors specified by \cdf{with-accessors} must
already have been defined before they are used.

\penalty-10000 %required

\subsection{Inheritance}
\label{Inheritance-SECTION}

A class can inherit methods, slots, and some \cdf{defclass} options
from its superclasses.  The following sections describe the inheritance of
methods, the inheritance of slots and slot options, and the inheritance of
class options.
 
\subsubsection{Inheritance of Methods}
\label{Inheritance-of-Methods-SECTION}

A subclass inherits methods in the sense that any method applicable to
all instances of a class is also applicable to all instances of any
subclass of that class.

The inheritance of methods acts the same way regardless of whether the
method was created by using one of the method-defining forms or by
using one of the \cdf{defclass} options that causes methods to be
generated automatically.

The inheritance of methods is described in detail in
section~\ref{Method-Selection-and-Combination-SECTION}.


\subsubsection{Inheritance of Slots and Slot Options}
\label{Inheritance-of-Slots-and-Slot-Options-SECTION}

The set of names of all slots accessible in an instance of a class
\emph{C} is the union of the sets of names of slots defined by \emph{C} and its
superclasses. The {\bit structure} of an instance is the set of names
of local slots in that instance.

In the simplest case, only one class among \emph{C} and its superclasses
defines a slot with a given slot name.  If a slot is defined by a
superclass of \emph{C}, the slot is said to be {\bit
inherited}.  The characteristics of the slot are determined by the
slot specifier of the defining class.  Consider the defining class for
a slot \emph{S}.  If the value of the \cd{:allocation} slot
option is \cd{:instance}, then \emph{S} is a local slot and each instance
of \emph{C} has its own slot named \emph{S} that stores its own value.  If the
value of the \cd{:allocation} slot option is \cd{:class}, then \emph{S}
is a shared slot, the class that defined \emph{S} stores the value, and all
instances of \emph{C} can access that single slot.  If the 
\cd{:allocation} slot option is omitted, \cd{:instance} is used.

In general, more than one class among \emph{C} and its superclasses can
define a slot with a given name.  In such cases, only one slot with
the given name is accessible in an instance of \emph{C}, and
the characteristics of that slot are a combination of the several slot
specifiers, computed as follows:

\begin{itemize}

\item  All the slot specifiers for a given slot name are ordered
from most specific to least specific, according to the order in \emph{C\/}'s
class precedence list of the classes that define them. All references
to the specificity of slot specifiers immediately following refer to this
ordering.

\item  The allocation of a slot is controlled by the most specific
slot specifier.  If the most specific slot specifier does not contain an
\cd{:allocation} slot option, \cd{:instance} is used.  Less specific
slot specifiers do not affect the allocation.

\item  The default initial value form for a
slot is the value of the \cd{:initform} slot option in the most
specific slot specifier that contains one.  If no slot specifier
contains an \cd{:initform} slot option, the slot has no default
initial value form.

\item  The contents of a slot will always be of type 
\cd{(and $T\sub 1$ $\ldots$ $T\sub {\hbox{\scriptsize\it n}}$)}
where $T\sub 1, \ldots, T\sub {\hbox{\scriptsize\it n}}$ are
the values of the \cd{:type} slot options contained in all of the slot
specifiers.  If no slot specifier contains the \cd{:type} slot option, the
contents of the slot will always be of type \cdf{t}. The result
of attempting to store in a slot
a value that does not satisfy the type of the slot is undefined.

\item  The set of initialization arguments that initialize a given
slot is the union of the initialization arguments declared in the 
\cd{:initarg} slot options in all the slot specifiers.

\item  The documentation string for a slot is the value of the
\cd{:documentation} slot option in the most specific slot specifier
that contains one.  If no slot specifier contains a 
\cd{:documentation} slot option, the slot has no documentation string.
\end{itemize}

A consequence of the allocation rule is that a shared slot can be
shadowed.  For example, if a class $C\sub 1$ defines a slot named \emph{S}
whose value for the \cd{:allocation} slot option is \cd{:class},
that slot is accessible in instances of $C\sub 1$ and all of its
subclasses.  However, if $C\sub 2$ is a subclass of $C\sub 1$ and also
defines a slot named \emph{S}, $C\sub 1$'s slot is not shared
by instances of $C\sub 2$ and its subclasses. When a class
$C\sub 1$ defines a shared slot, any subclass $C\sub 2$ of $C\sub
1$ will share this single slot unless the \cdf{defclass} form for
$C\sub 2$ specifies a slot of the same name or there is a superclass
of $C\sub 2$ that precedes $C\sub 1$ in the class precedence list of
$C\sub 2$ that defines a slot of the same name.

A consequence of the type rule is that the value of a slot satisfies
the type constraint of each slot specifier that contributes to that
slot.  Because the result of attempting to store in a slot a value
that does not satisfy the type constraint for the slot is undefined,
the value in a slot might fail to satisfy its type constraint.

The \cd{:reader}, \cd{:writer}, and \cd{:accessor} slot options
create methods rather than define the characteristics of a slot.
Reader and writer  methods are inherited in the sense described in
section~\ref{Inheritance-of-Methods-SECTION}. 

Methods that access slots use only the name of the slot and the type
of the slot's value.  Suppose a superclass provides a method that
expects to access a shared slot of a given name, and a subclass defines
a local slot with the same name.  If the method provided by the
superclass is used on an instance of the subclass, the method accesses
the local slot.

\subsubsection{Inheritance of Class Options}

The \cd{:default-initargs} class option is inherited.  The set of
defaulted initialization arguments for a class is the union of the
sets of initialization arguments specified in the 
\cd{:default-initargs} class options of the class and its superclasses.
When more than one default initial value form is supplied for a given
initialization argument, the default initial value form that is used
is the one supplied by the class that is most specific according to
the class precedence list.


If a given \cd{:default-initargs} class option specifies an
initialization argument of the same name more than once, an
error is signaled.

\subsubsection{Examples}

\begin{lisp}
(defclass C1 () \\*
~~((S1 :initform 5.4 :type number) \\*
~~~(S2 :allocation :class))) \\
\\
(defclass C2 (C1) \\*
~~((S1 :initform 5 :type integer)\\*
~~~(S2 :allocation :instance)\\*
~~~(S3 :accessor C2-S3)))
\end{lisp}

Instances of the class \cd{C1} have a local slot named \cd{S1}, whose default
initial value is 5.4 and whose value should always be a number.
The class \cd{C1} also has a shared slot named \cd{S2}.

There is a local slot named \cd{S1} in instances of \cd{C2}.  The
default initial value of \cd{S1} is 5.  The value of \cd{S1} will be
of type \cd{(and integer number)}.  There are also local slots named
\cd{S2} and \cd{S3} in instances of \cd{C2}.  The class \cd{C2}
has a method for \cd{C2-S3} for reading the value of slot \cd{S3};
there is also a method for \cd{(setf C2-S3)} that writes the
value of \cd{S3}.


\subsection{Integrating Types and Classes} 
\label{Integrating-Types-and-Classes-SECTION} 

The \CLOS\ maps the space of classes into the Common Lisp type space.
Every class that has a proper name has a corresponding type with the same 
name.  

The proper name of every class is a valid type specifier.  In
addition, every class object is a valid type specifier.  Thus the
expression \cd{(typep \emph{object class\/})} evaluates to true if the
class of \emph{object\/} is \emph{class\/} itself or a subclass of {\it
class}.  The evaluation of the expression \cd{(subtypep \emph{class1
class2\/})} returns the values \cdf{t}~and~\cdf{t} if \emph{class1\/} is a
subclass of \emph{class2\/} or if they are the same class; otherwise it
returns the values \cdf{nil}~and~\cdf{t}.  If \emph{I} is an instance of some class
\emph{C} named \emph{S} and \emph{C} is an instance of \cdf{standard-class}, the
evaluation of the expression \cd{(type-of \emph{I\/})} will return \emph{S} if
\emph{S} is the proper name of \emph{C\/}; if \emph{S} is not the proper
name of \emph{C}, the expression \cd{(type-of \emph{I\/})} will
return \emph{C}.

Because the names of classes and class objects are type specifiers, they may
be used in the special form \cdf{the} and in type declarations.

Many but not all of the predefined Common Lisp type specifiers have a
corresponding class with the same proper name as the type.  These type
specifiers are listed in table~\ref{CLOS-PRECEDENCE-TABLE}.  For example, the
type \cdf{array} has a corresponding class named \cdf{array}.  No type specifier
that is a list, such as \cd{(vector double-float 100)}, has a corresponding
class. The form \cdf{deftype} does not create any classes.

Each class that corresponds to a predefined Common Lisp type specifier
can be implemented in one of three ways, at the discretion of each
implementation.  It can be a {\bit standard class\/} (of the kind
defined by \cdf{defclass}), a {\bit structure class\/} (defined
by \cdf{defstruct}), or a {\bit built-in class\/} (implemented in
a special, non-extensible way).

A built-in class is one whose instances have restricted capabilities or
special representations.  Attempting to use \cdf{defclass} to define 
subclasses of a built-in class signals an error.  Calling 
\cdf{make-instance} to create an instance of a built-in class signals an error.
Calling \cdf{slot-value} on an instance of a built-in class signals an
error.  Redefining a built-in class or using \cdf{change-class} to change
the class of an instance to or from a built-in class signals an error.
However, built-in classes can be used as parameter specializers in
methods.

%The \OS\ specifies that all predefined Common Lisp type specifiers
%listed in table~\ref{CLOS-PRECEDENCE-TABLE} are built-in classes, but a particular
%implementation is allowed to extend the \OS\ to define some of them as
%standard classes or as structure classes.

It is possible to determine whether a class is a built-in class by
checking the metaclass.  A standard class is an instance of 
\cdf{standard-class}, a built-in class is an instance of 
\cdf{built-in-class}, and a structure class is an instance of 
\cdf{structure-class}.

Each structure type created by \cdf{defstruct} without using the 
\cd{:type} option has a corresponding class.  This class is an instance of
\cdf{structure-class}.  
%A portable program must assume that 
%\cdf{structure-class} is a subclass of \cdf{built-in-class} and has the
%same restrictions as built-in classes.  Whether \cdf{structure-class}
%in fact is a subclass of \cdf{built-in-class} is
%implementation-dependent. 
The \cd{:include} option of \cdf{defstruct} creates a direct
subclass of the class that corresponds to the included structure.

The purpose of specifying that many of the standard Common Lisp type
specifiers have a corresponding class is to enable users to write methods that
discriminate on these types.  
Method selection requires that a class precedence list can be
determined for each class. 

The hierarchical relationships among the Common Lisp type specifiers
are mirrored by relationships among the classes corresponding to those
types.  The existing type hierarchy is used for determining the
class precedence list for each class that corresponds to a predefined
Common Lisp type.  In some cases, the first edition
did not specify a local precedence order for two supertypes of a
given type specifier.  For example, \cdf{null} is a subtype of both
\cdf{symbol} and \cdf{list}, but the first edition
did not specify whether \cdf{symbol} is more specific or less
specific than \cdf{list}.  The CLOS specification defines those
relationships for all such classes.

Table~\ref{CLOS-PRECEDENCE-TABLE} lists the set of classes required by the \OS\
that correspond to predefined Common Lisp type specifiers.  The
superclasses of each such class are presented in order from most
specific to most general, thereby defining the class precedence list
for the class. The local precedence order for each class that
corresponds to a Common Lisp type specifier can be derived from this
table.

Individual implementations may be extended to define other type
specifiers to have a corresponding class.  Individual implementations
can be extended to add other subclass relationships and to add other
elements to the class precedence lists in the above table as long as
they do not violate the type relationships and disjointness
requirements specified in section~\ref{DATA-TYPE-RELATIONSHIPS}.
A standard class defined with no direct superclasses is guaranteed to
be disjoint from all of the classes in the table, except for the
class named \cdf{t}.

[At this point the original CLOS report specified that certain Common Lisp
types were to appear in table~\ref{CLOS-PRECEDENCE-TABLE} if and only if
X3J13 voted to make them disjoint from
\cdf{cons}, \cdf{symbol}, \cdf{array}, \cdf{number}, and \cdf{character}.
X3J13 voted to do so in June 1988
\issue{DATA-TYPES-HIERARCHY-UNDERSPECIFIED}.  I have added these types
and their class precedence lists to the table; the new types are indicated
by asterisks.---GLS]


\begin{table}[t]
\caption{Class Precedence Lists for Predefined Types}
\label{CLOS-PRECEDENCE-TABLE}
\begin{flushleft}
\cf
\begin{tabular}{@{}ll@{}}
{\rm Predefined Common Lisp Type}&{\rm Class Precedence List for Corresponding Class} \\
\hlinesp
array&(array t)\\
bit-vector&(bit-vector vector array sequence t)\\
character&(character t)\\
complex&(complex number t)\\
cons&(cons list sequence t)\\
float&(float number t)\\
function {\rm *}&(function t) \\
hash-table {\rm *}&(hash-table t) \\
integer&(integer rational number t)\\
list&(list sequence t)\\
null&(null symbol list sequence t)\\
number&(number t)\\
package {\rm *}&(package t) \\
pathname {\rm *}&(pathname t) \\
random-state {\rm *}&(random-state t) \\
ratio&(ratio rational number t)\\
rational&(rational number t)\\
readtable {\rm *}&(readtable t) \\
sequence&(sequence t)\\
stream {\rm *}&(stream t) \\
string&(string vector array sequence t)\\
symbol&(symbol t)\\
t&(t)\\
vector&(vector array sequence t)
\end{tabular}
\end{flushleft}
[An asterisk indicates a type added to this table as a consequence
of a portion of the CLOS specification that was conditional on X3J13 voting
to make that type disjoint from certain other built-in types
\issue{DATA-TYPES-HIERARCHY-UNDERSPECIFIED}.---GLS]
\end{table}


\subsection{Determining the Class Precedence List}
\label{Determining-the-Class-Precedence-List-SECTION}

The \cdf{defclass} form for a class provides a total ordering on that
class and its direct superclasses.  This ordering is called the {\bit
local precedence order}.  It is an ordered list of the class and its
direct superclasses. The {\bit class precedence list\/} for a
class \emph{C} is a total ordering on \emph{C} and its superclasses that is consistent
with the local precedence orders for \emph{C} and its superclasses.

A class precedes its direct superclasses, and a
direct superclass precedes all other direct superclasses specified to
its right in the superclasses list of the \cdf{defclass} form.  For
every class \emph{C}, define
$$R\sub C=\{(C,C\sub 1),(C\sub 1,C\sub 2),\ldots,(C\sub {n-1},C\sub {n})\}$$
where $C\sub 1,\ldots,C\sub {n}$ are
the direct superclasses of \emph{C} in the order in which
they are mentioned in the \cdf{defclass} form. These ordered pairs
generate the total ordering on the class \emph{C} and its direct
superclasses.

Let $S\sub C$ be the set of \emph{C} and its superclasses. Let \emph{R} be
$$R=\bigcup\sub{\textstyle c\in {S\sub {C}}} R\sub {c}$$

The set \emph{R} may or may not generate a partial ordering, depending on
whether the $R\sub {c}$, $c\in S\sub {C}$,
are consistent; it is assumed
that they are consistent and that \emph{R} generates a partial ordering.
When the $R\sub {c}$ are not consistent, it is said that \emph{R} is inconsistent.


To compute the class precedence list for~\emph{C},
topologically sort the elements of $S\sub {C}$ with respect to the
partial ordering generated by \emph{R}.  When the topological
sort must select a class from a set of two or more classes, none of
which are preceded by other classes with respect to~\emph{R},
the class selected is chosen deterministically, as described below.
If \emph{R} is inconsistent, an error is signaled.

\penalty-10000 %required


\subsubsection{Topological Sorting}

Topological sorting proceeds by finding a class \emph{C} in~$S\sub {C}$ such
that no other class precedes that element according to the elements
in~\emph{R}.  The class \emph{C} is placed first in the result.
Remove \emph{C} from $S\sub {\hbox{\scriptsize\it C}}$, and remove all pairs of the form
$(C,D)$,
$D\in S\sub {\hbox{\scriptsize\it C}}$, from \emph{R}. Repeat the process, adding
classes with no predecessors to the end of the result.  Stop when no
element can be found that has no predecessor.

If $S\sub {\hbox{\scriptsize\it C}}$ is not empty and the process has stopped, the set \emph{R} is
inconsistent. If every class in the finite set of classes is preceded
by another, then \emph{R} contains a loop. That is, there is a chain of
classes $C\sub 1,\ldots,C\sub {\hbox{\scriptsize\it n}}$
such that $C\sub {\hbox{\scriptsize\it i}}$ precedes
$C\sub{\hbox{\scriptsize\it i}+1}$, $1\leq i<n$,
and $C\sub {\hbox{\scriptsize\it n}}$ precedes $C\sub 1$.

Sometimes there are several classes from $S\sub {\hbox{\scriptsize\it C}}$ with no
predecessors.  In this case select the one that has a direct
subclass rightmost in the class precedence list computed so far.
%%%%%%% RPG said to take out the following sentence 10/5/89.
%Because a direct superclass precedes all other direct superclasses to
%its right, there can be only one such candidate class.
If there is no
such candidate class, \emph{R} does not generate a partial ordering---the
$R\sub {\hbox{\scriptsize\it c}}$, $c\in S\sub {\hbox{\scriptsize\it C}}$, are inconsistent.

In more precise terms, let $\{N\sub 1,\ldots,N\sub {\hbox{\scriptsize\it m}}\}$,
$m\geq 2$, be
the classes from $S\sub {\hbox{\scriptsize\it C}}$ with no predecessors.  Let $(C\sub
1\ldots C\sub {\hbox{\scriptsize\it n}})$, $n\geq 1$, be the class precedence list
constructed so far.  $C\sub 1$ is the most specific class, and $C\sub
n$ is the least specific.  Let $1\leq j\leq n$ be the largest number
such that there exists an \emph{i} where $1\leq i\leq m$ and
$N\sub {\hbox{\scriptsize\it i}}$
is a direct superclass of $C\sub {\hbox{\scriptsize\it j}}$;
$N\sub {\hbox{\scriptsize\it i}}$ is placed next.

The effect of this rule for selecting from a set of classes with no
predecessors is that classes in a simple superclass chain are
adjacent in the class precedence list and that classes in each
relatively separated subgraph are adjacent in the class
precedence list. For example, let $T\sub 1$ and $T\sub 2$ be subgraphs
whose only element in common is the class \emph{J}. Suppose
that no superclass of \emph{J} appears in either $T\sub 1$ or $T\sub 2$.
Let $C\sub 1$ be the bottom of $T\sub 1$; and let $C\sub 2$ be the
bottom of $T\sub 2$.  Suppose \emph{C} is a class whose direct superclasses
are $C\sub 1$ and $C\sub 2$ in that order; then the class precedence
list for \emph{C} will start with \emph{C} and will be followed by all classes
in $T\sub 1$ except \emph{J}. All the classes of $T\sub 2$ will be next.
The class \emph{J} and its superclasses will appear last.


\subsubsection{Examples}

This example determines a class precedence list for the
class \cdf{pie}.  The following classes are defined:

\begin{lisp}
(defclass pie (apple cinnamon) ()) \\*
(defclass apple (fruit) ()) \\*
(defclass cinnamon (spice) ()) \\
(defclass fruit (food) ()) \\
(defclass spice (food) ()) \\*
(defclass food () ())
\end{lisp}

\begin{flushleft}\parindent 1em\relax
\newbox\Qhyphbox
\setbox\Qhyphbox\hbox{\cdf{-}}
\def\Qhyphen{\copy\Qhyphbox}

\setbox0\hbox{\hskip\textwidth\hskip 1pt\vrule height 10pt depth 490pt width 0.25pt}
\ht0=0pt \dp0=0pt \wd0=0pt \relax
\leavevmode\box0 The set
$S=\{\cdf{pie},\discretionary{}{}{}
\cdf{apple},\discretionary{}{}{}
\cdf{cinnamon},\discretionary{}{}{}
\cdf{fruit},\discretionary{}{}{}
\cdf{spice},\discretionary{}{}{}
\cdf{food},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object},\discretionary{}{}{}
\cdf{t}\}$.
The set $R=\{(\cdf{pie},\discretionary{}{}{}
\cdf{apple}),\discretionary{}{}{}
(\cdf{apple},\discretionary{}{}{}
\cdf{cinnamon}),\discretionary{}{}{}
(\cdf{cinnamon},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{apple},\discretionary{}{}{}
\cdf{fruit}),\discretionary{}{}{}
(\cdf{fruit},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{cinnamon},\discretionary{}{}{}
\cdf{spice}),\discretionary{}{}{}
(\cdf{spice},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{fruit},\discretionary{}{}{}
\cdf{food}),\discretionary{}{}{}
(\cdf{food},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{spice},\discretionary{}{}{}
\cdf{food}),\discretionary{}{}{}
(\cd{standard{\Qhyphen}\discretionary{}{}{}object},\discretionary{}{}{}
\cdf{t})\}$.

[The original CLOS specification~\cite{SIGPLAN-CLOS,LASC-CLOS-PART-1}
contained a minor error in this example: the pairs
$(\cdf{cinnamon},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object})$,
$(\cdf{fruit},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object})$, and
$(\cdf{spice},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object})$
were inadvertently omitted from \emph{R} in the preceding paragraph.
It is important to understand that \cdf{defclass} implicitly appends the
class \cdf{standard-object} to the list of superclasses when the metaclass
is \cdf{standard-class} (the normal situation),
in order to insure that \cdf{standard-object} will be a superclass
of every instance of \cdf{standard-class} except \cdf{standard-object} itself
(see section~\ref{Classes-SECTION}).
$R\sub {\hbox{\scriptsize\it c}}$ is then generated from this augmented list of superclasses;
this is where the extra pairs come from.  I~have corrected the example
by adding these pairs as appropriate throughout the example.  The final result,
the class precedence list for \cdf{pie},
is unchanged.---GLS]

The class \cdf{pie} is not preceded by anything, so it comes first;
the result so far is \cd{(pie)}.  Remove \cdf{pie} from \emph{S} and pairs
mentioning \cdf{pie} from \emph{R} to get
$S=\{\cdf{apple},\discretionary{}{}{}
\cdf{cinnamon},\discretionary{}{}{}
\cdf{fruit},\discretionary{}{}{}
\cdf{spice},\discretionary{}{}{}
\cdf{food},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object},\discretionary{}{}{}
\cdf{t}\}$ and $R=\{
(\cdf{apple},\discretionary{}{}{}
\cdf{cinnamon}),\discretionary{}{}{}
(\cdf{cinnamon},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{apple},\discretionary{}{}{}
\cdf{fruit}),\discretionary{}{}{}
(\cdf{fruit},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{cinnamon},\discretionary{}{}{}
\cdf{spice}),\discretionary{}{}{}
(\cdf{spice},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{fruit},\discretionary{}{}{}
\cdf{food}),\discretionary{}{}{}
(\cdf{food},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{spice},\discretionary{}{}{}
\cdf{food}),\discretionary{}{}{}
(\cd{standard{\Qhyphen}\discretionary{}{}{}object},\discretionary{}{}{}
\cdf{t})\}$.

The class \cdf{apple} is not preceded by anything, so it is next; the
result is \cd{(pie~apple)}. Removing \cdf{apple} and the relevant
pairs results in $S=\{\cdf{cinnamon},\discretionary{}{}{}
\cdf{fruit},\discretionary{}{}{}
\cdf{spice},\discretionary{}{}{}
\cdf{food},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object},\discretionary{}{}{}
\cdf{t}\}$ and $R=\{(\cdf{cinnamon},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{fruit},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{cinnamon},\discretionary{}{}{}
\cdf{spice}),\discretionary{}{}{}
(\cdf{spice},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{fruit},\discretionary{}{}{}
\cdf{food}),\discretionary{}{}{}
(\cdf{food},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{spice},\discretionary{}{}{}
\cdf{food}),\discretionary{}{}{}
(\cd{standard{\Qhyphen}\discretionary{}{}{}object},\discretionary{}{}{}
\cdf{t})\}$.

The classes \cdf{cinnamon} and \cdf{fruit} are not preceded by
anything, so the one with a direct subclass rightmost in the class
precedence list computed so far goes next.  The class \cdf{apple} is a
direct subclass of \cdf{fruit}, and the class \cdf{pie} is a direct
subclass of \cdf{cinnamon}.  Because \cdf{apple} appears to the right
of \cdf{pie} in the precedence list, \cdf{fruit} goes next, and the
result so far is \cd{(pie apple fruit)}.  $S=\{\cdf{cinnamon},\discretionary{}{}{}
\cdf{spice},\discretionary{}{}{}
\cdf{food},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object},\discretionary{}{}{}
\cdf{t}\}$; $R=\{(\cdf{cinnamon},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{cinnamon},\discretionary{}{}{}
\cdf{spice}),\discretionary{}{}{}
(\cdf{spice},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{food},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{spice},\discretionary{}{}{}
\cdf{food}),\discretionary{}{}{}
(\cd{standard{\Qhyphen}\discretionary{}{}{}object},\discretionary{}{}{}
\cdf{t})\}$.

The class \cdf{cinnamon} is next, giving the result so far as 
\cd{(pie apple fruit cinnamon)}.  At this point $S=\{\cdf{spice},\discretionary{}{}{}
\cdf{food},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object},\discretionary{}{}{}
\cdf{t}\}$; $R=\{(\cdf{spice},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{food},\discretionary{}{}{}
\cd{standard{\Qhyphen}\discretionary{}{}{}object}),\discretionary{}{}{}
(\cdf{spice},\discretionary{}{}{}
\cdf{food}),\discretionary{}{}{}
(\cd{standard{\Qhyphen}\discretionary{}{}{}object},\discretionary{}{}{}
\cdf{t})\}$.
\end{flushleft}

The classes \cdf{spice}, \cdf{food}, \cdf{standard-object}, and 
\cdf{t} are then added in that order, and the final class precedence list for \cdf{pie} is
\begin{lisp}
(pie apple fruit cinnamon spice food standard-object t)
\end{lisp}

It is possible to write a set of class definitions that cannot be 
ordered.   For example: 

\begin{lisp}
(defclass new-class (fruit apple) ()) \\
(defclass apple (fruit) ())
\end{lisp}

The class \cdf{fruit} must precede \cdf{apple} because the local
ordering of superclasses must be preserved.  The class \cdf{apple} must
precede \cdf{fruit} because a class always precedes its own
superclasses.  When this situation occurs, an error is signaled when
the system tries to compute the class precedence list.

The following might appear to be a conflicting set of definitions:

\begin{lisp}
(defclass pie (apple cinnamon) ()) \\
(defclass pastry (cinnamon apple) ()) \\
(defclass apple () ()) \\
(defclass cinnamon () ())
\end{lisp}

The class precedence list for \cdf{pie} is
\begin{lisp}
(pie apple cinnamon standard-object t)
\end{lisp}

The class precedence list for \cdf{pastry} is
\begin{lisp}
(pastry cinnamon apple standard-object t)
\end{lisp}

It is not a problem for \cdf{apple} to precede \cdf{cinnamon} in the
ordering of the superclasses of \cdf{pie} but not in the ordering for
\cdf{pastry}.  However, it is not possible to build a new class that
has both \cdf{pie} and \cdf{pastry} as superclasses.


\subsection{Generic Functions and Methods}

A {\bit generic function\/} is a function whose behavior depends on
the classes or identities of the arguments supplied to it.  The {\bit
methods} define the class-specific behavior and operations of the
generic function. The following sections describe generic functions
and methods.

\subsubsection{Introduction to Generic Functions}

A generic function object contains a set of methods, a
lambda-list, a method combination type, and other information.

Like an ordinary Lisp function, a generic function takes arguments,
performs a series of operations, and perhaps returns useful values.
An ordinary function has a single body of code that is always executed
when the function is called.  A generic function has a set of bodies
of code of which a subset is selected for execution. The selected
bodies of code and the manner of their combination are determined by
the classes or identities of one or more of the arguments to the
generic function and by its method combination type.

Ordinary functions and generic functions are called with identical function-call
syntax.
 
Generic functions are true functions that can be passed as arguments, returned as values,
used as the first argument to \cdf{funcall} and \cdf{apply}, and otherwise used in all the ways
an ordinary function may be used.

A name can be given to an ordinary function in one of
two ways: a {\bit global\/} name can be given to a function using the
\cdf{defun} construct; a {\bit local\/} name can be given using the
\cdf{flet} or \cdf{labels} special forms.  A generic function can be
given a global name using the \cdf{defmethod} or \cdf{defgeneric}
construct.  A generic function can be given a local name using the
\cdf{generic-flet}, \cdf{generic-labels}, or \cdf{with-added-methods}
special forms.  The name of a generic function, like the name of an
ordinary function, can be either a symbol or a two-element list whose
first element is \cdf{setf} and whose second element is a symbol.
This is true for both local and global names.

The \cdf{generic-flet} special form creates new local generic
functions using the set of methods specified by the method definitions
in the \cdf{generic-flet} form.  The scoping of generic function names
within a \cdf{generic-flet} form is the same as for \cdf{flet}.

The \cdf{generic-labels} special form creates a set of new mutually
recursive local generic functions using the set of methods specified
by the method definitions in the \cdf{generic-labels} form.  The
scoping of generic function names within a \cdf{generic-labels} form
is the same as for \cdf{labels}.

The \cdf{with-added-methods} special form creates new local generic
functions by adding the set of methods specified by the method
definitions with a given name in the \cdf{with-added-methods} form to
copies of the methods of the lexically visible generic function of the
same name. If there is a lexically visible ordinary function of the
same name as one of the specified generic functions, that function
becomes the method function of the default method for the new generic
function of that name.

The \cdf{generic-function} macro creates an anonymous generic
function with the set of methods specified by the method definitions that appear
in the \cd{generic-\discretionary{}{}{}function} form.

When a \cdf{defgeneric} form is evaluated, one of three actions
is taken:

\begin{itemize}

\item  If a generic function of the given name already exists,
the existing generic function object is modified.  Methods specified
by the current \cdf{defgeneric} form are added, and any methods in the
existing generic function that were defined by a previous 
\cdf{defgeneric} form are removed.  Methods added by the current 
\cdf{defgeneric} form might replace methods defined by \cdf{defmethod} or
\cdf{defclass}.  No other methods in the generic function are affected
or replaced.

\item  If the given name names a non-generic function, a
macro, or a special form, an error is signaled.

\item  Otherwise a generic function is created with the
methods specified by the method definitions in the \cdf{defgeneric}
form.

\end{itemize}

Some forms specify the options of a generic function,
such as the type of method combination it uses or its argument
precedence order.  They will be referred to as ``forms that
specify generic function options.'' These forms are \cdf{defgeneric},
\cdf{generic-function}, \cdf{generic-flet}, \cdf{generic-labels}, and
\cdf{with-added-methods}.

Some forms define methods for a generic function.  They will be
referred to as ``method-defining forms.'' These forms are 
\cdf{defgeneric}, \cdf{defmethod}, \cdf{generic-function}, 
\cdf{generic-flet}, \cdf{generic-labels}, \cdf{with-added-methods}, and
\cdf{defclass}. Note that all the method-defining forms except 
\cdf{defclass} and \cdf{defmethod}
are also forms that specify generic function options.

\subsubsection{Introduction to Methods}
\label{Introduction-to-Methods-SECTION}

A method object contains a method function, a sequence of {\bit
parameter specializers\/} that specify when the given method is
applicable, a lambda-list, and a sequence of {\bit qualifiers\/} that
are used by the method combination facility to distinguish among
methods.

A method object is not a function and cannot be invoked as a function. 
Various mechanisms in the \OS\ take a method object and invoke its method
function, as is the case when a generic function is invoked.  When this
occurs it is said that the method is invoked or called.

A method-defining form contains the code that is to be run when the
arguments to the generic function cause the method that it defines to
be invoked.  When a method-defining form is evaluated, a method object
is created and one of four actions is taken:

\begin{itemize}

\item  If a generic function of the given name already exists
and if a method object already exists that agrees with the new one on
parameter specializers and qualifiers, the new method object replaces
the old one.  For a definition of one method agreeing with another on
parameter specializers and qualifiers, see
section~\ref{Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION}.

\item  If a generic function of the given name already exists
and if there is no method object that agrees with the new one on
parameter specializers and qualifiers, the existing generic function
object is modified to contain the new method object.

\item  If the given name names a non-generic function, a macro,
or a special form, an error is signaled.

\item  Otherwise a generic function is created with the methods
specified by the method-defining form.

\end{itemize}

If the lambda-list of a new method is not congruent with the lambda-list
of the generic function, an error is signaled.  If a
method-defining form that cannot specify generic function options
creates a new generic function, a lambda-list for that generic
function is derived from the lambda-lists of the methods in the
method-defining form in such a way as to be congruent with them.  For
a discussion of {\bit congruence}, see
section~\ref{Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION}.

Each method has a {\bit specialized lambda-list}, which determines
when that method can be applied.  A specialized lambda-list is like
an ordinary lambda-list except that a {\bit specialized parameter\/}
may occur instead of the name of a required parameter.  A specialized parameter
is a list \cd{(\emph{variable-name parameter-specializer-name\/})},
where \emph{parameter-specializer-name\/} is either
a name that names a class or a list \cd{(\cdf{eql} \emph{form\/})}.
A parameter specializer name denotes a parameter specializer as follows:

\begin{itemize}
\item  A name that names a class denotes that class.

\item  The list \cd{(\cdf{eql} \emph{form\/})} denotes the type specifier
\cd{(\cdf{eql} \emph{object\/})}, where \emph{object\/} is the result of
evaluating \emph{form\/}.  The form \emph{form\/} is evaluated in the
lexical environment in which the method-defining form is
evaluated.  Note that \emph{form\/} is evaluated only once, at the time
the method is defined, not each time the generic function is called.
\end{itemize}

Parameter specializer names are used in macros intended as the
user-level interface (\cdf{defmethod}), while parameter specializers
are used in the functional interface.

[It is very important to understand clearly the distinction made
in the preceding paragraph.  A parameter specializer name
has the form of a type specifier but is semantically quite different
from a type specifier: a parameter specializer name of the form
\cd{(\cdf{eql} \emph{form\/})} is not a type specifier, for it contains
a \emph{form\/} to be evaluated.   Type specifiers
never contain forms to be evaluated.  All parameter specializers
(as opposed to parameter specializer names) are valid type specifiers,
but not all type specifiers are valid parameter specializers.  Macros such as \cdf{defmethod}
take parameter specializer names and treat them as specifications for
constructing certain type specifiers (parameter specializers) that may then be used
with such functions as \cdf{find-method}.---GLS]


Only required parameters may be specialized, and there must be a
parameter specializer for each required parameter.  For notational
simplicity, if some required parameter in a specialized lambda-list in
a method-defining form is simply a variable name, its parameter
specializer defaults to the class named \cdf{t}.

Given a generic function and a set of arguments, an {\bit applicable
method\/} is a method for that generic function whose parameter
specializers are satisfied by their corresponding arguments.  The
following definition specifies what it means for a method to be
applicable and for an argument to satisfy a parameter specializer.

Let $\langle A\sub 1, \ldots, A\sub {\hbox{\scriptsize\it n}}\rangle$ be the required
arguments to a generic function in order. Let $\langle P\sub 1,
\ldots, P\sub {\hbox{\scriptsize\it n}}\rangle$ be the parameter specializers corresponding to
the required parameters of the method \emph{M} in order.  The method \emph{M} is
{\bit applicable\/} when each $A\sub {\hbox{\scriptsize\it i}}$
{\bit satisfies\/} $P\sub {\hbox{\scriptsize\it i}}$.
If $P\sub {\hbox{\scriptsize\it i}}$ is a class,
and if $A\sub {\hbox{\scriptsize\it i}}$ is an instance of a class
\emph{C}, then it is said that $A\sub {\hbox{\scriptsize\it i}}$ {\bit satisfies\/}
$P\sub {\hbox{\scriptsize\it i}}$ when $C=P\sub {\hbox{\scriptsize\it i}}$ or when C is a subclass of $P\sub {\hbox{\scriptsize\it i}}$.  If
$P\sub {\hbox{\scriptsize\it i}}$ is of the form
\cd{(\cdf{eql} \emph{object\/})}, then it is said that
$A\sub {\hbox{\scriptsize\it i}}$ satisfies $P\sub {\hbox{\scriptsize\it i}}$
when the function \cdf{eql} applied to
$A\sub {\hbox{\scriptsize\it i}}$ and \emph{object} is true.

Because a parameter specializer is a type specifier, the function 
\cdf{typep} can be used during method selection to determine whether an
argument satisfies a parameter specializer.  In general a
parameter specializer cannot be a type specifier list, such as 
\cd{(\cd{vector single-float})}.  The only parameter specializer that can
be a list is \cd{(\cdf{eql} \emph{object\/})}.  This requires that
Common Lisp define the type specifier \cdf{eql}
as if the following were evaluated:

\begin{lisp}
(deftype eql (\emph{object\/}) {\Xbq}(member ,\emph{object\/}))
\end{lisp}
[See section~\ref{PREDICATING-TYPE-SPECIFIERS-SECTION}.---GLS]

A method all of whose parameter specializers are the class named 
\cdf{t} is called a {\bit default method}; it is always applicable but
may be shadowed by a more specific method.

Methods can have {\bit qualifiers}, which give the method combination
procedure a way to distinguish among methods.  A method that has one
or more qualifiers is called a {\bit qualified\/} method.
A method with no qualifiers is called an {\bit unqualified method}. 
A qualifier is any object other than a list, that is,
any non-\cdf{nil} atom.  The qualifiers defined by standard method combination
and by the built-in method combination types are symbols.

In this specification, the terms {\bit primary method\/} and {\bit
auxiliary method\/} are used to partition methods within a method
combination type according to their intended use.  In standard method
combination, primary methods are unqualified methods, and auxiliary
methods are methods with a single qualifier that is one of 
\cd{:around}, \cd{:before}, or \cd{:after}.  When a method combination
type is defined using the short form of 
\cdf{define-method-combination}, primary methods are methods qualified with
the name of the type of method combination, and auxiliary methods have
the qualifier \cd{:around}.  Thus the terms {\bit primary method\/}
and {\bit auxiliary method\/} have only a relative definition within a
given method combination type.

\subsubsection{Agreement on Parameter Specializers and Qualifiers}
\label{Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION}

Two methods are said to agree with each other on parameter specializers
and qualifiers if the following conditions hold:

\begin{itemize}

\item Both methods have the same number of required parameters.
Suppose the parameter specializers of the two methods are
$P\sub{1,1}\ldots P\sub{1,\hbox{\scriptsize\it n}}$
and $P\sub{2,1}\ldots P\sub{2,\hbox{\scriptsize\it n}}$.

\item For each $1\leq i\leq n$,
$P\sub{1,\hbox{\scriptsize\it i}}$ agrees with $P\sub{2,\hbox{\scriptsize\it i}}$.
The parameter specializer $P\sub{1,\hbox{\scriptsize\it i}}$
agrees with $P\sub{2,\hbox{\scriptsize\it i}}$ if
$P\sub{1,\hbox{\scriptsize\it i}}$ and $P\sub{2,\hbox{\scriptsize\it i}}$ are the same class or if 
$P\sub{1,\hbox{\scriptsize\it i}}=\hbox{{\tt(\cdf{eql} $\hbox{object}\sub 1$)}}$,
$P\sub{2,\hbox{\scriptsize\it i}}=\hbox{{\tt(\cdf{eql} $\hbox{object}\sub 2$)}}$, and
\cd{(\cdf{eql} $\hbox{object}\sub 1$ $\hbox{object}\sub 2$)}.
Otherwise $P\sub{1,\hbox{\scriptsize\it i}}$ and $P\sub{2,\hbox{\scriptsize\it i}}$ do not agree.


\item The lists of qualifiers of both methods contain the same 
non-\cdf{nil} atoms in the same order. That is, the lists are \cdf{equal}.

\end{itemize}


\subsubsection{Congruent Lambda-Lists for All Methods of a \hfil\penalty-10000\relax Generic~Function}
\label{Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION}

These rules define the congruence of a set of lambda-lists, including the
lambda-list of each method for a given generic function and the
lambda-list specified for the generic function itself, if given.

\begin{itemize}

\item Each lambda-list must have the same number of required
parameters.

\item Each lambda-list must have the same number of optional
parameters.  Each method can supply its own default for an optional
parameter.

\item If any lambda-list mentions \cd{\&rest} or \cd{\&key}, each
lambda-list must mention one or both of them.

\item If the generic function lambda-list mentions \cd{\&key}, each
method must accept all of the keyword names mentioned after \cd{\&key},
either by accepting them explicitly, by specifying 
\cd{\&allow-other-keys}, or by specifying \cd{\&rest} but not \cd{\&key}.
Each method can accept additional keyword arguments of its own.  The
checking of the validity of keyword names is done in the generic
function, not in each method. A method is invoked as if the keyword
argument pair whose  keyword is \cd{:allow-other-keys} and whose value
is \cdf{t} were supplied, though no such argument pair will be passed.

\item The use of \cd{\&allow-other-keys} need not be consistent
across lambda-lists.  If \cd{\&allow-other-keys} is mentioned in 
the lambda-list of any applicable method or of the generic function,
any keyword arguments may be mentioned in the call to the
generic function.

\item The use of \cd{\&aux} need not be consistent across methods.
\end{itemize}


If a method-defining form that cannot specify generic function options
creates a generic function, and if the lambda-list for the method
mentions keyword arguments, the lambda-list of the generic function
will mention \cd{\&key} (but no keyword arguments).


\subsubsection{Keyword Arguments in Generic Functions and Methods}

When a generic function or any of its methods mentions \cd{\&key} in
a lambda-list, the specific set of keyword arguments accepted by the
generic function varies according to the applicable methods.  The set
of keyword arguments accepted by the generic function for a particular
call is the union of the keyword arguments accepted by all applicable
methods and the keyword arguments mentioned after \cd{\&key} in the
generic function definition, if any.  A method that has \cd{\&rest}
but not \cd{\&key} does not affect the set of acceptable keyword
arguments.  If the lambda-list of any applicable method or of the
generic function definition contains \cd{\&allow-other-keys}, all
keyword arguments are accepted by the generic function.

The lambda-list congruence rules require that each method
accept all of the keyword arguments mentioned after \cd{\&key} in the
generic function definition, by accepting them explicitly, by
specifying \cd{\&allow-other-keys}, or by specifying \cd{\&rest} but
not \cd{\&key}.  Each method can accept additional keyword arguments
of its own, in addition to the keyword arguments mentioned in the
generic function definition.

\penalty-10000 %required

If a generic function is passed a keyword argument that no applicable
method accepts, an error is signaled.

For example, suppose there are two methods defined for \cdf{width}
as follows:

\begin{lisp}
(defmethod width ((c character-class) \&key font) ...)\\*
\\*
(defmethod width ((p picture-class) \&key pixel-size) ...)
\end{lisp}

\noindent Assume that there are no other methods and no generic
function definition for \cdf{width}. The evaluation of the
following form will signal an error because the keyword argument
\cd{:pixel-size} is not accepted by the applicable method.

\begin{lisp}
(width (make-instance 'character-class :char \#{\Xbackslash}Q) \\*
~~~~~~~:font 'baskerville :pixel-size 10)
\end{lisp}

The evaluation of the following form will signal an error.

\begin{lisp}
(width (make-instance 'picture-class :glyph (glyph \#{\Xbackslash}Q)) \\*
~~~~~~~:font 'baskerville :pixel-size 10)
\end{lisp}

The evaluation of the following form will not signal an error
if the class named \cdf{character-picture-class} is a subclass of
both \cdf{picture-class} and \cdf{character-class}.

\begin{lisp}
(width (make-instance 'character-picture-class :char \#{\Xbackslash}Q) \\*
~~~~~~~:font 'baskerville :pixel-size 10)
\end{lisp}


\subsection{Method Selection and Combination}
\label{Method-Selection-and-Combination-SECTION}

When a generic function is called with particular arguments, it must
determine the code to execute.  This code is called the {\bit effective
method\/} for those arguments.  The effective method is a {\bit
combination\/} of the applicable methods in the generic function.  A
combination of methods is a Lisp expression that contains calls to some or
all of the methods.  If a generic function is
called and no methods apply, the generic function 
\cdf{no-applicable-method} is invoked.

When the effective method has been determined, it is invoked with the same
arguments that were passed to the generic function.  Whatever values it
returns are returned as the values of the generic function.

\subsubsection{Determining the Effective Method}
\label{Determining-the-Effective-Method-SECTION}

The effective method for a set of
arguments is determined by the following three-step procedure:

\begin{enumerate}

\item Select the applicable methods.

\item Sort the applicable methods by precedence order, putting
the most specific method first.

\item Apply method combination to the sorted list of
applicable methods, producing the effective method.

\end{enumerate}

{\bf Selecting the Applicable Methods.}
This step is described in section~\ref{Introduction-to-Methods-SECTION}.


{\bf Sorting the Applicable Methods by Precedence Order.}
To compare the precedence of two methods, their parameter specializers
are examined in order.  The default examination order is from left to
right, but an alternative order may be specified by the 
\cd{:argument-precedence-order} option to \cdf{defgeneric} or to any of
the other forms that specify generic function options.

The corresponding parameter specializers from each method are
compared.  When a pair of parameter specializers are equal, the next
pair are compared for equality.  If all corresponding parameter
specializers are equal, the two methods must have different
qualifiers; in this case, either method can be selected to precede the
other.

If some corresponding parameter specializers are not equal, the first
pair of parameter specializers that are not equal determines the
precedence.  If both parameter specializers are classes, the more
specific of the two methods is the method whose parameter specializer
appears earlier in the class precedence list of the corresponding
argument.  Because of the way in which the set of applicable methods
is chosen, the parameter specializers are guaranteed to be present in
the class precedence list of the class of the argument.

If just one parameter specializer is \cd{(\cdf{eql} {\it
object\/})}, the method with that parameter specializer precedes the
other method.  If both parameter specializers are \cdf{eql}
forms, the
specializers must be the same (otherwise the two methods would
not both have been applicable to this argument).

The resulting list of applicable methods has the most specific
method first and the least specific method last.    

{\bf Applying Method Combination to the Sorted List of Applicable Methods.}
In the simple case---if standard method combination is used and all
applicable methods are primary methods---the effective method is the
most specific method.  That method can call the next most specific
method by using the function \cdf{call-next-method}.  The method that
\cdf{call-next-method} will call is referred to as the {\bit next
method}.  The predicate \cdf{next-method-p} tests whether a next
method exists.  If \cdf{call-next-method} is called and there is no
next most specific method, the generic function \cdf{no-next-method}
is invoked.

In general, the effective method is some combination of the applicable
methods.  It is defined by a Lisp form that contains calls to some or all
of the applicable methods, returns the value or values that will be
returned as the value or values of the generic function, and optionally
makes some of the methods accessible by means of \cdf{call-next-method}.
This Lisp form is the body of the effective method; it is augmented with
an appropriate lambda-list to make it a function.

The role of each method in the effective method is determined by its
method qualifiers and the specificity of the method.  A qualifier
serves to mark a method, and the meaning of a qualifier is
determined by the way that these marks are used by this step
of the procedure.  If an applicable method has an unrecognized
qualifier, this step signals an error and does not include that method
in the effective method.

When standard method combination is used together with qualified methods, 
the effective method is produced as described in
section~\ref{Standard-Method-Combination-SECTION}.

Another type of method combination can be specified by using the 
\cd{:method-\discretionary{}{}{}combination} option of \cdf{defgeneric} or of any of the other
forms that specify generic function options.  In this way this step of
the procedure can be customized.

New types of method combination can be defined by using the 
\cd{define-\discretionary{}{}{}method-\discretionary{}{}{}combination} macro. 


The meta-object level also offers a mechanism for defining new types
of method combination.  The generic function 
\cd{compute-\discretionary{}{}{}effective-\discretionary{}{}{}method} receives as arguments the generic function,
the method combination object, and the sorted list of applicable
methods.  It returns the Lisp form that defines the effective method.
A method for \cd{compute-\discretionary{}{}{}effective-\discretionary{}{}{}method} can be defined directly by
using \cdf{defmethod} or indirectly by using 
\cd{define-\discretionary{}{}{}method-\discretionary{}{}{}combination}.
A {\bit method combination object} is an
object that encapsulates the method combination type and options
specified by the \cd{:method-combination} option to forms that
specify generic function options.



\beforenoterule
\begin{implementation}
In the simplest implementation, the generic function would compute
the effective method each time it was called.  In practice, this will
be too inefficient for some implementations.  Instead, these
implementations might employ a variety of optimizations of the
three-step procedure. Some illustrative examples of such optimizations
are the following:

\begin{itemize}

\item  Use a hash table keyed by the class of the arguments to
store the effective method.

\item  Compile the effective method and save the resulting
compiled function in a table.

\item  Recognize the Lisp form as an instance of a pattern of
control structure and substitute a closure that implements
that structure.

\item  Examine the parameter specializers of all methods for the
generic function and enumerate all possible effective methods.
Combine the effective methods, together with code to select from
among them, into a single function and compile that function.  Call
that function whenever the generic function is called.
\end{itemize}
\end{implementation}
\afternoterule


\subsubsection{Standard Method Combination}
\label{Standard-Method-Combination-SECTION}

Standard method combination is supported by the class 
\cd{standard-\discretionary{}{}{}generic-\discretionary{}{}{}function}.
It is used if no other type of method
combination is specified or if the built-in method combination type
\cdf{standard} is specified. 

{\bit Primary methods\/} define the main action of the effective method,  
while {\bit auxiliary methods\/} modify that action in one of three ways.
A primary method has no method qualifiers.

An auxiliary method is a method whose method qualifier is 
\cd{:before}, \cd{:after}, or \cd{:around}.  Standard method combination
allows no more than one qualifier per method; if a method definition
specifies more than one qualifier per method, an error is signaled.

\begin{itemize}

\item 
A \cd{:before} method has the keyword \cd{:before} as its
only qualifier.  A \cd{:before} method specifies code that is to be
run before any primary method.

\item 
An \cd{:after} method has the keyword \cd{:after} as its only
qualifier.  An \cd{:after} method specifies code that is to be run
after primary methods.  

\item 
An \cd{:around} method has the keyword \cd{:around} as its only
qualifier. An \cd{:around} method specifies code that is to
be run instead of other applicable methods but that is
able to cause some of them to be run.

\end{itemize}
The semantics of standard method combination are as follows:

\begin{itemize}

\item  If there are any \cd{:around} methods, the most specific
\cd{:around} method is called.  It supplies the value or values of the
generic function.

\item  Inside the body of an \cd{:around} method, 
\cdf{call-next-method} can be used to call the next method.  When the next
method returns, the \cd{:around} method can execute more code,
perhaps based on the returned value or values.  The generic function
\cdf{no-next-method} is invoked if \cdf{call-next-method} is used and
there is no applicable method to call.  The function 
\cdf{next-method-p} may be used to determine whether a next method exists.

\item  
If an \cd{:around} method invokes \cdf{call-next-method}, the next
most specific \cd{:around} method is called, if one is applicable.
If there are no \cd{:around} methods or if 
\cdf{call-next-method} is called by the least specific \cd{:around}
method, the other methods are called as follows:

\begin{itemize}
\item  All the \cd{:before} methods are called, in
most-specific-first order.  Their values are ignored.
An error is signaled if \cdf{call-next-method} is used in a
\cd{:before} method.

\item  The most specific primary method is called.  Inside the
body of a primary method, \cdf{call-next-method} may be used to call
the next most specific primary method.  When that method returns, the
previous primary method can execute more code, perhaps based on the
returned value or values.  The generic function \cdf{no-next-method}
is invoked if \cdf{call-next-method} is used and there are no more
applicable primary methods.  The function \cdf{next-method-p} may be
used to determine whether a next method exists.  If 
\cdf{call-next-method} is not used, only the most specific primary method
is called.


\item  All the \cd{:after} methods are called in
most-specific-last order.  Their values are ignored.
An error is signaled if \cdf{call-next-method} is used in an
\cd{:after} method.
\end{itemize}

\item  If no \cd{:around} methods were invoked, the most
specific primary method supplies the value or values returned by the
generic function.  The value or values returned by the invocation of
\cdf{call-next-method} in the least specific \cd{:around} method are
those returned by the most specific primary method.

\end{itemize}

In standard method combination, if there is an applicable method
but no applicable primary method, an error is signaled.

The \cd{:before} methods are run in most-specific-first order and
the \cd{:after} methods are run in least-specific-first order.  The
design rationale for this difference can be illustrated with an
example.  Suppose class $C \sub 1$ modifies the behavior of its
superclass, $C \sub 2$, by adding \cd{:before} and \cd{:after}
methods. Whether the behavior of the class $C\sub 2$ is defined
directly by methods on $C\sub 2$ or is inherited from its superclasses
does not affect the relative order of invocation of methods on
instances of the class $C\sub 1$.  Class $C \sub 1$'s \cd{:before}
method runs before all of class $C \sub 2$'s methods.  Class $C \sub
1$'s \cd{:after} method runs after all of class $C \sub 2$'s methods.

By contrast, all \cd{:around} methods run before any other methods
run.  Thus a less specific \cd{:around} method runs before a more
specific primary method.

If only primary methods are used and if \cdf{call-next-method} is not
used, only the most specific method is invoked; that is, more specific
methods shadow more general ones. 

\subsubsection{Declarative Method Combination}

The macro \cdf{define-method-combination} defines new forms of method
combination.  It provides a mechanism for customizing the production
of the effective method. The default procedure for producing an
effective method is described in
section~\ref{Determining-the-Effective-Method-SECTION}.
There are two forms of 
\cdf{define-method-combination}.  The short form is a simple facility;
the long form is more powerful and more verbose.  The long form
resembles \cdf{defmacro} in that the body is an expression that
computes a Lisp form; it provides mechanisms for implementing
arbitrary control structures within method combination and for
arbitrary processing of method qualifiers.  The syntax and use of both
forms of \cdf{define-method-combination} are explained in
section~\ref{Functions-in-the-Programmer-Interface-SECTION}.


\subsubsection{Built-in Method Combination Types}
\label{Built-in-Method-Combination-Types-SECTION}

The \CLOS\ provides a set of built-in method combination types.  To
specify that a generic function is to use one of these method
combination types, the name of the method combination type is given as
the argument to the \cd{:method-combination} option to 
\cdf{defgeneric} or to the \cd{:method-combination} option to any of the
other forms that specify generic function options.

The names of the built-in  method combination types are
\cdf{+}, \cdf{and}, \cdf{append}, \cdf{list}, \cdf{max}, \cdf{min}, 
\cdf{nconc}, \cdf{or}, \cdf{progn}, and \cdf{standard}.

The semantics of the \cdf{standard} built-in method combination type were
described in section~\ref{Standard-Method-Combination-SECTION}.  The other
built-in method combination types are called {\bit simple built-in method
combination types.}

The simple built-in method combination types act as though they were
defined by the short form of \cdf{define-method-combination}.  They
recognize two roles for methods:

\begin{itemize}

\item  An \cd{:around} method has the keyword symbol 
\cd{:around} as its sole qualifier.  The meaning of \cd{:around}
methods is the same as in standard method combination.  Use of the
functions \cdf{call-next-method} and \cdf{next-method-p} is supported
in \cd{:around} methods.

\item  A primary method has the name of the method combination
type as its sole qualifier.  For example, the built-in method
combination type \cdf{and} recognizes methods whose sole qualifier is
\cdf{and}; these are primary methods. Use of the functions 
\cdf{call-next-method} and \cdf{next-method-p} is not supported in primary
methods.

\end{itemize}
The semantics of the simple built-in method combination types are as
follows:

\begin{itemize}
\item 
If there are any \cd{:around} methods, the most specific \cd{:around}
method is called.   It supplies the value or values of the generic function. 

\item  Inside the body of an \cd{:around} method, the function
\cdf{call-next-method} can be used to call the next method.  The
generic function \cdf{no-next-method} is invoked if 
\cdf{call-next-method} is used and there is no applicable method to call.
The function \cdf{next-method-p} may be used to determine whether a
next method exists. When the next method returns, the \cd{:around}
method can execute more code, perhaps based on the returned value or
values.

\item  If an \cd{:around} method invokes 
\cdf{call-next-method}, the next most specific \cd{:around} method is
called, if one is applicable.  If there are no \cd{:around} methods
or if \cdf{call-next-method} is called by the least specific 
\cd{:around} method, a Lisp form derived from the name of the built-in
method combination type and from the list of applicable primary
methods is evaluated to produce the value of the generic function.
Suppose the name of the method combination type is \emph{operator\/}
and the call to the generic function is of the form
\begin{lisp}
(\emph{generic-function\/} $a\sub 1$ ... $a\sub {\hbox{\scriptsize\it n}}$)
\end{lisp}
Let $M\sub 1,\ldots,M\sub {\hbox{\scriptsize\it k}}$ be the applicable primary methods
in order; then the derived Lisp form is
\begin{lisp}
(\emph{operator\/} $\langle M\sub 1\;a\sub 1\ldots a\sub {\hbox{\scriptsize\it n}}\rangle$
... $\langle M\sub k\;a\sub 1\ldots a\sub {\hbox{\scriptsize\it n}}\rangle$)
\end{lisp}
If the expression $\langle M\sub {\hbox{\scriptsize\it i}} \;a\sub 1\ldots a\sub
{\hbox{\scriptsize\it n}}\rangle$ is
evaluated, the method $M\sub i$ will be applied to the arguments
$a\sub 1\ldots a\sub {\hbox{\scriptsize\it n}}$.  
For example,
if \emph{operator\/} is \cdf{or},
the expression $\langle M\sub{\hbox{\scriptsize\it i}} \ a\sub 1\ldots a\sub {\hbox{\scriptsize\it n}}\rangle$ is
evaluated only if $\langle M\sub {\hbox{\scriptsize\it j}} \ a\sub 1\ldots a\sub {\hbox{\scriptsize\it n}}\rangle$,
$1\leq j<i$, returned \cdf{nil}.

The default order for the primary methods is 
\cd{:most-specific-first}.  However, the order can be reversed by supplying
\cd{:most-specific-last} as the second argument to the 
\cd{:method-combination} option.

\end{itemize}

The simple built-in method combination types require exactly one qualifier per
method.  An error is signaled if there are applicable methods with no
qualifiers or with qualifiers that are not supported by the method
combination type. An error is signaled if there are applicable \cd{:around}
methods and no applicable primary methods.


\subsection{Meta-objects}

The implementation of the \OS\ manipulates classes, methods, and generic
functions.  The meta-object protocol specifies a set of generic
functions defined by methods on classes; the behavior of those generic
functions defines the behavior of the \OS.  The instances of the classes
on which those methods are defined are called {\bit meta-objects}.  Programming
at the meta-object protocol level involves defining new classes of
meta-objects along with methods specialized on these classes.

\penalty-10000 %required

\subsubsection{Metaclasses}

The {\bit metaclass\/} of an object is the class of its class.  The
metaclass determines the representation of instances of its instances and
the forms of inheritance used by its instances for slot descriptions and
method inheritance.  The metaclass mechanism can be used to provide
particular forms of optimization or to tailor the \CLOS\ for particular
uses.  The protocol for defining metaclasses is discussed in the third part
of the CLOS specification, The \CLOS\ Meta-Object Protocol.
[The third part
has not yet been approved by X3J13 for inclusion in the forthcoming
Common Lisp standard and is not included in this book.---GLS]


\subsubsection{Standard Metaclasses}

The \CLOS\ provides a number of predefined metaclasses.  These include the
classes \cdf{standard-class}, \cdf{built-in-class}, and 
\cdf{structure-class}:

\begin{itemize}

\item 
The class \cdf{standard-class} is the default class of classes defined
by \cdf{defclass}.

\item  The class \cdf{built-in-class} is the class whose
instances are classes that have special implementations with
restricted capabilities.  Any class that corresponds to a standard
Common Lisp type
might be an instance of \cdf{built-in-class}.
The predefined Common Lisp type specifiers that are required to have
corresponding classes are listed in table~\ref{CLOS-PRECEDENCE-TABLE}.
It is implementation-dependent whether each of these classes is implemented as a built-in class.

\item 
All classes defined by means of \cdf{defstruct} are instances of 
\cdf{structure-class}.
\end{itemize}


\subsubsection{Standard Meta-objects}

The \OS\ supplies a standard set of meta-objects, called {\bit standard
meta-objects}. These include the class \cdf{standard-object} and
instances of the classes \cdf{standard-method}, 
\cdf{standard-generic-function}, and \cdf{method-combination}.

\begin{itemize}

\item  
The class \cdf{standard-method} is the default class of
methods that are defined by the forms \cdf{defmethod}, 
\cdf{defgeneric}, \cdf{generic-function}, \cdf{generic-flet}, 
\cdf{generic-labels}, and \cdf{with-added-methods}.

\item 
The class \cdf{standard-generic-function} is the default class of 
generic functions defined by the forms \cdf{defmethod},
\cdf{defgeneric}, \cdf{generic-function}, \cdf{generic-flet},
\cdf{generic-labels}, \cdf{with-added-methods}, and \cdf{defclass}.

\item  The class named \cdf{standard-object} is an instance of
the class \cdf{standard-class} and is a superclass of every class that
is an instance of \cdf{standard-class} except itself.

\item  Every method combination object is an instance of a
subclass of the class \cdf{method-combination}.

\end{itemize}


\subsection{Object Creation and Initialization}
\label{Object-Creation-and-Initialization-SECTION}

The generic function \cdf{make-instance} creates and returns a new
instance of a class.  The first argument is a class or the name of a
class, and the remaining arguments form an {\bit initialization argument\/}
list.  

The initialization of a new instance consists of several distinct
steps, including the following: combining the explicitly supplied
initialization arguments with default values for the unsupplied
initialization arguments, checking the validity of the initialization
arguments, allocating storage for the instance, filling slots with
values, and executing user-supplied methods that perform additional
initialization.  Each step of \cdf{make-instance} is implemented by a
generic function to provide a mechanism for customizing that step.  In
addition, \cdf{make-instance} is itself a generic function and thus
also can be customized.

The \OS\ specifies system-supplied primary methods for each step and
thus specifies a well-defined standard behavior for the entire
initialization process.  The standard behavior provides four simple
mechanisms for controlling initialization:

\begin{itemize}

\item  Declaring a symbol to be an initialization argument for a
slot.  An initialization argument is declared by using the 
\cd{:initarg} slot option to \cdf{defclass}.  This provides a mechanism
for supplying a value for a slot in a call to \cdf{make-instance}.

\item  Supplying a default value form for an initialization
argument.  Default value forms for initialization arguments are
defined by using the \cd{:default-initargs} class option to 
\cdf{defclass}.  If an initialization argument is not explicitly provided
as an argument to \cdf{make-instance}, the default value form is
evaluated in the lexical environment of the \cdf{defclass} form that
defined it, and the resulting value is used as the value of the
initialization argument.

\item  Supplying a default initial value form for a slot.  A
default initial value form for a slot is defined by using the 
\cd{:initform} slot option to \cdf{defclass}.  If no initialization
argument associated with that slot is given as an argument to 
\cdf{make-instance} or is defaulted by \cd{:default-initargs}, this
default initial value form is evaluated in the lexical environment of
the \cdf{defclass} form that defined it, and the resulting value is
stored in the slot.  The \cd{:initform} form for a local slot may be
used when creating an instance, when updating an instance to conform
to a redefined class, or when updating an instance to conform to the
definition of a different class. The \cd{:initform} form for a shared
slot may be used when defining or re-defining the class.

\item  Defining methods for \cdf{initialize-instance} and 
\cdf{shared-initialize}.  The slot-filling behavior described above is
implemented by a system-supplied primary method for 
\cdf{initialize-instance} which invokes \cdf{shared-initialize}. The
generic function \cdf{shared-initialize} implements the parts of
initialization shared by these four situations: when making an
instance, when re-initializing an instance, when updating an instance
to conform to a redefined class, and when updating an instance to
conform to the definition of a different class. The system-supplied
primary method for \cdf{shared-initialize} directly implements the
slot-filling behavior described above, and \cdf{initialize-instance}
simply invokes \cdf{shared-initialize}.

\end{itemize}

\subsubsection{Initialization Arguments}

An initialization argument controls object creation and
initialization.  It is often convenient to use keyword symbols to name
initialization arguments, but the name of an initialization argument
can be any symbol, including \cdf{nil}.  An initialization argument
can be used in two ways: to fill a slot with a value or to provide an
argument for an initialization method.  A single initialization
argument can be used for both purposes.

An {\bit initialization argument list\/} is a list of alternating
initialization argument names and values.  Its structure is identical
to a property list and also to the portion of an argument list
processed for \cd{\&key} parameters.  As in those lists, if an
initialization argument name appears more than once in an
initialization argument list, the leftmost occurrence supplies the
value and the remaining occurrences are ignored.  The arguments to
\cdf{make-instance} (after the first argument) form an initialization
argument list.  Error checking of initialization argument names is
disabled if the keyword argument pair whose keyword is 
\cd{:allow-other-keys} and whose value is non-\cdf{nil} appears in the
initialization argument list.

An initialization argument can be associated with a slot.  If the
initialization argument has a value in the initialization argument
list, the value is stored into the slot of the newly created object,
overriding any \cd{:initform} form associated with the slot.  A
single initialization argument can initialize more than one slot.  An
initialization argument that initializes a shared slot stores its
value into the shared slot, replacing any previous value.

An initialization argument can be associated with a method.  When an
object is created and a particular initialization argument is
supplied, the generic functions \cdf{initialize-instance}, 
\cdf{shared-initialize}, and \cdf{allocate-instance} are called with that
initialization argument's name and value as a keyword argument pair.
If a value for the initialization argument is not supplied in the
initialization argument list, the method's lambda-list supplies a
default value.

Initialization arguments are used in four situations: when making an
instance, when re-initializing an instance, when updating an instance to
conform to a redefined class, and when updating an instance to conform
to the definition of a different class.

Because initialization arguments are used to control the creation and
initialization of an instance of some particular class, we say that an
initialization argument is ``an initialization argument for'' that
class.


\subsubsection{Declaring the Validity of Initialization Arguments}
\label{Declaring-the-Validity-of-Initialization-Arguments-SECTION}

Initialization arguments are checked for validity in each of the four
situations that use them.  An initialization argument may be valid in
one situation and not another. For example, the system-supplied
primary method for \cdf{make-instance} defined for the class 
\cdf{standard-class} checks the validity of its initialization arguments
and signals an error if an initialization argument is supplied that is
not declared valid in that situation.


There are two means of declaring initialization arguments valid.

\begin{itemize}

\item  Initialization arguments that fill slots are declared
valid by the \cd{:initarg} slot option to \cdf{defclass}.  The 
\cd{:initarg} slot option is inherited from superclasses.  Thus the set of
valid initialization arguments that fill slots for a class is the
union of the initialization arguments that fill slots declared
valid by that class and its superclasses. Initialization arguments
that fill slots are valid in all four contexts.

\item  Initialization arguments that supply arguments to methods
are declared valid by defining those methods.  The keyword name of
each keyword parameter specified in the method's lambda-list becomes
an initialization argument for all classes for which the method is
applicable.  Thus method inheritance controls the set of valid
initialization arguments that supply arguments to methods.  The
generic functions for which method definitions serve to declare
initialization arguments valid are as follows:

\begin{itemize}
\item Making an instance of a class: \cdf{allocate-instance},
\cdf{initialize-instance}, and \cdf{shared-initialize}.
Initialization arguments declared valid by these methods are
valid when making an instance of a class.

\item  Re-initializing an instance: the functions \cdf{reinitialize-instance}
and \cd{shared-\discretionary{}{}{}initialize}.
Initialization arguments declared valid by these methods are
valid when re-initializing an instance.

\item   Updating an instance to conform to a redefined class:
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class}
and \cdf{shared-initialize}.
Initialization arguments declared valid by these methods are
valid when updating an instance to conform to a redefined class.

\item  Updating an instance to conform to the definition of a
different class: \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} and 
\cdf{shared-initialize}.
Initialization arguments declared valid by these methods are
valid when updating an instance to conform to the definition
of a different class.
\end{itemize}
\end{itemize}

The set of valid initialization arguments for a class is the set of
valid initialization arguments that either fill slots or supply
arguments to methods, along with the predefined initialization
argument \cd{:allow-other-keys}.  The default value for 
\cd{:allow-other-keys} is \cdf{nil}.  The meaning of 
\cd{:allow-other-keys} is the same here as when it is passed to an ordinary
function.


\subsubsection{Defaulting of Initialization Arguments}

A {\bit default value form\/} can be supplied for an initialization
argument by using the \cd{:default-initargs} class option.  If an
initialization argument is declared valid by some particular class,
its default  value form might be specified by a different class. 
In this case \cd{:default-initargs} is used to supply a default value
for an inherited initialization argument.

The \cd{:default-initargs} option is used only to provide default
values for initialization arguments; it does not declare a symbol as a
valid initialization argument name.  Furthermore, the 
\cd{:default-initargs} option is used only to provide default values for
initialization arguments when making an instance.

The argument to the \cd{:default-initargs} class option is a list of
alternating initialization argument names and forms.  Each form is the
default  value form for the corresponding initialization
argument.  The default  value form of an initialization
argument is used and evaluated only if that initialization argument
does not appear in the arguments to \cdf{make-instance} and is not
defaulted by a more specific class.  The default  value form is
evaluated in the lexical environment of the \cdf{defclass} form that
supplied it; the result is used as the initialization
argument's value.

The initialization arguments supplied to \cdf{make-instance} are combined
with defaulted initialization arguments to produce a {\bit
defaulted initialization argument list}. A defaulted initialization
argument list is a list of alternating initialization argument names and
values in which unsupplied initialization arguments are defaulted and in
which the explicitly supplied initialization arguments appear earlier in
the list than the defaulted initialization arguments.  Defaulted
initialization arguments are ordered according to the order in the class
precedence list of the classes that supplied the default values.

There is a distinction between the purposes of the 
\cd{:default-initargs} and the \cd{:initform} options with respect to the
initialization of slots.  The \cd{:default-initargs} class option
provides a mechanism for the user to give a default  value form
for an initialization argument without knowing whether the
initialization argument initializes a slot or is passed to a method.
If that initialization argument is not explicitly supplied in a call
to \cdf{make-instance}, the default  value form is used, just
as if it had been supplied in the call.  In contrast, the 
\cd{:initform} slot option provides a mechanism for the user to give a
default initial value form for a slot.  An \cd{:initform} form is
used to initialize a slot only if no initialization argument
associated with that slot is given as an argument to 
\cdf{make-instance} or is defaulted by \cd{:default-initargs}.

The order of evaluation of default value forms for initialization
arguments and the order of evaluation of \cd{:initform} forms are
undefined.  If the order of evaluation matters, use
\cdf{initialize-instance} or \cdf{shared-initialize} methods.


\subsubsection{Rules for Initialization Arguments}
\label{Rules-for-Initialization-Arguments-SECTION}

The \cd{:initarg} slot option may be specified more than
once for a given slot.
The following rules specify when initialization arguments may be
multiply defined:

\begin{itemize}

\item  A given initialization argument can be used to
initialize more than one slot if the same initialization argument name
appears in more than one \cd{:initarg} slot option.

\item  A given initialization argument name can appear 
in the lambda-list of more than one initialization method.

\item  A given initialization argument name can
appear both in an \cd{:initarg} slot option and in the lambda-list
of an initialization method.

\end{itemize}

If two or more initialization arguments that initialize
the same slot are given in the arguments to \cdf{make-instance}, the
leftmost of these initialization arguments in the initialization
argument list supplies the value, even if the initialization arguments
have different names.

If two or more different initialization arguments that
initialize the same slot have default values and none is given
explicitly in the arguments to \cdf{make-instance}, the initialization
argument that appears in a \cd{:default-initargs} class option in the
most specific of the classes supplies the value. If a single 
\cd{:default-initargs} class option specifies two or more initialization
arguments that initialize the same slot and none is given explicitly
in the arguments to \cdf{make-instance}, the leftmost argument in the 
\cd{:default-initargs} class option supplies the value, and the values of
the remaining default value forms are ignored.

Initialization arguments given explicitly in the
arguments to \cdf{make-instance} appear to the left of defaulted
initialization arguments. Suppose that the classes $C\sub 1$ and
$C\sub 2$ supply the values of defaulted initialization arguments for
different slots, and suppose that $C\sub 1$ is more specific than
$C\sub 2$; then the defaulted initialization argument whose value is
supplied by $C\sub 1$ is to the left of the defaulted initialization
argument whose value is supplied by $C\sub 2$ in the defaulted
initialization argument list.  If a single \cd{:default-initargs}
class option supplies the values of initialization arguments for two
different slots, the initialization argument whose value is specified
farther to the left in the \cdf{default-initargs} class option appears
farther to the left in the defaulted initialization argument list.

If a slot has both an \cd{:initform} form and an 
\cd{:initarg} slot option, and the initialization argument is defaulted
using \cd{:default-initargs} or is supplied to \cdf{make-instance},
the captured \cd{:initform} form is neither used nor evaluated.

The following is an example of the preceding rules:

\begin{lisp}
(defclass q () ((x :initarg a))) \\*
\\*
(defclass r (q) ((x :initarg b)) \\*
~~(:default-initargs a 1 b 2))
\end{lisp}

\begin{flushleft}
\begin{tabular*}{\textwidth}{@{}l@{\extracolsep{\fill}}ll@{}}
&{\rm Defaulted Initialization}&{\rm Contents} \\
{\rm Form}&{\rm Argument List}&{\rm of Slot} \\
\hlinesp
\cd{(make-instance 'r)}&\cd{(a 1 b 2)}&\cd{1}\\
\cd{(make-instance 'r 'a 3)}&\cd{(a 3 b 2)}&\cd{3}\\
\cd{(make-instance 'r 'b 4)}&\cd{(b 4 a 1)}&\cd{4}\\
\cd{(make-instance 'r 'a 1 'a 2)}&\cd{(a 1 a 2 b 2)}&\cd{1} \\
\hline
\end{tabular*}
\end{flushleft}

\subsubsection{Shared-Initialize}
\label{Shared-Initialize-SECTION}

The generic function \cdf{shared-initialize} is used to fill the slots
of an instance using initialization arguments and \cd{:initform}
forms when an instance is created, when an instance is re-initialized,
when an instance is updated to conform to a redefined class, and when
an instance is updated to conform to a different class. It uses
standard method combination. It takes the following arguments: the
instance to be initialized, a specification of a set of names of slots
accessible in that instance, and any number of initialization
arguments.  The arguments after the first two must form an initialization
argument list.

The second argument to \cdf{shared-initialize} may be one of the following:

\begin{itemize}

\item  It can be a list of slot names, which specifies
the set of those slot names. 

\item  It can be \cdf{nil}, which specifies the empty set of
slot names.

\item  It can be the symbol \cdf{t}, which specifies the set of
all of the slots.

\end{itemize}

There is a system-supplied primary method for 
\cdf{shared-initialize} whose first parameter specializer is the class 
\cdf{standard-object}.  This method behaves as follows on each slot,
whether shared or local:

\begin{itemize}

\item  If an initialization argument in the initialization
argument list specifies a value for that slot, that value is stored
into the slot, even if a value has already been stored in the slot
before the method is run.  The affected slots are independent of which
slots are indicated by the second argument to \cdf{shared-initialize}.

\item  Any slots indicated by the second argument that are still
unbound at this point are initialized according to their 
\cd{:initform} forms.  For any such slot that has an \cd{:initform} form,
that form is evaluated in the lexical environment of its defining 
\cdf{defclass} form and the result is stored into the slot.  For example,
if a \cd{:before} method stores a value in the slot, the 
\cd{:initform} form will not be used to supply a value for the slot.  If
the second argument specifies a name that does not correspond to any
slots accessible in the instance, the results are unspecified.

\item  The rules mentioned in section~\ref{Rules-for-Initialization-Arguments-SECTION} are obeyed.

\end{itemize}

The generic function \cdf{shared-initialize} is called by the
system-supplied primary methods for the generic functions
\cd{initialize-\discretionary{}{}{}instance},
\cd{reinitialize-\discretionary{}{}{}instance}, 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}, and
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class}.
Thus methods can be written for 
\cd{shared-\discretionary{}{}{}initialize} to specify actions that should be taken in all of
these contexts.


\subsubsection{Initialize-Instance}

The generic function \cdf{initialize-instance} is called by 
\cdf{make-instance} to initialize a newly created instance.  It uses
standard method combination.  Methods for 
\cdf{initialize-instance} can be defined in order to perform any
initialization that cannot be achieved with the simple slot-filling
mechanisms.

\penalty-10000 %required

During initialization, \cdf{initialize-instance} is invoked
after the following actions have been taken:

\begin{itemize} 

\item  The defaulted initialization argument list has been computed by
combining the supplied initialization argument list with any default
initialization arguments for the class.

\item  The validity of the defaulted initialization argument
list has been checked.  If any of the initialization arguments has not
been declared valid, an error is signaled.

\item  A new instance whose slots are unbound has been created.

\end{itemize}

The generic function \cdf{initialize-instance} is called with the
new instance and the defaulted initialization arguments.  There is
a system-supplied primary method for \cdf{initialize-instance}
whose parameter specializer is the class \cdf{standard-object}.  This
method calls the generic function \cdf{shared-initialize} to fill in
the slots according to the initialization arguments and the 
\cd{:initform} forms for the slots; the generic function 
\cdf{shared-initialize} is called with the following arguments: the instance,
\cdf{t}, and the defaulted initialization arguments.

Note that \cdf{initialize-instance} provides the defaulted
initialization argument list in its call to \cdf{shared-initialize},
so the first step performed by the system-supplied primary method for
\cdf{shared-initialize} takes into account both the initialization
arguments provided in the call to \cdf{make-instance} and the
defaulted initialization argument list.

Methods for \cdf{initialize-instance} can be defined to specify
actions to be taken when an instance is initialized.  If only \cd{:after}
methods for \cdf{initialize-instance} are defined, they will be
run after the system-supplied primary method for initialization and
therefore they will not interfere with the default behavior of 
\cdf{initialize-instance}.

The \OS\ provides two functions that are useful in the bodies of 
\cdf{initialize-instance} methods.  The function \cdf{slot-boundp}
returns a boolean value that indicates whether a specified slot has a
value; this provides a mechanism for writing \cd{:after} methods for
\cdf{initialize-instance} that initialize slots only if they have
not already been initialized.  The function \cdf{slot-makunbound}
causes the slot to have no value.


\subsubsection{Definitions of Make-Instance and Initialize-Instance}

The generic function \cdf{make-instance} behaves as if it were defined as
follows, except that certain optimizations are permitted:

\penalty-10000 %required

\begin{lisp}
(defmethod make-instance ((class standard-class) \&rest initargs) \\*
~~(setq initargs (default-initargs class initargs)) \\*
~~... \\*
~~(let ((instance (apply \#'allocate-instance class initargs))) \\*
~~~~(apply \#'initialize-instance instance initargs) \\*
~~~~instance)) \\
\\
(defmethod make-instance ((class-name symbol) \&rest initargs) \\*
~~(apply \#'make-instance (find-class class-name) initargs))
\end{lisp}

%This is the code:
%(defmethod make-instance ((class standard-class) &rest initargs)
%  (setq initargs (default-initargs class initargs))
%  (let* ((proto (class-prototype class))
%         (methods 
%           (append
%	      (compute-applicable-methods #'allocate-instance `(,class))
%	      (compute-applicable-methods #'initialize-instance `(,proto))
%	      (compute-applicable-methods #'shared-initialize `(,proto nil)))))
%	 (unless
%	   (subsetp
%	     (let ((keys '()))
%	       (do ((plist initargs (cddr plist)))
%		   ((null plist) keys)
%	 	 (push (car plist) keys)))
%	     (union 
%	       (class-slot-initargs class)
%	       (reduce #'union (mapcar #'function-keywords methods))))
%	   (error ...)))
%  (let ((instance (apply #'allocate-instance class initargs)))
%    (apply #'initialize-instance instance initargs)
%    instance))

The elided code in the definition of \cdf{make-instance} checks the
supplied initialization arguments to determine whether an initialization
argument was supplied that neither filled a slot nor supplied an argument
to an applicable method. This check could be implemented using the generic
functions \cdf{class-prototype}, \cdf{compute-applicable-methods}, 
\cdf{function-keywords}, and \cdf{class-slot-initargs}. See the third
part of the \CLOS\ specification for a
description of this initialization argument check.
[The third part
has not yet been approved by X3J13 for inclusion in the forthcoming
Common Lisp standard and is not included in this book.---GLS]

The generic function \cdf{initialize-instance} behaves as if it were
defined as follows, except that certain optimizations are permitted:

\begin{lisp}
(defmethod initialize-instance \\*
~~~~~~~~~~~((instance standard-object) \&rest initargs) \\*
~~(apply \#'shared-initialize instance t initargs)))
\end{lisp}

These procedures can be customized at either the Programmer Interface level,
the meta-object level, or both.  

Customizing at the Programmer Interface level includes using the 
\cd{:initform}, \cd{:initarg}, and \cd{:default-initargs} options to
\cdf{defclass}, as well as defining methods for \cdf{make-instance}
and \cdf{initialize-instance}.  It is also possible to define
methods for \cdf{shared-initialize}, which would be invoked by the
generic functions \cdf{reinitialize-instance}, 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class}, 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}, and 
\cdf{initialize-instance}.  The meta-object level supports additional
customization by allowing methods to be defined on 
\cdf{make-instance}, \cdf{default-initargs}, and 
\cdf{allocate-instance}.  Parts~2 and~3 of the \CLOS\ specification document each of these generic
functions and the system-supplied primary methods.
[The third part
has not yet been approved by X3J13 for inclusion in the forthcoming
Common Lisp standard and is not included in this book.---GLS]

Implementations are permitted to make certain optimizations to 
\cd{initialize-\discretionary{}{}{}instance} and \cdf{shared-initialize}.  The
description of \cd{shared-\discretionary{}{}{}initialize} in
section~\ref{Functions-in-the-Programmer-Interface-SECTION}
mentions the
possible optimizations.

Because of optimization, the check for valid initialization arguments
might not be implemented using the generic functions 
\cdf{class-prototype}, \cd{compute-\discretionary{}{}{}applicable-\discretionary{}{}{}methods}, 
\cdf{function-keywords}, and \cdf{class-slot-initargs}. In addition,
methods for the generic function \cd{default-\discretionary{}{}{}initargs} and the
system-supplied primary methods for \cd{allocate-\discretionary{}{}{}instance}, 
\cd{initialize-\discretionary{}{}{}instance},
and \cd{shared-\discretionary{}{}{}initialize} might not be called on
every call to \cd{make-\discretionary{}{}{}instance} or might not receive exactly the
arguments that would be expected.


\subsection{Redefining Classes}  
\label{Redefining-Classes-SECTION}  

A class that is an instance of \cdf{standard-class} can be redefined
if the new class will also be an instance of \cdf{standard-class}.
Redefining a class modifies the existing class object to reflect the
new class definition; it does not create a new class object for the
class.  Any method object created by a \cd{:reader}, \cd{:writer}, or
\cd{:accessor} option specified by the old \cdf{defclass} form is
removed from the corresponding generic function.
Methods specified by the new \cdf{defclass} form are added.

% any function specified by the \cd{:constructor}
% option of the old \cdf{defclass} form is removed from the
% corresponding symbol function cell.

When the class \emph{C} is redefined, changes are propagated to its instances
and to instances of any of its subclasses.  Updating such an
instance occurs at an implementation-dependent time, but no later than
the next time a slot of that instance is read or written.  Updating an
instance does not change its identity as defined by the \cdf{eq}
function.  The updating process may change the slots of that
particular instance, but it does not create a new instance.  Whether
updating an instance consumes storage is implementation-dependent.

Note that redefining a class may cause slots to be added or deleted.
If a class is redefined in a way that changes the set of local slots
accessible in instances, the instances will be updated.  It is
implementation-dependent whether instances are updated if a class is
redefined in a way that does not change the set of local slots
accessible in instances.

The value of a slot that is specified as shared both in the old class
and in the new class is retained.  If such a shared slot was unbound
in the old class, it will be unbound in the new class.  Slots that
were local in the old class and that are shared in the new class are
initialized.  Newly added shared slots are initialized.

Each newly added shared slot is set to the result of evaluating the
captured \cd{:initform} form for the slot that was specified in the
\cdf{defclass} form for the new class. If there is no \cd{:initform}
form, the slot is unbound.

If a class is redefined in such a way that the set of local slots
accessible in an instance of the class is changed, a two-step process
of updating the instances of the class takes place.  The process may
be explicitly started by invoking the generic function 
\cdf{make-instances-obsolete}.  This two-step process can happen in other
circumstances in some implementations.  For example, in some
implementations this two-step process will be triggered if the order
of slots in storage is changed.

The first step modifies the structure of the instance by adding new
local slots and discarding local slots that are not defined in the new
version of the class.
The second step initializes the newly added local slots and performs
any other user-defined actions. These steps are further specified
in the next two sections.

\subsubsection{Modifying the Structure of Instances}

The first step modifies the structure of instances of the redefined
class to conform to its new class definition.  Local slots specified
by the new class definition that are not specified as either local or
shared by the old class are added, and slots not specified as either
local or shared by the new class definition that are specified as
local by the old class are discarded. The names of these added and discarded
slots are passed as arguments to \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class}
as described in the next section.

The values of local slots specified by both the new and old classes
are retained. If such a local slot was unbound, it remains unbound.

The value of a slot that is specified as shared in the old class and
as local in the new class is retained.  If such a shared slot was
unbound, the local slot will be unbound.


\subsubsection{Initializing Newly Added Local Slots}

The second step initializes the newly added local slots and performs
any other user-defined actions.  This step is implemented by the generic
function \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class}, which is called after
completion of the first step of modifying the structure of the
instance.

The generic function \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} takes
four required arguments: the instance being updated after it has
undergone the first step, a list of the names of local slots that were
added, a list of the names of local slots that were discarded, and a
property list containing the slot names and values of slots that were
discarded and had values.  Included among the discarded slots are
slots that were local in the old class and that are shared in the new
class.

The generic function \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} also
takes any number of initialization arguments.  When it is called by
the system to update an instance whose class has been redefined, no
initialization arguments are provided.

There is a system-supplied primary method for the generic function
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} whose parameter specializer for
its instance argument is the class \cdf{standard-object}.  First this
method checks the validity of initialization arguments and signals an
error if an initialization argument is supplied that is not declared
valid (see
section~\ref{Declaring-the-Validity-of-Initialization-Arguments-SECTION}.)
Then it calls the generic function
\cdf{shared-initialize} with the following arguments: the instance,
the list of names of the newly added slots, and the initialization
arguments it received.


\subsubsection{Customizing Class Redefinition}

Methods for \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} may be defined
to specify actions to be taken when an instance is updated.  If only
\cd{:after} methods for \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} are
defined, they will be run after the system-supplied primary method for
initialization and therefore will not interfere with the default
behavior of \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class}.  Because no
initialization arguments are passed to 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} when it is called by the system,
the \cd{:initform} forms for slots that are filled by \cd{:before}
methods for \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} will not be
evaluated by \cdf{shared-initialize}.

Methods for \cdf{shared-initialize} may be defined to customize class
redefinition (see section~\ref{Shared-Initialize-SECTION}).


\subsubsection{Extensions}

There are two allowed extensions to class redefinition: 

\begin{itemize}

\item  The \OS\ may be extended to permit the new class
to be an instance of a metaclass other than the metaclass of the
old class.

\item  The \OS\ may be extended to support an updating process
when either the old or the new class is an instance of a
class other than \cdf{standard-class} that is not a built-in class.

\end{itemize}


\subsection{Changing the Class of an Instance}
\label{Changing-the-Class-of-an-Instance-SECTION}

The function \cdf{change-class} can be used to change the class of an
instance from its current class, $C\sub {\hbox{{\footnotesize\rm from}}}$, to a
different class, $C\sub {\hbox{{\footnotesize\rm to}}}$; it changes the
structure of the instance to conform to the definition of the class
$C\sub {\hbox{{\footnotesize\rm to}}}$.

Note that changing the class of an instance may cause slots to be
added or deleted. 

When \cdf{change-class} is invoked on an instance, a two-step updating
process takes place.  The first step modifies the structure of
the instance by adding new local slots and discarding local slots that
are not specified in the new version of the instance.  The second step
initializes the newly added local slots and performs any other
user-defined actions. These steps are further described in the
following two sections.

\subsubsection{Modifying the Structure of an Instance}

In order to make an instance conform to the class $C\sub
{\hbox{{\footnotesize\it to}}}$, local slots specified by the class $C\sub
{\hbox{{\footnotesize\it to}}}$ that are not specified by the class $C\sub
{\hbox{{\footnotesize\it from}}}$ are added, and local slots not specified by
the class $C\sub {\hbox{{\footnotesize\it to}}}$ that are specified by the
class $C\sub {\hbox{{\footnotesize\it from}}}$ are discarded.

The values of local slots specified by both the class $C\sub
{\hbox{{\footnotesize\it to}}}$ and the class $C\sub {\hbox{{\footnotesize\it
from}}}$ are retained. If such a local slot was unbound, it remains
unbound.

The values of slots specified as shared in the class $C\sub
{\hbox{{\footnotesize\it from}}}$ and as local in the class $C\sub
{\hbox{{\footnotesize\it to}}}$ are retained.

This first step of the update does not affect the values of any shared
slots.


\subsubsection{Initializing Newly Added Local Slots}

The second step of the update initializes the newly added slots and
performs any other user-defined actions.  This step is implemented by
the generic function \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}.  The
generic function \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} is invoked
by \cdf{change-class} after the first step of the update has been
completed.

The generic function \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} is
invoked on two arguments computed by \cdf{change-class}.  The first
argument passed is a copy of the instance being updated and is an
instance of the class $C\sub {\hbox{{\footnotesize\it from}}}$; this copy has
dynamic extent within the generic function \cdf{change-class}.  The
second argument is the instance as updated so far by \cdf{change-class}
and is an instance of the class $C\sub {\hbox{{\footnotesize\it to}}}$.

The generic function \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} also
takes any number of initialization arguments.  When it is called by
\cdf{change-class}, no initialization arguments are provided.

There is a system-supplied primary method for the generic function
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} that has two parameter
specializers, each of which is the class \cdf{standard-object}.  First
this method checks the validity of initialization arguments and
signals an error if an initialization argument is supplied that is not
declared valid (see section~\ref{Declaring-the-Validity-of-Initialization-Arguments-SECTION}).
Then it calls the
generic function \cdf{shared-initialize} with the following arguments:
the instance, a list of names of the newly added slots, and the
initialization arguments it received.


\subsubsection{Customizing the Change of Class of an Instance}

Methods for \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} may be defined
to specify actions to be taken when an instance is updated.  If only
\cd{:after} methods for \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} are
defined, they will be run after the system-supplied primary method for
initialization and will not interfere with the default behavior of
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}.  Because no initialization
arguments are passed to \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} when
it is called by \cdf{change-class}, the \cd{:initform} forms for slots
that are filled by \cd{:before} methods for 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} will not be evaluated by 
\cdf{shared-initialize}.

Methods for \cdf{shared-initialize} may be defined to customize class
redefinition (see section~\ref{Shared-Initialize-SECTION}).

\subsection{Reinitializing an Instance}
\label{Reinitializing-an-Instance-SECTION}

The generic function \cdf{reinitialize-instance} may be used to change
the values of slots according to initialization arguments.

The process of reinitialization changes the values of some slots and
performs any user-defined actions.

Reinitialization does not modify the structure
of an instance to add or delete slots, and it does not use any 
\cd{:initform} forms to initialize slots.

The generic function \cdf{reinitialize-instance} may be called
directly.  It takes one required argument, the instance.  It also
takes any number of initialization arguments to be used by methods for
\cdf{reinitialize-instance} or for \cdf{shared-initialize}. The
arguments after the required instance must form an initialization
argument list.

There is a system-supplied primary method for 
\cdf{reinitialize-instance} whose parameter specializer is the class 
\cdf{standard-object}.  First this method checks the validity of
initialization arguments and signals an error if an initialization
argument is supplied that is not declared valid (see
section~\ref{Declaring-the-Validity-of-Initialization-Arguments-SECTION}).
Then it calls the generic function 
\cdf{shared-initialize} with the following arguments: the instance, 
\cdf{nil}, and the initialization arguments it received.

\penalty-10000 %required

\subsubsection{Customizing Reinitialization}

Methods for the generic function \cdf{reinitialize-instance} may be defined to specify
actions to be taken when an instance is updated.  If only \cd{:after}
methods for \cdf{reinitialize-instance} are defined, they will be run
after the system-supplied primary method for initialization and
therefore will not interfere with the default behavior of 
\cdf{reinitialize-instance}.

Methods for \cdf{shared-initialize} may be defined to customize class
redefinition (see section~\ref{Shared-Initialize-SECTION}).


\section{Functions in the Programmer Interface}
\label{Functions-in-the-Programmer-Interface-SECTION}

This section describes the functions, macros, special forms, and
generic functions provided by the \CLOS\ Programmer Interface.  The
Programmer Interface comprises the functions and macros that are
sufficient for writing most object-oriented programs.

This section is reference material that requires an understanding of
the basic concepts of the Common Lisp Object System.  The functions
are arranged in alphabetical order for convenient reference.

The description of each function, macro, special form,
and generic function includes its purpose, its syntax, the
semantics of its arguments and returned values, and often an example
and cross-references to related functions.

The syntax description for a function, macro, or special form
describes its parameters.
The description of a generic function includes descriptions of the
methods that are defined on that generic function by the \CLOS.  A
{\bit method signature\/} is used to describe the parameters and
parameter specializers for each method.

The following is an example of the format for
the syntax description of a generic function with the method
signature for one primary method:

\begin{defun}[Generic function][Primary method]
f x y &optional z &key :k \\
f (x class) (y t) &optional z &key :k

This description indicates that the generic function \cdf{f} 
has two required parameters, \emph{x\/} and \emph{y}.  In addition,
there is an optional parameter \emph{z\/} and a keyword parameter \cd{:k}.

The method signature indicates that this method on the generic function
\cdf{f} has two required parameters, \emph{x}, which must be an
instance of the class \cdf{class}, and \emph{y}, which can be any
object. In addition, there is an optional parameter \emph{z\/} and a
keyword parameter \cd{:k}.  The signature also indicates that this
method on \cdf{f} is a primary method and has no qualifiers.

The syntax description for a generic function describes the
lambda-list of the generic function itself, while the method
signatures describe the lambda-lists of the defined methods.

The generic functions described in this book are all standard
generic functions.  They all use standard method combination.

Any implementation of the \CLOS\ is allowed to provide additional methods
on the generic functions described here.


It is useful to categorize the functions and macros according to their
role in this standard:
\end{defun}   %misplaced to make better break

\begin{itemize}
\item 
\emph{Tools used for simple object-oriented programming}

These tools allow for defining new classes, methods, and generic 
functions and for making instances.   Some tools used within
method bodies are also listed here.   Some of the macros listed here have 
a corresponding function that performs the same task at a lower level of
abstraction. 

\begin{flushleft}
\cf
\begin{tabular}{@{}ll@{}}
\cd{call-next-method~~~~~~~~~~~}&\cdf{initialize-instance}\\
\cdf{change-class}&\cdf{make-instance}\\
\cdf{defclass}&\cdf{next-method-p}\\
\cdf{defgeneric}&\cdf{slot-boundp}\\
\cdf{defmethod}&\cdf{slot-value}\\
\cdf{generic-flet}&\cdf{with-accessors}\\
\cdf{generic-function}&\cdf{with-added-methods}\\
\cdf{generic-labels}&\cdf{with-slots}
\end{tabular}
\end{flushleft}

\item 
\emph{Functions underlying the commonly used macros}

\begin{flushleft}
\cf
\begin{tabular}{@{}ll@{}}
\cdf{add-method}&\cdf{reinitialize-instance}\\
\cdf{class-name}&\cdf{remove-method}\\
\cdf{compute-applicable-methods}&\cdf{shared-initialize}\\
\cdf{ensure-generic-function}&\cdf{slot-exists-p}\\
\cdf{find-class}&\cdf{slot-makunbound}\\
\cdf{find-method}&\cdf{slot-missing}\\
\cdf{function-keywords}&\cdf{slot-unbound}\\
\cdf{make-instances-obsolete}&\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}\\
\cdf{no-applicable-method}&\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class}\\
\cdf{no-next-method}&
\end{tabular}
\end{flushleft}

\item 
\emph{Tools for declarative method combination}

\begin{flushleft}
\cf
\begin{tabular}{@{}ll@{}}
\cdf{call-method}&\cdf{method-combination-error}\\
\cd{define-method-combination~~}&\cdf{method-qualifiers}\\
\cdf{invalid-method-error}&
\end{tabular}
\end{flushleft}

\item 
\emph{General Common Lisp support tools}

\begin{flushleft}
\cf
\begin{tabular}{@{}ll@{}}
\cdf{class-of}&\cdf{print-object}\\
\cd{documentation~~~~~~~~~~~~~~}&\cdf{symbol-macrolet}
\end{tabular}
\end{flushleft}

[Note that \cdf{describe} appeared in this list in the original CLOS proposal
\cite{SIGPLAN-CLOS,LASC-CLOS-PART-2}, but X3J13 voted in March 1989 \issue{DESCRIBE-UNDERSPECIFIED}
not to make \cdf{describe} a generic function after all (see \cdf{describe-object}).---GLS]
\end{itemize}

\vskip10pt
\noindent
[At this point the original CLOS report contained a description of the
\Mchoice{ } and \Mind{} notation; that description is omitted here.
I have adopted the notation for use
throughout this book. It is described in
section~\ref{FUNCTION-HEADER-NOTATION-SECTION}.---GLS]

\begin{defun}[Generic function][Primary method]
add-method generic-function method \\
add-method (generic-function standard-generic-function) (method method)

The generic function \cdf{add-method} adds a method to a generic
function.  It destructively modifies the generic function and returns
the modified generic function as its result.


The \emph{generic-function\/} argument is a generic function
object.

The \emph{method\/} argument is a method object.  The lambda-list of
the method function must be congruent with the lambda-list of the
generic function, or an error is signaled.


The modified generic function is returned.  The result of \cdf{add-method} 
is \cdf{eq} to the \emph{generic-function\/} argument.


If the given method agrees with an existing method of the generic
function on parameter specializers and qualifiers, the existing method
is replaced.  See section~\ref{Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION}
for a definition of agreement in this context.

If the method object is a method object of another generic function,
an error is signaled.

See section~\ref{Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION}
as well as
\cdf{defmethod},
\cdf{defgeneric},
\cdf{find-method},
and \cdf{remove-method}.
\end{defun}


\begin{defmac}
call-method method next-method-list

The macro \cdf{call-method} is used in method combination.  This macro hides
the implementation-dependent details of how methods are called. It can be used only within
an effective method form, for the name \cdf{call-method} is defined only 
within the lexical scope of such a form.

The macro \cdf{call-method} invokes the specified method, supplying it
with arguments and with definitions for \cdf{call-next-method} and for
\cdf{next-method-p}.  The arguments are the arguments that were
supplied to the effective method form containing the invocation of
\cdf{call-method}.  The definitions of \cdf{call-next-method} and 
\cdf{next-method-p} rely on the list of method objects given as the second
argument to \cdf{call-method}.

The \cdf{call-next-method} function available to the method that
is the first subform will call the first method in the list that
is the second subform.  The \cdf{call-next-method} function
available in that method, in turn, will call the second
method in the list that is the second subform, and so on, until
the list of next methods is exhausted.





The \emph{method\/} argument is a method object; the {\it
next-method-list\/} argument is a list of method objects.

A list whose first element is the symbol \cdf{make-method} and whose
second element is a Lisp form can be used instead of a method object
as the first subform of \cdf{call-method} or as an element of the
second subform of \cdf{call-method}.  Such a list specifies a method
object whose method function has a body that is the given form.


The result of \cdf{call-method} is the value or values returned by
the method invocation.

See \cdf{call-next-method}, \cdf{define-method-combination}, and \cdf{next-method-p}.
\end{defmac}


\begin{defun}[Function]
call-next-method &rest args

The function \cdf{call-next-method} can be used within the body of a
method defined by a method-defining form to call the next method.

The function \cdf{call-next-method} returns the value or values
returned by the method it calls.  If there is no next method, 
the generic function \cdf{no-next-method} is called.

The type of method combination used determines which 
methods can invoke \cdf{call-next-method}.  The standard method
combination type allows \cd{call-\discretionary{}{}{}next-\discretionary{}{}{}method}
to be used within primary
methods and \cd{:around} methods.

The standard method combination
type defines the next method according to the following rules:

\begin{itemize}
\item 
If \cdf{call-next-method} is used in an \cd{:around} method,
the next method is the next most specific \cd{:around} method, if one is
applicable.

\item 
If there are no \cd{:around} methods at all or if 
\cdf{call-next-method} is called by the least specific \cd{:around}
method,  other methods are called as follows:

\begin{itemize}
\item  All the \cd{:before} methods are called, in
most-specific-first order.  The function \cdf{call-next-method}
cannot be used in \cd{:before} methods.

\item 
The most specific primary method is called.  Inside the body of a
primary method, \cdf{call-next-method} may be used to pass control to
the next most specific primary method.  The generic function 
\cdf{no-next-method} is called if \cdf{call-next-method} is used and there
are no more primary methods.

\item  All the \cd{:after} methods are called in
most-specific-last order.  The function \cdf{call-next-method}
cannot be used in \cd{:after} methods.
\end{itemize}
\end{itemize}

For further discussion of the use of \cdf{call-next-method}, see
sections~\ref{Standard-Method-Combination-SECTION}
and~\ref{Built-in-Method-Combination-Types-SECTION}.




When \cdf{call-next-method} is called with no arguments, it passes the
current method's original arguments to the next method.  Neither
argument defaulting, nor using \cdf{setq}, nor rebinding variables
with the same names as parameters of the method affects the values
\cdf{call-next-method} passes to the method it calls.

When \cdf{call-next-method} is called with arguments, the next method
is called with those arguments.  When providing arguments to 
\cdf{call-next-method}, the following rule must be satisfied or an error is
signaled: The ordered set of methods applicable for a changed set of
arguments for \cdf{call-next-method} must be the same as the ordered set of
applicable methods for the original arguments to the generic function.
Optimizations of the error checking are possible, but they must 
not change the semantics of \cdf{call-next-method}.

If \cdf{call-next-method} is called with arguments but omits
optional arguments, the next method called defaults those arguments.



The function \cdf{call-next-method} returns the value or values
returned by the method it calls.  


Further computation is possible after \cdf{call-next-method} returns.

The definition of the function \cdf{call-next-method} has lexical scope (for it
is defined only within the body of a method defined by a method-defining form)
and indefinite extent.

For generic functions using a type of method combination defined by
the short form of \cdf{define-method-combination}, 
\cdf{call-next-method} can be used in \cd{:around} methods only.

The function \cdf{next-method-p} can be used to test whether or not there is
a next method.

If \cdf{call-next-method} is used in methods that do not support it,
an error is signaled.

See sections~\ref{Method-Selection-and-Combination-SECTION},
\ref{Standard-Method-Combination-SECTION}, and
\ref{Built-in-Method-Combination-Types-SECTION} as well as the functions
\cd{define-\discretionary{}{}{}method-\discretionary{}{}{}combination},
\cdf{next-method-p},
and \cdf{no-next-method}.
\end{defun}


\begin{defun}[Generic function][Primary method]
change-class instance new-class \\
change-class (instance standard-object) (new-class standard-class) \\
change-class (instance t) (new-class symbol)

The generic function \cdf{change-class} changes the class of an
instance to a new class.  It destructively modifies and returns the
instance.

If in the old class there is any slot of the same name as a local
slot in the new class, the value of that slot is retained.  This
means that if the slot has a value, the value returned by 
\cdf{slot-value} after \cdf{change-class} is invoked is \cdf{eql} to the
value returned by \cdf{slot-value} before \cdf{change-class} is
invoked.  Similarly, if the slot was unbound, it remains
unbound.  The other slots are initialized as described in
section~\ref{Changing-the-Class-of-an-Instance-SECTION}.





The \emph{instance\/} argument is a Lisp object.

The \emph{new-class\/} argument is a class object or a symbol that names
a class. 

If the second of the preceding methods is selected, that method
invokes \cdf{change-class} on \emph{instance\/} and 
\cd{(find-class \emph{new-class\/})}.


The modified instance is returned.  The result of \cdf{change-class}
is \cdf{eq} to the \emph{instance} argument.

Examples:

\begin{lisp}
(defclass position () ()) \\
\\
(defclass x-y-position (position) \\*
~~((x :initform 0 :initarg :x) \\*
~~~(y :initform 0 :initarg :y))) \\
\\
(defclass rho-theta-position (position) \\*
~~((rho :initform 0) \\*
~~~(theta :initform 0))) \\
\\
(defmethod update-instance-for-different-class :before \\*
~~~~~~~~~~~((old x-y-position)  \\*
~~~~~~~~~~~~(new rho-theta-position) \\*
~~~~~~~~~~~~\&key) \\
~~;; Copy the position information from old to new to make new \\*
~~;; be a rho-theta-position at the same position as old. \\*
~~(let ((x (slot-value old 'x)) \\*
~~~~~~~~(y (slot-value old 'y))) \\*
~~~~(setf (slot-value new 'rho) (sqrt (+ (* x x) (* y y))) \\*
~~~~~~~~~~(slot-value new 'theta) (atan y x))))
\end{lisp}
\begin{lisp}
;;; At this point an instance of the class x-y-position can be \\*
;;; changed to be an instance of the class rho-theta-position \\*
;;; using change-class: \\
\\
(setq p1 (make-instance 'x-y-position :x 2 :y 0)) \\
\\
(change-class p1 'rho-theta-position) \\
\\
;;; The result is that the instance bound to p1 is now \\*
;;; an instance of the class rho-theta-position. \\*
;;; The update-instance-for-different-class method \\*
;;; performed the initialization of the rho and theta \\*
;;; slots based on the values of the x and y slots, \\*
;;; which were maintained by the old instance.
\end{lisp}


After completing all other actions, \cdf{change-class} invokes the generic
function \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}.  The generic function
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}
can be used to assign values to slots in the transformed instance.

The generic function \cdf{change-class} has several semantic difficulties.
First, it performs a destructive operation that can be invoked within a
method on an instance that was used to select that method. When multiple
methods are involved because methods are being combined,
the methods currently executing or about to be executed
may no longer be applicable.  Second, some implementations might use compiler
optimizations of slot access, and when the class of an instance is
changed the assumptions the compiler made might be violated.
This implies that a programmer must not use 
\cdf{change-class} inside a method if any methods for that generic function 
access any slots, or the results are undefined.


See section~\ref{Changing-the-Class-of-an-Instance-SECTION} as well as
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}.
\end{defun}



\begin{defun}[Generic function][Primary method]
class-name class \\
class-name (class class)

The generic function \cdf{class-name} takes a class object and returns its
name.
The \emph{class\/} argument is a class object.
The \emph{new-value\/} argument is any object.
The name of the given class is returned.

The name of an anonymous class is \cdf{nil}.

If \emph{S} is a symbol such that \emph{S}~$=$\cd{(class-name \emph{C})} and \emph{C}~$=$
\cd{(find-class \emph{S})}, then \emph{S} is the proper name of \emph{C} (see section~\ref{Classes-SECTION}).

See also section~\ref{Classes-SECTION} and \cdf{find-class}.
\end{defun}


\begin{defun}[Generic function][Primary method]
(setf class-name) new-value class \\
(setf class-name) new-value (class class)

The generic function \cd{(setf class-name)} takes a class object and sets
its name.
The \emph{class\/} argument is a class object.
The \emph{new-value\/} argument is any object.
\end{defun}


\begin{defun}[Function]
class-of object

The function \cdf{class-of} returns the class of which
the given object is an instance.
The argument to \cdf{class-of} may be any Common Lisp object.
The function \cdf{class-of} returns the class of which
the argument is an instance.

\end{defun}


\begin{defun}[Function]
compute-applicable-methods generic-function function-arguments

Given a generic function and a set of arguments, the function
\cd{compute-\discretionary{}{}{}applicable-\discretionary{}{}{}methods} returns the set of methods
that are applicable for those arguments.

The methods are
sorted according to precedence order.
See section~\ref{Method-Selection-and-Combination-SECTION}.





The \emph{generic-function\/} argument must be a generic function object.
The \emph{function-arguments\/} argument is a list of the arguments to
that generic function.
The result is a list of the applicable methods in order of precedence.
See section~\ref{Method-Selection-and-Combination-SECTION}.
\end{defun}


\begin{defmac}
defclass class-name ({superclass-name}*)
         ({slot-specifier}*) <?class-option>

\begin{tabbing}
\emph{class-name\/} ::= \emph{symbol\/} \\
\emph{superclass-name\/} ::= \emph{symbol\/}\\
%\cleartabs
\emph{slot-specifier\/} ::= \emph{slot-name\/} {\Mor} (\emph{slot-name\/}  $\lbrack\!\lbrack\downarrow\!\hbox{slot-option}\,\rbrack\!\rbrack$)\\
\emph{slot-name\/} ::= \emph{symbol\/}\\
\pushtabs\emph{slot-option\/} ::= \=\Mstar{{\cd{:reader} \emph{reader-function-name\/}}} \\
\>\hbox to 0pt{\hss\Mor~}\Mstar{{\cd{:writer} \emph{writer-function-name\/}}} \\
\>\hbox to 0pt{\hss\Mor~}\Mstar{{\cd{:accessor} \emph{reader-function-name\/}}} \\
\>\hbox to 0pt{\hss\Mor~}\Mgroup{\cd{:allocation} \emph{allocation-type\/}} \\
\>\hbox to 0pt{\hss\Mor~}\Mstar{{\cd{:initarg} \emph{initarg-name\/}}} \\
\>\hbox to 0pt{\hss\Mor~}\Mgroup{\cd{:initform} \emph{form\/}} \\
\>\hbox to 0pt{\hss\Mor~}\Mgroup{\cd{:type} \emph{type-specifier\/}} \\
\>\hbox to 0pt{\hss\Mor~}\Mgroup{\cd{:documentation} \emph{string\/}} \poptabs
\end{tabbing}
\penalty-10000 %required
\begin{tabbing}
\emph{reader-function-name\/} ::= \emph{symbol\/}\\
\emph{writer-function-name\/} ::= \emph{function-name/}\\
\emph{function-name\/} ::= \Mgroup{\emph{symbol\/} {\Mor} \cd{(setf \emph{symbol\/})}}\\
\emph{initarg-name\/} ::= \emph{symbol\/}\\
\emph{allocation-type\/} ::= \cd{:instance {\Mor} :class}\\
\pushtabs\emph{class-option\/} ::= \=\cd{(:default-initargs \emph{initarg-list\/})} \\
\>\hbox to 0pt{\hss\Mor~}\cd{(:documentation \emph{string\/})} \\
\>\hbox to 0pt{\hss\Mor~}\cd{(:metaclass \emph{class-name\/})} \poptabs \\
\emph{initarg-list\/} ::= \Mstar{\emph{initarg-name default-initial-value-form}}
\end{tabbing}
The macro \cdf{defclass} defines a new named class.  It returns the new class
object as its result.

The syntax of \cdf{defclass} provides options for specifying
initialization arguments for slots, for specifying default
initialization values for slots, and for requesting that methods on
specified generic functions be automatically generated for reading and
writing the values of slots.  No reader or writer functions are
defined by default; their generation must be explicitly requested.

Defining a new class also causes a type of the same name to be
defined.  The predicate \cd{(typep \emph{object class-name\/})} returns
true if the class of the given object is \emph{class-name\/} itself or
a subclass of the class \emph{class-name}.  A class object can be used
as a type specifier.  Thus \cd{(typep \emph{object class\/})} returns true
if the class of the \emph{object\/} is \emph{class\/} itself or a
subclass of \emph{class}.





The \emph{class-name\/} argument is a non-\cdf{nil} symbol.  It becomes
the proper name of the new class.  If a class with the same proper
name already exists and that class is an instance of 
\cdf{standard-class}, and if the \cdf{defclass} form for the definition of the
new class specifies a class of class \cdf{standard-class}, the definition
of the existing class is replaced.

Each \emph{superclass-name\/} argument is a non-\cdf{nil} symbol that
specifies a direct superclass of the new class.  The new class will
inherit slots and methods from each of its direct superclasses, from
their direct superclasses, and so on.  See
section~\ref{Inheritance-SECTION}
for a discussion of how slots and methods are inherited.

Each \emph{slot-specifier\/} argument is the name of the slot or a list
consisting of the slot name followed by zero or more slot options.
The \emph{slot-name\/} argument is a symbol that is syntactically valid
for use as a variable name.  If there are any duplicate
slot names, an error is signaled.

The following slot options are available:

\begin{itemize}

\item 
The \cd{:reader} slot option specifies that an unqualified method is
to be defined on the generic function named {\it
reader-function-name\/} to read the value of the given slot.
The \emph{reader-function-name\/} argument is a non-\cdf{nil}
symbol.  The \cd{:reader} slot option may be specified more than once
for a given slot.

\item  
The \cd{:writer} slot option specifies that an unqualified method is
to be defined on the generic function named {\it
writer-function-name\/} to write the value of the slot.  The
\emph{writer-function-name\/} argument is a function-name.
The \cd{:writer} slot option may be specified more than once for a
given slot.

\item  
The \cd{:accessor} slot option specifies that an unqualified method
is to be defined on the generic function named {\it
reader-function-name\/} to read the value of the given slot
and that an unqualified method is to be defined on the generic
function named \cd{(setf \emph{reader-function-name\/})} to be
used with \cdf{setf} to modify the value of the slot.  The {\it
reader-function-name\/} argument is a non-\cdf{nil} symbol.
The \cd{:accessor} slot option may be specified more than once for a
given slot.

\item  
The \cd{:allocation} slot option is used to specify where storage is
to be allocated for the given slot.  Storage for a slot may be located
in each instance or in the class object itself, for example.  The value of the {\it
allocation-type\/} argument can be either the keyword \cd{:instance}
or the keyword \cd{:class}.  The \cd{:allocation} slot option may be
specified at most once for a given slot.  If the \cd{:allocation}
slot option is not specified, the effect is the same as specifying
\cd{:allocation :instance}.

\begin{itemize}
\item
If \emph{allocation-type\/} is \cd{:instance}, a local slot of the given name
is allocated in each instance of the class.  

\item
If \emph{allocation-type\/} is \cd{:class}, a shared slot of the given
name is allocated.  The value of the slot is shared by all instances of the class.
If a class $C\sub1$ defines such a shared slot, any subclass $C\sub2$ of
$C\sub1$ will share this single slot unless the \cdf{defclass} form
for $C\sub2$ specifies a slot of the same name or there is a
superclass of $C\sub2$ that precedes $C\sub1$ in the class precedence
list of $C\sub2$ and that defines a slot of the same name.
\end{itemize}

\item  The \cd{:initform} slot option is used to provide a default
initial value form to be used in the initialization of the slot.  The
\cd{:initform} slot option may be specified at most once for a given
slot.  This form is evaluated every time it is used to initialize the
slot.  The lexical
environment in which this form is evaluated is the lexical environment
in which the \cdf{defclass} form was evaluated.  Note that the lexical
environment refers both to variables and to functions.  For local
slots, the dynamic environment is the dynamic environment in which
\cdf{make-instance} was called; for shared slots, the dynamic
environment is the dynamic environment in which the \cdf{defclass}
form was evaluated.  See section \ref{Object-Creation-and-Initialization-SECTION}.

No implementation is permitted to extend the syntax of \cdf{defclass}
to allow \cd{(\emph{slot-name form\/})} as an abbreviation for 
\cd{(\emph{slot-name\/} :initform \emph{form\/})}.

\item 
The \cd{:initarg} slot option declares an initialization argument
named \emph{initarg-name\/} and specifies that this initialization argument
initializes the given slot.  If the initialization argument has a
value in the call to \cdf{initialize-instance}, the value will be
stored into the given slot, and the slot's \cd{:initform} slot option, if
any, is not evaluated.  If none of the initialization arguments
specified for a given slot has a value, the slot is initialized
according to the \cd{:initform} slot option, if specified.  The 
\cd{:initarg} slot option can be specified more than once for a given
slot.  The \emph{initarg-name\/} argument can be any symbol.

\item 
The \cd{:type} slot option specifies that the contents of the slot
will always be of the specified data type.  It effectively declares
the result type of the reader generic function when applied to an
object of this class.  The result of attempting to store in a slot a
value that does not satisfy the type of the slot is undefined.  The
\cd{:type} slot option may be specified at most once for a given
slot.  The \cd{:type} slot option is further discussed in
section~\ref{Inheritance-of-Slots-and-Slot-Options-SECTION}.

\item 
The \cd{:documentation} slot option provides a documentation string
for the slot.
\end{itemize}

Each class option is an option that refers to the class as a whole
or to all class slots.  The following class options are available:

\begin{itemize}
\item 
The \cd{:default-initargs} class option is followed by a list of
alternating initialization argument names and default initial value
forms.  If any of these initialization arguments does not appear in
the initialization argument list supplied to \cdf{make-instance}, the
corresponding default initial value form is evaluated, and the
initialization argument name and the form's value are added to the end
of the initialization argument list before the instance is created
(see section~\ref{Object-Creation-and-Initialization-SECTION}).  The default
initial value form is evaluated each time it is used.  The lexical
environment in which this form is evaluated is the lexical environment
in which the \cdf{defclass} form was evaluated.  The dynamic
environment is the dynamic environment in which \cdf{make-instance}
was called.  If an initialization argument name appears more than once
in a \cd{:default-initargs} class option, an error is signaled.  The
\cd{:default-initargs} class option may be specified at most once.


\item  
The \cd{:documentation} class option causes a documentation string to be
attached to the class name.  The documentation type for this string is
\cdf{type}.  The form \cd{(documentation \emph{class-name\/} 'type)}
may be used to retrieve the documentation string.  The 
\cd{:documentation} class option may be specified at most once.

\item 
The \cd{:metaclass} class option is used to specify that instances of the
class being defined are to have a different metaclass than the default
provided by the system (the class \cdf{standard-class}).  The {\it
class-name} argument is the name of the desired metaclass.  The 
\cd{:metaclass} class option may be specified at most once.

\end{itemize}


The new class object is returned as the result.


If a class with the same proper name already exists and that class is
an instance of \cdf{standard-class}, and if the \cdf{defclass} form for
the definition of the new class specifies a class of class 
\cdf{standard-class}, the existing class is redefined, and instances of it
(and its subclasses) are updated to the new definition at the time
that they are next accessed (see section~\ref{Redefining-Classes-SECTION}).

Note the following rules of \cdf{defclass} for standard classes:

\begin{itemize}

\item 
It is not required that the superclasses of a class be defined before
the \cdf{defclass} form for that class is evaluated.

\item 
All the superclasses of a class must be defined before 
an instance of the class can be made.

\item 
A class must be defined before it can be used as a parameter
specializer in a \cdf{defmethod} form.

\end{itemize}

The \OS\ may be extended to cover situations where these rules are not
obeyed.

Some slot options are inherited by a class from its superclasses, and
some can be shadowed or altered by providing a local slot description.
No class options except \cd{:default-initargs} are inherited.  For a
detailed description of how slots and slot options are inherited, see
section~\ref{Inheritance-of-Slots-and-Slot-Options-SECTION}.

The options to \cdf{defclass} can be extended.
An implementation must signal an error if it observes a class option or
a slot option that is not implemented locally.

It is valid to specify more than one reader, writer, accessor, or
initialization argument for a slot.  No other slot option may appear
more than once in a single slot description, or an error is
signaled.

If no reader, writer, or accessor is specified for a slot, the slot
can be accessed only by the function \cdf{slot-value}.

See sections \ref{Classes-SECTION},
\ref{Inheritance-SECTION},
\ref{Redefining-Classes-SECTION},
\ref{Determining-the-Class-Precedence-List-SECTION},
\ref{Object-Creation-and-Initialization-SECTION} as well as
\cdf{slot-value},
\cdf{make-instance}, and
\cdf{initialize-instance}.
\end{defmac}



\begin{defmac}
defgeneric function-name lambda-list
           <?option | {method-description}*>

\begin{tabbing}
\emph{function-name\/} ::= \Mgroup{\emph{symbol\/} {\Mor} \cd{(setf \emph{symbol\/})}} \\*
\pushtabs\emph{lambda-list\/} ::= \cd{(}\=\Mstar{{var}}  \\*
\>\Mopt{\cd{\&optional} \Mstar{{var {\Mor} \cd{(\emph{var\/})}}}}  \\*
\>\Mopt{\cd{\&rest} \emph{var\/}} \\*
\>\Mopt{\cd{\&key} \Mstar{keyword-parameter} \Mopt{\cd{\&allow-other-keys}}}\cd{)} \poptabs
\end{tabbing}
\begin{tabbing}
\emph{keyword-parameter\/} ::= \emph{var} {\Mor} \cd{(\Mgroup{var {\Mor} \cd{(\emph{keyword\/} \emph{var\/})}})} \\[2pt]
\pushtabs\emph{option\/} ::= \=\cd{(:argument-precedence-order \Mplus{parameter-name})} \\[2pt]
\>\hbox to 0pt{\hss\Mor~}\cd{(declare \Mplus{declaration})} \\
\>\hbox to 0pt{\hss\Mor~}\cd{(:documentation \emph{string\/})} \\
\>\hbox to 0pt{\hss\Mor~}\cd{(:method-combination \emph{symbol\/} \Mstar{{arg\/}})} \\
\>\hbox to 0pt{\hss\Mor~}\cd{(:generic-function-class \emph{class-name\/})} \\
\>\hbox to 0pt{\hss\Mor~}\cd{(:method-class \emph{class-name\/})} \poptabs \\[2pt]
\pushtabs\emph{method-description\/} ::= \cd{(:method }\=\Mstar{{method-qualifier\/}} \\
\>\emph{specialized-lambda-list\/} \\
\>\Mchoice{{\Mstar{declaration\/} {\Mor} documentation\/}} \\
\>\Mstar{{\,form\/}}\cd{)} \poptabs \\[2pt]
\emph{method-qualifier\/} ::= \emph{non-nil-atom} \\[2pt]
\pushtabs\emph{specialized-lambda-list\/} ::= \\*
\hskip 2pc \cd{(}\=\Mstar{{var {\Mor} \cd{(}var parameter-specializer-name\/\cd{)}}}  \\
\>\Mopt{\cd{\&optional} \Mstar{{var {\Mor} \cd{(}var \Mopt{initform {\Mopt{supplied-p-parameter}}}\cd{)}}}}  \\
\>\Mopt{\cd{\&rest \emph{var\/}}} \\
\>\Mopt{\cd{\&key} \Mstar{specialized-keyword-parameter} \Mopt{\cd{\&allow-other-keys}}} \\
\>\Mopt{\cd{\&aux} \Mstar{{var {\Mor} \cd{(\emph{var\/} \Mopt{initform})}}}}\cd{)} \poptabs \\[2pt]
\emph{specialized-keyword-parameter\/} ::= \\
\hskip 2pc \emph{var} {\Mor} \cd{(}\Mgroup{var {\Mor} \cd{(\emph{keyword\/} \emph{var\/}\cd{)}}}
       \Mopt{initform \Mopt{supplied-p-parameter}}\cd{)} \\[2pt]
\emph{parameter-specializer-name\/} ::= \emph{symbol} {\Mor} \cd{(eql \emph{eql-specializer-form\/})}
\end{tabbing}
The macro \cdf{defgeneric} is used to define a generic function or to
specify options and declarations that pertain to a generic function as
a whole.

If \cd{(fboundp \emph{function-name\/})} is \cdf{nil}, a new
generic function is created.  If \cd{(fdefinition {\it
function-specifier\/})} is a generic function, that generic function
is modified.  If \emph{function-name/} names a non-generic
function, a macro, or a special form, an error is signaled.

[X3J13 voted in March 1989 \issue{FUNCTION-NAME} to use \cdf{fdefinition}
in the previous paragraph, as shown, rather than \cdf{symbol-function},
as it appeared in the original report on CLOS~\cite{SIGPLAN-CLOS,LASC-CLOS-PART-2}.
The vote also changed all occurrences of \emph{function-specifier} in the
original report to \emph{function-name}; this change is reflected here.---GLS]

Each \emph{method-description\/} defines a method on the generic function.
The lambda-list of each method must be congruent with the lambda-list
specified by the \emph{lambda-list\/} option.  If this condition
does not hold, an error is signaled.
See section~\ref{Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION}
for a definition
of congruence in this context.

The macro \cdf{defgeneric} returns the generic function object 
as its result.




The \emph{function-name} argument is a non-\cdf{nil} symbol or a
list of the form \cd{(setf \emph{symbol\/})}.

\penalty-10000 %required

The \emph{lambda-list\/} argument is an ordinary function lambda-list
with the following exceptions:

\begin{itemize}
\item 
The use of \cd{\&aux} is not allowed. 

\item 
Optional and keyword arguments may not have default initial value forms
nor use supplied-p parameters.
The generic function passes to the method all the argument values passed to
it, and only those; default values are not supported.
Note that optional and keyword arguments in method definitions, however,
can have default initial value forms and can use supplied-p parameters. 
\end{itemize}

The following options are provided.  A given option may occur only once,
or an error is signaled.

\begin{itemize}
 
\item  
The \cd{:argument-precedence-order} option is used to specify the
order in which the required arguments in a call to the generic
function are tested for specificity when selecting a particular
method.  Each required argument, as specified in the \emph{lambda-list\/}
argument, must be included exactly once as a {\it
parameter-name} so that the full and unambiguous precedence order is
supplied.  If this condition is not met, an error is signaled.

\item 
The \cdf{declare} option is used to specify declarations that pertain
to the generic function.  The following standard Common Lisp
declaration is allowed:

\begin{itemize}
\item
An \cdf{optimize} declaration specifies whether method selection
should be optimized for speed or space, but it has no effect on
methods.  To control how a method is optimized, an \cdf{optimize}
declaration must be placed directly in the \cdf{defmethod} form or
method description.  The optimization qualities \cdf{speed} and 
\cdf{space} are the only qualities this standard requires, but an
implementation can extend the \CLOS\ to recognize other qualities.  A
simple implementation that has only one method selection technique and
ignores the \cdf{optimize} declaration is valid.
\end{itemize}

The \cdf{special}, \cdf{ftype}, \cdf{function}, \cdf{inline}, 
\cdf{notinline}, and \cdf{declaration} declarations are not permitted.
Individual implementations can extend the \cdf{declare} option to
support additional declarations.  If an implementation notices a
declaration that it does not support and that has not been proclaimed
as a non-standard declaration name in a \cdf{declaration} proclamation, it
should issue a warning.

\item  
The \cd{:documentation} argument associates a documentation string
with the generic function.  The documentation type for this string is
\cdf{function}.  The form \cd{(documentation {\it
function-name/} 'function)} may be used to retrieve this
string.

\item  
The \cd{:generic-function-class} option may be used to specify that
the generic function is to have a different class than the default
provided by the system (the class \cdf{standard-generic-function}).
The \emph{class-name\/} argument is the name of a class that can be the
class of a generic function.  If \emph{function-name\/} specifies
an existing generic function that has a different value for the 
\cd{:generic-function-class} argument and the new generic function class
is compatible with the old, \cdf{change-class} is called to change the
class of the generic function; otherwise an error is signaled.

\item  
The \cd{:method-class} option is used to specify that all methods on
this generic function are to have a different class from the default
provided by the system (the class \cdf{standard-method}).  The {\it
class-name\/} argument is the name of a class that is capable of being
the class of a method.

\item  
The \cd{:method-combination} option is followed by a symbol that
names a type of method combination.  The arguments (if any) that
follow that symbol depend on the type of method combination.  Note
that the standard method combination type does not support any
arguments.  However, all types of method combination defined by the
short form of \cdf{define-method-combination} accept an optional
argument named \emph{order\/}, defaulting to 
\cd{:most-specific-first}, where a value of \cd{:most-specific-last} reverses
the order of the primary methods without affecting the order of the
auxiliary methods.

\end{itemize}

The \emph{method-description\/} arguments define methods that will
be associated with the generic function.  The \emph{method-qualifier}
and \emph{specialized-lambda-list} arguments in a method description
are the same as for \cdf{defmethod}.

The \emph{form\/} arguments specify the method body.  The body of the
method is enclosed in an implicit block.  If {\it
function-name\/} is a symbol, this block bears the same name as
the generic function.  If \emph{function-name\/} is a list of the
form \cd{(setf \emph{symbol\/})}, the name of the block is {\it
symbol}.  


The generic function object is returned as the result. 


The effect of the \cdf{defgeneric} macro is as if the following three
steps were performed: first, methods defined by previous 
\cdf{defgeneric} forms are removed; second, \cdf{ensure-generic-function}
is called; and finally, methods specified by the current 
\cdf{defgeneric} form are added to the generic function. 

If no method descriptions are specified and a generic function of the same
name does not already exist, a generic function with no methods is created.


The \emph{lambda-list\/} argument of 
\cdf{defgeneric} specifies the shape of lambda-lists for the methods on
this generic function.  All methods on the resulting generic function must have
lambda-lists that are congruent with this shape.  If a 
\cdf{defgeneric} form is evaluated and some methods for that generic
function have lambda-lists that are not congruent with that given in
the \cdf{defgeneric} form, an error is signaled.  For further details
on method congruence,
see section~\ref{Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION}.

Implementations can extend \cdf{defgeneric} to include other options.
It is required that an implementation signal an error if
it observes an option that is not implemented locally.

See section~\ref{Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION}
as well as \cdf{defmethod}, \cdf{ensure-generic-function}, and \cdf{generic-function}.
\end{defmac}


\begin{defmac}
define-method-combination name <?short-form-option> \\
define-method-combination name lambda-list
    ({method-group-specifier}*)
    [(\!:arguments! \!.! lambda-list)]
    [(\!:generic-function! generic-fn-symbol)]
    <{declaration}* | doc-string>
    {\,form}*

\begin{tabbing}
\pushtabs\emph{short-form-option\/} ::= \=\cd{:documentation \emph{string\/}} \\
\>\hbox to 0pt{\hss\Mor~}\cd{:identity-with-one-argument \emph{boolean\/}} \\
\>\hbox to 0pt{\hss\Mor~}\cd{:operator \emph{operator\/}} \poptabs \\
\pushtabs\emph{method-group-specifier\/} ::= \cd{(}\=\emph{variable\/}
    \Mgroup{\Mplus{{qualifier-pattern}} {\Mor} predicate\/} \\
\>\Mchoice{\Mind{long-form-option}}\cd{)} \poptabs \\
\pushtabs\emph{long-form-option\/} ::= \=\cd{:description \emph{format-string\/}} \\
\>\hbox to 0pt{\hss\Mor~}\cd{:order \emph{order\/}} \\
\>\hbox to 0pt{\hss\Mor~}\cd{:required \emph{boolean\/}} \poptabs
\end{tabbing}
The macro \cdf{define-method-combination} is used to define new types
of method combination.

There are two forms of \cdf{define-method-combination}.  The short
form is a simple facility for the cases that are expected
to be most commonly needed.  The long form is more powerful but more
verbose.  It resembles \cdf{defmacro} in that the body is an
expression, usually using backquote, that computes a Lisp form.  Thus
arbitrary control structures can be implemented.  The long form also
allows arbitrary processing of method qualifiers.





In both the short and long forms, \emph{name\/} is a symbol.  By convention,
non-keyword, non-\cdf{nil} symbols are usually used.

\medskip

The short-form syntax of \cdf{define-method-combination} is recognized
when the second subform is a non-\cdf{nil} symbol or is not present.
When the short form is used, \emph{name\/} is defined as a type of
method combination that produces a Lisp form \cd{(\emph{operator
method-call method-call $\ldots$ })}.  The \emph{operator\/} is a symbol
that can be the name of a function, macro, or special form.  The
\emph{operator\/} can be specified by a keyword option; it defaults to {\it
name}.

Keyword options for the short form are the following:

\begin{itemize}

\item 
The \cd{:documentation} option is used to document the method-combination type.

\item 
The \cd{:identity-with-one-argument} option enables an optimization
when \emph{boolean\/} is true (the default is false).  If there is
exactly one applicable method and it is a primary method, that method
serves as the effective method and \emph{operator\/} is not called.
This optimization avoids the need to create a new effective method and
avoids the overhead of a function call.  This option is designed to be
used with operators such as \cdf{progn}, \cdf{and}, \cdf{+}, and
\cdf{max}.

\item 
The \cd{:operator} option specifies the name of the operator.  The
\emph{operator\/} argument is a symbol that can be the name of a
function, macro, or special form.  By convention, \emph{name\/} and
\emph{operator\/} are often the same symbol.  This is the default,
but it is not required.

\end{itemize}

None of the subforms is evaluated.

These types of method combination require exactly one qualifier per
method.  An error is signaled if there are applicable methods with no
qualifiers or with qualifiers that are not supported by the method
combination type. 

A method combination procedure defined in this way recognizes two
roles for methods.  A method whose one qualifier is the symbol naming
this type of method combination is defined to be a primary method.  At
least one primary method must be applicable or an error is signaled.
A method with \cd{:around} as its one qualifier is an auxiliary
method that behaves the same as an \cd{:around} method in standard
method combination.  The function \cdf{call-next-method} can be
used only in \cd{:around} methods; it cannot be used in primary methods
defined by the short form of the \cdf{define-method-combination} macro.

A method combination procedure defined in this way accepts an optional
argument named \emph{order}, which defaults to 
\cd{:most-specific-first}.  A value of \cd{:most-specific-last} reverses
the order of the primary methods without affecting the order of the
auxiliary methods.

The short form automatically includes error checking and support for
\cd{:around} methods.

For a discussion of built-in method combination types,
see section~\ref{Built-in-Method-Combination-Types-SECTION}.

\medskip

The long-form syntax of \cdf{define-method-combination} is recognized 
when the second subform is a list.  

The \emph{lambda-list\/} argument is an ordinary lambda-list.  It
receives any arguments provided after the name of the method
combination type in the \cd{:method-\discretionary{}{}{}combination} option to 
\cdf{defgeneric}.

A list of method group specifiers follows.  Each specifier selects a subset
of the applicable methods to play a particular role, either by matching
their qualifiers against some patterns or by testing their qualifiers with
a predicate.   These method group specifiers define all method qualifiers
that can be used with this type of method combination.  If an applicable 
method does not fall into any method group, the system signals the error
that the method is invalid for the kind of method combination in use.

Each method group specifier names a variable.  During the execution of
the forms in the body of \cdf{define-method-combination}, this
variable is bound to a list of the methods in the method group.  The
methods in this list occur in most-specific-first order.

A qualifier pattern is a list or the symbol \cdf{*}.  A method matches
a qualifier pattern if the method's list of qualifiers is \cdf{equal}
to the qualifier pattern (except that the symbol \cdf{*} in a qualifier
pattern matches anything).  Thus a qualifier pattern can be one of the
following: the empty list \cd{()}, which matches unqualified methods;
the symbol \cdf{*}, which matches all methods; a true list, which
matches methods with the same number of qualifiers as the length of
the list when each qualifier matches the corresponding list element;
or a dotted list that ends in the symbol \cdf{*} (the \cdf{*} matches
any number of additional qualifiers).


Each applicable method is tested against the qualifier patterns and
predicates in left-to-right order.  As soon as a qualifier pattern matches
or a predicate returns true, the method becomes a member of the
corresponding method group and no further tests are made.  Thus if a method
could be a member of more than one method group, it joins only the first
such group.  If a method group has more than one qualifier pattern, a
method need only satisfy one of the qualifier patterns to be a member of
the group.

The name of a predicate function can appear instead of qualifier
patterns in a method group specifier.  The predicate is called for
each method that has not been assigned to an earlier method group; it
is called with one argument, the method's qualifier list.  The
predicate should return true if the method is to be a member of the
method group.  A predicate can be distinguished from a qualifier pattern
because it is a symbol other than \cdf{nil} or \cdf{*}.

If there is an applicable method whose qualifiers are not valid
for the method combination type, the function \cdf{invalid-method-error}
is called.

Method group specifiers can have keyword options following the
qualifier patterns or predicate.  Keyword options can be distinguished from
additional qualifier patterns because they are neither lists nor the symbol
\cdf{*}.  The keyword options are:
\vskip 0pt plus 4pt%manual
\hrule width 0pt\relax

\begin{itemize}

\item 
The \cd{:description} option is used to provide a description of the
role of methods in the method group.  Programming environment tools
use \cd{(apply \#'format stream \emph{format-string\/}
(method-qualifiers \emph{method\/}))} to print this description, which
is expected to be concise.  This keyword
option allows the description of a method qualifier to be defined in
the same module that defines the meaning of the method
qualifier.  In most cases, \emph{format-string\/} will not contain any
\cdf{format} directives, but they are available for generality.  If 
\cd{:description} is not specified, a default description is generated
based on the variable name and the qualifier patterns and on whether
this method group includes the unqualified methods.  The argument {\it
format-string\/} is not evaluated.

\item 
The \cd{:order} option specifies the order of methods.  The {\it
order\/} argument is a form that evaluates to 
\cd{:most-specific-first} or \cd{:most-specific-last}.  If it evaluates
to any other value, an error is signaled.  This keyword option is a
convenience and does not add any expressive power.
If \cd{:order} is not specified, it defaults to \cd{:most-specific-first}.

\item 
The \cd{:required} option specifies whether at least one method in
this method group is required.  If the \emph{boolean\/} argument is
non-\cdf{nil} and the method group is empty (that is, no applicable
methods match the qualifier patterns or satisfy the predicate), an
error is signaled.  This keyword option is a convenience and does not
add any expressive power.  If \cd{:required} is not specified,
it defaults to \cdf{nil}.  The \emph{boolean\/} argument is not
evaluated.

\end{itemize}

The use of method group specifiers provides a convenient syntax to
select methods, to divide them among the possible roles, and to perform the
necessary error checking.  It is possible to perform further filtering
of methods in the body forms by using normal list-processing operations
and the functions \cdf{method-qualifiers} and 
\cdf{invalid-method-error}.  It is permissible to use \cdf{setq} on the
variables named in the method group specifiers and to bind additional
variables.  It is also possible to bypass the method group specifier
mechanism and do everything in the body forms.  This is accomplished
by writing a single method group with \cdf{*} as its only qualifier
pattern; the variable is then bound to a list of all of the applicable
methods, in most-specific-first order.

The body \emph{forms\/} compute and return the Lisp form that specifies
how the methods are combined, that is, the effective method.  The
effective method uses the macro \cdf{call-method}.  The definition of this macro has
lexical scope and is available only in an effective method form.
Given a method object in one of the lists produced by the method group
specifiers and a list of next methods, the macro \cdf{call-method}
will invoke the method so that \cdf{call-next-method} will have available
the next methods.

When an effective method has no effect other than to call a single
method, some implementations employ an optimization that uses the
single method directly as the effective method, thus avoiding the need
to create a new effective method.  This optimization is active when
the effective method form consists entirely of an invocation of
the \cdf{call-method} macro whose first subform is a method object and
whose second subform is \cdf{nil}.  Each 
\cdf{define-method-combination} body is responsible for stripping off
redundant invocations of \cdf{progn}, \cdf{and}, 
\cd{multiple-value-prog1}, and the like, if this optimization is desired.


The list \cd{(:arguments . \emph{lambda-list\/})} can appear before
any declaration or documentation string.  This form is useful when
the method combination type performs some specific behavior as part of
the combined method and that behavior needs access to the arguments to
the generic function.  Each parameter variable defined by {\it
lambda-list\/} is bound to a form that can be inserted into the
effective method.  When this form is evaluated during execution of the
effective method, its value is the corresponding argument to the
generic function.  If \emph{lambda-list\/} is not congruent to the
generic function's lambda-list, additional ignored parameters are
automatic\-ally inserted until it is congruent.  Thus it is permissible
for \emph{lambda-list\/} to receive fewer arguments than the number
that the generic function expects.
 
Erroneous conditions detected by the body should be reported with
\cd{method-\discretionary{}{}{}combination-\discretionary{}{}{}error} or
\cd{invalid-\discretionary{}{}{}method-\discretionary{}{}{}error}; these functions
add any necessary contextual information to the error message and will
signal the appropriate error.

The body \emph{forms\/} are evaluated inside the bindings created by the
lambda-list and method group specifiers.  Declarations at the head of
the body are positioned directly inside bindings created by the
lambda-list and outside the bindings of the method group variables. 
Thus method group variables cannot be declared.

Within the body \emph{forms\/}, \emph{generic-function-symbol}
is bound to the generic function object.

If a \emph{doc-string\/} argument is present, it provides the
documentation for the method combination type.

The functions \cdf{method-combination-error} and 
\cdf{invalid-method-error} can be called from the body \emph{forms\/} or
from functions called by the body \emph{forms\/}.  The actions of these
two functions can depend on implementation-dependent dynamic variables
automatically bound before the generic function 
\cd{compute-\discretionary{}{}{}effective-\discretionary{}{}{}method} is called.

Note that two methods with identical specializers, but with different
qualifiers, are not ordered by the algorithm described in step~2 of
the method selection and combination process described in
section~\ref{Method-Selection-and-Combination-SECTION}.
Normally the two methods play
different roles in the effective method because they have different
qualifiers, and no matter how they are ordered in the result of step~2
the effective method is the same.  If the two methods play the same
role and their order matters, an error is signaled.  This happens as
part of the qualifier pattern matching in 
\cdf{define-method-combination}.

\penalty-10000 %required

The value returned by the \cdf{define-method-combination} macro is the new
method combination object.


Most examples of the long form of \cdf{define-method-combination} also
illustrate the use of the related functions that are provided as part
of the declarative method combination facility.

\vskip 0pt plus 4pt
\hrule width0pt\relax

\begin{lisp}
;;; Examples of the short form of define-method-combination \\
\\
(define-method-combination and :identity-with-one-argument t) \\
\\
(defmethod func and ((x class1) y) \\
~~...) \\
\\
;;; The equivalent of this example in the long form is: \\*
\\*
(define-method-combination and \\*
~~~~~~~~(\&optional (order ':most-specific-first)) \\*
~~~~~~~~((around (:around)) \\*
~~~~~~~~~(primary (and) :order order :required t)) \\
~~(let ((form (if (rest primary) \\*
~~~~~~~~~~~~~~~~~~{\Xbq}(and ,{\Xatsign}(mapcar \#'(lambda (method) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,method ())) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~primary)) \\*
~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,(first primary) ())))) \\
~~~~(if around \\*
~~~~~~~~{\Xbq}(call-method ,(first around) \\*
~~~~~~~~~~~~~~~~~~~~~~(,{\Xatsign}(rest around) \\*
~~~~~~~~~~~~~~~~~~~~~~~(make-method ,form))) \\*
~~~~~~~~form))) \\
\\
\\
;;; Examples of the long form of define-method-combination \\*
\\*
;;; The default method-combination technique \\*
\\*
(define-method-combination standard () \\*
~~~~~~~~((around (:around)) \\*
~~~~~~~~~(before (:before)) \\*
~~~~~~~~~(primary () :required t) \\*
~~~~~~~~~(after (:after))) \\
~~(flet ((call-methods (methods) \\*
~~~~~~~~~~~(mapcar \#'(lambda (method) \\*
~~~~~~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,method ())) \\*
~~~~~~~~~~~~~~~~~~~methods))) \\
~~~~(let ((form (if (or before after (rest primary)) \\*
~~~~~~~~~~~~~~~~~~~~{\Xbq}(multiple-value-prog1 \\*
~~~~~~~~~~~~~~~~~~~~~~~(progn ,{\Xatsign}(call-methods before) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(call-method ,(first primary) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~,(rest primary))) \\*
~~~~~~~~~~~~~~~~~~~~~~~,{\Xatsign}(call-methods (reverse after))) \\*
~~~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,(first primary) ())))) \\
~~~~~~(if around \\*
~~~~~~~~~~{\Xbq}(call-method ,(first around) \\*
~~~~~~~~~~~~~~~~~~~~~~~~(,{\Xatsign}(rest around) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~(make-method ,form))) \\*
~~~~~~~~~~form))))
\end{lisp}
\vskip 0pt plus 10pt
\hrule width 0pt\relax
\begin{lisp}
;;; A simple way to try several methods until one returns non-nil \\*
\\*
(define-method-combination or () \\*
~~~~~~~~((methods (or))) \\*
~~{\Xbq}(or ,{\Xatsign}(mapcar \#'(lambda (method) \\*
~~~~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,method ())) \\*
~~~~~~~~~~~~~~~~~methods))) \\
\\
;;; A more complete version of the preceding \\*
\\*
(define-method-combination or  \\*
~~~~~~~~(\&optional (order ':most-specific-first)) \\*
~~~~~~~~((around (:around)) \\*
~~~~~~~~~(primary (or))) \\
~~;; Process the order argument \\*
~~(case order \\*
~~~~(:most-specific-first) \\*
~~~~(:most-specific-last (setq primary (reverse primary))) \\*
~~~~(otherwise (method-combination-error \\*
~~~~~~~~~~~~~~~~~"{\Xtilde}S is an invalid order.{\Xtilde}{\Xatsign} \\*
~~~~~~~~~~~~~~~~~~:most-specific-first and :most-specific-last {\Xtilde} \\*
~~~~~~~~~~~~~~~~~~~~are the possible values." \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~order))) \\
~~;; Must have a primary method \\*
~~(unless primary \\*
~~~~(method-combination-error "A primary method is required.")) \\
~~;; Construct the form that calls the primary methods \\*
~~(let ((form (if (rest primary) \\*
~~~~~~~~~~~~~~~~~~{\Xbq}(or ,{\Xatsign}(mapcar \#'(lambda (method) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,method ())) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~primary)) \\*
~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,(first primary) ())))) \\
~~~~;; Wrap the around methods around that form \\*
~~~~(if around \\*
~~~~~~~~{\Xbq}(call-method ,(first around) \\*
~~~~~~~~~~~~~~~~~~~~~~(,{\Xatsign}(rest around) \\*
~~~~~~~~~~~~~~~~~~~~~~~(make-method ,form))) \\*
~~~~~~~~form)))
\end{lisp}
\vskip 0pt plus 10pt
\hrule width 0pt\relax
\begin{lisp}
;;; The same thing, using the :order and :required keyword options \\*
(define-method-combination or  \\*
~~~~~~~~(\&optional (order ':most-specific-first)) \\*
~~~~~~~~((around (:around)) \\*
~~~~~~~~~(primary (or) :order order :required t)) \\
~~(let ((form (if (rest primary) \\*
~~~~~~~~~~~~~~~~~~{\Xbq}(or ,{\Xatsign}(mapcar \#'(lambda (method) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,method ())) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~primary)) \\*
~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,(first primary) ())))) \\
~~~~(if around \\*
~~~~~~~~{\Xbq}(call-method ,(first around) \\*
~~~~~~~~~~~~~~~~~~~~~~(,{\Xatsign}(rest around) \\*
~~~~~~~~~~~~~~~~~~~~~~~(make-method ,form))) \\*
~~~~~~~~form))) \\
\\
;;; This short-form call is behaviorally identical to the preceding. \\*
(define-method-combination or :identity-with-one-argument t) \\
 \\
;;; Order methods by positive integer qualifiers; note that :around \\*
;;; methods are disallowed here in order to keep the example small. \\*
\\*
(define-method-combination example-method-combination () \\*
~~~~~~~~((methods positive-integer-qualifier-p)) \\
~~{\Xbq}(progn ,{\Xatsign}(mapcar \#'(lambda (method) \\*
~~~~~~~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,method ())) \\*
~~~~~~~~~~~~~~~~~~~~(stable-sort methods \#'< \\*
~~~~~~~~~~~~~~~~~~~~~~:key \#'(lambda (method) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(first (method-qualifiers \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~method))))))) \\
\\
(defun positive-integer-qualifier-p (method-qualifiers) \\*
~~(and (= (length method-qualifiers) 1) \\*
~~~~~~~(typep (first method-qualifiers) '(integer 0 *)))) \\
\\
;;; Example of the use of :arguments \\*
(define-method-combination progn-with-lock () \\*
~~~~~~~~((methods ())) \\*
~~~~~~~~(:arguments object) \\
~~{\Xbq}(unwind-protect \\*
~~~~~~~(progn (lock (object-lock ,object)) \\*
~~~~~~~~~~~~~~,{\Xatsign}(mapcar \#'(lambda (method) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~{\Xbq}(call-method ,method ())) \\*
~~~~~~~~~~~~~~~~~~~~~~~~methods)) \\*
~~~~~(unlock (object-lock ,object))))
\end{lisp}



The \cd{:method-combination} option of \cdf{defgeneric} is used to
specify that a generic function should use a particular method
combination type.  The argument to the \cd{:method-combination}
option is the name of a method combination type.
 
See sections~\ref{Method-Selection-and-Combination-SECTION} and
\ref{Built-in-Method-Combination-Types-SECTION} as well as
\cdf{call-method},
\cdf{method-qualifiers},
\cdf{method-combination-error},
\cdf{invalid-method-error},
and \cdf{defgeneric}.
\end{defmac}



\begin{defmac}
defmethod function-name {method-qualifier}*
          specialized-lambda-list
          <{declaration}* | doc-string> {\,form}*

\begin{tabbing}
\emph{function-name\/} ::= \Mgroup{\emph{symbol\/} {\Mor} \cd{(setf \emph{symbol\/})}} \\*
\emph{method-qualifier\/} ::= \emph{non-nil-atom} \\*
\emph{parameter-specializer-name\/} ::= \emph{symbol} {\Mor} \cd{(eql \emph{eql-specializer-form\/})}
\end{tabbing}
The macro \cdf{defmethod} defines a method on a generic function.  

If \cd{(fboundp \emph{function-name\/})} is \cdf{nil}, a generic
function is created with default values for the argument precedence
order (each argument is more specific than the arguments to its right
in the argument list), for the generic function class (the class 
\cdf{standard-generic-function}), for the method class (the class 
\cdf{standard-method}), and for the method combination type (the standard
method combination type).  The lambda-list of the generic function is
congruent with the lambda-list of the method being defined; if the
\cdf{defmethod} form mentions keyword arguments, the lambda-list of
the generic function will mention \cd{\&key} (but no keyword
arguments).  If \emph{function-name\/} names a non-generic
function, a macro, or a special form, an error is signaled.

If a generic function is currently named by {\it
function-name\/}, where \emph{function-name\/} is a symbol or
a list of the form \cd{(setf \emph{symbol\/})}, the lambda-list of the
method must be congruent with the lambda-list of the generic function.
If this condition does not hold, an error is signaled.  See
section~\ref{Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION}
for a definition of congruence in this context.




The \emph{function-name\/} argument is a non-\cdf{nil} symbol or a
list of the form \cd{(setf \emph{symbol\/})}.  It names the generic
function on which the method is defined.

Each \emph{method-qualifier\/} argument is an object that is used by
method combination to identify the given method.  A method qualifier
is a non-\cdf{nil} atom.  The method combination type may further
restrict what a method qualifier may be.  The standard method
combination type allows for unqualified methods or methods whose sole
qualifier is the keyword \cd{:before}, the keyword 
\cd{:after}, or the keyword \cd{:around}.

A \emph{specialized-lambda-list\/} is like an ordinary
function lambda-list except that the name of a required parameter can
be replaced by a specialized parameter, a
list of the form \cd{(\emph{variable-name
parameter-specializer-name\/})}.  Only required parameters may be
specialized.  A parameter specializer name is a symbol that names a
class or \cd{(eql \emph{eql-specializer-form\/})}.  The parameter
specializer name \cd{(eql \emph{eql-specializer-form\/})} indicates
that the corresponding argument must be \cdf{eql} to the object that
is the value of \emph{eql-specializer-form\/} for the method to be
applicable.  If no parameter specializer name is specified for a given
required parameter, the parameter specializer defaults to the class
named \cdf{t}.  See section \ref{Introduction-to-Methods-SECTION}.

The \emph{form\/} arguments specify the method body.
The body of the method is enclosed in an implicit block.  If
\emph{function-name\/} is a symbol, this block bears the same name as the
generic function.  If \emph{function-name\/} is a list of the form 
\cd{(setf \emph{symbol\/})}, the name of the block is \emph{symbol}.  


The result of \cdf{defmethod} is the method object.


The class of the method object that is created is that given by the 
method class option of the generic function on which the method is defined.

If the generic function already has a method that agrees with the
method being defined on parameter specializers and qualifiers, 
\cdf{defmethod} replaces the existing method with the one now being
defined.  See
section~\ref{Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION}
for a definition of agreement in this context.

The parameter specializers are derived from the parameter specializer
names as described in section~\ref{Introduction-to-Methods-SECTION}.

The expansion of the \cdf{defmethod} macro refers to each
specialized parameter (see the \cdf{ignore} declaration specifier), including
parameters that
have an explicit parameter specializer name of \cdf{t}.  This means
that a compiler warning does not occur if the body of the method does
not refer to a specialized parameter.  Note that a parameter that
specializes on \cdf{t} is not synonymous with an unspecialized
parameter in this context.

See sections~\ref{Introduction-to-Methods-SECTION},
\ref{Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION},
and \ref{Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION}.
\end{defmac}


[At this point the original CLOS report \cite{SIGPLAN-CLOS,LASC-CLOS-PART-2}
contained a specification for \cdf{describe} as a generic function.
This specification is omitted here because X3J13 voted in March 1989 \issue{DESCRIBE-UNDERSPECIFIED}
not to make \cdf{describe} a generic function after all (see \cdf{describe-object}).---GLS]


\begin{defun}[Generic function][Primary method]
documentation x &optional doc-type \\
documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      (method standard-method)  &optional doc-type \\
documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      (generic-function standard-generic-function) &optional doc-type \\
documentation (class standard-class)  &optional doc-type \\
documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      (method-combination method-combination) &optional doc-type \\
documentation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      (slot-description standard-slot-description) &optional doc-type \\
documentation (symbol symbol) &optional doc-type \\
documentation (list list) &optional doc-type

The ordinary function \cdf{documentation} (see section~\ref{DOCUMENTATION-SECTION})
is replaced by a generic
function.  The generic function \cdf{documentation} returns the
documentation string associated with the given object if it is
available; otherwise \cdf{documentation} returns \cdf{nil}.


The first argument of \cdf{documentation} is a symbol, a
function-name list of the form \cd{(setf \emph{symbol\/})}, a
method object, a class object, a generic function object, a method
combination object, or a slot description object.
Whether a second argument should be supplied depends on the
type of the first argument.
\begin{itemize}

\item 
If the first argument is a method object, a class object, a generic
function object, a method combination object, or a slot description
object, the second argument must not be supplied, or an error is
signaled.

\item  
If the first argument is a symbol or a list of the form
\cd{(setf \emph{symbol\/})}, the second argument must be
supplied.

\begin{itemize}
\item
The forms
\begin{lisp}
(documentation \emph{symbol\/} 'function)
\end{lisp}
and
\begin{lisp}
(documentation '(setf \emph{symbol\/}) 'function)
\end{lisp}
return the
documentation string of the function, generic function, special form, or
macro named by the symbol or list.

\item
The form \cd{(documentation \emph{symbol\/} 'variable)} returns the
documentation string of the special variable or constant named by the
symbol.

\item
The form \cd{(documentation \emph{symbol\/} 'structure)} returns the
documentation string of the \cdf{defstruct} structure named by the
symbol.

\item
The form \cd{(documentation \emph{symbol\/} 'type)} returns the documentation
string of the class object named by the symbol, if there is such a
class.   If there is no such class, it returns the documentation string
of the type specifier named by the symbol. 

\item
The form \cd{(documentation \emph{symbol\/} 'setf)} returns the documentation
string of the \cdf{defsetf} or \cdf{define-setf-method} definition
associated with the symbol.

\item
The form \cd{(documentation \emph{symbol\/} 'method-combination)} returns the
documentation string of the method combination type named by the
symbol.  
\end{itemize}

\end{itemize}

An implementation may extend the set of symbols that are acceptable as
the second argument.  If a symbol is not recognized as an acceptable
argument by the implementation, an error must be signaled.


The documentation string associated with the given object is returned
unless none is available, in which case \cdf{documentation} returns
\cdf{nil}.

\end{defun}


\begin{defun}[Generic function][Primary method]
(setf documentation) new-value x &optional doc-type \\
(setf documentation) new-value (method standard-method) &optional doc-type \\
(setf documentation) new-value (generic-function standard-generic-function) &optional doc-type \\
(setf documentation) new-value (class standard-class) &optional doc-type \\
(setf documentation) new-value (method-combination method-combination) &optional doc-type \\
(setf documentation) new-value (slot-description standard-slot-description) &optional doc-type \\
(setf documentation) new-value (symbol symbol) &optional doc-type \\
(setf documentation) new-value (list list) &optional doc-type

The generic function \cd{(setf documentation)} is used to update the
documentation.

The first argument of \cd{(setf documentation)} is the new documentation.

The second argument of \cdf{documentation} is a symbol, a
function-name list of the form \cd{(setf \emph{symbol\/})}, a
method object, a class object, a generic function object, a method
combination object, or a slot description object.
Whether a third argument should be supplied depends on the
type of the second argument.
See \cdf{documentation}.
\end{defun}


\begin{defun}[Function]
ensure-generic-function function-name &key :lambda-list
:argument-precedence-order
:declare
:documentation
:generic-function-class
:method-combination
:method-class
:environment

\begin{tabbing}
\emph{function-name\/} ::= \Mgroup{\emph{symbol\/} {\Mor} \cd{(setf \emph{symbol\/})}}
\end{tabbing}
The function \cdf{ensure-generic-function} is used to define a
globally named generic function with no methods or to specify or
modify options and declarations that pertain to a globally named
generic function as a whole.

If \cd{(fboundp \emph{function-name\/})} is \cdf{nil}, a new
generic function is created.  If \cd{(fdefinition {\it
function-name\/})} is a non-generic function, a macro, or a
special form, an error is signaled.

[X3J13 voted in March 1989 \issue{FUNCTION-NAME} to use \cdf{fdefinition}
in the previous paragraph, as shown, rather than \cdf{symbol-function},
as it appeared in the original report on CLOS~\cite{SIGPLAN-CLOS,LASC-CLOS-PART-2}.
The vote also changed all occurrences of \emph{function-specifier} in the
original report to \emph{function-name}; this change is reflected here.---GLS]

If \emph{function-name\/} specifies a generic function that has a
different value for any of the following arguments, the generic
function is modified to have the new value: 
\cd{:argument-precedence-order}, \cd{:declare}, \cd{:documentation},
\cd{:method-combination}.

If \emph{function-name\/} specifies a generic function that has a
different value for the \cd{:lambda-list} argument, and the new value
is congruent with the lambda-lists of all existing methods or there
are no methods, the value is changed; otherwise an error is signaled.

If \emph{function-name\/} specifies a generic function that has a
different value for the \cd{:generic-function-class} argument and if
the new generic function class is compatible with the old, 
\cdf{change-class} is called to change the class of the generic function;
otherwise an error is signaled.

If \emph{function-name\/} specifies a generic function that has a
different \cd{:method-class} value, the value is
changed but any existing methods are not changed.




The \emph{function-name\/} argument is a symbol or a list of the
form \cd{(setf \emph{symbol\/})}.

The keyword arguments correspond to the \emph{option\/} arguments of
\cdf{defgeneric}, except that the \cd{:method-class} and
\cd{:generic-function-class} arguments can be class objects
as well as names.


The \cd{:environment\/} argument is the same as the 
\cd{\&environment} argument to macro expansion functions.  It is typically
used to distinguish between compile-time and run-time environments.

The \cd{:method-combination} argument is a method combination object.


The generic function object is returned.
See \cdf{defgeneric}.
\end{defun}


\begin{defun}[Function]
find-class symbol &optional errorp environment

The function \cdf{find-class} returns the class object named by the
given symbol in the given environment.




The first argument to \cdf{find-class} is a symbol. 

If there is no such class and the \emph{errorp\/} argument is
not supplied or is non-\cdf{nil}, \cdf{find-class} signals an error.
If there is no such class and the \emph{errorp\/} argument is
\cdf{nil}, \cdf{find-class} returns \cdf{nil}.  The default value of
\emph{errorp\/} is \cdf{t}.

The optional \emph{environment\/} argument is the same as the 
\cd{\&environment} argument to macro expansion functions.  It is typically
used to distinguish between compile-time and run-time environments.


The result of \cdf{find-class} is the class object named by the given symbol.


The class associated with a particular symbol can be changed by using
\cdf{setf} with \cdf{find-class}.  The results are undefined if
the user attempts to change the class associated with a symbol that is
defined as a type specifier in chapter~\ref{DTSPEC}.
See section~\ref{Integrating-Types-and-Classes-SECTION}.

\end{defun}


\begin{defun}[Generic function][Primary method]
find-method generic-function method-qualifiers specializers &optional errorp \\
find-method (generic-function standard-generic-function)
   method-qualifiers specializers &optional errorp

The generic function \cdf{find-method} takes a generic function and
returns the method object that agrees on method qualifiers and
parameter specializers with the \emph{method-qualifiers\/} and {\it
specializers\/} arguments of \cdf{find-method}.
See section~\ref{Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION} for a
definition of agreement in this context.





The \emph{generic-function\/} argument is a generic function.

The \emph{method-qualifiers\/} argument is a list of the
method qualifiers for the method.   The order of the method qualifiers
is significant.  

The \emph{specializers\/} argument is a list of the parameter
specializers for the method.  It must correspond in length to
the number of required arguments of the generic function, or
an error is signaled.  This means that to obtain the
default method on a given generic function, a list whose
elements are the class named \cdf{t} must be given.

If there is no such method and the \emph{errorp\/} argument is
not supplied or is non-\cdf{nil}, \cdf{find-method} signals an error.
If there is no such method and the \emph{errorp\/} argument is
\cdf{nil}, \cdf{find-method} returns \cdf{nil}.  The default value of
\emph{errorp\/} is \cdf{t}.


The result of \cdf{find-method} is the method object with the given
method qualifiers and parameter specializers.

See section~\ref{Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION}.

\end{defun}


\begin{defun}[Generic function][Primary method]
function-keywords method \\
function-keywords (method standard-method)

The generic function \cdf{function-keywords} is used to return the keyword
parameter specifiers for a given method.





The \emph{method\/} argument is a method object.


The generic function \cdf{function-keywords} returns two values:
a list of the explicitly named keywords and a boolean that states whether
\cd{\&allow-other-keys} had been specified in the method definition.

\end{defun}


\begin{defspec}
generic-flet ({(function-name lambda-list
                <?option | {method-description}*>)}*)
            {\,form}*

The \cdf{generic-flet} special form is analogous to the
\cdf{flet} special form.  It produces new generic functions and
establishes new lexical function definition bindings.  Each generic
function is created with the set of methods specified by its method
descriptions.


The special form \cdf{generic-flet} is used to define generic functions whose
names are meaningful only locally and to execute a series of forms
with these function definition bindings.  Any number of such local
generic functions may be defined.


The names of functions defined by \cdf{generic-flet} have lexical
scope; they retain their local definitions only within the body of the
\cdf{generic-flet}.  Any references within the body of the 
\cdf{generic-flet} to functions whose names are the same as those defined
within the \cdf{generic-flet} are thus references to the local
functions instead of to any global functions of the same names.  The
scope of these generic function definition bindings, however, includes only
the body of \cdf{generic-flet}, not the definitions themselves.
Within the method bodies, local function names that match those
being defined refer to global functions defined outside the 
\cdf{generic-flet}.  It is thus not possible to define recursive functions
with \cdf{generic-flet}.


The \emph{function-name\/}, \emph{lambda-list\/}, \emph{option}, \emph{
method-qualifier}, and \emph{specialized-lambda-list\/} arguments are
the same as for \cdf{defgeneric}.


A \cdf{generic-flet} local method definition is identical in form to the
method definition part of a \cdf{defmethod}.


The body of each method is enclosed in an implicit block.  If \emph{
function-name\/} is a symbol, this block bears the same name as
the generic function.  If \emph{function-name\/} is a list of the
form \cd{(setf \emph{symbol\/})}, the name of the block is \emph{
symbol}.


The result returned by \cdf{generic-flet} is the value or values
returned by the last form executed.  If no forms are specified, 
\cdf{generic-flet} returns \cdf{nil}.

See \cdf{generic-labels}, \cdf{defmethod}, \cdf{defgeneric}, and \cdf{generic-function}.
\end{defspec}


\begin{defmac}
generic-function lambda-list <?option | {method-description}*>

\begin{tabbing}
\emph{option\/} ::= \cd{(:argument-precedence-order \Mplus{parameter-name})} \\
~~~ \Mor~\cd{(declare \Mplus{declaration})} \\
~~~ \Mor~\cd{(:documentation
  \emph{string\/})} \\
~~~ \Mor~\cd{(:method-combination \emph{symbol\/} \Mstar{{arg\/}})} \\
~~~ \Mor~\cd{(:generic-function-class \emph{class-name\/})} \\
~~~ \Mor~\cd{(:method-class \emph{class-name\/})} \\\\
 \emph{method-description\/} ::= \cd{(:method } \Mstar{{method-qualifier\/}}  \emph{specialized-lambda-list\/} 
\Mstar{{declaration\/ {\Mor} documentation\/}} 
\Mstar{{\,form\/}}\cd{)}
\end{tabbing}
The \cdf{generic-function} macro creates an anonymous generic
function. The generic function is created with the set of methods
specified by its method descriptions.




The \emph{option}, \emph{method-qualifier}, and {\it
specialized-lambda-list\/} arguments are the same as for 
\cdf{defgeneric}.


The generic function object is returned as the result.


If no method descriptions are specified, an anonymous generic function with no
methods is created.

See \cdf{defgeneric}, \cdf{generic-flet}, \cdf{generic-labels}, and \cdf{defmethod}.
\end{defmac}


\begin{defspec}
generic-labels ({(function-name lambda-list
                <?option | {method-description}*>)}*)
               {\,form}*


The \cdf{generic-labels} special form is analogous to the
\cdf{labels} special form.  It produces new generic functions and
establishes new lexical function definition bindings.  Each generic
function is created with the set of methods specified by its method
descriptions.



The special form \cdf{generic-labels} is used to define generic functions
whose names are meaningful only locally and to execute a series of
forms with these function definition bindings.  Any number of
such  local generic functions may be defined.  



The names of functions defined by \cdf{generic-labels} have lexical
scope; they retain their local definitions only within the body of the
\cdf{generic-labels} construct.  Any references within the body of the
\cdf{generic-labels} construct to functions whose names are the same
as those defined within the \cdf{generic-labels} form are thus
references to the local functions instead of to any global functions
of the same names.  The scope of these generic function definition bindings
includes the method bodies themselves as well as the body of the 
\cdf{generic-labels} construct.




The \emph{function-name\/}, \emph{lambda-list\/}, \emph{option}, {\it
method-qualifier}, and \emph{specialized-lambda-list\/} arguments are
the same as for \cdf{defgeneric}.

A \cdf{generic-labels} local method definition is identical in form to the
method definition part of a \cdf{defmethod}.

The body of each method is enclosed in an implicit block.  If {\it
function-name\/} is a symbol, this block bears the same name as
the generic function.  If \emph{function-name\/} is a list of the
form \cd{(setf \emph{symbol\/})}, the name of the block is {\it
symbol}.  


The result returned by \cdf{generic-labels} is the value or values
returned by the last form executed.  If no forms are specified, 
\cdf{generic-labels} returns \cdf{nil}.

See \cdf{generic-flet}, \cdf{defmethod}, \cdf{defgeneric}, \cdf{generic-function}.
\end{defspec}


\begin{defun}[Generic function][Primary method]
initialize-instance instance &rest initargs \\
initialize-instance (instance standard-object) &rest initargs

The generic function \cdf{initialize-instance} is called by 
\cdf{make-instance} to initialize a newly created instance.  The generic
function \cdf{initialize-instance} is called with the new instance and
the defaulted initialization arguments.

The system-supplied primary method on \cdf{initialize-instance}
initializes the slots of the instance with values according to the
initialization arguments and the \cd{:initform} forms of the slots.
It does this by calling the generic function \cdf{shared-initialize}
with the following arguments: the instance, \cdf{t} (this indicates
that all slots for which no initialization arguments are provided
should be initialized according to their \cd{:initform} forms) and
the defaulted initialization arguments.





The \emph{instance\/} argument is the object to be initialized.

The \emph{initargs\/} argument consists of alternating initialization
argument names and values.


The modified instance is returned as the result.


Programmers can define methods for \cdf{initialize-instance} to
specify actions to be taken when an instance is initialized.  If only
\cd{:after} methods are defined, they will be run after the
system-supplied primary method for initialization and therefore will
not interfere with the default behavior of \cdf{initialize-instance}.

See sections~\ref{Object-Creation-and-Initialization-SECTION},
\ref{Rules-for-Initialization-Arguments-SECTION}, and
\ref{Declaring-the-Validity-of-Initialization-Arguments-SECTION} as well as
\cdf{shared-initialize},
\cdf{make-instance},
\cdf{slot-boundp},
and \cdf{slot-makunbound}.
\end{defun}


\begin{defun}[Function]
invalid-method-error method format-string &rest args

The function \cdf{invalid-method-error} is used to signal an error
when there is an applicable method whose qualifiers are not valid for
the method combination type.  The error message is constructed by
using a \cdf{format} string and any arguments to it.  Because an
implementation may need to add additional contextual information to
the error message, \cdf{invalid-method-error} should be called only
within the dynamic extent of a method combination function.

The function \cdf{invalid-method-error} is called automatically when a
method fails to satisfy every qualifier pattern and predicate in a
\cd{define-\discretionary{}{}{}method-\discretionary{}{}{}combination} form.
A method combination function
that imposes additional restrictions should call 
\cdf{invalid-method-error} explicitly if it encounters a method it cannot
accept.





The \emph{method\/} argument is the invalid method object.  

The \emph{format-string\/} argument is a control string that can be
given to \cdf{format}, and \emph{args\/} are any arguments required by
that string.


Whether \cdf{invalid-method-error} returns to its caller or exits via
\cdf{throw} is implementation-dependent.

See \cdf{define-method-combination}.

\end{defun}


\begin{defun}[Generic function][Primary method]
make-instance class &rest initargs \\
make-instance (class standard-class) &rest initargs \\
make-instance (class symbol) &rest initargs

The generic function \cdf{make-instance} creates a new
instance of the given class.

The generic function \cdf{make-instance} may be used as described in
section~\ref{Object-Creation-and-Initialization-SECTION}.





The \emph{class\/} argument is a class object or a symbol that
names a class.  The remaining arguments form a list of alternating
initialization argument names and values.

If the second of the preceding methods is selected, that method invokes
\cdf{make-instance} on the arguments \cd{(find-class \emph{class\/})} and
\emph{initargs}.

The initialization arguments are checked within \cdf{make-instance}
(see section~\ref{Object-Creation-and-Initialization-SECTION}).


The new instance is returned.


The meta-object protocol can be used to define new methods on 
\cdf{make-instance} to replace the object-creation protocol.

See section \ref{Object-Creation-and-Initialization-SECTION} as well as
\cdf{defclass}, \cdf{initialize-instance}, and \cdf{class-of}.
\end{defun}



\begin{defun}[Generic function][Primary method]
make-instances-obsolete class \\
make-instances-obsolete (class standard-class) \\
make-instances-obsolete (class symbol)

The generic function \cdf{make-instances-obsolete} is invoked
automatically by the system when \cdf{defclass} has been used to
redefine an existing standard class and the set of local slots accessible in an
instance is changed or the order of slots in storage is changed.  It
can also be explicitly invoked by the user.

The function \cdf{make-instances-obsolete} has the effect of
initiating the process of updating the instances of the
class. During updating, the generic function 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} will be invoked.





The \emph{class\/} argument is a class object symbol that names
the class whose instances are to be made obsolete.

If the second of the preceding methods is selected, that method invokes
\cdf{make-instances-obsolete} on \cd{(find-class \emph{class\/})}.


The modified class is returned.  The result of \cdf{make-instances-obsolete}
is \cdf{eq} to the \emph{class} argument supplied to the first of the preceding
methods.

See section~\ref{Redefining-Classes-SECTION} as well as
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class}.
\end{defun}



\begin{defun}[Function]
method-combination-error format-string &rest args

The function \cdf{method-combination-error} is used to signal an error
in method combination.  The error message is constructed by using a
\cdf{format} string and any arguments to it.  Because an implementation may
need to add additional contextual information to the error message,
\cdf{method-combination-error} should be called only within the
dynamic extent of a method combination function.



 

The \emph{format-string\/} argument is a control string that can be
given to \cdf{format}, and \emph{args\/} are any arguments required by
that string.


Whether \cdf{method-combination-error} returns to its caller or exits
via \cdf{throw} is implementation-dependent.

See \cdf{define-method-combination}.

\end{defun}



\begin{defun}[Generic function][Primary method]
method-qualifiers method \\
method-qualifiers (method standard-method)

The generic function \cdf{method-qualifiers} returns a list of the
qualifiers of the given method.





The \emph{method\/} argument is a method object. 


A list of the qualifiers of the given method is returned.

Example:
\begin{lisp}
(setq methods (remove-duplicates methods \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~:from-end t \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~:key \#'method-qualifiers \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~:test \#'equal))
\end{lisp}

See \cdf{define-method-combination}.
\end{defun}

 

\begin{defun}[Function]
next-method-p

The locally defined function \cdf{next-method-p} can be used within
the body of a method defined by a method-defining form to determine
whether a next method exists.





The function \cdf{next-method-p} takes no arguments.


The function \cdf{next-method-p} returns true or false.


Like \cdf{call-next-method}, the function \cdf{next-method-p} has 
lexical scope (for it
is defined only within the body of a method defined by a method-defining form)
and indefinite extent.

See \cdf{call-next-method}.

\end{defun}


\begin{defun}[Generic function][Primary method]
no-applicable-method generic-function &rest function-arguments \\
no-applicable-method (generic-function t) &rest function-arguments

The generic function \cdf{no-applicable-method} is called when a
generic function of the class \cdf{standard-generic-function} is invoked
and no method on that generic function is applicable.
The default method signals an error.

The generic function \cdf{no-applicable-method} is not intended to be called
by programmers.  Programmers may write methods for it.





The \emph{generic-function\/} argument of \cdf{no-applicable-method} is the
generic function object on which no applicable method was found.  

The \emph{function-arguments} argument is a list of the arguments to that
generic function.

\end{defun}

\begin{defun}[Generic function][Primary method]
no-next-method generic-function method &rest args \\
no-next-method (generic-function standard-generic-function)
    (method standard-method) &rest args

The generic function \cdf{no-next-method} is called by 
\cdf{call-next-method} when there is no next method.  The system-supplied
method on \cdf{no-next-method} signals an error.

The generic function \cdf{no-next-method} is not intended to be called
by programmers.  Programmers may write methods for it.





The \emph{generic-function\/} argument is the generic function object
to which the method that is the second argument belongs.

The \emph{method\/} argument is the method that contains the call to
\cdf{call-next-method} for which there is no next method.

The \emph{args\/} argument is a list of the arguments to
\cdf{call-next-method}.

See \cdf{call-next-method}.

\end{defun}


\begin{defun}[Generic function][Primary method]
print-object object stream \\
print-object (object standard-object) stream

The generic function \cdf{print-object} writes the printed
representation of an object to a stream.  The function 
\cdf{print-object} is called by the print system; it should not be called
by the user.

\penalty-10000 %required

Each implementation must provide a method on the class 
\cdf{standard-object} and methods on enough other classes so as to ensure
that there is always an applicable method.  Implementations are free
to add methods for other classes.  Users can write methods for 
\cdf{print-object} for their own classes if they do not wish to inherit an
implementation-supplied method.

The first argument is any Lisp object.   The second argument is a
stream; it cannot be \cdf{t} or \cdf{nil}. 

The function \cdf{print-object} returns its first argument, the object.  

Methods on \cdf{print-object} must obey the print control special
variables named \cd{*print-\emph{xxx}*} for various \emph{xxx}.  The
specific details are the following:

\begin{itemize}

\item 
Each method must implement \cd{*print-escape*}. 

\item  
The \cd{*print-pretty*} control variable can be ignored
by most methods other than the one for lists.

\item 
The \cd{*print-circle*} control variable is handled by the printer
and can be ignored by methods.

\item 
The printer takes care of \cd{*print-level*} automatically, provided that
each method handles exactly one level of structure and
calls \cdf{write} (or an equivalent function) recursively if
there are more structural levels.  The printer's decision
of whether an object has components (and therefore should
not be printed when the printing depth is not less than
\cd{*print-level*}) is implementation-dependent.  In some
implementations its \cdf{print-object} method is not called; in
others the method is called, and the determination that the
object has components is based on what it tries to write
to the stream.

\item 
Methods that produce output of indefinite length must obey
\cd{*print-length*}, but most methods other than the one for lists can
ignore it.

\item 
The \cd{*print-base*}, \cd{*print-radix*}, \cd{*print-case*}, 
\cd{*print-gensym*}, and \cd{*print-array*} control variables apply
to specific types of objects and are handled by the methods for those
objects.

\item X3J13 voted in June 1989 \issue{DATA-IO} to add the following point.
   All methods for \cdf{print-object} must obey \cd{*print-readably*},
   which takes precedence over all other printer control variables.  This
   includes both user-defined methods and implementation-defined methods.
\end{itemize}

If these rules are not obeyed, the results are undefined.

In general, the printer and the \cdf{print-object} methods should not
rebind the print control variables as they operate recursively through the
structure, but this is implementation-dependent.

In some implementations the stream argument passed to a 
\cdf{print-object} method is not the original stream but is an
intermediate stream that implements part of the printer.  Methods
should therefore not depend on the identity of this stream.

All of the existing printing functions (\cdf{write}, \cd{prin1}, 
\cdf{print}, \cdf{princ}, \cdf{pprint}, \cdf{write-to-string}, 
\cd{prin1-to-string}, \cdf{princ-to-string}, the \cd{{\Xtilde}S} and 
\cd{{\Xtilde}A} \cdf{format} operations, and the \cd{{\Xtilde}B}, \cd{{\Xtilde}D},
\cd{{\Xtilde}E}, \cd{{\Xtilde}F}, \cd{{\Xtilde}G}, \cd{{\Xtilde}\$}, 
\cd{{\Xtilde}O}, \cd{{\Xtilde}R}, and \cd{{\Xtilde}X} \cdf{format} operations when they
encounter a non-numeric value) are required to be changed to go
through the \cdf{print-object} generic function.  Each implementation is
required to replace its former implementation of printing with one or
more \cdf{print-object} methods.  Exactly which classes have methods for
\cdf{print-object} is not specified; it would be valid for an implementation
to have one default method that is inherited by all system-defined
classes.

\end{defun}


\begin{defun}[Generic function][Primary method]
reinitialize-instance instance &rest initargs \\
reinitialize-instance (instance standard-object) &rest initargs

The generic function \cdf{reinitialize-instance} can be used to change
the values of local slots according to initialization arguments.  This
generic function is called by the Meta-Object Protocol.   It can also be
called by users.

The system-supplied primary method for \cdf{reinitialize-instance}
checks the validity of initialization arguments and signals an error if
an initialization argument is supplied that is not declared valid.
The method then calls the generic function \cdf{shared-initialize}
with the following arguments:  the instance, \cdf{nil} (which means no slots
should be initialized according to their \cd{:initform} forms) and the
initialization arguments it received.





The \emph{instance\/} argument is the object to be initialized.

The \emph{initargs\/} argument consists of alternating initialization
argument names and values.


The modified instance is returned as the result.


Initialization arguments are declared valid by using the 
\cd{:initarg} option to \cdf{defclass}, or by defining methods for 
\cdf{reinitialize-instance} or \cd{shared-\discretionary{}{}{}initialize}.  The keyword name
of each keyword parameter specifier in the lambda-list of any method
defined on \cdf{reinitialize-instance} or \cd{shared-\discretionary{}{}{}initialize} is
declared a valid initialization argument name for all classes for
which that method is applicable.

See sections~\ref{Reinitializing-an-Instance-SECTION},
\ref{Rules-for-Initialization-Arguments-SECTION},
\ref{Declaring-the-Validity-of-Initialization-Arguments-SECTION} as well as
\cdf{initialize-instance}, \cdf{slot-boundp},
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class},
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class},
\cdf{slot-makunbound}, and \cdf{shared-initialize}.

\end{defun}


\begin{defun}[Generic function][Primary method]
remove-method generic-function method \\
remove-method (generic-function standard-generic-function) method

The generic function \cdf{remove-method} removes a method from a
generic function.  It destructively modifies the specified generic
function and returns the modified generic function as its result.





The \emph{generic-function\/} argument is a generic function
object.

The \emph{method\/} argument is a method object.  The function 
\cdf{remove-method} does not signal an error if the method is not one of the
methods on the generic function.


The modified generic function is returned.  The result of \cdf{remove-method} 
is \cdf{eq} to the \emph{generic-function\/} argument.

See \cdf{find-method}.
\end{defun}

\begin{defun}[Generic function][Primary method]
shared-initialize instance slot-names &rest initargs \\
shared-initialize (instance standard-object) slot-names &rest initargs

The generic function \cdf{shared-initialize} is used to fill the slots
of an instance using initialization arguments and \cd{:initform}
forms.  It is called when an instance is created, when an instance is
re-initialized, when an instance is updated to conform to a redefined
class, and when an instance is updated to conform to a different
class.  The generic function \cd{shared-\discretionary{}{}{}initialize} is called by the
system-supplied primary method for \cd{initialize-\discretionary{}{}{}instance}, 
\cd{reinitialize-\discretionary{}{}{}instance},
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class}, and
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}.

The generic function \cdf{shared-initialize} takes the following
arguments: the instance to be initialized, a specification of a set of
names of slots accessible in that instance, and any number of initialization
arguments.  The arguments after the first two must form an initialization
argument list.  The system-supplied primary method on 
\cdf{shared-initialize} initializes the slots with values according to the
initialization arguments and specified \cd{:initform} forms.  The
second argument indicates which slots should be initialized according
to their \cd{:initform} forms if no initialization arguments are
provided for those slots. 

The system-supplied primary method behaves as follows, regardless of
whether the slots are local or shared: 

\begin{itemize}

\item  If an initialization argument in the
initialization argument list specifies a value for that slot, that
value is stored into the slot,  even if a value has
already been stored in the slot before the method is run.

\item  Any slots indicated by the second argument that are still
unbound at this point are initialized according to their 
\cd{:initform} forms.  For any such slot that has an \cd{:initform} form,
that form is evaluated in the lexical environment of its defining 
\cdf{defclass} form and the result is stored into the slot.  For example, if
a \cd{:before} method stores a value in the slot, the \cd{:initform}
form will not be used to supply a value for the slot.

\item  The rules mentioned in section~\ref{Rules-for-Initialization-Arguments-SECTION} are obeyed.

\end{itemize}





The \emph{instance\/} argument is the object to be initialized.

The \emph{slot-names\/} argument specifies the slots that are to be
initialized according to their \cd{:initform} forms if no
initialization arguments apply.  It is supplied in one of three forms
as follows:

\begin{itemize}

\item  It can be a list of slot names, which specifies
the set of those slot names.

\item  It can be \cdf{nil}, which specifies the empty set of
slot names.

\item  It can be the symbol \cdf{t}, which specifies the set of
all of the slots.

\end{itemize}

The \emph{initargs\/} argument consists of alternating initialization 
argument names and values.


The modified instance is returned as the result.


Initialization arguments are declared valid by using the 
\cd{:initarg} option to \cdf{defclass}, or by defining methods for 
\cdf{shared-initialize}.  The keyword name of each keyword parameter
specifier in the lambda-list of any method defined on 
\cdf{shared-initialize} is declared a valid initialization argument
name for all classes for which that method is applicable.

Implementations are permitted to optimize \cd{:initform} forms that 
neither produce nor depend on side effects by evaluating these forms
and storing them into slots before running any 
\cdf{initialize-instance} methods, rather than by handling them in the
primary \cdf{initialize-instance} method.  (This optimization might
be implemented by having the \cdf{allocate-instance} method copy a
prototype instance.)

Implementations are permitted to optimize default initial value forms
for initialization arguments associated with slots by not actually
creating the complete initialization argument list when the only method
that would receive the complete list is the method on 
\cdf{standard-object}.  In this case, default initial value forms can be 
treated like \cd{:initform} forms.  This optimization has no visible
effects other than a performance improvement.

See sections~\ref{Object-Creation-and-Initialization-SECTION},
\ref{Rules-for-Initialization-Arguments-SECTION},
\ref{Declaring-the-Validity-of-Initialization-Arguments-SECTION} as well as
\cdf{initialize-instance},
\cdf{reinitialize-instance},
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class},
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class},
\cdf{slot-boundp},
and \cdf{slot-makunbound}.
\end{defun}


\begin{defun}[Function]
slot-boundp instance slot-name

The function \cdf{slot-boundp} tests whether a specific slot in an
instance is bound.





The arguments are the instance and the name of the slot.


The function \cdf{slot-boundp} returns true or false.


This function allows for writing \cd{:after}
methods on \cdf{initialize-instance} in order to initialize only
those slots that have not already been bound.

If no slot of the given name exists in the instance, \cdf{slot-missing}
is called as follows:
\begin{lisp}
(slot-missing (class-of \emph{instance\/}) \\
~~~~~~~~~~~~~~\emph{instance\/} \\
~~~~~~~~~~~~~~\emph{slot-name\/} \\
~~~~~~~~~~~~~~'slot-boundp)
\end{lisp}

The function \cdf{slot-boundp} is implemented using 
\cdf{slot-boundp-using-class}.
See \cdf{slot-missing}.
\end{defun}


\begin{defun}[Function]
slot-exists-p object slot-name

The function \cdf{slot-exists-p} tests whether the specified object has
a slot of the given name.





The \emph{object\/} argument is any object.  The \emph{slot-name\/} argument
is a symbol.


The function \cdf{slot-exists-p} returns true or false.


The function \cdf{slot-exists-p} is implemented using 
\cd{slot-\discretionary{}{}{}exists-p-\discretionary{}{}{}using-\discretionary{}{}{}class}.

\end{defun}


\begin{defun}[Function]
slot-makunbound instance slot-name

The function \cdf{slot-makunbound} restores a slot in an instance to
the unbound state.





The arguments to \cdf{slot-makunbound} are the instance and the name of
the slot.


The instance is returned as the result.


If no slot of the given name exists in the instance, \cdf{slot-missing}
is called as follows:
\begin{lisp}
(slot-missing (class-of \emph{instance\/}) \\
~~~~~~~~~~~~~~\emph{instance\/} \\
~~~~~~~~~~~~~~\emph{slot-name\/} \\
~~~~~~~~~~~~~~'slot-makunbound)
\end{lisp}

The function \cdf{slot-makunbound} is implemented using 
\cd{slot-\discretionary{}{}{}makunbound-\discretionary{}{}{}using-\discretionary{}{}{}class}.
See \cdf{slot-missing}.
\end{defun}



\begin{defun}[Generic function][Primary method]
slot-missing class object slot-name operation &optional new-value \\
slot-missing (class t) object slot-name operation &optional new-value

The generic function \cdf{slot-missing} is invoked when an attempt is
made to access a slot in an object whose metaclass is 
\cdf{standard-class} and the name of the slot provided is not a name of a
slot in that class.  
The default method signals an error.

The generic function \cdf{slot-missing} is not intended to be called by
programmers.  Programmers may write methods for it.





The required arguments to \cdf{slot-missing} are the class of the object
that is being accessed, the object, the slot name, and a symbol that
indicates the operation that caused  \cdf{slot-missing} to be invoked.
The optional argument to \cdf{slot-missing} is used when the operation
is attempting to set the value of the slot.


If a method written for \cdf{slot-missing} returns values, these
values get returned as the values of the original function invocation.


The generic function \cdf{slot-missing} may be called during
evaluation of \cdf{slot-value}, \cd{(setf slot-value)}, 
\cdf{slot-boundp}, and \cdf{slot-makunbound}.  For each
of these operations the corresponding symbol for the \emph{operation\/}
argument is \cdf{slot-value}, \cdf{setf}, \cdf{slot-boundp}, and 
\cdf{slot-makunbound}, respectively.

The set of arguments (including the class of the instance) facilitates
defining methods on the metaclass for \cdf{slot-missing}.

\end{defun}


\begin{defun}[Generic function][Primary method]
slot-unbound class instance slot-name \\
slot-unbound (class t) instance slot-name

The generic function \cdf{slot-unbound} is called when an
unbound slot is read in an instance whose metaclass is 
\cdf{standard-class}.
The default method signals an error.

The generic function \cdf{slot-unbound} is not intended to be called
by programmers.  Programmers may write methods for it.
The function \cdf{slot-unbound} is called only by the function
\cdf{slot-value-using-class} and thus indirectly by \cdf{slot-value}.





The arguments to \cdf{slot-unbound} are the class of the instance
whose slot was accessed, the instance itself, and the name of the
slot.


If a method written for \cdf{slot-unbound} returns values, these
values get returned as the values of the original function invocation.


An unbound slot may occur if no \cd{:initform} form was
specified for the slot and the slot value has not been set, or if 
\cdf{slot-makunbound} has been called on the slot.

See \cdf{slot-makunbound}.
\end{defun}


\begin{defun}[Function]
slot-value object slot-name

The function \cdf{slot-value} returns the value contained in the slot
\emph{slot-name\/} of the given object.  If there is no slot with that
name, \cdf{slot-missing} is called.  If the slot is unbound,
\cdf{slot-unbound} is called.

The macro \cdf{setf} can be used with \cdf{slot-value} to change the value
of a slot. 





The arguments are the object and the name of the given slot.


The result is the value contained in the given slot.


If an attempt is made to read a slot and no slot of the given name
exists in the instance, \cdf{slot-missing} is called as follows: 
\begin{lisp}
(slot-missing (class-of \emph{instance\/}) \\
~~~~~~~~~~~~~~\emph{instance} \\
~~~~~~~~~~~~~~\emph{slot-name\/} \\
~~~~~~~~~~~~~~'slot-value)
\end{lisp}

If an attempt is made to write a slot and no slot of the given name
exists in the instance, \cdf{slot-missing} is called as follows: 
\begin{lisp}
(slot-missing (class-of \emph{instance\/}) \\
~~~~~~~~~~~~~~\emph{instance} \\
~~~~~~~~~~~~~~\emph{slot-name\/} \\
~~~~~~~~~~~~~~'setf \\
~~~~~~~~~~~~~~\emph{new-value\/})
\end{lisp}

The function \cdf{slot-value} is implemented using 
\cdf{slot-value-using-class}.

Implementations may optimize \cdf{slot-value} by compiling it in-line.

See \cdf{slot-missing} and \cdf{slot-unbound}.
\end{defun}


[At this point the original CLOS report \cite{SIGPLAN-CLOS,LASC-CLOS-PART-2}
contained a specification for \cdf{symbol-macrolet}.
This specification is omitted here.  Instead, a description
of \cdf{symbol-macrolet} appears with those of related constructs in chapter~\ref{CONTRL}.---GLS]


\begin{defun}[Generic function][Primary method]
update-instance-for-different-class previous current &rest initargs \\
update-instance-for-different-class (previous standard-object)
     (current standard-object) &rest initargs

The generic function \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} is not
intended to be called by programmers.  Programmers may write
methods for it.  This function is called only by the function \cdf{change-class}.

The system-supplied primary method on 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} checks the validity of
initialization arguments and signals an error if an initialization
argument is supplied that is not declared valid.  This method then
initializes slots with values according to the initialization
arguments and initializes the newly added slots with values according
to their \cd{:initform} forms.  It does this by calling the generic
function \cdf{shared-initialize} with the following arguments: the instance,
a list of names of the newly added slots, and the initialization
arguments it received.  Newly added slots are those local slots for which
no slot of the same name exists in the previous class.

Methods for
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}
can be defined to
specify actions to be taken when an instance is updated.  If only 
\cd{:after} methods for \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} are
defined, they will be run after the system-supplied primary method for
initialization and therefore will not interfere with the default
behavior of \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}.





The arguments to \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} are
computed by \cdf{change-class}.  When \cdf{change-class} is invoked on
an instance, a copy of that instance is made; \cdf{change-class} then
destructively alters the original instance.  The first argument to
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}, \emph{previous\/}, is that
copy; it holds the old slot values temporarily.  This argument has
dynamic extent within \cdf{change-class}; if it is referenced in any
way once \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} returns, the
results are undefined.  The second argument to 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class}, \emph{current}, is the altered
original instance.


The intended use of \emph{previous\/} is to extract old slot values by using
\cdf{slot-value} or \cdf{with-slots} or by invoking a reader generic
function, or to run other methods that were applicable to instances of
the original class.

The \emph{initargs\/} argument consists of alternating initialization
argument names and values.


The value returned by \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} is
ignored by \cdf{change-class}.

See the example for the function \cdf{change-class}.


Initialization arguments are declared valid by using the 
\cd{:initarg} option to \cdf{defclass}, or by defining methods for 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} or \cdf{shared-initialize}.  The
keyword name of each keyword parameter specifier in the lambda-list of
any method defined on \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} or 
\cdf{shared-initialize} is declared a valid initialization argument name
for all classes for which that method is applicable.

Methods on \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} can be defined to
initialize slots differently from \cdf{change-class}.  The default
behavior of \cd{change-\discretionary{}{}{}class} is described in
section~\ref{Changing-the-Class-of-an-Instance-SECTION}.


See sections~\ref{Changing-the-Class-of-an-Instance-SECTION},
\ref{Rules-for-Initialization-Arguments-SECTION}, and
\ref{Declaring-the-Validity-of-Initialization-Arguments-SECTION} as well as
\cdf{change-class} and \cdf{shared-initialize}.
\end{defun}

\penalty-10000 %required

\begin{defun}[Generic function][Primary method]
update-instance-for-redefined-class instance added-slots
    discarded-slots property-list &rest initargs \\
update-instance-for-redefined-class (instance standard-object) added-slots
    discarded-slots property-list &rest initargs

\relax
\vskip 0pt plus 10pt
\noindent
The generic function \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} is not
intended to be called by programmers. Programmers may
write methods for it.  The generic function 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} is called by the mechanism
activated by \cdf{make-instances-obsolete}.

The system-supplied primary method on 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}different-\discretionary{}{}{}class} checks the validity of
initialization arguments and signals an error if an initialization
argument is supplied that is not declared valid.  This method then
initializes slots with values according to the initialization
arguments and initializes the newly added slots with values according
to their \cd{:initform} forms.  It does this by calling the generic
function \cdf{shared-initialize} with the following arguments: the instance,
a list of names of the newly added slots, and the initialization
arguments it received.  Newly added slots are those local slots for which
no slot of the same name exists in the old version of the class.





When \cdf{make-instances-obsolete} is invoked or when a class has been
redefined and an instance is being updated, a property list is created
that captures the slot names and values of all the discarded slots with
values in the original instance.  The structure of the instance is
transformed so that it conforms to the current class definition.  The
arguments to \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} are this
transformed instance, a list of the names of the new slots added to the
instance, a list of the names of the old slots discarded from the
instance, and the property list containing the slot names and values for
slots that were discarded and had values.  Included in this list of
discarded slots are slots that were local in the old class and are
shared in the new class.

The \emph{initargs\/} argument consists of alternating initialization
argument names and values.


The value returned by \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} is ignored.


Initialization arguments are declared valid by using the 
\cd{:initarg} option to \cdf{defclass} or by defining methods for 
\cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} or \cdf{shared-initialize}.  The
keyword name of each keyword parameter specifier in the lambda-list of
any method defined on \cd{update-\discretionary{}{}{}instance-\discretionary{}{}{}for-\discretionary{}{}{}redefined-\discretionary{}{}{}class} or 
\cdf{shared-initialize} is declared a valid initialization argument name
for all classes for which that method is applicable.


See sections~\ref{Redefining-Classes-SECTION},
\ref{Rules-for-Initialization-Arguments-SECTION}, and
\ref{Declaring-the-Validity-of-Initialization-Arguments-SECTION} as well as
\cdf{shared-initialize} and \cd{make-\discretionary{}{}{}instances-\discretionary{}{}{}obsolete}.


\begin{lisp}
(defclass position () ()) \\
\\
(defclass x-y-position (position) \\*
~~((x :initform 0 :accessor position-x) \\*
~~~(y :initform 0 :accessor position-y))) \\
\\
;;; It turns out polar coordinates are used more than Cartesian  \\*
;;; coordinates, so the representation is altered and some new \\*
;;; accessor methods are added. \\
\\
(defmethod update-instance-for-redefined-class :before \\*
~~~~~~~~~~~((pos x-y-position) added deleted plist \&key) \\*
~~;; Transform the x-y coordinates to polar coordinates \\*
~~;; and store into the new slots. \\*
~~(let ((x (getf plist 'x)) \\*
~~~~~~~~(y (getf plist 'y))) \\*
~~~~(setf (position-rho pos) (sqrt (+ (* x x) (* y y))) \\*
~~~~~~~~~~(position-theta pos) (atan y x)))) \\
\\
(defclass x-y-position (position) \\*
~~~~((rho :initform 0 :accessor position-rho) \\*
~~~~~(theta :initform 0 :accessor position-theta)))
\end{lisp}
\vskip 0pt plus 10pt
\hrule width 0pt\relax
\begin{lisp}
;;; All instances of the old x-y-position class will be updated \\*
;;; automatically. \\
\\
;;; The new representation has the look and feel of the old one. \\
\\
(defmethod position-x ((pos x-y-position)) \\*
~~~(with-slots (rho theta) pos (* rho (cos theta)))) \\
\\
(defmethod (setf position-x) (new-x (pos x-y-position)) \\*
~~~(with-slots (rho theta) pos \\*
~~~~~(let ((y (position-y pos))) \\*
~~~~~~~(setq rho (sqrt (+ (* new-x new-x) (* y y))) \\*
~~~~~~~~~~~~~theta (atan y new-x)) \\*
~~~~~~~new-x))) \\
\\
(defmethod position-y ((pos x-y-position)) \\*
~~~(with-slots (rho theta) pos (* rho (sin theta))))
\end{lisp}
\begin{lisp}
(defmethod (setf position-y) (new-y (pos x-y-position)) \\*
~~~(with-slots (rho theta) pos \\*
~~~~~(let ((x (position-x pos))) \\*
~~~~~~~(setq rho (sqrt (+ (* x x) (* new-y new-y))) \\*
~~~~~~~~~~~~~theta (atan new-y x)) \\*
~~~~~~~new-y)))
\end{lisp}
\end{defun}

\newbox\hyphbox
\setbox\hyphbox\hbox\emph{-}
\def\foohyphen{\copy\hyphbox}

\begin{defmac}
with-accessors ({slot-entry}*) instance-form
     {declaration}* {\,form}*

The macro \cdf{with-accessors} creates a lexical environment in which
specified slots are lexically available through their accessors as if
they were variables.  The macro \cdf{with-accessors} invokes the
appropriate accessors to access the specified slots.  Both \cdf{setf}
and \cdf{setq} can be used to set the value of the slot.

 

The result returned is that obtained by executing the forms specified
by the \emph{body\/} argument.

Example:

\begin{lisp}
(with-accessors ((x position-x) (y position-y)) p1 \\*
~~(setq x y))
\end{lisp}


A \cdf{with-accessors} expression of the form
\begin{lisp}
(with-accessors ({\rm $slot\sub 1$} ... {\rm $slot\sub {n}$}) \emph{instance\/} \\*
~~$declaration\sub 1$ ... $declaration\sub {m}$) \\*
~~$form\sub 1$ ... $form\sub {k}$)
\end{lisp}
expands into the equivalent of
\begin{lisp}
(let ((\emph{in\/} \emph{instance\/})) \\
~~(symbol-macrolet (({\rm $variable\sub 1$} ({\rm $accessor\sub 1$} \emph{in\/})) \\*
~~~~~~~~~~~~~~~~~~~~... \\*
~~~~~~~~~~~~~~~~~~~~({\rm $variable\sub {n}$} ({\rm $accessor\sub {n}$} \emph{in\/}))) \\*
~~~~$declaration\sub 1$ ... $declaration\sub {m}$) \\*
~~~~$form\sub 1$ ... $form\sub {k}$)
\end{lisp}

[X3J13 voted in March 1989
\issue{SYMBOL-MACROLET-SEMANTICS}
to modify the definition of \cdf{symbol-macrolet} substantially
and also voted
\issue{SYMBOL-MACROLET-DECLARE} to allow declarations before the body
of \cdf{symbol-macrolet} but with peculiar treatment of \cdf{special}
and type declarations.  The syntactic changes are reflected in this definition
of \cdf{with-accessors}.---GLS]

See \cdf{with-slots} and \cdf{symbol-macrolet}.
\end{defmac}


\begin{defspec}
with-added-methods (function-name lambda-list
      <?option | {method-description}*>)
      {\,form}*

\relax
\vskip 0pt plus 4pt
\noindent
The \cdf{with-added-methods} special form
produces new generic functions and establishes new
lexical function definition bindings.  Each generic function is created by
adding the set of methods specified by its method definitions to a copy of the
lexically visible generic function of the same name and its methods.  If
such a generic function does not already exist, a new generic function is
created; this generic function has lexical scope.

The special form \cdf{with-added-methods} is used to define functions
whose names are meaningful only locally and to execute a series of
forms with these function definition bindings.


The names of functions defined by \cdf{with-added-methods} have lexical
scope; they retain their local definitions only within the body of the
\cdf{with-added-methods} construct.  Any references within the body of the
\cdf{with-added-methods} construct to functions whose names are the same
as those defined within the \cdf{with-added-methods} form are thus
references to the local functions instead of to any global functions
of the same names.  The scope of these generic function definition bindings
includes the method bodies themselves as well as the body of the 
\cdf{with-added-methods} construct.





The \emph{function-name}, \emph{option}, \emph{method-qualifier}, and {\it
specialized-lambda-list\/} arguments are the same as for \cdf{defgeneric}.

The body of each method is enclosed in an implicit block.  If
\emph{function-name\/} is a symbol, this block bears the same name as the
generic function.  If \emph{function-name\/} is a list of the form 
\cd{(setf \emph{symbol\/})}, the name of the block is \emph{symbol}.  


The result returned by \cdf{with-added-methods} is the value or values
of the last form executed.  If no forms are specified, 
\cdf{with-added-methods} returns \cdf{nil}.


If a generic function with the given name already exists, the
lambda-list specified in the \cdf{with-added-methods} form must be
congruent with the lambda-lists of all existing methods on that
function as well as with the lambda-lists of all methods defined by the
\cdf{with-added-methods} form; otherwise an error is signaled.

If \emph{function-name\/} specifies an existing generic function that has a
different value for any of the following \emph{option\/} arguments, the
copy of that generic function is modified to have the new value: 
\cd{:argument-precedence-order}, \cdf{declare}, \cd{:documentation}, 
\cd{:generic-function-class}, \cd{:method-combination}.

If \emph{function-name\/} specifies an existing generic function that has a
different value for the \cd{:method-class} \emph{option\/} argument,
that value is changed in the copy of that generic function, but any
methods copied from the existing generic function are not changed.

If a function of the given name already exists, that function is copied into
the default method for a generic function of the given name.  Note that
this behavior differs from that of \cdf{defgeneric}.

If a macro or special form of the given name already exists, an error
is signaled.

If there is no existing generic function, the \emph{option\/} arguments have
the same default values as the \emph{option\/} arguments to \cdf{defgeneric}.

See \cdf{generic-labels},
\cdf{generic-flet},
\cdf{defmethod},
\cdf{defgeneric},
and \cd{ensure-\discretionary{}{}{}generic-\discretionary{}{}{}function}.
\end{defspec}


\begin{defmac}
with-slots ({slot-entry}*) instance-form {declaration}* {\,form}*

\begin{tabbing}
\emph{slot-entry\/} ::= \emph{slot-name\/} {\Mor} \cd{(\emph{variable-name\/} \emph{slot-name\/})}
\end{tabbing}
The macro \cdf{with-slots} creates a lexical context for referring to
specified slots as though they were variables.  Within such a context
the value of the slot can be specified by using its slot name, as if
it were a lexically bound variable.  Both \cdf{setf} and \cdf{setq}
can be used to set the value of the slot.

The macro \cdf{with-slots} translates an appearance of the slot name as
a variable into a call to \cdf{slot-value}.

  



The result returned is that obtained by executing the forms specified
by the \emph{body\/} argument.

Example:

\begin{lisp}
(with-slots (x y) position-1 \\*
~~(sqrt (+ (* x x) (* y y)))) \\
\\
(with-slots ((x1 x) (y1 y)) position-1 \\*
~~(with-slots ((x2 x) (y2 y)) position-2 \\*
~~~~(psetf x1 x2 \\*
~~~~~~~~~~~y1 y2)))) \\
\\
(with-slots (x y) position \\*
~~(setq x (1+ x) \\*
~~~~~~~~y (1+ y)))
\end{lisp}


A \cdf{with-slots} expression of the form:
\begin{lisp}
(with-slots (\emph{$slot{\foohyphenentry}\sub 1$} ... $slot{\foohyphenentry\sub {\hbox{\scriptsize\it n}}$}) \emph{instance\/} \\*
~~$declaration\sub 1$ ... $declaration\sub {\hbox{\scriptsize\it m}}$) \\*
~~$form\sub 1$ ... $form\sub {\hbox{\scriptsize\it k}}$)
\end{lisp}
expands into the equivalent of
\begin{lisp}
(let ((\emph{in\/} \emph{instance\/})) \\
~~(symbol-macrolet ($Q\sub 1$ ... $Q\sub {\hbox{\scriptsize\it n}}$) \\*
~~~~$declaration\sub 1$ ... $declaration\sub {\hbox{\scriptsize\it m}}$) \\*
~~~~$form\sub 1$ ... $form\sub {\hbox{\scriptsize\it k}}$)
\end{lisp}
where ${Q}\sub {\hbox{\scriptsize\it j}}$ is 
\begin{lisp}
({\rm $slot{\foohyphen}entry\sub {\hbox{\scriptsize\it j}}$} (slot-value \emph{in\/} '\emph{$slot{\foohyphen}entry\sub {\hbox{\scriptsize\it j}}$}))
\end{lisp}
if ${\hbox{slot-entry}}\sub {\hbox{\scriptsize\it j}}$ is a symbol and is
\begin{lisp}
({\rm $variable{\foohyphen}name\sub {\hbox{\scriptsize\it j}}$} (slot-value \emph{in\/} '{\rm $slot{\foohyphen}name\sub {\hbox{\scriptsize\it j}}$}))
\end{lisp}
if ${\hbox{slot-entry}}\sub {\hbox{\scriptsize\it j}}$
is of the form \cd{({\rm $variable{\foohyphen}name\sub {\hbox{\scriptsize\it j}}$} {\rm $slot{\foohyphen}name\sub {\hbox{\scriptsize\it j}}$})}.

[X3J13 voted in March 1989
\issue{SYMBOL-MACROLET-SEMANTICS}
to modify the definition of \cdf{symbol-macrolet} substantially
and also voted
\issue{SYMBOL-MACROLET-DECLARE} to allow declarations before the body
of \cdf{symbol-macrolet} but with peculiar treatment of \cdf{special}
and type declarations.  The syntactic changes are reflected in this definition
of \cdf{with-slots}.---GLS]

See \cdf{with-accessors} and \cdf{symbol-macrolet}.

\end{defmac}
%\endgroup

