<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Модификация последовательностей</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1805--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse80.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse78.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse78.html#tailclmse78.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse79.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch14.html#clmse79.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">14.3   </span> <a 
href="clm.html#QQ2-98-1228" id="x98-121900014.3">Модификация
последовательностей</a></h3>
<!--l. 1807--><p class="noindent" >Каждая из этих функций или модифицирует последовательность, или
возвращает модифицированную копию.
<div class="defun">
<!--l. 1810--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx98-1219001"></a><a 
 id="x98-1219002r380"></a><b> ﬁll</b>  <i>sequence</i> <i>item</i> &#x0026;key  <i>:start</i> <i>:end</i>
</div>
<!--l. 1812--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-122000014.3" id="x98-122000014.3"></a></span>
   Функция модифицирует последовательность, заменяя каждый элемент
подпоследовательности, обозначенной с помощью параметров <tt>:start</tt> и <tt>:end</tt>,
объектом <i>item</i>. <i>item</i> может быть любым Lisp&#x2019;овыми объектом, подходящим
для типа элементов последовательности <i>sequence</i>. Объект <i>item</i> сохраняется в
всех указанных компонентах последовательности <i>sequence</i>, начиная с позиции
<tt>:start</tt> (по-умолчанию равна 0) и заканчивая невключительно позицией <tt>:end</tt>
(по-умолчанию равна длине последовательности). <tt>fill</tt> возвращает
изменённую последовательность. Например: <div class="lisp"><div class="tabbing">
(setq x (vector &#x2019;a &#x2019;b &#x2019;c &#x2019;d &#x2019;e)) <span class="math"> ⇒</span> #(a b c d e)
   <br>                                      (ﬁll x &#x2019;z <tt>:start</tt> 1 <tt>:end</tt> 3) <span class="math"> ⇒</span> #(a z z d e)<br>
  and now x <span class="math"> ⇒</span> #(a z z d e)<br>                   (ﬁll x &#x2019;p) <span class="math"> ⇒</span> #(p p p p p)<br>
  and now x <span class="math"> ⇒</span> #(p p p p p)<br>
<!--l. 1828--><p class="noindent" ></div>
<!--l. 1828--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-122100014.3" id="x98-122100014.3"></a></span>
<!--l. 1828--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-122200014.3" id="x98-122200014.3"></a></span>
</div>
</div>
                                                                          

                                                                          
<div class="defun">
<!--l. 1831--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx98-1222001"></a><a 
 id="x98-1222002r381"></a><b> replace</b>  <i>sequence1</i> <i>sequence2</i> &#x0026;key  <i>:start1</i> <i>:end1</i> <i>:start2 :end2</i>
</div>
<!--l. 1833--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-122300014.3" id="x98-122300014.3"></a></span>
   Функция модифицирует последовательность <i>sequence1</i> копируя в неё
элементы из последовательности <i>sequence2</i>. Элементы <i>sequence2</i> для
принадлежать типу элементов <i>sequence1</i>. Подпоследовательность <i>sequence2</i>,
указанная с помощью параметров <tt>:start2</tt> и <tt>:end2</tt>, копируется в
подпоследовательность <i>sequence2</i>, указанную с помощью параметров <tt>:start1</tt> и
<tt>:end1</tt>. Аргументы <tt>:start1</tt> и <tt>:start2</tt> по-умолчанию равны нулю. Аргументы
<tt>:end1</tt> и <tt>:end2</tt> по-умолчанию <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, что означает длины соответствующих
последовательностей. Если указанные подпоследовательности имеют
не равные длины, тогда для наиболее короткая из них определяет
копируемые элементы. Лишние элементы последовательностей функцией не
обрабатываются. Количество копируемых элементов можно вычислить так:
<div class="lisp"><div class="tabbing">
(min (- <i>end1</i> <i>start1</i>) (- <i>end2</i> <i>start2</i>))
   <br>
<!--l. 1848--><p class="noindent" ></div>
<!--l. 1848--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-122400014.3" id="x98-122400014.3"></a></span>
<!--l. 1848--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-122500014.3" id="x98-122500014.3"></a></span>
</div>
<!--l. 1849--><p class="indent" >   Значением функции <tt><a 
href="#x98-1222002r381">replace</a></tt> является модифицированная последовательность
<i>sequence1</i>.
<!--l. 1852--><p class="indent" >   Если обе последовательности равны (<tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt>), и интервал для модификации
перекрывается с исходным интервалом, тогда поведение такое, как если бы
все исходные данные сохранялись во временном месте, а затем сохранялись в
итоговый интервал. Однако, если последовательности не равны, но итоговый
интервал пересекается с исходным (возможно, при использовании
<i>соединённых</i> массивов), тогда после выполнения <tt><a 
href="#x98-1222002r381">replace</a></tt>, итоговое
                                                                          

                                                                          
содержимое не определено.
</div>
<div class="defun">
<!--l. 1861--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx98-1225001"></a><a 
 id="x98-1225002r382"></a><b> remove</b>  <i>item</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i> <i>:test-not</i> <i>:start</i> <i>:end</i>
<i>:count</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx98-1225003"></a><a 
 id="x98-1225004r383"></a><b> remove-if</b>  <i>predicate</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start</i> <i>:end</i> <i>:count</i>
<i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx98-1225005"></a><a 
 id="x98-1225006r384"></a><b> remove-if-not</b>  <i>predicate</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start</i> <i>:end</i>
<i>:count</i> <i>:key</i>
</div>
<!--l. 1865--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-122600014.3" id="x98-122600014.3"></a></span>
   Результатом является последовательность того же типа, что и
последовательность <i>sequence</i>. Однако, итоговая последовательность не будет
содержать элементы в интервале <tt>:start</tt>-<tt>:end</tt>, которые удовлетворяли
условию. Результат является копией входящей последовательности <i>sequence</i>
без исключённых элементов. Неудалённые элементы сохраняются в таком же
порядке.
<!--l. 1872--><p class="indent" >   Если указан аргумент <tt>:count</tt>, то удаляться будет только это количество.
Если количество удаляемых элементов превышает параметр, тогда будут
удалены только самые левые в количестве равном <tt>:count</tt>.
<!--l. 1876--><p class="indent" >   Если при использовании <tt>:count</tt> для параметра <tt>:from-end</tt> указано не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>
значение, тогда удаление элементов будет происходить справа в количестве
<tt>:count</tt>. Например: <div class="lisp"><div class="tabbing">
(remove 4 &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (1 2 1 3 5)
   <br>                         (remove 4 &#x2019;(1 2 4 1 3 4 5) <tt>:count</tt> 1) <span class="math"> ⇒</span> (1 2 1 3 4 5)<br>
(remove 4 &#x2019;(1 2 4 1 3 4 5) <tt>:count</tt> 1 <tt>:from-end</tt> t)<br>
   <span class="math"> ⇒</span> (1 2 4 1 3 5)<br>    (remove 3 &#x2019;(1 2 4 1 3 4 5) <tt>:test</tt> #&#x2019;&#x003E;) <span class="math"> ⇒</span> (4 3 4 5)<br>
(remove-if #&#x2019;oddp &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (2 4 4)<br>
(remove-if #&#x2019;evenp &#x2019;(1 2 4 1 3 4 5) <tt>:count</tt> 1 <tt>:from-end</tt> t)<br>
   <span class="math"> ⇒</span> (1 2 4 1 3 5)<br>
<!--l. 1889--><p class="noindent" ></div>
<!--l. 1889--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-122700014.3" id="x98-122700014.3"></a></span>
                                                                          

                                                                          
<!--l. 1889--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-122800014.3" id="x98-122800014.3"></a></span>
</div>
<!--l. 1890--><p class="indent" >   Результат <tt><a 
href="#x98-1225002r382">remove</a></tt> может быть <i>соединён</i> с исходной последовательностью.
Также результат может быть равен <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> исходной последовательности, если ни
одного элементы не было удалено.
</div>
<div class="defun">
<!--l. 1895--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx98-1228001"></a><a 
 id="x98-1228002r385"></a><b> delete</b>  <i>item</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i> <i>:test-not</i>
<i>:start :end :count :key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx98-1228003"></a><a 
 id="x98-1228004r386"></a><b> delete-if</b>  <i>predicate</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start :end :count :key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx98-1228005"></a><a 
 id="x98-1228006r387"></a><b> delete-if-not</b>  <i>predicate</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start :end :count :key</i>
</div>
<!--l. 1899--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-122900014.3" id="x98-122900014.3"></a></span>
   Данная функция в отличие от <tt><a 
href="#x98-1225002r382">remove</a></tt> модифицирует исходную
последовательность. Результатом является последовательность того же типа,
что и последовательность <i>sequence</i>. Однако, итоговая последовательность не
будет содержать элементы в интервале <tt>:start</tt>-<tt>:end</tt>, которые удовлетворяли
условию. Результат является копией входящей последовательности <i>sequence</i>
без исключённых элементов. Неудалённые элементы сохраняются в таком же
порядке. Последовательность <i>sequence</i> может быть модифицирована, поэтому
результат может быть равен <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> или нет исходной последовательности.
<!--l. 1909--><p class="indent" >   Если указан аргумент <tt>:count</tt>, то удаляться будет только это количество.
Если количество удаляемых элементов превышает параметр, тогда будут
удалены только самые левые в количестве равном <tt>:count</tt>.
<!--l. 1913--><p class="indent" >   Если при использовании <tt>:count</tt> для параметра <tt>:from-end</tt> указано не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>
значение, тогда удаление элементов будет происходить справа в количестве
<tt>:count</tt>. Например: <div class="lisp"><div class="tabbing">
(delete 4 &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (1 2 1 3 5)
   <br>                          (delete 4 &#x2019;(1 2 4 1 3 4 5) <tt>:count</tt> 1) <span class="math"> ⇒</span> (1 2 1 3 4 5)<br>
(delete 4 &#x2019;(1 2 4 1 3 4 5) <tt>:count</tt> 1 <tt>:from-end</tt> t)<br>
   <span class="math"> ⇒</span> (1 2 4 1 3 5)<br>     (delete 3 &#x2019;(1 2 4 1 3 4 5) <tt>:test</tt> #&#x2019;&#x003E;) <span class="math"> ⇒</span> (4 3 4 5)<br>
(delete-if #&#x2019;oddp &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (2 4 4)<br>
(delete-if #&#x2019;evenp &#x2019;(1 2 4 1 3 4 5) <tt>:count</tt> 1 <tt>:from-end</tt> t)<br>
   <span class="math"> ⇒</span> (1 2 4 1 3 5)<br>
                                                                          

                                                                          
<!--l. 1926--><p class="noindent" ></div>
<!--l. 1926--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-123000014.3" id="x98-123000014.3"></a></span>
<!--l. 1926--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-123100014.3" id="x98-123100014.3"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1929--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx98-1231001"></a><a 
 id="x98-1231002r388"></a><b> remove-duplicates</b>  <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i> <i>:test-not</i> <i>:start</i>
<i>:end</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx98-1231003"></a><a 
 id="x98-1231004r389"></a><b> delete-duplicates</b>  <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i> <i>:test-not</i> <i>:start</i>
<i>:end</i> <i>:key</i>
</div>
<!--l. 1932--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-123200014.3" id="x98-123200014.3"></a></span>
   Функция попарно сравнивает элементы последовательности <i>sequence</i>,
и если они равны, тогда первый из них удаляется (если параметр
<tt>:from-end</tt> равен истине, то удаляется последний). Результат является
последовательностью того же типа, что и исходная, с удалёнными
повторяющимися элементами. Порядок следования элементов в итоге такой
же как в исходной последовательности.
<tt>
<!--l. 1940--><p class="indent" >   <a 
href="#x98-1231002r388">remove-duplicates</a></tt> является не модифицирующей версией этой
операции. Результат <tt><a 
href="#x98-1231002r388">remove-duplicates</a></tt> может быть <i>соединён</i> с исходной
последовательностью. Также результат может быть равен <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> исходной
последовательности, если ни одного элементы не было удалено.
<tt>
<!--l. 1945--><p class="indent" >   <a 
href="#x98-1231004r389">delete-duplicates</a></tt> может модифицировать аргумент <i>sequence</i>.
<!--l. 1947--><p class="indent" >   Например: <div class="lisp"><div class="tabbing">
(remove-duplicates &#x2019;(a b c b d d e)) <span class="math"> ⇒</span> (a c b d e)
   <br>           (remove-duplicates &#x2019;(a b c b d d e) <tt>:from-end</tt> t) <span class="math"> ⇒</span> (a b c d e)<br>
(remove-duplicates &#x2019;((foo #\a) (bar #\%) (baz #\A))<br>
                   <tt>:test</tt> #&#x2019;char-equal <tt>:key</tt> #&#x2019;cadr)<br>
   <span class="math"> ⇒</span> ((bar #\%) (baz #\A))<br>
                                                                          

                                                                          
(remove-duplicates &#x2019;((foo #\a) (bar #\%) (baz #\A))<br>
                   <tt>:test</tt> #&#x2019;char-equal <tt>:key</tt> #&#x2019;cadr <tt>:from-end</tt> t)<br>
   <span class="math"> ⇒</span> ((foo #\a) (bar #\%))<br>
<!--l. 1957--><p class="noindent" ></div>
<!--l. 1957--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-123300014.3" id="x98-123300014.3"></a></span>
<!--l. 1957--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-123400014.3" id="x98-123400014.3"></a></span>
</div>
<!--l. 1959--><p class="indent" >   Эти функции полезны для преобразования последовательности в
каноническую форму представления множества.
</div>
<div class="defun">
<!--l. 1963--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx98-1234001"></a><a 
 id="x98-1234002r390"></a><b> substitute</b>  <i>newitem</i> <i>olditem</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i>
<i>:test-not</i> <i>:start</i> <i>:end</i> <i>:count</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx98-1234003"></a><a 
 id="x98-1234004r391"></a><b> substitute-if</b>  <i>newitem</i> <i>test</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start :end</i>
<i>:count</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx98-1234005"></a><a 
 id="x98-1234006r392"></a><b> substitute-if-not</b>  <i>newitem</i> <i>test</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start</i>
<i>:end</i> <i>:count</i> <i>:key</i>
</div>
<!--l. 1967--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-123500014.3" id="x98-123500014.3"></a></span>
   Результатом является последовательность такого же типа что и исходная
<i>sequence</i> за исключением того, что удовлетворяющие условию элементы в
интервале <tt>:start</tt>-<tt>:end</tt> будут заменены на объект <i>newitem</i>. Эта операция
создаёт копию исходной последовательности с некоторыми изменёнными
элементами.
<!--l. 1974--><p class="indent" >   Если указан аргумент <tt>:count</tt>, то изменяться будет только это
количество элементов. Если количество изменяемых элементов превышает
параметр, тогда будут удалены только самые левые в количестве равном
<tt>:count</tt>.
<!--l. 1979--><p class="indent" >   Если при использовании <tt>:count</tt> для параметра <tt>:from-end</tt> указано не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>
значение, тогда изменение элементов будет происходить справа в количестве
<tt>:count</tt>. Например: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(substitute 9 4 &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (1 2 9 1 3 9 5)
   <br>                (substitute 9 4 &#x2019;(1 2 4 1 3 4 5) <tt>:count</tt> 1) <span class="math"> ⇒</span> (1 2 9 1 3 4 5)<br>
(substitute 9 4 &#x2019;(1 2 4 1 3 4 5) <tt>:count</tt> 1 <tt>:from-end</tt> t)<br>
   <span class="math"> ⇒</span> (1 2 4 1 3 9 5)<br>
(substitute 9 3 &#x2019;(1 2 4 1 3 4 5) <tt>:test</tt> #&#x2019;&#x003E;) <span class="math"> ⇒</span> (9 9 4 9 3 4 5)<br>
(substitute-if 9 #&#x2019;oddp &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (9 2 4 9 9 4 9)<br>
(substitute-if 9 #&#x2019;evenp &#x2019;(1 2 4 1 3 4 5) <tt>:count</tt> 1 <tt>:from-end</tt> t)<br>
   <span class="math"> ⇒</span> (1 2 4 1 3 9 5)<br>
<!--l. 1992--><p class="noindent" ></div>
<!--l. 1992--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-123600014.3" id="x98-123600014.3"></a></span>
<!--l. 1992--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-123700014.3" id="x98-123700014.3"></a></span>
</div>
<!--l. 1993--><p class="indent" >   Результат <tt><a 
href="#x98-1234002r390">substitute</a></tt> может быть <i>соединён</i> с исходной последовательностью.
Также результат может быть равен <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> исходной последовательности, если ни
одного элементы не было изменено.
<!--l. 1997--><p class="indent" >   Смотрите также <tt><a 
href="clmse85.html#x105-1368002r476">subst</a></tt>, которая осуществляет замену в древовидной
структуре.
</div>
<div class="defun">
<!--l. 2001--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx98-1237001"></a><a 
 id="x98-1237002r393"></a><b> nsubstitute</b>  <i>newitem</i> <i>olditem</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i>
<i>:test-not</i> <i>:start</i> <i>:end</i> <i>:count</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx98-1237003"></a><a 
 id="x98-1237004r394"></a><b> nsubstitute-if</b>  <i>newitem</i> <i>test</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start :end</i>
<i>:count</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx98-1237005"></a><a 
 id="x98-1237006r395"></a><b> nsubstitute-if-not</b>  <i>newitem</i> <i>test</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start</i>
<i>:end</i> <i>:count</i> <i>:key</i>
</div>
<!--l. 2005--><p class="noindent" ><span class="paragraphHead"><a 
href="#x98-123800014.3" id="x98-123800014.3"></a></span>
   Эта функция является деструктивным аналогом для <tt><a 
href="#x98-1234002r390">substitute</a></tt>. Это
значит, что они модифицирует свой аргумент. Результатом является
последовательность такого же типа что и исходная <i>sequence</i> за исключением
того, что удовлетворяющие условию элементы в интервале <tt>:start</tt>-<tt>:end</tt> будут
                                                                          

                                                                          
заменены на объект <i>newitem</i>. Последовательность <i>sequence</i> может быть
модифицирована, поэтому результат может быть равен <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> или нет исходной
последовательности.
<!--l. 2015--><p class="indent" >   Смотрите также <tt><a 
href="clmse85.html#x105-1373002r479">nsubst</a></tt>, которая осуществляет деструктивную замену в
древовидной структуре.
</div>
                                                                          

                                                                          
<!--l. 2019--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse80.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse78.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse78.html#tailclmse78.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse79.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch14.html#clmse79.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse79.html"></a>    </div> </div> 
</body></html> 
