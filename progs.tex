%Part{Progs, Root = "CLM.MSS"}
%Chapter of Spice Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}


\chapter{Program Structure Структура программы}
\label{PROGS}

In chapter~\ref{DTYPES} the syntax was sketched for notating data objects
in Common Lisp.  The same syntax is used for notating programs because all
Common Lisp programs have a representation as Common Lisp data objects.

В главе~\ref{DTYPES} был обозначен синтаксис для записи объектов данных в Common
Lisp'е. Такой же синтаксис используется для записи программ, потому что все
Common Lisp программы представлены как объекты данных Common Lisp'а.

Lisp programs are organized as forms and functions.  Forms are
\textit{evaluated} (relative to some context) to produce values and side
effects.  Functions are invoked by \textit{applying} them to arguments.
The most important kind of form performs a function call;
conversely, a function performs computation by evaluating forms.

Lisp программы организованы как формы и функции. Формы \textit{выполняются}
(относительно некоторого контекста) для получения значений и побочных
эффектов. Функции вызываются с помощью \textit{применения} их к аргументам.
Наиболее важный вид форм выполняет вызов функции, и наоборот, функция выполняет
вычисление с помощью выполнения форм.

In this chapter, forms are discussed first and then functions.
Finally, certain ``top level'' special forms are discussed; the most
important of these is \cdf{defun}, whose purpose is to define a
named function.

В данной главе, сначала обсуджаются формы и затем функции. В конце, обсуждаются
специальные формы <<верхнего уровня (top level)>>. Наиболее важной из этих форм
является \cdf{defun}, цель которой --- создание именных функций (будут
еще и безымянные).

\section{Forms Формы}

The standard unit of interaction with a Common Lisp implementation is the \textit{form},
which is simply a data object meant to be \textit{evaluated} as a program
to produce one or more \textit{values} (which are also data objects).
One may request evaluation of \textit{any} data object, but only certain ones
are meaningful.  For instance,
symbols and lists are meaningful forms, while arrays
normally are not.  Examples of meaningful forms are \cd{3},
whose value is \cd{3}, and \cd{(+ 3 4)}, whose value is \cd{7}.
We write \cd{3} \EV\ \cd{3} and \cd{(+ 3 4)} \EV\ \cd{7}
to indicate these facts.  (\EV\ means ``evaluates to.'')

Стандартная единица взаимодействия с реализацией Common Lisp'а является
\textit{форма}, которая является объектом данных, который выполняется как
программа для вычисления одного или более \textit{значений} (который также
являются объектами данных). Запросить выполнение можно для \textit{любого}
объекта данных, но не для всех это имеет смысл. Например, символы и списки имеет
смысл выполнять, тогда как массивы обычно нет. Примеры содержательных форм:
\cd{3}, значение которой \cd{3}, и \cd{(+ 3 4)}, значение которой \cd{7}.
Для обозначения этих фактов мы пишем \cd{3} \EV\ \cd{3} и \cd{(+ 3 4)} \EV\
\cd{7}. (\EV\ означает <<вычисляется в>>)

Meaningful forms may be divided into three categories:
self-evaluating forms, such as numbers; symbols, which stand
for variables; and lists.  The lists in turn may be divided
into three categories: special forms, macro calls, and function calls.

Содержательные формы могут быть разделены на три категории:
самовычисляемые формы, такие как числа,
символы, которые используются для переменных,
и списки. Списки в свою очередь могут быть разделены на три категории:
специальные формы, 
вызовы макросов,
вызовы функций.

\begin{obsolete}
Any Common Lisp data object not explicitly defined here to be a valid form
is not a valid form.  It is an error to evaluate
anything but a valid form.

\beforenoterule
\begin{implementation}
An implementation is free to make
implementation-dependent extensions to the evaluator but is
strongly encouraged to signal an error on any attempt to
evaluate anything but a valid form or an object for which
a meaningful evaluation extension has been purposely defined.
\end{implementation}
\afternoterule
\end{obsolete}

\begin{newer}
X3J13 voted in October 1988 \issue{EVAL-OTHER} to specify that
\textit{all} standard Common Lisp data objects other than symbols
and lists (including \cdf{defstruct} structures defined
without the \cd{:type} option) are self-evaluating.

Все стандартные объекты данных Common Lisp, не являющиеся символами и списками
(включая \cdf{defstruct} структуры, определенные без опции \cd{:type}) являются
самовычисляемыми. 
\end{newer}

\subsection{Self-Evaluating Forms Самовычисляемые формы}

All numbers, characters, strings, and bit-vectors
are \textit{self-evaluating} forms.
When such an object is evaluated, that object
(or possibly a copy in the case of numbers or characters)
is returned as the value
of the form.  The empty list {\emptylist}, which is also the false value {\false},
is also a self-evaluating form: the value of {\false} is {\false}.
Keywords (symbols written with a leading colon) also evaluate
to themselves: the value of \cd{:start} is \cd{:start}.

Все числа, строковые символы, строки и битовые векторы являются
\textit{самовычисляемыми} формами.
Когда данный объект вычисляется, тогда объект (или возможно копия в случае с
числами и строковыми символами) возвращается в качестве значения данной
формы. Пустой список {\emptylist}, который также является значением false
{\false}, также является самовычисляемой формой: значение {\false} является
{\false}. 
Ключевые символы (примечание переводчика: не путать с ключевыми словами в других
языках, в Common Lisp'е это вид символов) также вычисляюется сами в себя:
значение \cd{:start} является \cd{:start}.

\begin{newer}
X3J13 voted in January 1989 \issue{CONSTANT-MODIFICATION} to clarify that
it is an error to destructively modify any object that appears as a constant
in executable code, whether as
a self-evaluating form or within a \cdf{quote} special form.
\end{newer}

\subsection{Variables Переменные}

Symbols are used as names of variables in Common Lisp programs.
When a symbol is evaluated as a form, the value of the variable it names
is produced.  For example, after doing \cd{(setq items 3)}, which assigns
the value \cd{3} to the variable named \cdf{items}, then \cdf{items} \EV\ \cd{3}.
Variables can be \textit{assigned} to, as by \cdf{setq}, or \textit{bound},
as by \cdf{let}.
Any program construct that binds a variable effectively saves the old
value of the variable and causes it to have a new value, and on exit from
the construct the old value is reinstated.

В Common Lisp программах символы используются в качестве имен переменных.
Когда символ вычисляется как форма, то в качестве результата возвращается
значение переменной, которую данный символ именовал. Например, после выполнения
\cd{(setq items 3)}, которая присвоила значение \cd{3} переменой именованной
символом \cdf{items}, форма \cdf{items} выполнится в \cd{3} (\cdf{items} \EV\
\cd{3}).
Переменные могут \textit{назначены} с помощью \cdf{setq} или \textit{связаны} с
помощью \cdf{let}.
Любая программная конструкция, которая связывает переменную, сохраняет старое
значение переменной, и назначает новое, и при выходе из конструкции
восстанавливается старое значение.

There are actually two kinds of variables in Common Lisp, called \textit{lexical} (or
\textit{static}) variables and \textit{special} (or \textit{dynamic}) variables.
At any given time either or both kinds of variable with the same name may
have a current value.  Which of the two kinds of variable is referred to
when a symbol is evaluated depends on the context of the evaluation.
The general rule is that if the symbol occurs textually within a program
construct that creates a \textit{binding} for a variable of the same name,
then the reference is to the variable specified by the binding;
if no such program construct textually contains the reference, then
it is taken to refer to the special variable of that name.

В Common Lisp'е есть два вида переменных. Они называются \cd{лексические} (или
\textit{статические}) и \textit{специальные} (или \textit{динамические}).
В одно время каждая из или обе переменные с одинаковым именем могут иметь
некоторое значение. На какую переменную ссылается символ при его вычислении,
зависит от контекста выполнения. Главное правило заключается в том, что если
символ вычисляется по тексту в конструкции, которая создала \textit{связывание} для
переменной с одинаковым именем, то символ ссылается на переменную, обозначенную
в этом связывании, если же по тексту такой конструкции нет, то символ ссылается
на специальную переменную.

The distinction between the two kinds of variable is one of scope
and extent.  A lexically bound variable can be referred to \textit{only}
by forms occurring at any \textit{place} textually within the program construct that
binds the variable.  A dynamically bound (special) variable can
be referred to at any \textit{time} from the time the binding is made
until the time evaluation of the construct that binds the variable
terminates.  Therefore lexical binding of variables
imposes a spatial limitation
on occurrences of references (but no temporal limitation, for the
binding continues to exist as long as the possibility of reference
remains).  Conversely, dynamic binding of variables imposes a temporal
limitation on occurrences of references (but no spatial limitation).
For more information on scope and extent, see chapter~\ref{SCOPE}.

Различие между двумя видами переменных заключается в области видимости и
продолжительности видимости. Лексически связанная переменная может быть использована
\textit{только} по тексту в форме, которая установила связывание. Динамически
связанная (специальная) переменная может быть использована в любое
\textit{время} между установкой связи и до выполнения конструкции, которая
упраздняет связывание. Таким образом лексическое связывание переменных
накладывает ограничение на использование переменной только в некоторой текстовой
области (но не на временные ограничения, так связывание продолжает существовать,
пока возможно существование ссылки на переменную). И наоборот, динамическое
связывание переменных накладывает ограничение на временные рамки использования
переменной (но не на текстовую область).
Для более подробной информации смотрите главу~\ref{SCOPE}.

The value a special variable has when there are currently
no bindings of that variable is called the \textit{global} value of the
(special) variable.
A global value can be given to a variable only by assignment,
because a value given by binding is by definition not global.

Когда нет связываний, значение, которое имеет специальная
переменная, называется \textit{глобальным} значением (специальной) переменной.
Глобальное значение может быть задано переменной только с помощью назначения,
потому что значение заданное связыванием по определению не глобально.

It is possible for a special variable to have no value at all,
in which case it is said to be \textit{unbound}.
By default, every global variable is unbound unless and until
explicitly assigned a value, except for those global variables
defined in this book or by the implementation already to have values
when the Lisp system is first started.
It is also possible to establish a binding of a special variable
and then cause that binding to be valueless by using the
function \cdf{makunbound}.  In this situation the variable
is also said to be ``unbound,'' although this is a misnomer;
precisely speaking, it is bound but valueless.
It is an error to refer to a variable that is unbound.

Специальная переменная может вообще не иметь значения, в таком случае,
говориться, что они \textit{несвязанная}. 
По умолчанию, каждая глобальная переменная является несвязанной, пока значение
не будет назначено явно, за исключением переменных определенных в этой книге или
реализацией, которые уже имеют значения сразу после первого запуска Lisp машины.
Кроме того, существует возможность установки связывания специальной переменной и
затем упразднения этого связывания с помощью функции \cdf{makunbound}. В такой
ситуации переменная также называется <<несвязанной>>, хотя это и неправильно,
если быть точнее, переменная связана, но без значения FIXME. Ссылка на несвязанную
переменную является ошибкой.

\begin{newer}
X3J13 voted in June 1989 \issue{UNDEFINED-VARIABLES-AND-FUNCTIONS}
to specify more precisely the effects of referring to an unbound variable.

  Reading an unbound variable or an undefined function
  must be detected in the highest safety setting (see the
  \cdf{safety} quality of the \cdf{optimize} declaration specifier)
  but the effect is undefined in any other safety setting. That is,
   reading an unbound variable should signal an error and
   reading an undefined function should signal an error.
  (``Reading a function'' includes
  both references to the function using the \cdf{function}
  special form, such as \cdf{f} in \cd{(function~f)}, and references to the
  function in a call, such as \cdf{f} in \cd{(f~x~y)}.)

  For the case of \cdf{inline} functions (in implementations where they are
  supported), a permitted point of view is that performing the inlining
  constitutes the read of the function, so that an \cdf{fboundp}
  check need not be done at
  execution time. Put another way, the effect of the application of
  \cdf{fmakunbound} to a function name
  on potentially inlined references to that function is undefined.

  When an unbound variable 
  is detected an error of type \cdf{unbound-variable} is signaled,
  and the \cdf{name} slot of the
  \cdf{unbound-variable} condition is initialized to the name of the
  offending variable.

  When an undefined function
  is detected an error of type \cdf{undefined-function} is signaled,
  and the \cdf{name} slot of the
  \cdf{undefined-function} condition is initialized to the name of the
  offending function.

  The condition type \cdf{unbound-slot}, which inherits from
  \cdf{cell-error}, has an additional slot \cdf{instance}, which
  can be initialized using the \cd{:instance} keyword to \cdf{make-condition}.
  The function \cdf{unbound-slot-instance} accesses this slot.

  The type of error signaled by the default primary
  method for the CLOS \cdf{slot-unbound} generic function is \cdf{unbound-slot}.
  The \cdf{instance} slot
  of the \cdf{unbound-slot} condition is initialized to the offending instance
  and the \cdf{name} slot is initialized
  to the name of the offending variable.
\end{newer}

Certain global variables are reserved as ``named constants.''
They have a global value and may not be bound or assigned to.
For example,
the symbols {\true} and {\false} are reserved.
One may not assign a value to {\true} or {\false},
and one may not bind {\true} or {\false}.  The global value of
{\true} is always {\true}, and the global value of
{\false} is always {\false}.  Constant symbols defined by
\cdf{defconstant} also become reserved and may not be further
assigned to or bound (although they may be redefined, if necessary, by
using \cdf{defconstant} again).  Keyword symbols,
which are notated with a leading colon, are reserved and
may never be assigned to or bound; a keyword always evaluates
to itself.

Некоторые глобальные переменные зарезервированы в качестве <<именованных
констант>>.
Они имеют глобальное значение и не могут быть связаны или переназначены.
Например символы {\true} и {\false} зарезервированы.
Невозможно назначить и этим символам. Также невозможно связать эти символы со
другими значениями. Символы констант определенных с помощью \cdf{defconstant}
также становяться зарезервированными и не могут быть переназначены или связаны
(но они могут быть переопределены с помощью вызова \cdf{defconstant}). Ключевые
символы также не могут быть переназначены или связаны, ключевые символы всегда
вычисляются сами в себя.

\subsection{Special Forms Специальные формы}

If a list is to be evaluated as a form, the first step is to examine
the first element of the list.  If the first element is one of
the symbols appearing in table~\ref{SPECIAL-FORM-TABLE},
then the list is called a \textit{special form}.  (This use of the word
``special'' is unrelated to its use in the phrase ``special variable.'')

Если список выполняется в качестве формы, первым шагом является определение
первого элемента списка. Если первый элемент списка является одним из символов,
перечисленных в таблице~\ref{SPECIAL-FORM-TABLE}, тогда список называется
\textit{специальной формой}. (Использование слова <<специальный>> никак не
связано с использованием этого слова в фразе <<специальная переменная>>.)

Special forms are generally environment and control constructs.
Every special form has its own idiosyncratic syntax.  An example
is the \cdf{if} special form:
\cd{(if p (+ x 4) 5)} in Common Lisp means what
``\textbf{if} \textit{p} \textbf{then} \textit{x}+4 \textbf{else} 5'' means in
Algol.

Специальные формы обычно являются окружениями и управляющими конструкциями.
Каждая специальная форма имеет свой идиосинкразитечский синтаксис. Например
специальная форма \cdf{if}:
\cd{(if p (+ x 4) 5)} в Common Lisp'е означает то же, что и
<<\textbf{if} \textit{p} \textbf{then} \textit{x}+4 \textbf{else} 5>> означает в
Algol'е.

The evaluation of a special form normally produces a value or values,
but the evaluation may instead call for a non-local exit; see \cdf{return-from},
\cdf{go}, and \cdf{throw}.

Выполнение специальной формы обычно возвращает значение или значения, но
выполнение может и вызвать нелокальный выход; смотрите \cdf{return-from},
\cdf{go} и \cdf{throw}.

The set of special forms is fixed in Common Lisp; no way is provided
for the user to define more.  The user can create new syntactic
constructs, however, by defining macros.

Множество специальных форм в Common Lisp'е фиксировано. Создание
пользовательский специальных форм невозможно. Однако пользователь может создавать новые
синтаксические конструкции с помощью оперделения макросов.

The set of special forms in Common Lisp is purposely kept very small
because any program-analyzing program must have special knowledge
about every type of special form.  Such a program needs no special
knowledge about macros because it is simple to expand the macro
and operate on the resulting expansion.  (This is not to say that
many such programs, particularly compilers, will not have such
special knowledge.  A compiler may be able
to produce much better code if it recognizes such constructs
as \cdf{typecase} and \cdf{multiple-value-bind} and gives them customized
treatment.)

Множество специальных форм в Common Lisp'е специально держится малым, потому что
любая программа, анализирующая программы, должна содержить специальные знания он
каждом типе специальной формы. Такие программы не нуждаются в специальных
знаниях о макросах, так как раскрытие макроса просто, и далее остается только
оперирования с результатом раскрытия. (Это не значит, что программы, в
частности, компиляторы, не будут иметь специальных знаний о макросах. Компилятор
может генерировать более лучший код, если он распознает такие конструкции, как
\cdf{typecase} и \cdf{multiple-value-bind} и по особому будет обращаться с ними.)

\begin{table}[t]
\caption{Names of All Common Lisp Special Forms}
\label{SPECIAL-FORM-TABLE}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lll@{}}
\cdf{block}&\cdf{if}&\cdf{progv} \\
\cdf{catch}&\cdf{labels}&\cdf{quote} \\
\rtextrm{\lbrack}\cdf{compiler-let}\textrm{\rbrack}&\cdf{let}&\cdf{return-from} \\
\cdf{declare}&\cd{let*}&\cdf{setq} \\
\cdf{eval-when}&\cdf{macrolet}&\cdf{tagbody} \\
\cdf{flet}&\cdf{multiple-value-call}&\cdf{the} \\
\cdf{function}&\cd{multiple-value-prog1}&\cdf{throw} \\
\cdf{go}&\cdf{progn}&\cdf{unwind-protect}
\end{tabular*}
\vskip 4pt
\begin{newer}
X3J13 voted in June 1989 \issue{COMPILER-LET-CONFUSION} to remove
\cdf{compiler-let} from the language.
\end{newer}

\begin{newer}
X3J13 voted in June 1988 \issue{CLOS} to add the special forms \cdf{generic-flet},
\cdf{generic-labels}, \cdf{symbol-macrolet}, and \cdf{with-added-methods}.
\end{newer}

\begin{newer}
X3J13 voted in March 1989 \issue{LOCALLY-TOP-LEVEL} to make
\cdf{locally} a special form rather than a macro.
\end{newer}

\begin{newer}
X3J13 voted in March 1989 \issue{LOAD-TIME-EVAL} to add the special form
\cdf{load-time-eval}.
\end{newer}
\end{table}

An implementation is free to implement as a macro any construct described
herein as a special form.  Conversely, an implementation is free
to implement as a special form any construct described herein as a macro
if an equivalent macro definition is also provided.
The practical consequence is that the predicates \cdf{macro-function} and
\cdf{special-form-p} may both be true of the same symbol.
It is recommended that a program-analyzing program process
a form that is a list whose \textit{car} is a symbol as follows:

Реализация может осуществлять как макросы любую конструкцию описанную здесь как
специальную форму. И наоборот, реализация может осуществлять как специальную
форму любую конструкцию описанную здесь как макрос, при условии что также
предоставляется эквивалентное определение макроса.
Практическое значение заключается в том, что предикаты \cdf{macro-function} и
\cdf{special-form-p} могут оба возвращать true принимая один и тот же символ.
Рекомендуется, чтобы программа для анализа других программ обрабатывала форму
являющуюся списком, \textit{car} которого является символом, следующим образом:

\begin{enumerate}
\item
If the program has particular knowledge about the symbol,
process the form using special-purpose code.
All of the symbols listed in table~\ref{SPECIAL-FORM-TABLE}
should fall into this category. 

\item
Если программа имеет подробные знания о символе, обрабатывать форму необходимо с
помощью специализированного кода. Все символы, перечисленные в
таблице~\ref{SPECIAL-FORM-TABLE} должны попадать под данную категорию.

\item
Otherwise, if \cdf{macro-function} is true of the symbol, apply either
\cdf{macroexpand} or \cd{macroexpand-1}, as appropriate,
to the entire form and then start over.

\item
В противном случае, если для этого символа \cdf{macro-function} вычисляется в
true, необходимо применить \cdf{macroexpand} или \cd{macroexpand-1} для раскрытия
формы, и результат вновь анализировать.

\item
Otherwise, assume it is a function call.

\item
В противном случае, необходимо раценивать форму как вызов функции.
\end{enumerate}

\subsection{Macros Макросы}

If a form is a list and the first element is not the name of a special
form, it may be the name of a \textit{macro}; if so, the form is said
to be a \textit{macro call}.  A macro is essentially a function from
forms to forms that will, given a call to that macro, compute
a new form to be evaluated in place of the macro call.
(This computation is sometimes referred to as \textit{macro expansion}.)
For example, the macro named \cdf{return} will take a form such as
\cd{(return x)} and from that form compute a new form
\cd{(return-from {\nil} x)}.  We say that the old
form \textit{expands} into the new form.  The new form is then evaluated in
place of the original form; the value of the new form is returned as the
value of the original form.

Если форма является списком и первый элемент не обозначает специальную
форму, возможно он является именем \textit{макроса}. Если так, то форма
называется \textit{макровызовом или вызовом марокса (macrocall)} FIXME. Макрос
это функция, которая принимает формы и возвращает формы. Возвращенные формы
подставляются в то место, где происходил макровызов, и затем выполняются. (Этот
процесс иногда называется \textit{раскрытием макроса}.)
Например, макрос с именем \cdf{return} принимает форма, вот так: \cd{(return x)},
и полученная в результате раскрытия форма такая: \cd{(return-from {\nil} x)}. Мы
говорим: старая форма раскрылась в новую. Новая форма будет вычислена на месте
оригинальной формы. Значение новой формы будет возвращено, как значение
оригинальной формы.

\begin{new}
X3J13 voted in January 1989
\issue{DOTTED-MACRO-FORMS}
to clarify that macro calls, and subforms
of macro calls, need not be proper lists, but that use of dotted forms
requires the macro definition to use ``\cd{.~\textit{var}}'' or
``\cd{\&rest~\textit{var}}'' in order to match them properly.
It is then the responsibility of the macro definition to recognize
and appropriately handle such dotted forms or subforms.
\end{new}

There are a number of standard macros in Common Lisp, and the user can define more
by using \cdf{defmacro}.

В Common Lisp'е существует некоторое количество стандартных макросов, и
пользователь может определять свои макросы используя \cdf{defmacro}.

Macros provided by a Common Lisp implementation as described herein may expand
into code that is not portable among differing implementations.
That is, a macro call may be implementation-independent because
the macro is defined in this book, but the expansion need not be.

Макросы, предоставляемые реализацией Common Lisp'а и описанные здесь, могут
раскрываться в код, которые не будет являться переносимым между реализациями.
Вызов макроса является портабельным, в то время как результат раскрытия нет.

\beforenoterule
\begin{implementation}
Implementors are encouraged to implement the macros
defined in this book, as far as is possible, in such a way that
the expansion will not contain any implementation-dependent
special forms, nor contain as forms data objects that
are not considered to be forms in Common Lisp.
The purpose of this restriction is to ensure that the expansion
can be processed by a program-analyzing program in an
implementation-independent manner.
There is no problem with a macro expansion containing
calls to implementation-dependent functions.
This restriction is not a requirement of Common Lisp; it is recognized
that certain complex macros may be able to expand into significantly
more efficient code in certain implementations
by using implementation-dependent special forms in the macro expansion.
\end{implementation}
\afternoterule

\subsection{Function Calls Вызовы функций}

If a list is to be evaluated as a form and the first element is
not a symbol that names a special form or macro, then the list
is assumed to be a \textit{function call}.  The first element of the
list is taken to name a function.  Any and all remaining elements
of the list are forms to be evaluated; one value is obtained
from each form,
and these values become the \textit{arguments} to the function.
The function is then \textit{applied} to the arguments.
The functional computation normally produces a value,
but it may instead call for a non-local exit; see \cdf{throw}.
A function that does return may produce no value or several values;
see \cdf{values}.
If and when the function returns, whatever values it returns
become the values of the function-call form.

Если список выполняется как форма, и первый элемент не является символом,
обозначающим специальную форму или макрос, тогда предполагается, что список
является \textit{вызовом функции}. Первый элемент списка является именем
функции. Все следующие элементы списка будут вычислены. Одно значение каждого
вычисленного элемента будет является \textit{аргументом} для вызываемой
функции. 
Затем функция будет \textit{применена} к аргументам. Вычисление функции обычно
возвращает значение, однако вместо этого может быть выполнен нелокальный выход,
смотрите \cdf{throw}. Функция может возвращать 0 и более значений, смотрите
\cdf{values}. 
Если и когда функция возвращает значения, они становяться значениями вычисления
формы вызова функции.

For example, consider the evaluation of the form \cd{(+ 3 (* 4 5))}.
The symbol \cd{+} names the addition function, not a special form or macro.
Therefore the two forms \cd{3} and \cd{(* 4 5)} are evaluated to produce
arguments.  The form \cd{3} evaluates to \cd{3}, and the form
\cd{(* 4 5)} is a function call (to the multiplication function).
Therefore the forms \cd{4} and \cd{5} are evaluated, producing arguments
\cd{4} and \cd{5} for the multiplication.  The multiplication function
calculates the number \cd{20} and returns it.  The values \cd{3} and \cd{20}
are then given as arguments to the addition function, which calculates
and returns the number \cd{23}.  Therefore we say \cd{(+ 3 (* 4 5)) \EV\ 23}.

Например, рассмотрим вычисление формы: \cd{(+ (* 4 5))}.
Символ \cd{+} обозначает функцию сложения, а не специальную форму или макрос.
Таким образом две формы \cd{3} и \cd{(* 4 5)} вычисляются для аргументов. Форма
\cd{3} вычисляется в \cd{3}, а форма \cd{(* 4 5)} является вызовом функции
(умножения). Таким образом формы \cd{4} и \cd{5} вычисляются сами в себя, тем
самым предоставляя аргументы для функции умножения. Функция умножения вычисляет
результат \cd{20} и возвращает его. Значения \cd{3} и \cd{20} становяться
аргументами функции сложения, которая вычисляет и возвращает результат
\cd{23}. Таким образом мы говорим \cd{(+3 (* 4 5)) \EV\ 23}.

\begin{newer}
X3J13 voted in October 1988 \issue{FUNCTION-CALL-EVALUATION-ORDER}
to clarify that while the arguments in a function call are always
evaluated in strict left-to-right order, whether the function to
be called is determined before or after argument evaluation
is unspecified.  Programs are in error
that rely on a particular order of evaluation
of the first element of a function call relative to the
argument forms.
\end{newer}

\section{Functions Функции}

There are two ways to indicate a function to be used in a function-call
form.  One is to use a symbol that names the function.  This use of
symbols to name functions is completely independent of their use in
naming special and lexical variables.  The other way is to use a
\textit{lambda-expression}, which is a list whose first element is the symbol
\cdf{lambda}.  A lambda-expression is \textit{not} a form; it cannot be
meaningfully evaluated.  Lambda-expressions and symbols, when used in
programs as names of functions, can appear only as the first element of a
function-call form, or as the second element of the \cdf{function}
special form.  Note that symbols and lambda-expressions are treated as
\textit{names} of functions in these two contexts.  This should be
distinguished from the treatment of symbols and lambda-expressions as
\textit{function objects}, that is,
objects that satisfy the predicate \cdf{functionp},
as when giving such an object to \cdf{apply} or \cdf{funcall} to be
invoked.

Существуют два метода указать функцию для использования в форме вызова
функции. Один из них заключается в указании символа имени функции. Это
использование символов для обозначения функций полностью независимо от их
использования для обозначения специальных и лексических переменных. Другой путь
заключается в использовании \textit{лямбда выражения}, которое является списком
с первым элементом равным \cdf{lambda}. Лябда выражение \textit{не} является
формой, оно не может быть полноценно вычислено. Лямбда выражения и символы,
когда они используются в программах для обозначения функций, могут быть
указаны в качестве первого элемента формы вызова функции, или только в качестве
второго параметры в специальной форме \cdf{function}. Следует отметить, что
в этих двух контекстах символы и лябда выражения обрабатываются, как
\textit{имена} функций. Необходимо отличать это от обработки символов и лямбда
выражений, как \textit{функциональных объектов, или объектов функций (function
  objects)}, которые удовлетворяют предикату \cdf{functionp}, как при
представлении таких объектов в вызовы функций \cdf{apply} или \cdf{funcall}.

\subsection{Named Functions Именованные функции}

A name can be given to a function in one of two ways.
A \textit{global name} can be given to a function by using the
\cdf{defun} construct.
A \textit{local name} can be given to a function by using the
\cdf{flet} or
\cdf{labels} special form.
When a function is named, a lambda-expression is effectively
associated with that name
along with information about the entities that are lexically apparent
at that point.
If a symbol appears as the first element of a function-call form, then it
refers to the definition established by the innermost \cdf{flet} or \cdf{labels}
construct that textually contains the reference, or to the global
definition (if any) if there is no such containing construct.

Имя может задано функции двумя способами.
\textit{Глобальное имя} может быть дано функции с помощью конструкции
\textit{defun}.
\textit{Локальное имя} может быть дано функции с помощью специальных форм
\cdf{flet} или \cdf{labels}.
Когда функция именуется, лямбда выражение связывается с этим именем вместе с
информацией о сущностях, которые были лексически доступны на момент связи.
Если символ используется в качестве первого элементы формы вызова функции, тогда
он ссылается на определение функции из наиболее ближней формы \cdf{flet} или
\cdf{labels}, которые по тексту содержат эту форму, иначе символ ссылается на
глобальное определение функции, при отсутствии вышеназванных форм.

\subsection{Lambda-Expressions Лябда выражения}
\label{LAMBDA-EXPRESSIONS-SECTION}
\indexterm{lambda-expression}

A \textit{lambda-expression} is a list with the following syntax:
\begin{lisp}
(lambda \textit{lambda-list} . \textit{body})
\end{lisp}
The first element must be the symbol \cdf{lambda}.  The second element
must be a list.  It is called the \textit{lambda-list}, and specifies
names for the \textit{parameters} of the function.  When the function
denoted by the lambda-expression is applied to arguments,
the arguments are matched with the parameters specified by the
lambda-list.  The \textit{body} may then refer to the arguments by using
the parameter names.  The \textit{body} consists of any number of
forms (possibly zero).  These forms are evaluated in sequence,
and the results of the \textit{last} form only are returned as the results
of the application (the value {\false} is returned if there are zero
forms in the body).
The complete syntax of a lambda-expression is:

\textit{Лямбда выражение} является списком со следующим синтаксисом:
\begin{lisp}
(lambda \textit{lambda-list} . \textit{body})
\end{lisp}
Первый элемент должен быть символом \cdf{lambda}. Второй элемент должен быть
списком. Он называется \textit{лямбда списком}, и задает имена для
\textit{параметров} функции. Когда функция, обозначенная лямбда выражением,
применяется к аргументам, аргументы подставляются в соответствии с лямбда
списком. \textit{body} может впоследствии ссылаться на аргументы используя имена
параметров. \textit{body} состоит из любого количества форм (возможно нулевого
количества). Эти формы последовательно выполняются, и результат только \textit{последней} формы,
возвращается в качестве значения (в случае отсутствия форм, возвращается
{\false}).
Полный синтаксис лямбда выражения:
\begingroup
\def\GrossOptVars{\Mstar{\textit{var} {\Mor} \cd{(}\textit{var} \Mopt{\textit{initform} \Mopt{\textit{svar}}}\cd{)}}}
\def\GrossKeyOptVars{\Mstar{\textit{var} {\Mor} \cd{(}\Mgroup{\textit{var} {\Mor} \cd{(}\textit{keyword} \textit{var}\cd{)}} \Mopt{\textit{initform} \Mopt{\textit{svar}}}\cd{)}}}
\def\GrossAuxVars{\Mstar{\textit{var} {\Mor} \cd{(}\textit{var} \Mopt{\textit{initform}}\cd{)}}}
\begin{lisp}
(lambda (\Mstar{\textit{var}} \\
~~~~~~~~~\Mopt{\cd{\&optional} \GrossOptVars} \\
~~~~~~~~~\Mopt{\cd{\&rest} \textit{var}} \\
~~~~~~~~~\Mopt{\cd{\&key} \GrossKeyOptVars \\
~~~~~~~~~~~~~~{\setbox0\hbox{\Mopt{}}\hskip0.5\wd0}\Mopt{\cd{\&allow-other-keys}}} \\
~~~~~~~~~\Mopt{\cd{\&aux} \GrossAuxVars}) \\
~~~\Mchoice{\Mstar\textit{declaration} {\Mor} \textit{documentation-string}} \\
~~~\Mstar{{\it\,form}})
\end{lisp}
\endgroup
Each element of a lambda-list is either a \textit{parameter specifier}
or a \textit{lambda-list keyword}; lambda-list keywords begin with \cd{\&}.
(Note that lambda-list keywords are not keywords in the usual sense;
they do not belong to the keyword package.  They are ordinary symbols
each of whose names begins with an ampersand.  This terminology
is unfortunately confusing but is retained for historical reasons.)

Каждый элемент лямбда списка является или спецификатором параметра или \textit{ключевым
 символом лямбда списка}. Ключевые символы лямбда списка начинаются с символа
\cd{\&}.
Следует отметить, что ключевые символы лямбда списка не является ключевыми
символами в обычном понимании. Они не принадлежат пакету keyword. Они являются
обычными символами, имена которых начинается амперсандом. Такая терминология
запутывает, но так сложилась история.

\begin{obsolete}
In all cases a \textit{var} or \textit{svar} must be a symbol, the name of a variable;
each \textit{keyword} must be a keyword symbol, such as \cd{:start}.
An \textit{initform} may be any form.
\end{obsolete}

\begin{newer}
X3J13 voted in March 1988 \issue{KEYWORD-ARGUMENT-NAME-PACKAGE}
to allow a \textit{keyword} in the preceding specification of a lambda-list
to be any symbol whatsoever, not just a keyword symbol
in the \cdf{keyword} package.  See below.
\end{newer}

A lambda-list has five parts, any or all of which may be empty:
Лямбда список имеет пять частей, любая или все могут быть пустыми:

\begin{itemize}
\item
Specifiers for the \textit{required} parameters.  These are all the parameter
specifiers up to the first lambda-list keyword; if there is no such
lambda-list keyword, then all the specifiers are for required parameters.

\item
Спецификаторы для \textit{обязательных параметров}. К ним относятся все
спецификаторы параметров до первого ключевого символа лямбда списка. Если такой
ключевой символ отсутствует, все спецификаторы считаются обязательными.

\item
Specifiers for \textit{optional} parameters.
If the lambda-list keyword \cd{\&optional} is present,
the \textit{optional} parameter specifiers are those following the
lambda-list keyword \cd{\&optional} up to the next lambda-list keyword or the
end of the list.

\item
Спецификаторы для \textit{необязательных} параметров.
Если указан ключевой символ лямбда списка \cd{\&optional}, спецификаторы
\textit{необязательных} параметров будут следовать после ключевого символа
\cd{\&optional} и до следующего ключевого слова, или до конца списка.

\item
A specifier for a \textit{rest} parameter.  The lambda-list keyword \cd{\&rest}, if present, must
be followed by a single \textit{rest} parameter specifier,
which in turn must be followed by another lambda-list keyword or the end
of the lambda-list.

\item
Спецификатор для \textit{неопределенного количества или оставшегося (rest)} параметра. Если указан ключевой символ
лямбда списка \cd{\&rest}, за ним должен следовать только один спецификатор
\textit{оставшегося (rest)} параметра, за которым может следовать другой ключевой символ или
лямбда список может заканчиваться.

\item
Specifiers for \textit{keyword} parameters.
If the lambda-list keyword \cd{\&key} is present, all specifiers up to the next lambda-list keyword
or the end of the list are \textit{keyword} parameter specifiers.
The keyword parameter specifiers may optionally be followed by the
lambda-list keyword \cd{\&allow-other-keys}.

\item
Спецификатор для \textit{именованных (keyword)} параметров. Если указан ключевой
символ лямбда списка \cd{\&key}, все спецификаторы после данного символа до
следующего ключевого символа или конца списка являются спецификаторами
\textit{именованных} параметров. За спецификаторами именованных параметров
опционально может использовать ключевой символ лямбда списка \cd{\&allow-others-keys}.

\item
Specifiers for \textit{aux} variables.  These are not really parameters.
If the lambda-list keyword \cd{\&aux} is present, all specifiers after it are
\textit{auxiliary variable} specifiers.

\item
Спецификатор для \textit{вспомогательных (aux)} переменных. Они не являются
параметрами. Если указан ключевой символ лямбда списка \cd{\&aux}, все
спецификаторы после него являются спецификаторами вспомогательных переменных.
\end{itemize}

When the function represented by the lambda-expression is applied
to arguments, the arguments and parameters are processed in order
from left to right.
In the simplest case, only required parameters are present
in the lambda-list; each is specified simply by a name \textit{var} for
the parameter variable.
When the function is applied,
there must be exactly as many arguments as there are parameters,
and each parameter is bound to one argument.  Here, and in general,
the parameter is bound as a lexical variable unless a
declaration has been made that it should be a special binding;
see \cdf{defvar}, \cdf{proclaim}, and \cdf{declare}.

Когда функция, заданная лямбда выражением, применяется к аргументам, то эти
аргументы и параметры вычисляются слева направо.
В простейшем случае, в лямбда списке присутствуют только обязательные
параметры. Каждый из них задается просто именем переменной \textit{var}
параметра.
Когда функция применяется, аргументов должно быть столько же, сколько и
параметров, и каждый параметр связывается с одним аргументом. В общем случае,
каждый параметр связывается как лексическая переменная, если только с помощью
декларации не указано, что связь должна осуществляться, как для специальной
переменной. Смотрите \cdf{defvar}, \cdf{proclaim}, \cdf{declare}.

In the more general case, if there are \textit{n} required parameters
(\textit{n} may be zero), there must be at least \textit{n} arguments,
and the required parameters are bound to the first \textit{n} arguments.
The other parameters are then processed using any remaining arguments.

В более общем случае, если указано \textit{n} обязательных параметров
(\textit{n} может равняться нулю), тогда должно быть как мимимум \textit{n}
аргументов, и обязательные параметры будут связаны с \textit{n} первыми
аргументами.

If \textit{optional} parameters are specified, then each one is processed as
follows.  If any unprocessed arguments remain, then the parameter variable
\textit{var} is bound to the next remaining argument, just as for a required
parameter.  If no arguments remain, however, then the \textit{initform} part
of the parameter specifier is evaluated, and the parameter variable
is bound to the resulting value (or to {\false} if no \textit{initform} appears
in the parameter specifier).
If another variable name \textit{svar} appears in the specifier, it is bound
to \textit{true} if an argument was available, and to \textit{false} if no
argument remained (and therefore \textit{initform} had to be evaluated).
The variable \textit{svar} is called a \textit{supplied-p} parameter;
it is bound not to an argument but to a value indicating whether or not
an argument had been supplied for another parameter.

Если указаны необязательные параметры, тогда каждый из них будет оработан так,
как описано ниже. Если осталось некоторое количество аргументов, тогда
переменная параметра \cd{var} будет связана с оставшимся аргументом. Принцип
такой же, как и для обязательных параметров. Если не осталось аргументов, тогда
выполняется часть \textit{initform}, и переменная
параметра связывается с ее результатом (или с {\false}, если форма
\textit{initform} не была задана).
Если в спецификаторе указано имя еще одной переменной \textit{svar}, то она
связывается с \textit{true}, если аргумент был задан, и с \textit{false}
аргумент не был задан (и в таком случае выполняется \textit{initform}).
Переменная \textit{svar} называется \textit{supplied-p} параметр. Она
связывается не с аргументом, а со значением, которое показывается был ли задан
аргумент для данного параметра или нет.

After all \textit{optional} parameter specifiers have been processed,
then there may or may not be a \textit{rest} parameter.
If there is a \textit{rest} parameter, it is bound to a list of all
as-yet-unprocessed arguments.  (If no unprocessed arguments remain,
the \textit{rest} parameter is bound to the empty list.)
If there is no \textit{rest} parameter and there are no \textit{keyword}
parameters,
then there should be no unprocessed arguments (it is an error if there are).

После того, как все \textit{необязательные} параметры были обработаны, могут
быть указан \textit{оставшийся (rest)} параметр.
Если \textit{оставшийся (rest)} параметр указан, он будет связан со списком все
оставшихся необработанных аргументов. Если таких аргументов не осталось,
\textit{оставшийся (rest)} параметр будет связан с пустым списком. Если в лямбда
списке отсутствуют \textit{оставшийся (rest)} параметр и \textit{именованные
  (keyword)} параметры, то необработанных аргументов оставаться не должно (иначе
будет ошибка).

\begin{new}
X3J13 voted in January 1989
\issue{REST-LIST-ALLOCATION}
to clarify that if a function has a \textit{rest} parameter
and is called using \cdf{apply}, then the list to which the
\textit{rest} parameter is bound is permitted, but not required,
to share top-level list structure with the list that was the last
argument to \cdf{apply}.  Programmers should be careful about performing
side effects on the top-level list structure of a \textit{rest} parameter.

This was the result of a rather long discussion within X3J13 and the
wider Lisp community.  To set it in its historical context, I must remark
that in Lisp Machine Lisp the list to which a \textit{rest} parameter was
bound had only dynamic extent; this in conjunction with the
technique of ``cdr-coding'' permitted a clever stack-allocation technique
with very low overhead.  However, the early designers of
Common Lisp, after a great deal of debate, concluded that it was dangerous
for cons cells to have dynamic extent; as an example, the ``obvious''
definition of the function \cdf{list}
\begin{lisp}
(defun list (\&rest x) x)
\end{lisp}
could fail catastrophically.  Therefore the first edition simply implied
that the list for a \textit{rest} parameter, like all other lists, would
have indefinite extent.  This still left open the flip side of the
question, namely, Is the list for a \textit{rest} parameter guaranteed fresh?
This is the question addressed by the X3J13 vote.
If it is always freshly consed, then it is permissible to destroy it,
for example by giving it to \cdf{nconc}.  However, the requirement always
to cons fresh lists could impose an unacceptable overhead in many implementations.
The clarification approved by X3J13 specifies that the programmer may
not rely on the list being fresh; if the function was called using \cdf{apply},
there is no way to know where the list came from.
\end{new}

Next, any \textit{keyword} parameters are processed.
For this purpose the same arguments are processed that
would be made into a list for a \textit{rest} parameter.
(Indeed, it is permitted to specify both \cd{\&rest} and \cd{\&key}.
In this case the remaining arguments are used for both purposes;
that is, all remaining arguments are made into a list for the
\cd{\&rest} parameter and are also processed for the \cd{\&key} parameters.
This is the only situation in which an argument is used
in the processing of more than one parameter specifier.)
If \cd{\&key} is specified, there must remain
an even number of arguments; these are considered as pairs,
the first argument in each pair being interpreted as a keyword name
and the second as the corresponding value.

Далее обрабатываются все \textit{именованные (keyword)} параметры.
Для этих параметров обрабатываются те же аргументы, что и для
\textit{оставшегося (rest)} параметра.
Безусловно, возможно указывать и \cd{\&rest} и \cd{\&key}. В таком случае
оставшиеся аргументы используются для обеих целей:
все оставшиеся аргументы составляются в список для \cd{\&rest} параметра и они
также обрабатываются, как \cd{\&key} параметры. Только в этой ситуации один
аргумент может обрабатываться более чем для одного параметра.
Если указан \cd{\&key}, должно остаться четное количество аргументов. Они будут
обработаны попарно. Первый аргумент в паре должен быть ключевым символом,
который задает имя параметра, второй аргумент должен быть соответствующим
значением.

\begin{obsolete}
It is an error for the first object of each pair to be
anything but a keyword.

\beforenoterule
\begin{rationale}
This last restriction is imposed so that a compiler may
issue warnings about certain malformed calls to functions
that take keyword arguments.  It must be remembered that the
arguments in a function call that evaluate to keywords are just
like any other arguments and may be any evaluable forms.
A compiler could not, without additional context, issue a warning
about the call
\begin{lisp}
(fill seq item x y)
\end{lisp}
because in principle the variable \cdf{x} might have as its value a keyword
such as \cd{:start}.  However, a compiler would be justified in issuing
a warning about the call
\begin{lisp}
(fill seq item 0 10)
\end{lisp}
because the constant \cd{0} is definitely not a keyword.  Similarly,
if in the first case the variable \cdf{x} had been declared to be
of type \cdf{integer}, then type analysis could enable the compiler
to justify a warning.
\end{rationale}
\afternoterule
\end{obsolete}

\begin{newer}
X3J13 voted in March 1988 \issue{KEYWORD-ARGUMENT-NAME-PACKAGE}
to allow a \textit{keyword} in a lambda-list
to be any symbol whatsoever, not just a keyword symbol
in the \cdf{keyword} package.  If, after \cd{\&key},
a variable appears alone or within only one set of parentheses
(possibly with an \textit{initform} and a \textit{svar}), then
the behavior is as before: a keyword symbol with the same name as
the variable is used as the keyword-name when matching arguments
to parameter specifiers.  Only a parameter specifier of the form
\cd{((\textit{keyword} \textit{var})~...)} can cause the keyword-name
not to be a keyword symbol, by specifying a symbol not in the \cdf{keyword}
package as the \textit{keyword}.
For example:
\begin{lisp}
(defun wager (\&key ((secret password) nil) amount) \\*
~~(format nil "You {\Xtilde}A \${\Xtilde}D" \\*
~~~~~~~~~~(if (eq password 'joe-sent-me) "win" "lose") \\*
~~~~~~~~~~amount)) \\
\\
(wager :amount 100) \EV\ "You lose \$100" \\*
(wager :amount 100 'secret 'joe-sent-me) \EV\ "You win \$100"
\end{lisp}
The \cdf{secret} word could be made even more secret in this example
by placing it in some other \cdf{obscure} package, so that one would
have to write
\begin{lisp}
(wager :amount 100 'obscure:secret 'joe-sent-me) \EV\ "You win \$100"
\end{lisp}
to win anything.
\end{newer}

In each keyword parameter specifier must be a name \textit{var} for the
parameter variable.  If an explicit \textit{keyword} is
specified, then that is the keyword name for the parameter.  Otherwise
the name \textit{var} serves to indicate the keyword name,
in that a keyword with the same name (in the \cdf{keyword} package) is used
as the keyword.  Thus

In each keyword parameter specifier must be a name \textit{var} for the
parameter variable.
Если явно указан ключевой символ, тогда он будет использоваться для имени
параметра. В противном случае используется имя переменной \cdf{var} для поиска
ключевого символа в аргументах. Таким образом:

\begin{lisp}
(defun foo (\cd{\&key} radix (type 'integer)) ...)
\end{lisp}
means exactly the same as

означает то же, что и

\begin{lisp}
(defun foo (\cd{\&key} ((:radix radix)) ((:type type) 'integer)) ...)
\end{lisp}

The keyword parameter specifiers are, like all parameter specifiers,
effectively processed from left to right.
For each keyword parameter specifier, if there is an argument
pair whose keyword name matches that specifier's keyword name
(that is, the names are \cdf{eq}),
then the parameter variable for that specifier is bound to the
second item (the value) of that argument pair.
If more than one such argument pair matches, it is not an error;
the leftmost argument pair is used.
If no such argument pair exists, then
the \textit{initform} for that specifier is evaluated
and the parameter variable is bound to that value (or to {\false} if
no \textit{initform} was specified).  The variable \textit{svar} is treated
as for ordinary \textit{optional} parameters: it is bound to \textit{true}
if there was a matching argument pair, and to \textit{false} otherwise.

Спецификатор именованого (keyword) параметра, как и все спецификаторы
параметров, обрабатывается слева направо.
Для каждого спецификатора именованного параметра, если в паре аргумента, в
которой ключевой символ совпадает с именем параметра (сравнение производится с
помощью \cdf{eq}), тогда переменная параметра связывается значением из этой
пары.
Если имеется более одной пар аргументов с одинаковым именем, то это не ошибка. В таком
случае используется наиболее левая пара.
Если пары аргументов не нашлось, тогда выполняется \textit{initform} и
переменная параметра связыванется с этим значением (или с {\false}, если
\textit{initform} не задана). Переменная \textit{svar} используется в тех же
целях, что и для \textit{необязательных} параметров. Она будет связана с
\textit{true} если была необходимая пара аргументов, иначе с \textit{false}.

It is an error if an argument pair has a keyword name not matched
by any parameter specifier, unless at least one of the following
two conditions is met:

Если пара аргументов содержит ключевой символ, который не
присутствует в спецификаторах параметров в лямбда списке, то или возникнет
ошибка или возможны следующие условия:

\begin{itemize}
\item
\cd{\&allow-other-keys} was specified in the lambda-list.

\item
\cd{\&allow-other-keys} был указан в лямбда списке.

\item
Somewhere among the keyword argument pairs is a pair whose keyword
is \cd{:allow-other-keys} and whose value is not {\false}.

\item
Где-то среди именованных аргументов есть пара, в которой есть ключевой символ
\cd{:allow-other-keys} и значение не равно {\false}.
\end{itemize}
If either condition obtains, then it is not an error
for an argument pair to match no parameter specified,
and the argument pair is simply ignored (but such an
argument pair is accessible through the \cd{\&rest} parameter if
one was specified). The purpose of these mechanisms is to
allow sharing of argument lists among several functions
and to allow either the caller or the called function
to specify that such sharing may be taking place.

В случае возникновения одного из этих условий, можно использовать именованные
аргументы, которые не имеют соответствующих параметров (эти аргументы будут
доступны, как оставшийся \cd{\&rest} параметр). 
Целью этого механизма является возможность объединять лямбда списки разных
функции без необходмиости копировать все спецификаторы именованных (keyword)
параметров. Например функция обертка может передать часть именованных аргументов
в обернутую функцию без необходимости явного ручного указания их всех. 

After all parameter specifiers have been processed, the auxiliary
variable specifiers (those following the lambda-list keyword \cd{\&aux}) are processed from
left to right.  For each one, the \textit{initform} is evaluated and the
variable \textit{var} bound to that value (or to {\false} if no \textit{initform} was
specified).  Nothing can be done with \cd{\&aux} variables that cannot be
done with the special form \cd{let*}:

После того как все спецификаторы были обработаны, слева направо обрабатываются
спецификаторы вспомогательных параметров. Для каждого из них выполняется
\textit{initform} и переменная \textit{var} связывается с этим результатом (или
с {\false}, если \textit{initform} не определена). С \cd{\&aux} переменными
можно делать то же, что и со специальной формой \cd{let*}:

\begin{lisp}
(lambda (x y \&aux (a (car x)) (b 2) c) ...) \\
~~~\EQ\ (lambda (x y) (let* ((a (car x)) (b 2) c) ...))
\end{lisp}

Which to use is purely a matter of style.

Что использовать зависит только от стиля.

Whenever any \textit{initform} is evaluated for any parameter
specifier, that form may refer to any parameter variable to the left of
the specifier in which the \textit{initform} appears, including any supplied-p
variables, and may rely on the fact that no other parameter variable
has yet been bound (including its own parameter variable).

Когда какая-либо форма \textit{initform} выполняется в каком-либо спецификаторе
параметра, данная форма может ссылаться на любую переменную параметра, стоящую
слева от данной формы, включая supplied-p переменные, и может рассчитывать на
то, что другие переменные параметров еще не связаны (включая переменную данного
параметра).

Once the lambda-list has been processed, the forms in the body of the
lambda-expression are executed.  These forms may refer to the arguments
to the function by using the names of the parameters.  On exit from the
function, either by a normal return of the function's value(s) or by a
non-local exit, the parameter bindings, whether lexical or special, are
no longer in effect.  (The bindings are not necessarily permanently discarded,
for a lexical binding can later be reinstated if a
``closure'' over that binding was created,
perhaps by using \cdf{function}, and saved before the exit occurred.)

После того как был обработан лямбда список, выполняются формы в теле лямбда
выражения. Эти формы могут ссылаться на аргументы функции, используя именя
параметров. При выходе из функции, как с помощью нормального возврата, так и с
помощью нелокального выхода, связывания параметров, и лексическеие, и
специальные, упраздняются. В случае создания <<замыкания>> над данными
связываниями, связи упраздняются не сразу, а сначала сохраняются, чтобы
потом быть вновь восстановленными.

\noindent
Examples of \cd{\&optional} and \cd{\&rest} parameters:

\noindent
Примеры использования \cd{\&optional} и \cd{\&rest} параметров:

\begin{lisp}
((lambda (a b) (+ a (* b 3))) 4 5) \EV\ 19 \\
((lambda (a \cd{\&optional} (b 2)) (+ a (* b 3))) 4 5) \EV\ 19 \\
((lambda (a \cd{\&optional} (b 2)) (+ a (* b 3))) 4) \EV\ 10 \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x))) \\*
~~~\EV\ (2 {\false} 3 {\false} {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6) \\*
~~~\EV\ (6 t 3 {\false} {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3) \\*
~~~\EV\ (6 t 3 t {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3 8) \\*
~~~\EV\ (6 t 3 t (8)) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3 8 9 10 11) \\*
~~~\EV\ (6 t 3 t (8 9 10 11))
\end{lisp}
Examples of \cd{\&key} parameters:

\noindent
Примеры \cd{\&key} параметров:
\begin{lisp}
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2) \\*
~~~\EV\ (1 2 {\nil} {\nil}) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :c 6) \\*
~~~\EV\ (1 2 6 {\nil}) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :d 8) \\*
~~~\EV\ (1 2 {\nil} 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :c 6 :d 8) \\*
~~~\EV\ (1 2 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :d 8 :c 6) \\*
~~~\EV\ (1 2 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) :a 1 :d 8 :c 6) \\*
~~~\EV\ (:a 1 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) :a :b :c :d) \\
~~~\EV\ (:a :b :d {\nil})
\end{lisp}
Examples of mixtures:

\noindent 
Пример смешения всех:
\begin{lisp}
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1)   \EV\ (1 3 {\nil} 1 ())
\end{lisp}

\newpage%manual

\begin{lisp}
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 2)   \EV\ (1 2 {\nil} 1 ()) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~:c 7)   \EV\ (:c 7 {\nil} :c ()) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :c 7)   \EV\ (1 6 7 1 (:c 7)) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :d 8)   \EV\ (1 6 {\nil} 8 (:d 8)) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :d 8 :c 9 :d 10)   \EV\ (1 6 9 8 (:d 8 :c 9 :d 10))
\end{lisp}

All lambda-list keywords are permitted, but not terribly useful, in
lambda-expressions appearing explicitly as the first element of a
function-call form.  They are extremely
useful, however, in functions given global names by \cdf{defun}.

В лямбда выражении, которое стоит на первом месте в списке формы вызова функции
допускаются все ключевые символы лямбда списка, хотя и не очень то они полезны в
этом качестве.
Гораздо полезнее они используются в глобальных функциях, определенных с помощью
\cdf{defun}.

All symbols whose names begin with \cd{\&} are conventionally reserved
for use as lambda-list keywords and should not be used as variable names.
Implementations of Common Lisp are free to provide additional lambda-list
keywords.

Все символы, что начиаются на \cd{\&} обычно зарезервированы для использования в
качестве ключевых символов лямбда списка, и не должны использоваться для имен
переменных.
Реализации Common Lisp'а могут также предоставлять свои дополнительные ключевые
символы лямбда списка.

\begin{defun}[Constant]
lambda-list-keywords

The value of \cdf{lambda-list-keywords} is a list of all the lambda-list
keywords used in the implementation, including the additional ones
used only by \cdf{defmacro}.  This list must contain at least the symbols
\cd{\&optional}, \cd{\&rest}, \cd{\&key}, \cd{\&allow-other-keys}, \cd{\&aux}, \cd{\&body}, \cd{\&whole},
and \cd{\&environment}.

Значение \cdf{lambda-list-keywords} является списком всех ключевых символов
лямбда списка, используемых в данной реализации, включая те, которые
используются только в \cdf{defmacro}. Этот список должен содержать как минимум
символы \cd{\&optional}, \cd{\&rest}, \cd{\&key}, \cd{\&allow-other-keys}, \cd{\&aux}, \cd{\&body}, \cd{\&whole}
и \cd{\&environment}.
\end{defun}

As an example of the use of \cd{\&allow-other-keys} and \cd{:allow-other-keys},
consider a function that takes two keyword arguments of its own and also
accepts additional keyword arguments to be passed to \cdf{make-array}:

Вот пример использования \cd{\&allow-other-keys} и \cd{:allow-other-keys}, 
рассматривающий функция, которая принимает два своих именованных аргумента и
также дополнительные именованные аргументы, которые затем передаются
\cdf{make-array}:

\begin{lisp}
(defun array-of-strings (str dims \cd{\&rest} keyword-pairs \\*
~~~~~~~~~~~~~~~~~~~~~~~~~\cd{\&key} (start 0) end \cd{\&allow-other-keys}) \\*
~~(apply \#'make-array dims \\*
~~~~~~~~~:initial-element (subseq str start end) \\
~~~~~~~~~:allow-other-keys t \\*
~~~~~~~~~keyword-pairs))
\end{lisp}

This function takes a string and dimensioning information and returns
an array of the specified dimensions, each of whose elements is the
specified string.  However, \cd{:start} and \cd{:end} keyword arguments
may be used in the usual manner (see chapter~\ref{KSEQUE}) to specify
that a substring of the given string should be used.  In addition,
the presence of \cd{\&allow-other-keys} in the lambda-list indicates that the caller
may specify additional keyword arguments; the \cd{\&rest} argument provides
access to them.  These additional keyword arguments are fed to \cdf{make-array}.
Now, \cdf{make-array} normally does not allow the keywords \cd{:start}
and \cd{:end} to be used, and it would be an error to specify such
keyword arguments to \cdf{make-array}.  However, the presence in the
call to \cdf{make-array} of the keyword argument \cd{:allow-other-keys}
with a non-{\false} value causes any extraneous keyword arguments,
including \cd{:start} and \cd{:end}, to be acceptable and ignored.

Такая функция принимает строку и информацию о размерности и возвращает массив с
заданной размерностью, каждый из элементов которого равен заданной
строке. Именованные аргументы \cd{:start} и \cd{:end}, как обчыно (смотрите
главу~\ref{KSEQUE}), можно использовать для указания того, что должна
использоваться подстрока. Кроме того, использование \cd{\&allow-other-keys} в
лямбда списке указывает на то, что вызов этой функции может содержать
дополнительные именованные аргументы. Для доступа к ним используется \cd{\&rest}
аргумент. Эти дополнительные именованные аргументы передаются в
\cdf{make-array}. \cdf{make-array} не принимает именованные аргументы
\cd{:start} и \cd{:end}, и было бы ошибкой допустить их использование. Однако
указание \cd{:allow-other-keys} равное не-{\false} значению позволяет передавать
любые другие именованные аргументы, включая \cd{:start} и \cd{:end}, и они были
бы приняты и проигнорированы.

\begin{defun}[Constant]
lambda-parameters-limit

The value of \cdf{lambda-parameters-limit} is a positive integer that is
the upper exclusive bound on the number of distinct parameter names
that may appear in a single lambda-list.
This bound depends on the implementation
but will not be smaller than 50.
Implementors are encouraged to make this limit as large as practicable
without sacrificing performance.
See \cdf{call-arguments-limit}.

Значение \cdf{lambda-parameters-limir} является положительным целым, которое
невключительно является верхней границей допустимого количества имен параметров,
которые могут использоваться в лямбда списке.
Значение зависит от реализации, но не может быть менее 50.
Разработчики поощряются за создание данной границы как можно большей без потери
производительности. 
Смотрите \cdf{call-arguments-list}.
\end{defun}

\section{Top-Level Forms Формы верхнего уровня}

The standard way for the user to interact with a Common Lisp implementation is
via a \textit{read-eval-print loop}: the system repeatedly
reads a form from some input source (such as a keyboard or a disk file),
evaluates it, and then prints the value(s) to some output sink (such as a
display screen or another disk file).  Any form (evaluable
data object) is acceptable; however, certain special forms are specifically
designed to be convenient for use as \textit{top-level} forms,
rather than as forms embedded within other forms in the way
that \cd{(+ 3 4)}
is embedded within \cd{(if p (+ 3 4) 6)}.
These top-level special forms may be used to define globally named
functions, to define macros, to make declarations,
and to define global values for special variables.

Стандартный путь взаимодействия с реализацией Common Lisp через
\textit{read-eval-print loop} \textit{цикл чтение-выполнение-печать}: система
повторно читает форму из некоторого источника ввода (клавиатура, файл),
выполняет ее, затем выводит результат(ы) в некоторое устройство вывода (дисплей,
другой файл). Допускается любая форма (выполняемый объект данных), однако
существуют некоторые формы разработанные для удобного применения в качестве форм 
\textit{верхнего уровня}.
Эти специальные формы верхнего уровня могут использоваться для определения
глобальных функции (globally named functions), макросов, создания деклараций и
определения глобальных значений для специальных переменных.

\begin{obsolete}
It is not illegal to use these forms at other than top level,
but whether it is meaningful to do so depends on context.
Compilers, for example, may not recognize these forms properly
in other than top-level contexts.  (As a special case, however,
if a \cdf{progn} form appears at top level, then all forms
within that \cdf{progn} are considered by the compiler to be top-level
forms.)
\end{obsolete}

\newpage%manual

\begin{newer}
X3J13 voted in March 1989 \issue{DEFINING-MACROS-NON-TOP-LEVEL}
to clarify that, while defining forms normally appear at top level,
it is meaningful to place them in non-top-level contexts.
All defining forms that create functional objects from code appearing
as argument forms must ensure that
such argument forms refer to the enclosing lexical environment.
Compilers must handle defining forms properly in all situations,
not just top-level contexts.  However, certain
compile-time side effects of these defining forms are performed only
when the defining forms occur at top level (see section~\ref{COMPILER-SECTION}).
\end{newer}

\beforenoterule
\begin{incompatibility}
In MacLisp, a top-level \cdf{progn} is considered to
contain top-level forms only if the first form is \cd{(quote compile)}.
This odd marker is unnecessary in Common Lisp.
\end{incompatibility}
\afternoterule

Macros are usually defined by using the special form \cdf{defmacro}.
This facility is fairly complicated; it is described in chapter~\ref{MACROS}.

Макросы обычно определяются с помощью специальной формы \cdf{defmacro}.
Этот механизм достаточно сложен. Для подробностей смотрите главу~\ref{MACROS}.


\subsection{Defining Named Functions Определение именованных функций}

The \cdf{defun} special form is the usual means of defining named functions.

Специальная форма \cdf{defun} обычно обозначает определение именованных функций.

\begin{defmac}
defun name lambda-list <{declaration}* | doc-string> {\,form}*

Evaluating a \cdf{defun} form causes the symbol \textit{name} to be a global name
for the function specified by the lambda-expression

Выполнение формы \cdf{defun} приводит к тому, что символ \textit{name}
становиться глобальным именем для функции определенной лямбда выражением.

\begin{lisp}
(lambda \textit{lambda-list} \Mstar{\textit{declaration} {\Mor} \textit{doc-string}} \Mstar{\textit{\,form}})
\end{lisp}
defined in the lexical environment in which the \cdf{defun} form was
executed.  Because \cdf{defun} forms normally appear at top level, this is
normally the null lexical environment.

определеяется в лексическом окружении, в котором выполнялась форма
\cdf{defun}. А так как формы \cdf{defun} обычно выполняются на самом верхнем
уровне, лямбда выражение обычно выполняется в нулевом лексическом окружении.

\begin{newer}
X3J13 voted in March 1989 \issue{DEFINING-MACROS-NON-TOP-LEVEL}
to clarify that, while defining forms normally appear at top level,
it is meaningful to place them in non-top-level contexts;
\cdf{defun} must define the function
within the enclosing lexical environment, not within the null lexical
environment.
\end{newer}

\begin{newer}
X3J13 voted in March 1989 \issue{FUNCTION-NAME} to extend \cdf{defun}
to accept any function-name (a symbol or a list
whose \textit{car} is \cdf{setf}---see section~\ref{FUNCTION-NAME-SECTION})
as a \textit{name}.
Thus one may write
\begin{lisp}
(defun (setf cadr) ...)
\end{lisp}
to define a \cdf{setf}
expansion function for \cdf{cadr} 
(although it may be much more convenient to
use \cdf{defsetf} or \cdf{define-modify-macro}).

\cdf{defun} была расширена для того, чтобы могла принимать любое имя функции
(символ или список, car которого равен \cdf{setf}---смотрите
раздел~\ref{FUNCTION-NAME-SECTION}) в качестве \textit{name}.
Так теперь можно записать
\begin{lisp}
(defun (setf cadr) ...)
\end{lisp}
для определения \cdf{setf}-определения для функции \cdf{cadr}. Это более удобно,
чем использование \cdf{defsetf} или \cdf{define-modify-macro}.
\end{newer}

\newpage%manual

If the optional documentation string \textit{doc-string} is present,
then it is attached to the \textit{name}
as a documentation string of type \cdf{function}; see \cdf{documentation}.
If \textit{doc-string} is not
followed by a declaration, it may be
present only if at least one \textit{form} is also specified, as it is
otherwise taken to be a \textit{form}.
It is an error if more than one \textit{doc-string} is present.

Если указана необязательная строка документации \textit{doc-string}, тогда они
присоединяется к символу \textit{name} в качестве строки документации типа
\cdf{function}, смотрите \cdf{documentation}. Если после \textit{doc-string} нет
деклараций, строка документации может быть использована только при условии
существования хотя бы одной формы после нее, иначе она будет использована в
качестве \textit{form} функции. Указывать более чем одну \textit{doc-string} является ошибкой.

The \textit{forms} constitute the body of the defined function; they are
executed as an implicit \cdf{progn}.

\textit{forms} составляют тело определяемой функции. Они выполняются как неявный \cdf{progn}.

The body of the defined function is implicitly enclosed
in a \cdf{block} construct whose name is the same as the \textit{name}
of the function.  Therefore \cdf{return-from}
may be used to exit from the function.

Тело оперделяемой функции неявно заключается в конструкцию \cdf{block}, имя
которой совпадает с \textit{именем (name)} функции. Таким образом
\cdf{return-from} может быть использовано для выхода из функции.

Other implementation-dependent bookkeeping actions may be taken as well
by \cdf{defun}.  The \textit{name} is returned as the value of the \cdf{defun}
form.
For example:

Другие учетные действия специальные для некоторой реализации могут также
выполнятся в \cdf{defun}. \textit{name} возвращается в качестве значения формы
\cdf{defun}.
Например:

\begin{lisp}
(defun discriminant (a b c) \\
~~(declare (number a b c)) \\
~~"Compute the discriminant for a quadratic equation. \\
~~~Given a, b, and c, the value b{\Xcircumflex}2-4*a*c is calculated. \\
~~~The quadratic equation a*x{\Xcircumflex}2+b*x+c=0 has real, multiple, \\
~~~or complex roots depending on whether this calculated \\
~~~value is positive, zero, or negative, respectively." \\
~~(- (* b b) (* 4 a c))) \\
~~~\EV\ discriminant \\
~~~\textrm{and now} (discriminant 1 2/3 -2) \EV\ 76/9
\end{lisp}
\begin{new}%CORR
The documentation string in this example neglects to mention that the
coefficients \cdf{a}, \cdf{b}, and \cdf{c}
must be real for the discrimination criterion to hold.
Here is an improved version:
\begin{lisp}
~~"Compute the discriminant for a quadratic equation. \\
~~~Given a, b, and c, the value b{\Xcircumflex}2-4*a*c is calculated. \\
~~~If the coefficients a, b, and c are all real (that is, \\
~~~not complex), then the quadratic equation a*x{\Xcircumflex}2+b*x+c=0 \\
~~~has real, multiple, or complex roots depending on \\
~~~whether this calculated value is positive, zero, or \\
~~~negative, respectively."
\end{lisp}
\end{new}

It is permissible to use \cdf{defun} to redefine a function,
to install a corrected version of an incorrect definition, for example.
It is permissible to redefine a macro as a function.
It is an error to attempt to redefine the name of a special
form (see table~\ref{SPECIAL-FORM-TABLE}) as a function.

Пользователю разрешено использовать \cdf{defun} для переопределения функции, например, для
установки корректной версии некорректного определения.
Пользователю также разрешено переопределять макрос на функцию.
Однако является ошибкой, попытка переопределить имя специальной формы (смотрите
таблицу~\ref{SPECIAL-FORM-TABLE}) на функцию.
\end{defmac}

\subsection{Declaring Global Variables and Named Constants Определение
  глобальных переменных и констант}

The \cdf{defvar} and \cdf{defparameter} special forms are
the usual means of specifying globally defined variables.
The \cdf{defconstant} special form is used for defining named constants.

Специальные формы \cdf{defvar} и \cdf{defparameter} используются для определения
глобально определенных переменных.
Специальная форма \cdf{defconstant} используется для определения констант.

\begin{defmac}
defvar name [initial-value [documentation]] \\
defparameter name initial-value [documentation] \\
defconstant name initial-value [documentation]

\cdf{defvar} is the recommended way to declare the use
of a special variable in a program.
\cdf{defvar} рекомендуется для декларации использования в программе специальных
переменных.
\begin{lisp}
(defvar \textit{variable})
\end{lisp}
proclaims \textit{variable} to be \cdf{special} (see \cdf{proclaim}),
and may perform other system-dependent bookkeeping actions.

указывает на то, что переменная \textit{variable} будет специальной
(\cdf{special}) (смотрите \cdf{proclaim}), и может выполнять некоторые учетные
действия, зависимые от реализации.

\begin{newer}
X3J13 voted in June 1987 \issue{DEFVAR-INITIALIZATION} to clarify
that if no \textit{initial-value} form is provided, \cdf{defvar}
does not change the value of the \textit{variable};
if no \textit{initial-value} form is provided and the variable
has no value, \cdf{defvar} does not give it a value.
\end{newer}
If a second argument form is supplied,

Если для формы указан второй аргумент,
\begin{lisp}
(defvar \textit{variable} \textit{initial-value})
\end{lisp}
then \textit{variable} is initialized to the result of evaluating the form
\textit{initial-value} unless it already has a value.  The \textit{initial-value} form
is not evaluated unless it is used; this fact is useful if
evaluation of the \textit{initial-value} form does something
expensive like creating a large data structure.

тогда переменная \textit{variable}, если она еще не была проинициализирована,
инициализируется результатом выполнения формы \textit{initial-value}. Форма
\textit{initial-value} не выполняется, если в этом нет необходимости. Это
полезно, если форма \textit{initial-value} выполняет что-то
трудоемкое, как, например, создание большого структуры данных.

\begin{newer}
X3J13 voted in June 1987 \issue{DEFVAR-INIT-TIME} to clarify that
evaluation of the \textit{initial-value} and the initialization of the
variable occur, if at all, at the time the \cdf{defvar} form is executed,
and that the \textit{initial-value} form is evaluated
if and only if the \textit{variable} does not already have a value.
\end{newer}
The initialization is
performed by assignment and thus assigns a global value to the variable
unless there are currently special bindings of that variable.
Normally there should not be any such special bindings.

Инициализация производится присвоением глобального значения переменной, если
только не существует специального связывания этой переменной.
Обычно, такого связывания быть не должно. FIXME.

\cdf{defvar} also provides a good place to put a comment describing the
meaning of the variable, whereas an ordinary \cdf{special} proclamation
offers the
temptation to declare several variables at once and not have room to
describe them all.

\cdf{defvar} также предоставляют хорошее место для комметария описывающего
значение переменной, тогда как обычное \cd{special} указание соблазняет
задекларировать несколько переменных за один раз и не предоставляет возможности
прокомментировать их.

\begin{lisp}
(defvar *visible-windows* 0 \\
~~"Number of windows at least partially visible on the screen")
\end{lisp}

\cdf{defparameter} is similar to \cdf{defvar}, but \cdf{defparameter} requires
an \textit{initial-value} form, always evaluates the form, and assigns the
result to the variable.  The semantic distinction is that \cdf{defvar}
is intended to declare a variable changed by the program, whereas
\cdf{defparameter} is intended to declare a variable that is normally
constant but can be changed (possibly at run time), where such a change
is considered a
change \textit{to} the program.  \cdf{defparameter} therefore does not indicate
that the quantity \textit{never} changes; in particular, it does not license
the compiler to build assumptions about the value into programs being
compiled.

\cdf{defparameter} подобен \cdf{defvar}, но \cdf{defparameter} требует
обязательной формы \textit{initial-value}, и всего выполняет эту форму, и
присваивает результат переменной. Семантическое различие заключается в том, что
\cdf{defvar} предназначена декларировать переменную, изменяемую программой,
тогда как \cdf{defparameter} предназначена для декларации переменной, как
константы, которая может быть изменена (и во время выполнения программы), для
изменения поведения программы. Таким образом \cdf{defparameter} не указывает,
что количество никогда не изменяется, в частности, она не разрешает 
компилятору предположить то, что значение может быть вкомпилировано в
программу.

\cdf{defconstant} is like \cdf{defparameter} but \textit{does} assert that
the value of the variable \textit{name} is fixed and does license
the compiler to build assumptions about the value into programs being
compiled.  (However, if the compiler chooses to replace references
to the name of the constant by the value of the constant in code
to be compiled, perhaps in order to allow further optimization,
the compiler must take care that such ``copies'' appear to be \cdf{eql}
to the object that is the actual value of the constant.  For example,
the compiler may freely make copies of numbers but must exercise
care when the value is a list.)

\cdf{defconstant} похожа на \cdf{defparameter}, но в отличие от последней,
указывает, что значение переменной \textit{name} фиксировано и позволяет
компилятору предположить, что значение может быть вкомпилировано в
программу. Однако, если компилятор выбирает путь замены ссылок на имя константы
на значения этой константы в компилируемом коде для оптимизации, он должен
позаботиться о том, чтобы такие <<копии>> были эквивалентны \cdf{eql}
объектам-значениям констант. Например, компилятор может спокойно копировать
числа, но должен позаботиться об этом правиле, если значение константы
является списком.

It is an error if there are any special bindings
of the variable at the time the \cdf{defconstant} form
is executed (but implementations may or may not check for this).

Если для переменной на момент вызова формы \cdf{defconstant} существует
специальные связывания, то возникает ошибка (но реализации могут проверять, а
могут и не проверять этот факт).

Once a name has been declared by \cdf{defconstant} to be constant,
any further assignment to or binding of that special variable is an error.
This is the case for such system-supplied constants as \cdf{t} and
\cdf{most-positive-fixnum}.
A compiler may also choose to issue warnings about bindings of
the lexical variable of the same name.

Если имя задекларировано с помощью \cdf{defconstant} быть константой,
последующие присваивания и связывания данной специальной переменной будут
являются ошибкой. Это справедливо для системозависимых констант, например,
\cdf{t} и \cdf{most-positive-fixnum}.
Компилятор может также сигнализировать о связывании лексической переменной с
одинаковым именем.

\begin{new}
X3J13 voted in January 1989
\issue{DEFCONSTANT-SPECIAL}
to clarify the preceding paragraph by specifying
that it is an error to rebind constant symbols
as either lexical or special variables.
Consequently, a valid reference to a symbol declared with \cdf{defconstant}
always refers to its global value.
(Unfortunately, this violates the principle of referential transparency,
for one cannot always choose names for lexical variables without regard
to surrounding context.)
\end{new}

For any of these constructs,
the documentation should be a string.  The string is attached
to the name of the variable, parameter, or constant
under the \cdf{variable} documentation type; see the \cdf{documentation}
function.

Для любой из этих конструкций, документация должна быть строкой. Строка
присоединяется к имени переменной, параметра или константы как тип документации
\cdf{variable}, смотрите функцию \cdf{documentation}.

\begin{new}
X3J13 voted in March 1988
\issue{DEFVAR-DOCUMENTATION}
to clarify that the \textit{documentation-string}
is not evaluated but must appear as a literal string when the \cdf{defvar},
\cdf{defparameter}, or \cdf{defconstant} form is evaluated.

For example,
the form

Например, форма

\begin{lisp}
(defvar *avoid-registers* nil "Compilation control switch \#43")
\end{lisp}

is legitimate, but

законна, но

\begin{lisp}
(defvar *avoid-registers* nil \\*
~~(format nil "Compilation control switch \#{\Xtilde}D" \\*
~~~~~~~~~~(incf *compiler-switch-number*)))
\end{lisp}

is erroneous because the call to \cdf{format} is not a literal string.

ошибочна, так как вызов \cdf{format} не является дословно строкой.

(On the other hand, the form

С другой стороны, форма

\begin{lisp}
(defvar *avoid-registers* nil \\*
~~\#.(format nil "Compilation control switch \#{\Xtilde}D" \\*
~~~~~~~~~~~~(incf *compiler-switch-number*)))
\end{lisp}

might be used to accomplish the same purpose, because the call to
\cdf{format} is evaluated at \cdf{read} time; when the \cdf{defvar} form
is evaluated, only the result of the call to \cdf{format}, a string,
appears in the \cdf{defvar} form.)

Может использоваться для вышеназванной цели, потому что вызов \cdf{format}
выполняется на во время чтения кода \cdf{read}, когда форма \cdf{defvar}
выполняется, в ней указана строка, которая являлась результатом вызова
\cdf{format}.

\end{new}

These constructs are normally used only as top-level forms.  The
value returned by each of these constructs is the \textit{name} declared.

Эти конструкции обычно используются только как формы верхнего уровня. Значения
возвращаемые каждой из этих конструкций это задекларированные имена \textit{name}.
\end{defmac}

\subsection{Control of Time of Evaluation Контроль времени выполнения}

\begin{obsolete}
The \cdf{eval-when} special form allows pieces of code to
be executed only at compile time, only at load time, or
when interpreted but not compiled.  Its uses are relatively esoteric.

\begin{defspec}
eval-when ({situation}*) {\,form}*

The body of an \cdf{eval-when} form is processed as an implicit
\cdf{progn}, but only in the situations listed.  Each \textit{situation}
must be a symbol, either \cdf{compile}, \cdf{load}, or \cdf{eval}.

\cdf{eval} specifies that the interpreter should process the body.
\cdf{compile} specifies that the compiler should evaluate the body
at compile time in the compilation context.
\cdf{load} specifies that the compiler should arrange to evaluate
the forms in the body when the compiled file containing the
\cdf{eval-when} form is loaded.

The \cdf{eval-when} construct may be more precisely understood in terms
of a model of how the compiler processes forms in a file to
be compiled.  Successive forms are read from the file using the
function \cdf{read}.
These top-level forms are normally processed in what we shall call
\textit{not-compile-time} mode.  There is another mode called \textit{compile-time-too}
mode.  The \cdf{eval-when} special form controls which of these two
modes to use.

Every form is processed as follows:
\begin{itemize}
\item
If the form is an \cdf{eval-when} form:
\begin{itemize}
\item
If the situation \cdf{load} is specified:
\begin{itemize}
\item
If the situation \cdf{compile} is specified, \textit{or} if the
current processing mode is \textit{compile-time-too} and the situation \cdf{eval}
is specified, then process each of the forms in the body
in \textit{compile-time-too} mode.

\item
Otherwise, process each of the forms in the body in \textit{not-compile-time} mode.
\end{itemize}

\item
If the situation \cdf{load} is not specified:
\begin{itemize}
\item
If the situation \cdf{compile} is specified, \textit{or} if the
current processing mode is \textit{compile-time-too} and the situation \cdf{eval}
is specified, then evaluate each of the forms in the body
in the compiler's executing environment.

\item
Otherwise, ignore the \cdf{eval-when} form entirely.
\end{itemize}
\end{itemize}

\item
If the form is not an \cdf{eval-when} form, then do two things.
First, if the current processing mode is \textit{compile-time-too} mode,
evaluate the form in the compiler's executing environment.
Second, perform normal compiler processing of the form
(compiling functions defined by \cdf{defun} forms, and so on).
\end{itemize}

One example of the use of \cdf{eval-when} is that
if the compiler is to be able to properly read a file
that uses user-defined reader macro characters,
it is necessary to write
\begin{lisp}
(eval-when (compile load eval) \\
~~(set-macro-character \#{\Xbackslash}\$ \#'(lambda (stream char) \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(declare (ignore char)) \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(list 'dollar (read stream)))))
\end{lisp}
This causes the call to \cdf{set-macro-character} to be executed
in the compiler's execution environment, thereby modifying its
reader syntax table.
\end{defspec}
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989 \issue{EVAL-WHEN-NON-TOP-LEVEL} to
completely redesign the \cdf{eval-when} construct to solve some problems
concerning its treatment in other than top-level contexts.
The new definition is upward compatible with the old definition,
but the old keywords are deprecated.

\cdf{eval-when} была переработан для разрешения некоторых проблем, касательно ее
использования в отличных от контекста верхнего уровня. Новое определение
совместимо со старым, но старые ключевые символы были упразднены.

\begin{defspec}
eval-when ({situation}*) {\,form}*

  The body of an \cdf{eval-when} form is processed as an implicit \cdf{progn}, but
  only in the situations listed.  Each \textit{situation} must be a symbol,
  either \cd{:compile-toplevel},
  \cd{:load-toplevel}, or \cd{:execute}.

  Тело формы \cdf{eval-when} выполняется как неявный \cdf{progn}, но только в
  ниже перечисленных ситуациях. Каждая ситуация \textit{situatuon} должна быть
  одним символов, \cd{:compile-toplevel}, \cd{:load-toplevel} или \cd{:execute}.

  The use of \cd{:compile-toplevel} and \cd{:load-toplevel}
  controls whether and when processing
  occurs for top-level forms. The use of \cd{:execute} controls whether
  processing occurs for non-top-level forms.

  Использование \cd{:compile-toplevel} и \cd{:load-toplevel} контролирует, что и
  когда выполняется для форм верхнего уровня. Использование \cd{:execute}
  контролирует будет ли производится выполнения форм не верхнего уровня.

  The \cdf{eval-when} construct may be more precisely understood in terms of
  a model of how the file compiler, \cdf{compile-file}, processes forms in a
  file to be compiled.

  Конструкция \cdf{eval-when} может быть более понятна в терминах модели того,
  как компилятор файлов, \cdf{compile-file}, выполняет формы в файле для
  компиляции.

  Successive forms are read from the file by the file compiler using 
  \cdf{read}. These top-level forms are normally processed in what we call
  ``not-compile-time'' mode. There is one other mode, called 
  ``compile-time-too'' mode, which can come into play for top-level
  forms. The \cdf{eval-when} special form is used to annotate a program
  in a way that allows the program doing the processing to select
  the appropriate mode.

  Формы следующие друг за другом читаются из файла с помощью компилятора файла
  используя \cdf{read}. Эти формы верхнего уровня обычно обрабатываются в том,
  что мы называем режим <<времени некомпиляции (not-compile-time
  mode)>>. Существует и другой режим, называемый режим <<времени-компиляции
  (compile-time-too mode)>>, которые вступает в игру для форм верхнего
  уровня. Специальная форма \cdf{eval-when} используется для аннотации программы
  таким образом, чтобы предоставить программе, осуществлять выбор режима.

  Processing of top-level forms in the file compiler works as follows:

  Обработка форм верхнего уровня в компиляторе файла работает так, как
  рассказано ниже:

\begin{itemize}
   \item If the form is a macro call, it is expanded and the result is
     processed as a top-level form in the same processing mode
     (compile-time-too or not-compile-time).

   \item Если форма является макровызовом, она разворачивается и результат
     обрабатывается, как форма верхнего уровня в том же режиме обработки
     (времени-компиляции или времени-некомпиляции, (compile-time-too или not-compile-time).

   \item If the form is a \cdf{progn} (or \cdf{locally} \issue{LOCALLY-TOP-LEVEL})
     form, each of its body forms is
     sequentially processed as top-level forms in the same processing
     mode.

   \item Если форма \cdf{progn} (или \cdf{locally}), каждая из форм из их тел
     обрабатываются, как формы верхнего уровня в том же режиме обработки.

   \item If the form is a \cdf{compiler-let}, \cdf{macrolet},
     or \cdf{symbol-macrolet},
     the file compiler makes the appropriate bindings and recursively
     processes the body forms as an implicit top-level \cdf{progn} with those 
     bindings in effect, in the same processing mode.

   \item Если форма \cdf{compiler-let}, \cdf{macrolet} или
     \cdf{symbol-macrolet}, компилятор файла создает соотвествующие связывания и
     рекурсивно обрабатывает тела форм, как неявный \cdf{progn} верхнего уровня
     в контексте установленных связей в том же режиме обработки.

   \item If the form is an \cdf{eval-when} form, it is handled according to
     the following table:
     \begin{flushleft}
     \begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}c@{}cccl@{}}
     LT&CT&EX&CTTM&Action \\ \hlinesp
       yes & yes &--   & --  &    process body in compile-time-too mode \\
       yes & no  &yes  & yes &    process body in compile-time-too mode \\
       yes & no  &--   & no  &    process body in not-compile-time mode \\
       yes & no  &no   & --  &    process body in not-compile-time mode \\
       no  & yes &--   & --  &    evaluate body \\
       no  & no  &yes  & yes &    evaluate body \\
       no  & no  &--   & no  &    do nothing \\
       no  & no  &no   & --  &    do nothing \\
       \hline
     \end{tabular*}
     \end{flushleft}
     In the preceding table the column LT asks whether \cd{:load-toplevel}
     is one of the situations specified in the \cdf{eval-when} form;
     CT similarly refers to \cd{:compile-toplevel} and EX to \cd{:execute}.
     The column CTTM asks whether the \cdf{eval-when} form was encountered
     while in compile-time-too mode.  The phrase
     ``process body'' means to process the body as an implicit top-level
     \cdf{progn} in the indicated mode, and  ``evaluate body'' means to
     evaluate the body forms sequentially as an
     implicit \cdf{progn} in the dynamic execution context of the compiler and
     in the lexical environment in which the \cdf{eval-when} appears.

   \item Если форма \cdf{eval-when}, она обрабатывается в соответствии со
     следующей таблицей:
     \begin{flushleft}
     \begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}c@{}cccl@{}}
     LT&CT&EX&CTTM&Action \\ \hlinesp
       yes & yes &--   & --  &    process body in compile-time-too mode \\
       yes & no  &yes  & yes &    process body in compile-time-too mode \\
       yes & no  &--   & no  &    process body in not-compile-time mode \\
       yes & no  &no   & --  &    process body in not-compile-time mode \\
       no  & yes &--   & --  &    evaluate body \\
       no  & no  &yes  & yes &    evaluate body \\
       no  & no  &--   & no  &    do nothing \\
       no  & no  &no   & --  &    do nothing \\
       \hline
     \end{tabular*}
     \end{flushleft}
     В этой таблице столбец LT спрашивает присутствует ли \cd{:load-toplevel} в
     ситуациях указанных в форме \cdf{eval-when}.
     CT соответственно указывает на \cd{:compile-toplevel} и EX на
     \cd{:execute}. Столбец CTTM спрашивает встречается ли форма \cdf{eval-when}
     в режиме времени-компиляции. Фраза <<обработка тела>> означает обработку
     последовательно форм тела, как неявного \cdf{progn} верхнего уровня в
     указанном режиме, и <<выполнение тела>> означает выполнение форм тела
     последовательно, как неявный \cdf{progn} в динамическом контексте
     выполнения компилятора и в лексическом окружении, в котором встретилась \cdf{eval-when}.

   \item Otherwise, the form is a top-level form that is not one of the
     special cases.  If in compile-time-too mode, the compiler first
     evaluates the form and then performs normal compiler processing
     on it.  If in not-compile-time mode, only normal compiler
     processing is performed (see section~\ref{COMPILER-SECTION}).
     Any subforms are treated as non-top-level forms.

   \item В противном случае, форма верхнего уровня, которая не представлена в
     специальных случаях. Если в режиме времени-компиляции, компилятор сначала
     выполняет форму и затем выполняет обычную обработку компилятором. Если
     установлен режим времени-некомпиляции, выполняется только обычная обработка
     компилятором (смотрите раздел~\ref{COMPILER-SECTION}).
     Любые подформы обрабатываются как формы не верхнего уровня.
\end{itemize}

  Note that top-level forms are guaranteed to be processed in the order
  in which they textually appear in the file, and that each top-level
  form read by the compiler is processed before the next is read.
  However, the order of processing (including, in particular, macro
  expansion) of subforms that are not top-level forms is unspecified.

  Следует отметить, что формы верхнего уровня обрабатываются гарантированно в
  порядке, в котором они текстово представлены в файле, и каждая форма верхнего
  уровня прочтенная компилятором обрабатывается перед тем, как следующая будет
  прочтена.
  Однако, порядок обработки (включая, в частности, раскрытие макросов) подформ,
  которые не являются формами верхнего уровня, не определен.

  For an \cdf{eval-when} form that is not a top-level form in the file compiler
  (that is, either in the interpreter, in \cdf{compile}, or in the file
  compiler but not at top level), if the \cd{:execute} situation is specified,
  its body is treated as an implicit \cdf{progn}.  Otherwise, the body
  is ignored and the \cdf{eval-when} form has the value \cdf{nil}.

  Для формы \cdf{eval-when}, которая не является формой верхнего уровня в
  компиляторе файлов (то есть либо в интерпретаторе, либо \cdf{compile}, либо в
  компиляторе файлов, но не на верхнем уровне), если указана ситуация
  \cd{:execute}, тело формы обрабатывается как неявный \cdf{progn}. В противном
  случае, тело игнорируется и форма \cdf{eval-when} имеет значение \cdf{nil}.

  For the sake of backward compatibility,
  a \textit{situation} may also be \cdf{compile}, \cdf{load}, or \cdf{eval}.
  Within a top-level \cdf{eval-when} form
  these have the same meaning as \cd{:compile-toplevel}, \cd{:load-toplevel},
  and \cd{:execute}, respectively; but their effect is undefined when used
  in an \cdf{eval-when} form that is not at top level.

  Для сохранения обратной совместимости, \textit{situation} может также быть
  \cdf{compile}, \cdf{load} или \cdf{eval}.
  Внутри формы верхнего уровня \cdf{eval-when}, они имеют значения
  \cd{:compile-toplevel}, \cd{:load-toplevel} и \cd{:execute} соответственно.
  Однако их поведение не определено при использовании в \cdf{eval-when} не
  верхнего уровня.

  The following effects are logical consequences of the preceding specification:

  Следующие правила являются логическим продолжением предыдущих определений:

  \begin{itemize}
   \item It is never the case that the execution of a single \cdf{eval-when}
     expression will execute the body code more than once.

   \item Никогда не случится так, что выполнение одного \cdf{eval-when}
     выражения приведет к выполнению тела более чем один раз.

   \item The old keyword \cdf{eval} was a misnomer because execution of
     the body need not be done by \cdf{eval}.  For example, when the
     function definition
     \begin{lisp}
     (defun foo () (eval-when (:execute) (print 'foo)))
     \end{lisp}
     is compiled
     the call to \cdf{print} should be compiled, not evaluated at compile time.

   \item Старый ключевой символ \cd{eval} был неправильно использован, потому
     что выполнение тела не нуждается в \cd{eval}. Например, когда определение
     функции
     \begin{lisp}
     (defun foo () (eval-when (:execute) (print 'foo)))
     \end{lisp}
     скомпилируется
     вызов \cdf{print} должен быть скомпилирован, а не выполнен во время
     компиляции.

   \item Macros intended for use in top-level forms should arrange for all
     side-effects to be done by the forms in the macro expansion.
     The macro-expander itself should not perform the side-effects.

\begin{lisp}
(defmacro foo () \\*
~~(really-foo)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;{\rm Wrong}\\*
~~{\Xbq}(really-foo)) \\
\\
(defmacro foo () \\*
~~{\Xbq}(eval-when (:compile-toplevel \\*
~~~~~~~~~~~~~~~:load-toplevel :execute)~~~~~;{\rm Right} \\*
~~~~(really-foo)))
\end{lisp}

     Adherence to this convention will mean that such macros will behave
     intuitively when called in non-top-level positions.   

   \item Макросы, предназначенные для использования в качестве форм верхнего
     уровня, должны контролировать все побочные эффекты, которые будут сделаны
     формами в процессе развертывания.
     Разворачиватель макроса сам по себе не должен порождать никаких побочных
     эффектов.
     
\begin{lisp}
(defmacro foo () \\*
~~(really-foo)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;{\rm Wrong}\\*
~~{\Xbq}(really-foo)) \\
\\
(defmacro foo () \\*
~~{\Xbq}(eval-when (:compile-toplevel \\*
~~~~~~~~~~~~~~~:load-toplevel :execute)~~~~~;{\rm Right} \\*
~~~~(really-foo)))
\end{lisp}
     Соблюдение этого правила будет значит, что такие макросы будут вести себя
     интуитивно понятно при вызовах в формах не верхнего уровня.

   \item Placing a variable binding around an \cdf{eval-when}
     reliably captures the
     binding because the ``compile-time-too'' mode cannot occur (because 
     the \cdf{eval-when} could not be a top-level form).
     For example,
\begin{lisp}
(let ((x 3)) \\*
~~(eval-when (:compile-toplevel :load-toplevel :execute) \\*
~~~~(print x)))
\end{lisp}
will print 3 at execution (that is, load) time
     and will not print anything at
     compile time.  This is important so that expansions of \cdf{defun} and 
     \cdf{defmacro} can be done in terms of \cdf{eval-when}
     and can correctly capture the lexical environment.
     For example, an implementation might expand a \cdf{defun} form such as
\begin{lisp}
(defun bar (x) (defun foo () (+ x 3)))
\end{lisp}
into
\begin{lisp}
(progn (eval-when (:compile-toplevel) \\*
~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~(setf (symbol-function 'bar) \\*
~~~~~~~~~~~~~~~\#'(lambda (x) \\*
~~~~~~~~~~~~~~~~~~~(progn (eval-when (:compile-toplevel)  \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(compiler::notice-function 'foo \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'())) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
\end{lisp}
     which by the preceding rules would be treated the same as
\begin{lisp}
(progn (eval-when (:compile-toplevel) \\*
~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~(setf (symbol-function 'bar) \\*
~~~~~~~~~~~~~~~\#'(lambda (x) \\*
~~~~~~~~~~~~~~~~~~~(progn (eval-when (:load-toplevel :execute) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
\end{lisp}

  \item Расположение связывания переменной окруженной \cdf{eval-when}
    захватывает связывание, потому что режим <<время-компиляции>> не может
    случиться (потому что \cdf{eval-when} не может быть формой верхнего уровня)
\begin{lisp}
(let ((x 3)) \\*
~~(eval-when (:compile-toplevel :load-toplevel :execute) \\*
~~~~(print x)))
\end{lisp}
выведет 3 во время выполнения (в данном случае загрузки) и не будет ничего
выводить во время компиляции. Разворачивание \cdf{defun} и \cdf{defmacro} может
быть выполнено в контексте \cdf{eval-when} и могут корректно захватывать
лесическое окружение.
Например, реализация может разворачивать форму \cdf{defun}, такую как:
\begin{lisp}
(defun bar (x) (defun foo () (+ x 3)))
\end{lisp}
в
\begin{lisp}
(progn (eval-when (:compile-toplevel) \\*
~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~(setf (symbol-function 'bar) \\*
~~~~~~~~~~~~~~~\#'(lambda (x) \\*
~~~~~~~~~~~~~~~~~~~(progn (eval-when (:compile-toplevel)  \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(compiler::notice-function 'foo \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'())) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
\end{lisp}
которая по предыдущим правилам будет обработана также, как и 
\begin{lisp}
(progn (eval-when (:compile-toplevel) \\*
~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~(setf (symbol-function 'bar) \\*
~~~~~~~~~~~~~~~\#'(lambda (x) \\*
~~~~~~~~~~~~~~~~~~~(progn (eval-when (:load-toplevel :execute) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
\end{lisp}

\end{itemize}

Here are some additional examples.

Вот несколько дополнительных примеров.
\begin{lisp} 
(let ((x 1)) \\*
~~(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~~~(setf (symbol-function 'foo1) \#'(lambda () x))))
\end{lisp}
 The \cdf{eval-when} in the preceding expression is not at top level,
       so only the \cd{:execute}
       keyword is considered.  At compile time, this has no effect.
       At load time (if the \cdf{let} is at top level), or at execution time
       (if the \cdf{let} is embedded in some other form which does not execute
       until later), this sets \cd{(symbol-function 'foo1)} to a function that
       returns \cd{1}.

\cdf{eval-when} в предыдущем выражении не является формой верхнего уровня, таким
образом только ключевой символ \cd{:execute} берется во внимаение. В время
компиляции, это не будет иметь эффекта. В время загрузки (если \cdf{let} форма
верхнего уровня) или во время выполнения (если форма \cdf{let} вложена в
какую-либо другую форму, которая еще не была выполнена), этот код установит
в \cd{(symbol-function 'foo1)} функцию которая возвращает \cd{1}.

\begin{lisp}
(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~(let ((x 2)) \\*
~~~~(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~~~~~(setf (symbol-function 'foo2) \#'(lambda () x)))))
\end{lisp}

 If the preceding expression occurs at the top level of a file to be compiled,
       it has \textit{both} a compile time \textit{and} a load-time effect of setting
       \cd{(symbol-function 'foo2)} to a function that returns \cd{2}.

Если предыдущее выражение находилось на верхнем уровне в компилируемом файле, оно
будет выполнятся в обоих случаях, и во время компиляции и во время загрузки.
\begin{lisp}
(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~(setf (symbol-function 'foo3) \#'(lambda () 3)))
\end{lisp}
 If the preceding expression occurs at the top level of a file to be compiled,
       it has \textit{both} a compile time \textit{and}
       a load-time effect of setting the
       function cell of \cd{foo3} to a function that returns \cd{3}.

Если предыдущее выражение находилось на верхнем уровне в компилируемом файле, оно
будет выполняться в обоих случаях, и во время компиляции и во время загрузки.
\begin{lisp}
(eval-when (:compile-toplevel) \\*
~~(eval-when (:compile-toplevel)  \\*
~~~~(print 'foo4)))
\end{lisp}
  The preceding expression always does nothing; it simply returns \cdf{nil}.

Предыдущее выражение ничего не делает, оно просто возвращает \cdf{nil}.

\begin{lisp}
(eval-when (:compile-toplevel)  \\*
~~(eval-when (:execute) \\*
~~~~(print 'foo5)))
\end{lisp}
  If the preceding form occurs at the top level of a file to be compiled,
       \cd{foo5} is
       printed at compile time. If this form occurs in a non-top-level
       position, nothing is printed at compile time. Regardless of context,
       nothing is ever printed at load time or execution time.

Если предыдущее выражение находилось на верхнем уровне в компилируемом файле,
\cd{foo5} будет выведено во время компиляции. Если эта форма была не на верхнем
уровне, ничего не будет выведено во время компиляции. Вне зависимости от 
контекста, ничего не будет выведено во время загрузки или выполнения.

\begin{lisp}
(eval-when (:execute :load-toplevel) \\*
~~(eval-when (:compile-toplevel) \\*
~~~~(print 'foo6)))
\end{lisp}

    If the preceding form occurs at the top level of a file to be compiled,
       \cd{foo6} is
       printed at compile time.  If this form occurs in a non-top-level
       position, nothing is printed at compile time. Regardless of context,
       nothing is ever printed at load time or execution time.

Если предыдущая форма находилась на верхнем уровне в компилируемом файле,
\cd{foo6} будет выведено во время компиляции. Если форма была не на верхнем
уровне, ничего не будет выведено во время компиляции. Вне зависимости от
контекста, ничего не будет выведение во время загрузки или выполнения кода.
\end{defspec}
\end{newer}