<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Логические операторы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1833--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmch7.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html#tailclmse33.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse34.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse34.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">6.4   </span> <a 
href="clm.html#QQ2-45-420" id="x45-4120006.4">Логические
операторы</a></h3>
<!--l. 1835--><p class="noindent" >Common Lisp содержит три логических оператора для булевых значений:
<tt><a 
href="#x45-413002r49">and</a></tt>, <tt><a 
href="#x45-420002r50">or</a></tt> и <tt><a 
href="#x45-412002r48">not</a></tt> (и, или, не, соответственно). <tt><a 
href="#x45-413002r49">and</a></tt> и <tt><a 
href="#x45-420002r50">or</a></tt> являются управляющими
структурами, потому что их аргументы вычисляются в зависимости от
условия. Функции <tt><a 
href="#x45-412002r48">not</a></tt> необходимо инвертировать её один аргумент, поэтому
она может быть простой функцией.
<div class="defun">
<!--l. 1842--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx45-412001"></a><a 
 id="x45-412002r48"></a><b> not</b>  <i>x</i>
</div>
<!--l. 1844--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4130006.4" id="x45-4130006.4"></a></span>
<tt>
   <a 
href="#x45-412002r48">not</a></tt> возвращает <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt>, если <i>x</i> является <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, иначе возвращает <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. Таким
образом она инвертирует аргумент как булево значение.
<tt>
<!--l. 1849--><p class="indent" >   <a 
href="clmse32.html#x43-330002r22">null</a></tt> то же, что и <tt><a 
href="#x45-412002r48">not</a></tt>, обе функции включены для ясности. По
соглашению принято использовать <tt><a 
href="clmse32.html#x43-330002r22">null</a></tt>, когда надо проверить пустой ли
список, и <tt><a 
href="#x45-412002r48">not</a></tt>, когда надо инвертировать булево значение.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1855--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> and </b><a 
 id="dx45-413001"></a><a 
 id="x45-413002r49"></a> {form}*
   <br>
<!--l. 1856--><p class="noindent" ></div>
<!--l. 1856--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4140006.4" id="x45-4140006.4"></a></span>
</div>
                                                                          

                                                                          
<tt>
<!--l. 1857--><p class="indent" >   (and <i>form1</i> <i>form2</i> ... )</tt> последовательно слева направо вычисляет
формы. Если какая-либо форма <i>formN</i> вычислилась в <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, тогда
немедленно возвращается значение <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> без выполнения оставшихся форм.
Если все формы кроме последней вычисляются в не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> значение, <tt><a 
href="#x45-413002r49">and</a></tt>
возвращает то, что вернула последняя форма. Таким образом, <tt><a 
href="#x45-413002r49">and</a></tt> может
использоваться, как для логических операций, где <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> обозначает ложь и
не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> значения истину, так и для условных выражений. Например:
<div class="lisp"><div class="tabbing">
(if (and (&#x003E;= n 0)
   <br>                                                  (&#x003C; n (length a-simple-vector))<br>
         (eq (elt a-simple-vector n) &#x2019;foo))<br>                 (princ &#x0022;Foo!&#x0022;))<br>
<!--l. 1871--><p class="noindent" ></div>
<!--l. 1871--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4150006.4" id="x45-4150006.4"></a></span>
<!--l. 1871--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4160006.4" id="x45-4160006.4"></a></span>
</div>
<!--l. 1872--><p class="indent" >   Выражение выше выводит <tt>Foo!</tt>, если <tt>n</tt>-ый элемент вектора <tt>a-simple-vector</tt>
является символом <tt>foo</tt>, проверяя при этом вхождения <tt>n</tt> в границы вектора
<tt>a-simple-vector</tt>. <tt><a 
href="clmse77.html#x96-1197002r365">elt</a></tt> не будет вызвано с аргументом <tt>n</tt> выходящим за
границы вектора, так как <tt><a 
href="#x45-413002r49">and</a></tt> гарантирует ленивую проверку аргументов
слева направо.
<!--l. 1878--><p class="indent" >   Специальная форма Lisp&#x2019;а <tt><a 
href="#x45-413002r49">and</a></tt> отличается тем, что в определённых
случаях вычисляет не все аргументы.
<!--l. 1881--><p class="indent" >   Запись предыдущего примера <div class="lisp"><div class="tabbing">
(and (&#x003E;= n 0)
   <br>                                                    (&#x003C; n (length a-simple-vector))<br>
     (eq (elt a-simple-vector n) &#x2019;foo)<br>                      (princ &#x0022;Foo!&#x0022;))<br>
<!--l. 1887--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1887--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4170006.4" id="x45-4170006.4"></a></span>
<!--l. 1887--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4180006.4" id="x45-4180006.4"></a></span>
</div>
<!--l. 1888--><p class="indent" >   будет выполнять ту же функцию. Разница в них только стилистическая.
Некоторые программисты никогда не используют в форме <tt><a 
href="#x45-413002r49">and</a></tt> выражения с
побочными эффектами, предпочитая для этих целей использовать <tt><a 
href="clmse133.html#x163-2394002r817">if</a></tt> или
<tt><a 
href="clmse133.html#x163-2395002r818">when</a></tt>.
<!--l. 1892--><p class="indent" >   Из общего определения можно сделать дедуктивный вывод о том, что
<tt>(and <i>x</i>)</tt> <span class="math"> ≡</span> <i>x</i>. Также <tt>(and)</tt> выполняется в <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt>, который тождественен этой
операции.
<!--l. 1896--><p class="indent" >   Можно определить <tt><a 
href="#x45-413002r49">and</a></tt> в терминах <tt><a 
href="clmse40.html#x52-624002r90">cond</a></tt> таким образом: <div class="lisp"><div class="tabbing">
(and <i>x</i> <i>y</i> <i>z</i> ... <i>w</i>) <span class="math"> ≡</span> (cond ((not <i>x</i>) <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>)
   <br>                                                                              ((not <i>y</i>) <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>)<br>
                           ((not <i>z</i>) <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>)<br>                                 <span class="math">…</span><br>
                           (<tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> <i>w</i>))<br>
<!--l. 1903--><p class="noindent" ></div>
<!--l. 1903--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4190006.4" id="x45-4190006.4"></a></span>
<!--l. 1903--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4200006.4" id="x45-4200006.4"></a></span>
</div>
<!--l. 1905--><p class="indent" >   Смотрите <tt>id</tt> и <tt><a 
href="clmse133.html#x163-2395002r818">when</a></tt>, которые иногда являются стилистически более
удобными, чем <tt><a 
href="#x45-413002r49">and</a></tt> в целях ветвления. Если необходимо проверить
истинность предиката для всех элементов списка или вектора (element 0
<i>and</i> element 1 <i>and</i> element 2 <i>and</i> <span class="math">…</span>), можно использовать функцию
<tt><a 
href="clmse78.html#x97-1214004r376">every</a></tt>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1913--><p class="indent" >   <div class="tabbing">
                                                                          

                                                                          
 <i>[Макрос]</i><b> or </b><a 
 id="dx45-420001"></a><a 
 id="x45-420002r50"></a> {form}*
   <br>
<!--l. 1914--><p class="noindent" ></div>
<!--l. 1914--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4210006.4" id="x45-4210006.4"></a></span>
</div>
<tt>
<!--l. 1915--><p class="indent" >   (or <i>form1</i> <i>form2</i> ... )</tt> последовательно выполняет каждую форму
слева направо. Если какая-либо непоследняя форма выполняется в что-либо
отличное от <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, <tt><a 
href="#x45-420002r50">or</a></tt> немедленно возвращает это не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> значение без
выполнения оставшихся форм. Если все формы кроме последней,
вычисляются в <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, <tt><a 
href="#x45-420002r50">or</a></tt> возвращает то, что вернула последняя форма. Таким
образом <tt><a 
href="#x45-420002r50">or</a></tt> может быть использована как для логических операций, в
который <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> обозначает ложь, и не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> истину, так и для условного
выполнения форм.
<!--l. 1924--><p class="indent" >   Специальная форма Lisp&#x2019;а <tt><a 
href="#x45-420002r50">or</a></tt> отличается тем, что в определённых
случаях вычисляет не все аргументы.
<!--l. 1927--><p class="indent" >   Из общего определения, можно сделать дедуктивный вывод о том, что <tt>(or
<i>x</i>)</tt> <span class="math"> ≡</span> <i>x</i>. Также, <tt>(or)</tt> выполняется в <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, который тождественен этой
операции.
<!--l. 1931--><p class="indent" >   Можно определить <tt><a 
href="#x45-420002r50">or</a></tt> в терминах <tt><a 
href="clmse40.html#x52-624002r90">cond</a></tt> таким образом: <div class="lisp"><div class="tabbing">
(or <i>x</i> <i>y</i> <i>z</i> ... <i>w</i>) <span class="math"> ≡</span> (cond (<i>x</i>) (<i>y</i>) (<i>z</i>) ... (<tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> <i>w</i>))
   <br>
<!--l. 1934--><p class="noindent" ></div>
<!--l. 1934--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4220006.4" id="x45-4220006.4"></a></span>
<!--l. 1934--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4230006.4" id="x45-4230006.4"></a></span>
</div>
                                                                          

                                                                          
<!--l. 1936--><p class="indent" >   Смотрите <tt>id</tt> и <tt><a 
href="clmse133.html#x163-2396002r819">unless</a></tt>, которые иногда являются стилистически более
удобными, чем <tt><a 
href="#x45-420002r50">or</a></tt> в целях ветвления. Если необходимо проверить истинность
предиката для всех элементов списка или вектора (element 0 <i>or</i> element 1 <i>or</i>
element 2 <i>or</i> <span class="math">…</span>), можно использовать функцию <tt><a 
href="clmse78.html#x97-1214002r375">some</a></tt>.
</div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
<!--l. 4401--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmch7.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html#tailclmse33.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse34.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse34.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse34.html"></a>   </div> </div> 
</body></html> 
