<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Логические операторы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-28 14:08:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 1677--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch7.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html#tailclmse33.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse34.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse34.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">6.4   </span> <a 
href="clm.html#QQ2-45-86" id="x45-790006.4">Логические операторы</a></h3>
<!--l. 1679--><p class="noindent" >Common Lisp содержит три логических оператора для булевых значений:
<a 
href="#x45-79004r49">and</a>, <a 
href="#x45-80002r50">or</a> и <a 
href="#x45-79002r48">not</a> (и, или, не, соответственно). <a 
href="#x45-79004r49">and</a> и <a 
href="#x45-80002r50">or</a> являются управляющими
структурами, потому что их аргументы вычисляются в зависимости от
условия. Функции <a 
href="#x45-79002r48">not</a> необходимо инвертировать её один аргумент, поэтому
она может быть простой функцией.
<div class=defun>
<!--l. 1686--><p class="noindent" ><i>[Функция]</i><a 
 id="dx45-79001"></a><a 
 id="x45-79002r48"></a><b> not</b>  <i>x</i>
<!--l. 1688--><p class="noindent" ><a 
href="#x45-79002r48">not</a> возвращает <a 
href="clmse31.html#x42-74004r19">t</a>, если <i>x</i> является <a 
href="clmse31.html#x42-74002r18">nil</a>, иначе возвращает <a 
href="clmse31.html#x42-74002r18">nil</a>. Таким образом
она инвертирует аргумент как булево значение.
<!--l. 1693--><p class="indent" >   <a 
href="clmse32.html#x43-77002r22">null</a> то же, что и <a 
href="#x45-79002r48">not</a>, обе функции включены для ясности. По соглашению
принято использовать <a 
href="clmse32.html#x43-77002r22">null</a>, когда надо проверить пустой ли список, и <a 
href="#x45-79002r48">not</a>,
когда надо инвертировать булево значение.
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Макрос]</i><b> and </b><a 
 id="dx45-79003"></a><a 
 id="x45-79004r49"></a> { form}*
</td></tr></table>
<!--l. 1700--><p class="indent" >
</div>
<!--l. 1700--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-800006.4" id="x45-800006.4"></a></span>
   (and <i>form1</i> <i>form2</i> ... ) последовательно слева направо вычисляет формы.
Если какая-либо форма <i>formN</i> вычислилась в <a 
href="clmse31.html#x42-74002r18">nil</a>, тогда немедленно
возвращается значение <a 
href="clmse31.html#x42-74002r18">nil</a> без выполнения оставшихся форм. Если все
формы кроме последней вычисляются в не-<a 
href="clmse31.html#x42-74002r18">nil</a> значение, <a 
href="#x45-79004r49">and</a> возвращает то,
                                                                          

                                                                          
что вернула последняя форма. Таким образом, <a 
href="#x45-79004r49">and</a> может использоваться,
как для логических операций, где <a 
href="clmse31.html#x42-74002r18">nil</a> обозначает ложь и не-<a 
href="clmse31.html#x42-74002r18">nil</a> значения
истину, так и для условных выражений. Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(if (and (&#x003E;= n 0)
</td></tr></table>
<!--l. 1711--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (&#x003C; n (length a-simple-vector))</td></tr></table>
<!--l. 1712--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (eq (elt a-simple-vector n) &#x2019;foo))</td></tr></table>
<!--l. 1713--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (princ &#x0022;Foo!&#x0022;))</td></tr></table>
<!--l. 1715--><p class="indent" >
</div>
</div>
<!--l. 1716--><p class="noindent" >Выражение выше выводит Foo!, если n-ый элемент вектора a-simple-vector
является символом foo, проверяя при этом вхождения n в границы вектора
a-simple-vector. <a 
href="clmse75.html#x94-195002r348">elt</a> не будет вызвано с аргументом n выходящим за границы
вектора, так как <a 
href="#x45-79004r49">and</a> гарантирует ленивую проверку аргументов слева
направо.
<!--l. 1722--><p class="indent" >   Специальная форма Lisp&#x2019;а <a 
href="#x45-79004r49">and</a> отличается тем, что в определенных
случаях вычисляет не все аргументы.
<!--l. 1725--><p class="indent" >   Запись предыдущего примера <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(and (&#x003E;= n 0)
</td></tr></table>
<!--l. 1727--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">     (&#x003C; n (length a-simple-vector))</td></tr></table>
<!--l. 1728--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">     (eq (elt a-simple-vector n) &#x2019;foo)</td></tr></table>
<!--l. 1729--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">     (princ &#x0022;Foo!&#x0022;))</td></tr></table>
<!--l. 1731--><p class="indent" >
</div>
</div>
<!--l. 1732--><p class="noindent" >будет выполнять ту же функцию. Разница в них только стилистическая.
Некоторые программисты никогда не используют в форме <a 
href="#x45-79004r49">and</a> выражения с
побочными эффектами, предпочитая для этих целей использовать <a 
href="clmse134.html#x165-338002r803">if</a> или
<a 
href="clmse134.html#x165-338004r804">when</a>.
<!--l. 1736--><p class="indent" >   Из общего определения можно сделать дедуктивный вывод о том, что
(and <i>x</i>) <span class="math"> ≡</span> <i>x</i>. Также (and) выполняется в <a 
href="clmse31.html#x42-74004r19">t</a>, который тождественен этой
операции.
                                                                          

                                                                          
<!--l. 1740--><p class="indent" >   Можно определить <a 
href="#x45-79004r49">and</a> в терминах <a 
href="clmse40.html#x52-109002r84">cond</a> таким образом: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:212;" 
class="tabbing">(and <i>x</i> <i>y</i> <i>z</i> ... <i>w</i>) <span class="math"> ≡</span> (cond </td><td  
class="tabbing">((not <i>x</i>) <a 
href="clmse31.html#x42-74002r18">nil</a>)
</td></tr></table>
<!--l. 1742--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:212;" 
class="tabbing">                                    </td><td  
class="tabbing">((not <i>y</i>) <a 
href="clmse31.html#x42-74002r18">nil</a>)</td></tr></table>
<!--l. 1743--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:212;" 
class="tabbing">                                    </td><td  
class="tabbing">((not <i>z</i>) <a 
href="clmse31.html#x42-74002r18">nil</a>)</td></tr></table>
<!--l. 1744--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:212;" 
class="tabbing">                                    </td><td  
class="tabbing"><span class="math">…</span></td></tr></table>
<!--l. 1745--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:212;" 
class="tabbing">                               </td><td  
class="tabbing">(<a 
href="clmse31.html#x42-74004r19">t</a> <i>w</i>))</td></tr></table>
<!--l. 1747--><p class="indent" >
</div>
</div>
<!--l. 1749--><p class="indent" >   Смотрите id и <a 
href="clmse134.html#x165-338004r804">when</a>, которые иногда являются стилистически более
удобными, чем <a 
href="#x45-79004r49">and</a> в целях ветвления. Если необходимо проверить
истинность предиката для всех элементов списка или вектора (element 0
<i>and</i> element 1 <i>and</i> element 2 <i>and</i> <span class="math">…</span>), можно использовать функцию
<a 
href="clmse76.html#x95-196010r359">every</a>.
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Макрос]</i><b> or </b><a 
 id="dx45-80001"></a><a 
 id="x45-80002r50"></a> { form}*
</td></tr></table>
<!--l. 1758--><p class="indent" >
</div>
<!--l. 1758--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-810006.4" id="x45-810006.4"></a></span>
   (or <i>form1</i> <i>form2</i> ... ) последовательно выполняет каждую форму слева
направо. Если какая-либо непоследняя форма выполняется в что-либо
отличное от <a 
href="clmse31.html#x42-74002r18">nil</a>, <a 
href="#x45-80002r50">or</a> немедленно возвращает это не-<a 
href="clmse31.html#x42-74002r18">nil</a> значение без выполнения
оставшихся форм. Если все формы кроме последней, вычисляются в <a 
href="clmse31.html#x42-74002r18">nil</a>,
<a 
href="#x45-80002r50">or</a> возвращает то, что вернула последняя форма. Таким образом <a 
href="#x45-80002r50">or</a>
может быть использована как для логических операций, в который <a 
href="clmse31.html#x42-74002r18">nil</a>
обозначает ложь, и не-<a 
href="clmse31.html#x42-74002r18">nil</a> истину, так и для условного выполнения
форм.
                                                                          

                                                                          
<!--l. 1768--><p class="indent" >   Специальная форма Lisp&#x2019;а <a 
href="#x45-80002r50">or</a> отличается тем, что в определенных случаях
вычисляет не все аргументы.
<!--l. 1771--><p class="indent" >   Из общего определения, можно сделать дедуктивный вывод о том, что (or
<i>x</i>) <span class="math"> ≡</span> <i>x</i>. Также, (or) выполняется в <a 
href="clmse31.html#x42-74002r18">nil</a>, который тождественен этой
операции.
<!--l. 1775--><p class="indent" >   Можно определить <a 
href="#x45-80002r50">or</a> в терминах <a 
href="clmse40.html#x52-109002r84">cond</a> таким образом: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(or <i>x</i> <i>y</i> <i>z</i> ... <i>w</i>) <span class="math"> ≡</span> (cond (<i>x</i>) (<i>y</i>) (<i>z</i>) ... (<a 
href="clmse31.html#x42-74004r19">t</a> <i>w</i>))
</td></tr></table>
<!--l. 1778--><p class="indent" >
</div>
</div>
<!--l. 1780--><p class="indent" >   Смотрите id и <a 
href="clmse134.html#x165-338006r805">unless</a>, которые иногда являются стилистически более
удобными, чем <a 
href="#x45-80002r50">or</a> в целях ветвления. Если необходимо проверить истинность
предиката для всех элементов списка или вектора (element 0 <i>or</i> element 1 <i>or</i>
element 2 <i>or</i> <span class="math">…</span>), можно использовать функцию <a 
href="clmse76.html#x95-196008r358">some</a>.
</div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
   <!--l. 4629--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch7.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html#tailclmse33.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse34.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse34.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 4629--><p class="indent" >   <a 
 id="tailclmse34.html"></a>  
</body></html> 
