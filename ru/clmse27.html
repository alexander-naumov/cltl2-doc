<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Подбираемый тип</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 1729--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="progs.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html#tailclmse26.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse27.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="dtspec.html#clmse27.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">4.10   </span> <a 
href="clm.html#QQ2-36-219" id="x36-2120004.10">Подбираемый
тип</a></h3>
<!--l. 1731--><p class="noindent" >Common Lisp содержит функции, с помощью которых программы смогут
установить, как данная реализация будет <i>подбирать</i> тип, когда создаёт
массив для некого заданного типа элементов, или комплексное число с
заданными типами частей.
<div class="defun">
<!--l. 1735--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx36-212001"></a><a 
 id="x36-212002r9"></a> <b>upgraded-array-element-type</b>  <i>type</i>
</div>
<!--l. 1738--><p class="indent" >   Функция возвращает спецификатор типа, наиболее близкий к указанному,
как если бы последний использовался в функции <tt><a 
href="symbols.html#x185-2605533r533">make-array</a></tt>. Результат
обязательно является супертипом для заданного <i>type</i>. Кроме того, если тип <i>A</i>
является подтипом <i>B</i>, тогда <tt>(upgraded-array-element-type <i>A</i>)</tt> является
подтипом <tt>(upgraded-array-element-type <i>B</i>)</tt>.
<!--l. 1745--><p class="indent" >   Способ того, как обновляется тип элемента массива, зависит только от
запрашиваемого типа элемента и не зависит от других свойств массива, таких
как размер, ранг, расширяемость, наличия или отсутствия указателя
заполнения, или относительности._______________________________________<div class="rationale">
<!--l. 1750--><p class="noindent" ><b>Обоснование:</b> If upgrading were allowed to depend on any of these properties, all of
which can be referred to, directly or indirectly, in the language of type speciﬁers, then it
would not be possible to displace an array in a consistent and dependable manner to
another array created with the same <tt>:element-type</tt> argument but diﬀering in one of
these properties.
</div>___________________________________________________________________________________________________________
<!--l. 1760--><p class="indent" >     Следует отметить, что <tt><a 
href="symbols.html#x185-2605911r911">upgraded-array-element-type</a></tt> может быть
определён, как <div class="lisp"><div class="tabbing">
(defun upgraded-array-element-type (type)
     <br>                    (array-element-type (make-array 0 :element-type type)))<br>
                                                                          

                                                                          
<!--l. 1765--><p class="noindent" ></div>
<!--l. 1765--><p class="noindent" ><span class="paragraphHead"><a 
href="#x36-2130004.10" id="x36-2130004.10"></a></span>
<!--l. 1765--><p class="noindent" ><span class="paragraphHead"><a 
href="#x36-2140004.10" id="x36-2140004.10"></a></span>
</div>
<!--l. 1766--><p class="indent" >   но, это определение и имеет недостаток в виде создания и удаления
массива. Умная реализация конечно может имитировать создание для таких
случаев.
</div>
<div class="defun">
<!--l. 1771--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx36-214001"></a><a 
 id="x36-214002r10"></a> <b>upgraded-complex-part-type</b>  <i>type</i>
</div>
<!--l. 1774--><p class="indent" >   Функция возвращает спецификатор типа, указывающий на тип наиболее
приближенной для указанного типа <i>type</i> для частей комплексного числа.
Результат обязательно должен быть супертипом для переданного <i>type</i>. Кроме
того, если тип <i>A</i> является подтипом <i>B</i>, тогда <tt>(upgraded-complex-part-type
<i>A</i>)</tt> является подтипом <tt>(upgraded-complex-part-type <i>B</i>)</tt>.
</div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
<!--l. 1276--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="progs.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html#tailclmse26.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse27.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="dtspec.html#clmse27.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse27.html"></a>   </div> </div> 
</body></html> 
