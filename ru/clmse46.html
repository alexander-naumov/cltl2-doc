<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Определение макроса</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 16:17:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 1199--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse47.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="macro.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="macro.html#tailmacro.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse46.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="macro.html#clmse46.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">8.1   </span> <a 
href="clm.html#QQ2-59-716" id="x59-7070008.1">Определение
макроса</a></h3>
<!--l. 1201--><p class="noindent" >Функция <tt><a 
href="symbols.html#x187-2604528r528">macro-function</a></tt> определяет, является ли данный символ именем
макроса. Конструкция <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt> предоставляет удобный способ определить
новый макрос.
<div class="defun">
<!--l. 1205--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx59-707001"></a><a 
 id="x59-707002r123"></a> <b>macro-function</b>  <i>symbol</i> <b>&#x0026;optional</b>  <i>env</i>
</div>
<!--l. 1208--><p class="indent" >   Первый аргумент должен быть символом. Если символ содержит
определение функции, то есть определение макроса, локально созданное в
окружении <i>env</i> с помощью <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> или глобально созданное с помощью
<tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt>, тогда возвращается функция раскрытия (функция двух
аргументов, первый форма макровызова и второй — окружение). Если
символ не содержит определение функции, или это определение обычной
функции или это специальная форма, но не макрос, тогда возвращается <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>.
Наилучший способ вызвать функцию раскрытия использовать <tt><a 
href="symbols.html#x187-2604529r529">macroexpand</a></tt>
или <tt><a 
href="symbols.html#x187-2604530r530">macroexpand-1</a></tt>.
<!--l. 1218--><p class="indent" >   Возможно такое, что и <tt><a 
href="symbols.html#x187-2604528r528">macro-function</a></tt>, и <tt><a 
href="symbols.html#x187-2604813r813">special-operator-p</a></tt> обе
возвращают истину для одного заданного символа. Так происходит, потому
что реализация может для увеличения производительности реализовывать
любой макрос, как специальную форму. С другой стороны, определения
                                                                          

                                                                          
макросов должны быть доступны для использования программами, которые
понимают только стандартные специальные формы, перечисленные в
таблице <a 
href="clmse28.html#x38-2190011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>.
<tt>
<!--l. 1226--><p class="indent" >   <a 
href="symbols.html#x187-2604776r776">setf</a></tt> может быть использована с <tt><a 
href="symbols.html#x187-2604528r528">macro-function</a></tt> для установки в символ
глобального определения макроса: <div class="lisp"><div class="tabbing">
(setf (macro-function <i>symbol</i>) <i>fn</i>)
   <br>
<!--l. 1230--><p class="noindent" ></div>
<!--l. 1230--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7080008.1" id="x59-7080008.1"></a></span>
<!--l. 1230--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7090008.1" id="x59-7090008.1"></a></span>
</div>
<!--l. 1231--><p class="indent" >   Устанавливаемое значение должно быть функцией, которая принимает
два аргументы, список макровызова и окружение, и вычислять раскрытие
этого макровызова. Выполнение этой операции указывает на то, что символ
будет содержать <i>только</i> это определение макроса в качестве определения
глобальной функции. Предыдущее определение функции или макроса
утрачивается. С помощью <tt><a 
href="symbols.html#x187-2604776r776">setf</a></tt> невозможно установить локальное
определение макроса. При использовании <tt><a 
href="symbols.html#x187-2604776r776">setf</a></tt> указание второго параметра
(окружение) является ошибкой. Переопределение специальной формы также
является ошибкой.
<!--l. 1240--><p class="indent" >   Смотрите также <tt><a 
href="symbols.html#x187-2604235r235">compiler-macro-function</a></tt>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1244--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>defmacro</b> <a 
 id="dx59-709001"></a><a 
 id="x59-709002r124"></a> name lambda-list [[{declaration}* | doc-string]] {form}*
   <br>
                                                                          

                                                                          
<!--l. 1245--><p class="noindent" ></div>
<!--l. 1245--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7100008.1" id="x59-7100008.1"></a></span>
</div>
<tt>
<!--l. 1246--><p class="indent" >   <a 
href="symbols.html#x187-2604284r284">defmacro</a></tt> является макросом определяющим макросы, которые
преобразуют формы макровызовов. <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt> имеет почти такой же
синтаксис, как и <tt><a 
href="symbols.html#x187-2604291r291">defun</a></tt>: <i>name</i> является символом, для которого создаётся
макрос, <i>lambda-list</i> похож на список параметров лямбда-выражения и <i>form</i>
содержит тело функции раскрытия. Конструкция <i>defmacro</i> устанавливает
функцию раскрытия, как глобальное определение макроса для символа
<i>name</i>. FIXME
<!--l. 1256--><p class="indent" >   Форма обычно используется на верхнем уровне, но её также можно
использовать на неверхнем уровне. Таким образом, <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt> должна
определять функцию раскрытия макроса в некотором лексическом, а не
глобальном окружении.
<!--l. 1261--><p class="indent" >   Тело функции раскрытия, определяемое с помощью <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt>, неявно
оборачивается в конструкцию <tt><a 
href="symbols.html#x187-2604128r128">block</a></tt>, имя которой совпадает с именем <tt>name</tt>,
определяемого макроса. Таким образом для выхода из функции может
использоваться <tt><a 
href="symbols.html#x187-2604750r750">return-from</a></tt>.
<!--l. 1266--><p class="indent" >   Форма <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt> возвращает в качестве значение <i>name</i>.
<!--l. 1268--><p class="indent" >   Если мы рассмотрим макровызов, как список содержащий имя
функции и некоторые формы аргументов, то механизм заключается в
передаче в функцию <tt><a 
href="symbols.html#x187-2604081r81">apply</a></tt> этой функции и списка её (невычисленных)
аргументов. Спецификаторы параметров обрабатываются также, как и для
любого лямбда-выражения. В качестве параметров используются
формы аргументов макровызова. Затем вычисляются формы тела, как
неявный <tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt>. Значение последней формы возвращается, как раскрытие
макровызова.
<!--l. 1276--><p class="indent" >   Если указана необязательная строка документации <i>doc-string</i>, тогда
она присоединяется к символу <i>name</i>, как строка документации типа
<tt><a 
href="symbols.html#x187-2604399r399">function</a></tt>. Смотрите <tt><a 
href="symbols.html#x187-2604315r315">documentation</a></tt>. Если в определении макроса
представлена только строка документации, и после неё нет ни одной
формы, ни деклараций, ни просто для тела, то данная строка сама
становиться формой, и тело считается состоящим из одной формы — этой
строки.
<!--l. 1283--><p class="indent" >   Следующие три дополнительных маркера доступны в определении
                                                                          

                                                                          
лямбда-списка. <div class="indentdesc">
      <ul><li><b>
<tt>&#x0026;body</tt> </b></li>Данный  маркер  эквивалентен  <tt>&#x0026;rest</tt> маркеру,  но  дополнительно
      сообщает для функций вывода-форматирования и редактирования,
      что   оставшаяся   часть   формы   рассматривается   как   тело   и
      должна быть правильно отформатирована. (Можно использовать
      исключительно один маркер или <tt>&#x0026;body</tt>, или <tt>&#x0026;rest</tt>)
      <li><b>
<tt>&#x0026;whole</tt> </b></li>За данным маркером указывается одна переменная, которая будет
      связана  со  всей  формой  макровызова.  Это  значение,  которое
      получает функция определения макроса в качестве своего первого
      аргумента. <tt>&#x0026;whole</tt> и следующая переменная должны указываться
      на первой позиции в лямбда-списке, перед другими параметрами
      или маркерами.
      <li><b>
<tt>&#x0026;environment</tt> </b></li>За данным маркером указывается одна переменная, которая будет
      связана с окружением, отображающим лексическое окружение, в
      котором произошёл макровызов. Это окружение может не быть
      полным  лексическим  окружением.  Оно  должно  использоваться
      только                 с                 функцией                 <tt><a 
href="symbols.html#x187-2604529r529">macroexpand</a></tt>
      ради  любых  локальных  определений  макросов,  которые  могли
      быть установлены с помощью <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> конструкции внутри этого
      лексического окружения. Этот функционал полезен крайне редко,
      когда определение макроса должно явно раскрыть другие макросы
      в процессе своего раскрытия.</ul>
</div>
<!--l. 1308--><p class="noindent" >Смотрите <tt><a 
href="symbols.html#x187-2604463r463">lambda-list-keywords</a></tt>.
<div class="newer">
<!--l. 1311--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx59-710001"></a>to specify that macro environment objects
received with the <tt>&#x0026;environment</tt> argument of a macro function have only dynamic
extent. The consequences are undeﬁned if such objects are referred to outside the
dynamic extent of that particular invocation of the macro function. This allows
implementations to use somewhat more eﬃcient techniques for representing
environment objects.
</div>
                                                                          

                                                                          
<div class="newer">
<!--l. 1322--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx59-710002"></a>to clarify the permitted uses of <tt>&#x0026;body</tt>, <tt>&#x0026;whole</tt>,
and <tt>&#x0026;environment</tt>:
      <ul class="itemize1">
      <li class="itemize"><tt>&#x0026;body</tt> may appear at any level of a <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt> lambda-list.
      </li>
      <li class="itemize"><tt>&#x0026;whole</tt> may appear at any level of a <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt> lambda-list. At inner
      levels a <tt>&#x0026;whole</tt> variable is bound to that part of the argument that
      matches the sub-lambda-list in which <tt>&#x0026;whole</tt> appears. No matter where
      <tt>&#x0026;whole</tt> is used, other parameters or lambda-list keywords may follow
      it.
      </li>
      <li class="itemize"><tt>&#x0026;environment</tt> may occur only at the outermost level of a <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt>
      lambda-list, and it may occur at most once, but it may occur anywhere
      within that lambda-list, even before an occurrence of <tt>&#x0026;whole</tt>.</li></ul>
</div>
<tt>
<!--l. 1336--><p class="indent" >   <a 
href="symbols.html#x187-2604284r284">defmacro</a></tt>, в отличие от любых других конструкций Common Lisp&#x2019;а,
имеющих лямбда-списки в своём синтаксисе, предоставляет дополнительную
функциональность известную как <i>деструктуризация</i>.
<!--l. 1340--><p class="indent" >   Смотрите <tt><a 
href="symbols.html#x187-2604303r303">destructuring-bind</a></tt>, которая отдельно предоставляет эту
функциональность.
<!--l. 1342--><p class="indent" >   В любом месте, где могло бы стоять имя параметра, и где по синтаксису
не ожидается использование списка (как описано в разделе <a 
href="clmse29.html#x39-2240005.2.2">5.2.2<!--tex4ht:ref: LAMBDA-EXPRESSIONS-SECTION --></a>), можно
использовать ещё один встроенный лямбда-список. Когда использован такой
приём, при передаче форм аргументов для встроенного лямбда-списка,
необходимо обернуть эти формы в отдельный список. В качестве
примера, определение макроса для <tt><a 
href="symbols.html#x187-2604317r317">dolist</a></tt> можно записать в таком стиле:
<div class="lisp"><div class="tabbing">
(defmacro dolist ((var listform <tt>&#x0026;optional</tt> resultform)
   <br>                                                                     &#x0026;rest body)<br>
  ...)<br>
<!--l. 1354--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1354--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7110008.1" id="x59-7110008.1"></a></span>
<!--l. 1354--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7120008.1" id="x59-7120008.1"></a></span>
</div>
<!--l. 1355--><p class="indent" >   Ниже будет больше примеров использования встраиваемых лямбда-списков в
<tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt>.
<!--l. 1358--><p class="indent" >   Следующим правилом деструктуризации является то, что <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt>
позволяет любому лямбда-списку (верхнего уровня или встроенному) быть
dotted, заканчивающимся именем параметра. Такая ситуация обрабатывается
так, как будто имя параметра в конце списка, стоит после неявного маркера
<tt>&#x0026;rest</tt>. Например, уже показанное определение <tt><a 
href="symbols.html#x187-2604317r317">dolist</a></tt> может быть записано
так: <div class="lisp"><div class="tabbing">
(defmacro dolist ((var listform &#x0026;optional resultform)
   <br>                                                                           . body)<br>
  ...)<br>
<!--l. 1367--><p class="noindent" ></div>
<!--l. 1367--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7130008.1" id="x59-7130008.1"></a></span>
<!--l. 1367--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7140008.1" id="x59-7140008.1"></a></span>
</div>
<!--l. 1369--><p class="indent" >   Если компилятор встречает <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt>, он добавляет новый макрос в
окружение компиляции, и также функция раскрытия добавляется в
выходной файл. Таким образом новый макрос будет более быстрым во время
выполнения. Если необходимо избежать такого механизма, можно
использовать <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt> внутри конструкции <tt><a 
href="symbols.html#x187-2604344r344">eval-when</a></tt>.
<tt>
<!--l. 1375--><p class="indent" >   <a 
href="symbols.html#x187-2604284r284">defmacro</a></tt> может также использоваться для переопределения макроса
(например, для установки корректной версии определения вместо
некорректной), или для переопределения функции в макрос. Переопределение
специальной формы (смотрите таблицу <a 
href="clmse28.html#x38-2190011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>) не допускается. Смотрите
<tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt>, которая устанавливает определение макроса в замкнутом
                                                                          

                                                                          
лексическом области видимости.
<!--l. 1383--><p class="indent" >   Допустим, для примера, что необходимо реализовать условную
конструкцию аналогичную Fortran&#x2019;овскому арифметическому выражению
IF. (Это конечно требует определённого расширения воображения
и приостановки неверия.) Конструкция должна принимать четыре
формы: <i>test-value</i>, <i>neg-form</i>, <i>zero-form</i> и <i>pos-form</i>. В зависимости от того,
является ли <i>test-form</i> отрицательным, нулём или положительным
числом, для выполнения будет выбрана одна из трёх последних форм. С
использованием <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt>, определение этой конструкции может выглядеть
так: <div class="lisp"><div class="tabbing">
(defmacro arithmetic-if (test neg-form zero-form pos-form)
   <br>                    (let ((var (gensym)))<br>                      ‘(let ((,var ,test))<br>
       (cond ((&#x003C; ,var 0) ,neg-form)<br>              ((= ,var 0) ,zero-form)<br>
             (t ,pos-form)))))<br>
<!--l. 1402--><p class="noindent" ></div>
<!--l. 1402--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7150008.1" id="x59-7150008.1"></a></span>
<!--l. 1402--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7160008.1" id="x59-7160008.1"></a></span>
</div>
<!--l. 1403--><p class="indent" >   Необходимо отметить, что в данном определении используется
функциональность обратной кавычки (смотрите раздел <a 
href="clmse112.html#x139-157200022.1.3">22.1.3<!--tex4ht:ref: MACRO-CHARACTERS-SECTION --></a>). Также
необходимо заметить, что используется <tt><a 
href="symbols.html#x187-2604408r408">gensym</a></tt> для создания нового имени
переменной. Это необходимо для избежания конфликтов с другими
переменными, которые могут использоваться в формах <i>neg-form</i>, <i>zero-form</i>
или <i>pos-form</i>.
<!--l. 1410--><p class="indent" >   Если форма выполняется интерпретатором, то определение функции для
символа <tt>arithmetic-if</tt> будет является макросом, с которым ассоциирована
функция двух аргументом эквивалентная данной <div class="lisp"><div class="tabbing">
(lambda (calling-form environment)
                                                                          

                                                                          
   <br>                                                      (declare (ignore environment))<br>
  (let ((var (gensym)))<br>                                           (list &#x2019;let<br>
          (list (list &#x2019;var (cadr calling-form)))<br>                 (list &#x2019;cond<br>
                (list (list &#x2019;&#x003C; var &#x2019;0) (caddr calling-form))<br>
                (list (list &#x2019;= var &#x2019;0) (cadddr calling-form))<br>
                (list &#x2019;t (ﬁfth calling-form))))))<br>
<!--l. 1423--><p class="noindent" ></div>
<!--l. 1423--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7170008.1" id="x59-7170008.1"></a></span>
<!--l. 1423--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7180008.1" id="x59-7180008.1"></a></span>
</div>
<!--l. 1424--><p class="indent" >   Лямбда-выражение является результатом выполнения декларации
<tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt>. Вызов <tt><a 
href="symbols.html#x187-2604491r491">list</a></tt> является (гипотетически) результатом макросимвола
обратной кавычки (<tt>‘</tt>) и связанной с ним запятой. Конкретная функция
раскрытия макроса может зависеть от реализации, например, она также
может содержать проверку на корректность входных аргументов в
макровызове.
<!--l. 1430--><p class="indent" >   Теперь, если <tt><a 
href="symbols.html#x187-2604343r343">eval</a></tt> встретит <div class="lisp"><div class="tabbing">
(arithmetic-if (- x 4.0)
   <br>                     (- x)<br>                     (error &#x0022;Strange zero&#x0022;)<br>
               x)<br>
<!--l. 1436--><p class="noindent" ></div>
<!--l. 1436--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7190008.1" id="x59-7190008.1"></a></span>
<!--l. 1436--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7200008.1" id="x59-7200008.1"></a></span>
</div>
<!--l. 1437--><p class="indent" >   то раскроет эту форму в <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(let ((g407 (- x 4.0)))
   <br>   (cond ((&#x003C; g407 0) (- x))<br>         ((= g407 0) (error &#x0022;Strange zero&#x0022;))<br>
        (t x)))<br>
<!--l. 1443--><p class="noindent" ></div>
<!--l. 1443--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7210008.1" id="x59-7210008.1"></a></span>
<!--l. 1443--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7220008.1" id="x59-7220008.1"></a></span>
</div>
<!--l. 1444--><p class="indent" >   и <tt><a 
href="symbols.html#x187-2604343r343">eval</a></tt> выполнит полученную форму. (Сейчас должно быть понятно, что
функциональность обратной кавычки очень полезна для написания
макросов. Она используется для построения шаблона, возвращаемой
формы, с константными частями и частями для выполнения. Шаблон
представляет собой «картину» кода, с местами для заполнения выделенными
запятыми.)
<!--l. 1450--><p class="indent" >   Для улучшения примера мы можем сделать так, чтобы <i>pos-form</i> и
<i>zero-form</i> могли быть заменены на <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> в результате раскрытия макроса.
Таким же образом действует и <tt><a 
href="symbols.html#x187-2604435r435">if</a></tt> опуская ветку <i>else</i> в случае истинности
условия. <div class="lisp"><div class="tabbing">
(defmacro arithmetic-if (test neg-form
   <br>                                       <tt>&#x0026;optional</tt> zero-form pos-form)<br>
  (let ((var (gensym)))<br>                                  ‘(let ((,var ,test))<br>
       (cond ((&#x003C; ,var 0) ,neg-form)<br>              ((= ,var 0) ,zero-form)<br>
             (t ,pos-form)))))<br>
<!--l. 1462--><p class="noindent" ></div>
<!--l. 1462--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7230008.1" id="x59-7230008.1"></a></span>
                                                                          

                                                                          
<!--l. 1462--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7240008.1" id="x59-7240008.1"></a></span>
</div>
<!--l. 1463--><p class="indent" >   Тогда можно записать <div class="lisp"><div class="tabbing">
(arithmetic-if (- x 4.0) (print x))
   <br>
<!--l. 1466--><p class="noindent" ></div>
<!--l. 1466--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7250008.1" id="x59-7250008.1"></a></span>
<!--l. 1466--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7260008.1" id="x59-7260008.1"></a></span>
</div>
<!--l. 1467--><p class="indent" >   и это раскроется в что-то вроде <div class="lisp"><div class="tabbing">
(let ((g408 (- x 4.0)))
   <br>             (cond ((&#x003C; g408 0) (print x))<br>                   ((= g408 0) nil)<br>
        (t nil)))<br>
<!--l. 1473--><p class="noindent" ></div>
<!--l. 1473--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7270008.1" id="x59-7270008.1"></a></span>
<!--l. 1473--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7280008.1" id="x59-7280008.1"></a></span>
</div>
<!--l. 1474--><p class="indent" >   Результирующий код корректен, но некрасиво выглядит. Можно
переписать определение макроса для генерации лучшего кода, когда <i>pos-form</i>
и <i>zero-form</i> могут быть вообще опущены. Или же можно положиться на
реализацию Common Lisp&#x2019;а, которая возможно оптимизирует этот
код.
                                                                          

                                                                          
<!--l. 1480--><p class="indent" >   Деструктуризация является очень мощной функциональностью, которая
позволяет лямбда-списку в <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt> выразить сложную структуру
макровызова. Если не использовались ключевые символы лямбда-списка, то
он представляет собой просто список с некоторой степенью вложенности и
параметрами в качестве листьев. Структура макровызова должна иметь
такую же структуру списка. Например, рассмотрим следующее определение
макроса: <div class="lisp"><div class="tabbing">
(defmacro halibut ((mouth eye1 eye2)
   <br>                                             ((ﬁn1 length1) (ﬁn2 length2))<br>
                   tail)<br>                                             ...)<br>
<!--l. 1491--><p class="noindent" ></div>
<!--l. 1491--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7290008.1" id="x59-7290008.1"></a></span>
<!--l. 1491--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7300008.1" id="x59-7300008.1"></a></span>
</div>
<!--l. 1492--><p class="indent" >   Теперь давайте рассмотрим макровызов: <div class="lisp"><div class="tabbing">
(halibut (m (car eyes) (cdr eyes))
   <br>                                ((f1 (count-scales f1)) (f2 (count-scales f2)))<br>
         my-favorite-tail)<br>
<!--l. 1497--><p class="noindent" ></div>
<!--l. 1497--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7310008.1" id="x59-7310008.1"></a></span>
<!--l. 1497--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7320008.1" id="x59-7320008.1"></a></span>
</div>
<!--l. 1498--><p class="indent" >   Все это приведёт к тому, что функция раскрытия получит следующие
значения для её параметров:
                                                                          

                                                                          
<div class="flushleft" 
>
<!--l. 1500--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Параметр</td><td align="left" >Значение         </td>
</tr><tr><td align="left" >mouth     </td><td align="left" >m                   </td>
</tr><tr><td align="left" >eye1        </td><td align="left" >(car eyes)         </td>
</tr><tr><td align="left" >eye2        </td><td align="left" >(cdr eyes)         </td>
</tr><tr><td align="left" >ﬁn1         </td><td align="left" >f1                   </td>
</tr><tr><td align="left" >length1    </td><td align="left" >(count-scales f1)</td>
</tr><tr><td align="left" >ﬁn2         </td><td align="left" >f2                   </td>
</tr><tr><td align="left" >length2    </td><td align="left" >(count-scales f2)</td>
</tr><tr><td align="left" >tail         </td><td align="left" >my-favorite-tail </td></tr><tr><td align="left" > </td></tr></table></div></div>
<!--l. 1513--><p class="noindent" >Следующий макровызов ошибочный, так как аргумента для параметра <tt>length1</tt>
не представлено: <div class="lisp"><div class="tabbing">
(halibut (m (car eyes) (cdr eyes))
   <br>                                                       ((f1) (f2 (count-scales f2)))<br>
         my-favorite-tail)<br>
<!--l. 1519--><p class="noindent" ></div>
<!--l. 1519--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7330008.1" id="x59-7330008.1"></a></span>
<!--l. 1519--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7340008.1" id="x59-7340008.1"></a></span>
</div>
<!--l. 1520--><p class="indent" >   Следующий макровызов также ошибочный, так как на месте
предполагаемого списка указан символ. <div class="lisp"><div class="tabbing">
(halibut my-favorite-head
   <br>                                ((f1 (count-scales f1)) (f2 (count-scales f2)))<br>
         my-favorite-tail)<br>
<!--l. 1526--><p class="noindent" ></div>
<!--l. 1526--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7350008.1" id="x59-7350008.1"></a></span>
                                                                          

                                                                          
<!--l. 1526--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7360008.1" id="x59-7360008.1"></a></span>
</div>
<!--l. 1527--><p class="indent" >   Тот факт, что значение переменной <tt>my-favorite-head</tt> может быть
списком, не имеет здесь значения. В макровызове структура должна
совпадать с лямбда-списком в определении.
<!--l. 1531--><p class="indent" >   Использование ключевых символов лямбда-списка предоставляет ещё
большую гибкость. Например, предположим, что удобно будет в функции
раскрытия обращаться к элементам списка, называемым cdmouth, <tt>eye1</tt>, and
<tt>eye2</tt>, как к <tt>head</tt>. Можно записать так: <div class="lisp"><div class="tabbing">
(defmacro halibut ((<tt>&#x0026;whole</tt> head mouth eye1 eye2)
   <br>                                             ((ﬁn1 length1) (ﬁn2 length2))<br>
                   tail)<br>
<!--l. 1541--><p class="noindent" ></div>
<!--l. 1541--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7370008.1" id="x59-7370008.1"></a></span>
<!--l. 1541--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7380008.1" id="x59-7380008.1"></a></span>
</div>
<!--l. 1542--><p class="indent" >   Теперь рассмотрим такой же, как раньше, корректный макровызов:
<div class="lisp"><div class="tabbing">
(halibut (m (car eyes) (cdr eyes))
   <br>                                ((f1 (count-scales f1)) (f2 (count-scales f2)))<br>
         my-favorite-tail)<br>
<!--l. 1547--><p class="noindent" ></div>
<!--l. 1547--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7390008.1" id="x59-7390008.1"></a></span>
                                                                          

                                                                          
<!--l. 1547--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7400008.1" id="x59-7400008.1"></a></span>
</div>
<!--l. 1548--><p class="indent" >   Это приведёт к тому, что функции раскрытия получит те же значения
для своих параметров, а также значение для параметра <tt>head</tt>:
<div class="flushleft" 
>
<!--l. 1550--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Параметр</td><td align="left" >Значение                    </td></tr><tr><td align="left" >head </td> <td align="left" >(m (car eyes) (cdr eyes))</td></tr><tr><td align="left" > </td></tr></table>
</div></div>
<!--l. 1559--><p class="indent" >   Существует условие для деструктуризации, встроенный лямбда-список
разрешён только на позиции, где синтаксис лямбда-списка предусматривает
имя параметра, но не список. Это защищает от двусмысленности. Например,
нельзя записать <div class="lisp"><div class="tabbing">
(defmacro loser (x <tt>&#x0026;optional</tt> (a b <tt>&#x0026;rest</tt> c) <tt>&#x0026;rest</tt> z)
   <br>                                                                                          ...)<br>
<!--l. 1565--><p class="noindent" ></div>
<!--l. 1565--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7410008.1" id="x59-7410008.1"></a></span>
<!--l. 1565--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7420008.1" id="x59-7420008.1"></a></span>
</div>
<!--l. 1566--><p class="indent" >   потому что синтаксис лямбда-списка не позволяет использовать списки
после <tt>&#x0026;optional</tt>. Список <tt>(a b <tt>&#x0026;rest</tt> c)</tt> был бы интерпретирован как
необязательный параметр <tt>a</tt>, у которого значение по умолчанию <tt>b</tt>, и
supplied-p параметр с некорректным именем <tt>&#x0026;rest</tt>, и дополнительным
символом <tt>c</tt>, также некорректным. Было бы правильнее выразить это так:
<div class="lisp"><div class="tabbing">
(defmacro loser (x <tt>&#x0026;optional</tt> ((a b <tt>&#x0026;rest</tt> c)) <tt>&#x0026;rest</tt> z)
   <br>                                                                                          ...)<br>
<!--l. 1574--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1574--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7430008.1" id="x59-7430008.1"></a></span>
<!--l. 1574--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7440008.1" id="x59-7440008.1"></a></span>
</div>
<!--l. 1575--><p class="indent" >   Дополнительные круглые скобки устраняют двусмысленность. Однако,
такой макровызов, как <tt>(loser (car pool))</tt> не предоставляет никакой
формы аргумента для лямбда-списка <tt>(a b <tt>&#x0026;rest</tt> c)</tt>, значит значение по
умолчанию для него будет <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>. А так как <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> является пустым списком, то
этот макровызов ошибочен. Полностью корректное определение выглядит
так: <div class="lisp"><div class="tabbing">
(defmacro loser (x <tt>&#x0026;optional</tt> ((a b <tt>&#x0026;rest</tt> c) &#x2019;(nil nil)) <tt>&#x0026;rest</tt> z)
   <br>                                                                                          ...)<br>
<!--l. 1583--><p class="noindent" ></div>
<!--l. 1583--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7450008.1" id="x59-7450008.1"></a></span>
<!--l. 1583--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7460008.1" id="x59-7460008.1"></a></span>
</div>
<!--l. 1584--><p class="indent" >   или так <div class="lisp"><div class="tabbing">
(defmacro loser (x <tt>&#x0026;optional</tt> ((<tt>&#x0026;optional</tt> a b <tt>&#x0026;rest</tt> c)) <tt>&#x0026;rest</tt> z)
   <br>                                                                                          ...)<br>
<!--l. 1588--><p class="noindent" ></div>
<!--l. 1588--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7470008.1" id="x59-7470008.1"></a></span>
                                                                          

                                                                          
<!--l. 1588--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7480008.1" id="x59-7480008.1"></a></span>
</div>
<!--l. 1589--><p class="indent" >   Они слегка отличаются: первое определение требует, что если
макровызов явно указывает <tt>a</tt>, тогда он должен указать явно и <tt>b</tt>, тогда
как второе определение не содержит такого требования. Например,
<div class="lisp"><div class="tabbing">
(loser (car pool) ((+ x 1)))
   <br>
<!--l. 1594--><p class="noindent" ></div>
<!--l. 1594--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7490008.1" id="x59-7490008.1"></a></span>
<!--l. 1594--><p class="noindent" ><span class="paragraphHead"><a 
href="#x59-7500008.1" id="x59-7500008.1"></a></span>
</div>
<!--l. 1595--><p class="indent" >   будет корректным макровызовом для второго определения, но не для
первого.
</div>
                                                                          

                                                                          
<!--l. 1598--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse47.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="macro.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="macro.html#tailmacro.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse46.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="macro.html#clmse46.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse46.html"></a>  </div> </div> 
</body></html> 
