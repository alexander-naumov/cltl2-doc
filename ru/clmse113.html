<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Input Functions</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-06-05 15:52:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="clmse114.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse112.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse112.html#tailclmse112.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse113.html">В-конец</a>&#x003E;&#x003C;<a 
href="io.html#clmse113.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">22.2
</span> <a 
href="clm.html#QQ2-140-227" id="x140-18900022.2">Input Functions</a></h3>
<!--l. 3267--><p class="noindent" >The input functions are divided into two groups: those that operate on streams of
characters and those that operate on streams of binary data.
<!--l. 3271--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">22.2.1   </span> <a 
href="frontmatter.html#QQ2-140-228" id="x140-19000022.2.1">Input from Character Streams</a></h4>
<!--l. 3274--><p class="noindent" >Many character input functions take optional arguments called <em>input-stream</em>,
<em>eof-error-p</em>, and <em>eof-value</em>. The <em>input-stream</em> argument is the stream from which to
obtain input; if unsupplied or <b><a 
href="symbols.html#x188-375658r658">nil</a></b> it defaults to the value of the special variable
<b><a 
href="symbols.html#x188-375050r50">*standard-input*</a></b>. One may also specify <b><a 
href="symbols.html#x188-375939r939">t</a></b> as a stream, meaning the value of the
special variable <b><a 
href="symbols.html#x188-375052r52">*terminal-io*</a></b>.
<!--l. 3283--><p class="indent" >   The <em>eof-error-p</em> argument controls what happens if input is from a ﬁle (or any
other input source that has a deﬁnite end) and the end of the ﬁle is reached. If
<em>eof-error-p</em> is true (the default), an error will be signaled at end of ﬁle.
If it is false, then no error is signaled, and instead the function returns
<em>eof-value</em>.
<!--l. 3290--><p class="indent" >   An <em>eof-value</em> argument may be any Lisp datum whatsoever.
<!--l. 3293--><p class="indent" >   Functions such as <b><a 
href="symbols.html#x188-375766r766">read</a></b> that read the representation of an object rather than a
single character will always signal an error, regardless of <em>eof-error-p</em>, if the ﬁle
ends in the middle of an object representation. For example, if a ﬁle does not
contain enough right parentheses to balance the left parentheses in it, <b><a 
href="symbols.html#x188-375766r766">read</a></b> will
complain. If a ﬁle ends in a symbol or a number immediately followed by
end-of-ﬁle, <b><a 
href="symbols.html#x188-375766r766">read</a></b> will read the symbol or number successfully and when called
again will see the end-of-ﬁle and only then act according to <em>eof-error-p</em>.
Similarly, the function <b><a 
href="symbols.html#x188-375772r772">read-line</a></b> will successfully read the last line of a
ﬁle even if that line is terminated by end-of-ﬁle rather than the newline
character. If a ﬁle contains ignorable text at the end, such as blank lines and
comments, <b><a 
href="symbols.html#x188-375766r766">read</a></b> will not consider it to end in the middle of an object. Thus an
<em>eof-error-p</em> argument controls what happens when the ﬁle ends <em>between</em>
                                                                          

                                                                          
objects.
<!--l. 3312--><p class="indent" >   Many input functions also take an argument called <em>recursive-p</em>. If speciﬁed
and not <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, this argument speciﬁes that this call is not a “top-level” call
to <b><a 
href="symbols.html#x188-375766r766">read</a></b> but an imbedded call, typically from the function for a macro
character. It is important to distinguish such recursive calls for three
reasons.
<!--l. 3318--><p class="indent" >   First, a top-level call establishes the context within which the <b>#<em>n</em>=</b> and
<b>#<em>n</em>#</b> syntax is scoped. Consider, for example, the expression <div class="lisp"><tt><div class="tabbing">
(cons &#x2019;#3=(p q r) &#x2019;(x y . #3#))
   <br>
<!--l. 3323--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3324--><p class="indent" >   If the single-quote macro character were deﬁned in this way: <div class="lisp"><tt><div class="tabbing">
(set-macro-character #\&#x2019;
   <br>                                                  #&#x2019;(lambda (stream char)<br>
                         (declare (ignore char))<br>
                         (list &#x2019;quote (read stream))))<br>
<!--l. 3330--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3331--><p class="indent" >   then the expression could not be read properly, because there would be no way
to know when <b><a 
href="symbols.html#x188-375766r766">read</a></b> is called recursively by the ﬁrst occurrence of <b>&#x2019;</b> that the label
<b>#3=</b> would be referred to later in the containing expression. There would be no
way to know because <b><a 
href="symbols.html#x188-375766r766">read</a></b> could not determine that it was called by a
macro-character function rather than from “top level.” The correct way to
deﬁne the single quote macro character uses the <em>recursive-p</em> argument:
<div class="lisp"><tt><div class="tabbing">
(set-macro-character #\&#x2019;
                                                                          

                                                                          
   <br>                                                  #&#x2019;(lambda (stream char)<br>
                         (declare (ignore char))<br>
                         (list &#x2019;quote (read stream t nil t))))<br>
<!--l. 3344--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3346--><p class="indent" >   Second, a recursive call does not alter whether the reading process is to
preserve whitespace or not (as determined by whether the top-level call was to
<b><a 
href="symbols.html#x188-375766r766">read</a></b> or <b><a 
href="symbols.html#x188-375773r773">read-preserving-whitespace</a></b>). Suppose again that the single
quote had the ﬁrst, incorrect, macro-character deﬁnition shown above.
Then a call to <b><a 
href="symbols.html#x188-375773r773">read-preserving-whitespace</a></b> that read the expression
<b>&#x2019;foo </b> would fail to preserve the space character following the symbol
<b>foo</b> because the single-quote macro-character function calls <b><a 
href="symbols.html#x188-375766r766">read</a></b>, not
<b><a 
href="symbols.html#x188-375773r773">read-preserving-whitespace</a></b>, to read the following expression (in this case
<b>foo</b>). The correct deﬁnition, which passes the value <b><a 
href="symbols.html#x188-375939r939">t</a></b> for the <em>recursive-p</em> argument
to <b><a 
href="symbols.html#x188-375766r766">read</a></b>, allows the top-level call to determine whether whitespace is
preserved.
<!--l. 3359--><p class="indent" >   Third, when end-of-ﬁle is encountered and the <em>eof-error-p</em> argument is not <b><a 
href="symbols.html#x188-375658r658">nil</a></b>,
the kind of error that is signaled may depend on the value of <em>recursive-p</em>. If
<em>recursive-p</em> is not <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, then the end-of-ﬁle is deemed to have occurred within the
middle of a printed representation; if <em>recursive-p</em> is <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, then the end-of-ﬁle may be
deemed to have occurred between objects rather than within the middle of
one.
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3368--><p class="noindent" >[Function]</em><a 
 id="dx140-190001"></a> <b>read</b> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>input-stream</i> <i>eof-error-p</i> <i>eof-value</i> <i>recursive-p</i>
</div>
<b>
<!--l. 3370--><p class="indent" >   <a 
href="symbols.html#x188-375766r766">read</a></b> reads in the printed representation of a Lisp object from <em>input-stream</em>,
builds a corresponding Lisp object, and returns the object.
<!--l. 3374--><p class="indent" >   Note that when the variable <b>*read-suppress*</b> is not <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, then <b><a 
href="symbols.html#x188-375766r766">read</a></b> reads in a
printed representation as best it can, but most of the work of interpreting the
representation is avoided (the intent being that the result is to be discarded
anyway). For example, all extended tokens produce the result <b><a 
href="symbols.html#x188-375658r658">nil</a></b> regardless of
their syntax.
                                                                          

                                                                          
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3383--><p class="noindent" >[Variable]</em><a 
 id="dx140-190002"></a> <b>*read-default-ﬂoat-format*</b>
</div>
<!--l. 3385--><p class="indent" >   The value of this variable must be a type speciﬁer symbol for a speciﬁc
ﬂoating-point format; these include <b>short-ﬂoat</b>, <b>single-ﬂoat</b>, <b>double-ﬂoat</b>, and
<b>long-ﬂoat</b> and may include implementation-speciﬁc types as well. The default
value is <b>single-ﬂoat</b>.
<b>
<!--l. 3391--><p class="indent" >   <a 
href="symbols.html#x188-375045r45">*read-default-ﬂoat-format*</a></b> indicates the ﬂoating-point format to be used
for reading ﬂoating-point numbers that have no exponent marker or have <b>e</b> or <b>E</b>
for an exponent marker. (Other exponent markers explicitly prescribe
the ﬂoating-point format to be used.) The printer also uses this variable
to guide the choice of exponent markers when printing ﬂoating-point
numbers.
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3401--><p class="noindent" >[Function]</em><a 
 id="dx140-190003"></a> <b>read-preserving-whitespace</b> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>in-stream</i> <i>eof-error-p</i>
<i>eof-value</i> <i>recursive-p</i>
</div>
<!--l. 3403--><p class="indent" >   Certain printed representations given to <b><a 
href="symbols.html#x188-375766r766">read</a></b>, notably those of symbols and
numbers, require a delimiting character after them. (Lists do not, because the
close parenthesis marks the end of the list.) Normally <b><a 
href="symbols.html#x188-375766r766">read</a></b> will throw away the
delimiting character if it is a whitespace character; but <b><a 
href="symbols.html#x188-375766r766">read</a></b> will preserve the
character (using <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b>) if it is syntactically meaningful, because it may be
the start of the next expression.
<div class="new">
<!--l. 3412--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx140-190004"></a>to clarify the interaction of <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b> with
echo streams. These changes indirectly aﬀect the echoing behavior of
<b><a 
href="symbols.html#x188-375773r773">read-preserving-whitespace</a></b>.
</div>
                                                                          

                                                                          
<!--l. 3419--><p class="indent" >   The function <b><a 
href="symbols.html#x188-375773r773">read-preserving-whitespace</a></b> is provided for some specialized
situations where it is desirable to determine precisely what character terminated
the extended token.
<!--l. 3423--><p class="indent" >   As an example, consider this macro-character deﬁnition: <div class="lisp"><tt><div class="tabbing">
(defun slash-reader (stream char)
   <br>                                                                 (declare (ignore char))<br>
  (do ((path (list (read-preserving-whitespace stream))<br>
             (cons (progn (read-char stream nil nil t)<br>
                          (read-preserving-whitespace<br>
                             stream))<br>                     path)))<br>
      ((not (char= (peek-char nil stream nil nil t) #\/))<br>
       (cons &#x2019;path (nreverse path)))))<br>
(set-macro-character #\/ #&#x2019;slash-reader)<br>
<!--l. 3435--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3436--><p class="indent" >   (This is actually a rather dangerous deﬁnition to make because expressions
such as <b>(/ x 3)</b> will no longer be read properly. The ability to reprogram the
reader syntax is very powerful and must be used with caution. This redeﬁnition of
<b><a 
href="symbols.html#x188-375058r58">/</a></b> is shown here purely for the sake of example.)
<!--l. 3442--><p class="indent" >   Consider now calling <b><a 
href="symbols.html#x188-375766r766">read</a></b> on this expression: <div class="lisp"><tt><div class="tabbing">
(zyedh /usr/games/zork /usr/games/boggle)
   <br>
<!--l. 3445--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3446--><p class="indent" >   The <b><a 
href="symbols.html#x188-375058r58">/</a></b> macro reads objects separated by more <b><a 
href="symbols.html#x188-375058r58">/</a></b> characters; thus
<b>/usr/games/zork</b> is intended to be read as <b>(path usr games zork)</b>. The entire
example expression should therefore be read as <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(zyedh (path usr games zork) (path usr games boggle))
   <br>
<!--l. 3451--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3452--><p class="indent" >   However, if <b><a 
href="symbols.html#x188-375766r766">read</a></b> had been used instead of <b><a 
href="symbols.html#x188-375773r773">read-preserving-whitespace</a></b>,
then after the reading of the symbol <b>zork</b>, the following space would be discarded;
the next call to <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b> would see the following <b><a 
href="symbols.html#x188-375058r58">/</a></b>, and the loop would
continue, producing this interpretation: <div class="lisp"><tt><div class="tabbing">
(zyedh (path usr games zork usr games boggle))
   <br>
<!--l. 3459--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3460--><p class="indent" >   On the other hand, there are times when whitespace <em>should</em> be discarded. If a
command interpreter takes single-character commands, but occasionally reads a
Lisp object, then if the whitespace after a symbol is not discarded it might be
interpreted as a command some time later after the symbol had been
read.
<!--l. 3466--><p class="indent" >   Note that <b><a 
href="symbols.html#x188-375773r773">read-preserving-whitespace</a></b> behaves <em>exactly</em> like <b><a 
href="symbols.html#x188-375766r766">read</a></b> when the
<em>recursive-p</em> argument is not <b><a 
href="symbols.html#x188-375658r658">nil</a></b>. The distinction is established only by calls with
<em>recursive-p</em> equal to <b><a 
href="symbols.html#x188-375658r658">nil</a></b> or omitted.
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3472--><p class="noindent" >[Function]</em><a 
 id="dx140-190005"></a> <b>read-delimited-list</b> <i>char</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>input-stream</i> <i>recursive-p</i>
</div>
<!--l. 3474--><p class="indent" >   This reads objects from <em>stream</em> until the next character after an object&#x2019;s
representation (ignoring whitespace characters and comments) is <em>char</em>. (The <em>char</em>
should not have whitespace syntax in the current readtable.) A list of the objects
read is returned.
                                                                          

                                                                          
<!--l. 3480--><p class="indent" >   To be more precise, <b><a 
href="symbols.html#x188-375770r770">read-delimited-list</a></b> looks ahead at each step for the
next non-whitespace character and peeks at it as if with <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b>.
If it is <em>char</em>, then the character is consumed and the list of objects is
returned. If it is a constituent or escape character, then <b><a 
href="symbols.html#x188-375766r766">read</a></b> is used
to read an object, which is added to the end of the list. If it is a macro
character, the associated macro function is called; if the function returns a
value, that value is added to the list. The peek-ahead process is then
repeated.
<div class="new">
<!--l. 3491--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx140-190006"></a>to clarify the interaction of <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b> with echo
streams. These changes indirectly aﬀect the echoing behavior of the function
<b><a 
href="symbols.html#x188-375770r770">read-delimited-list</a></b>.
</div>
<!--l. 3498--><p class="indent" >   This function is particularly useful for deﬁning new macro characters. Usually
it is desirable for the terminating character <em>char</em> to be a terminating macro
character so that it may be used to delimit tokens; however, <b><a 
href="symbols.html#x188-375770r770">read-delimited-list</a></b>
makes no attempt to alter the syntax speciﬁed for <em>char</em> by the current readtable.
The user must make any necessary changes to the readtable syntax explicitly. The
following example illustrates this.
<!--l. 3506--><p class="indent" >   Suppose you wanted <b>#{<em>a</em> <em>b</em> <em>c</em> ... <em>z</em>}</b> to be read as a list of all pairs of the
elements <em>a</em>, <em>b</em>, <em>c</em>, <b>...</b>, <em>z</em>; for example: <div class="lisp"><tt><div class="tabbing">
#{p q z a}  reads as  ((p q) (p z) (p a) (q z) (q a) (z a))
   <br>
<!--l. 3511--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3512--><p class="indent" >   This can be done by specifying a macro-character deﬁnition for <b>#{</b> that does
two things: read in all the items up to the <b>}</b>, and construct the pairs.
<b><a 
href="symbols.html#x188-375770r770">read-delimited-list</a></b> performs the ﬁrst task.
<div class="new">
<!--l. 3518--><p class="indent" >   Note that <b><a 
href="symbols.html#x188-375606r606">mapcon</a></b> allows the mapped function to examine the items of the
list after the current one, and that <b><a 
href="symbols.html#x188-375606r606">mapcon</a></b> uses <b><a 
href="symbols.html#x188-375654r654">nconc</a></b>, which is all right
because <b><a 
href="symbols.html#x188-375605r605">mapcar</a></b> will produce fresh lists.
</div>
                                                                          

                                                                          
<div class="lisp">
<tt>
<!--l. 3526--><p class="indent" >   <div class="tabbing">
(defun |#{-reader| (stream char arg)
   <br>             (declare (ignore char arg))<br>             (mapcon #&#x2019;(lambda (x)<br>
              (mapcar #&#x2019;(lambda (y) (list (car x) y)) (cdr x)))<br>
          (read-delimited-list #\} stream t)))<br>                           <br>
(set-dispatch-macro-character #\# #\{ #&#x2019;|#{-reader|)<br>                    <br>
(set-macro-character #\} (get-macro-character #\) <b><a 
href="symbols.html#x188-375658r658">nil</a></b>))<br>
<!--l. 3536--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3537--><p class="indent" >   (Note that <b><a 
href="symbols.html#x188-375939r939">t</a></b> is speciﬁed for the <em>recursive-p</em> argument.)
<!--l. 3539--><p class="indent" >   It is necessary here to give a deﬁnition to the character <b>}</b> as well to prevent it
from being a constituent. If the line <div class="lisp"><tt><div class="tabbing">
(set-macro-character #\} (get-macro-character #\) <b><a 
href="symbols.html#x188-375658r658">nil</a></b>))
   <br>
<!--l. 3544--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3545--><p class="indent" >   shown above were not included, then the <b>}</b> in <div class="lisp"><tt><div class="tabbing">
#{p q z a}
   <br>
<!--l. 3548--><p class="noindent" ></div>
</tt>
</div>
<!--l. 3549--><p class="indent" >   would be considered a constituent character, part of the symbol named <b>a}</b>.
One could correct for this by putting a space before the <b>}</b>, but it is better simply
to use the call to <b><a 
href="symbols.html#x188-375829r829">set-macro-character</a></b>.
                                                                          

                                                                          
<!--l. 3554--><p class="indent" >   Giving <b>}</b> the same deﬁnition as the standard deﬁnition of the character <b>)</b> has
the twin beneﬁt of making it terminate tokens for use with <b><a 
href="symbols.html#x188-375770r770">read-delimited-list</a></b>
and also making it illegal for use in any other context (that is, attempting to read
a stray <b>}</b> will signal an error).
<!--l. 3560--><p class="indent" >   Note that <b><a 
href="symbols.html#x188-375770r770">read-delimited-list</a></b> does not take an <em>eof-error-p</em> (or <em>eof-value</em>)
argument. The reason is that it is always an error to hit end-of-ﬁle during the
operation of <b><a 
href="symbols.html#x188-375770r770">read-delimited-list</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3567--><p class="noindent" >[Function]</em><a 
 id="dx140-190007"></a> <b>read-line</b> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>input-stream</i> <i>eof-error-p</i> <i>eof-value</i> <i>recursive-p</i>
</div>
<b>
<!--l. 3569--><p class="indent" >   <a 
href="symbols.html#x188-375772r772">read-line</a></b> reads in a line of text terminated by a newline. It returns the line as
a character string (<em>without</em> the newline character). This function is usually
used to get a line of input from the user. A second returned value is a
ﬂag that is false if the line was terminated normally, or true if end-of-ﬁle
terminated the (non-empty) line. If end-of-ﬁle is encountered immediately (that
is, appears to terminate an empty line), then end-of-ﬁle processing is
controlled in the usual way by the <em>eof-error-p</em>, <em>eof-value</em>, and <em>recursive-p</em>
arguments.
<!--l. 3578--><p class="indent" >   The corresponding output function is <b><a 
href="symbols.html#x188-376016r1016">write-line</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3582--><p class="noindent" >[Function]</em><a 
 id="dx140-190008"></a> <b>read-char</b> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>input-stream</i> <i>eof-error-p</i> <i>eof-value</i> <i>recursive-p</i>
</div>
<b>
<!--l. 3584--><p class="indent" >   <a 
href="symbols.html#x188-375768r768">read-char</a></b> inputs one character from <em>input-stream</em> and returns it as a
character object.
<!--l. 3587--><p class="indent" >   The corresponding output function is <b><a 
href="symbols.html#x188-376015r1015">write-char</a></b>.
<div class="new">
                                                                          

                                                                          
<!--l. 3590--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx140-190009"></a>to clarify the interaction of <b><a 
href="symbols.html#x188-375768r768">read-char</a></b> with echo
streams (as created by <b><a 
href="symbols.html#x188-375581r581">make-echo-stream</a></b>). A character is echoed from the
input stream to the associated output stream the ﬁrst time it is seen. If a
character is read again because of an intervening <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b> operation, the
character is not echoed again when read for the second time or any subsequent
time.
</div>
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3601--><p class="noindent" >[Function]</em><a 
 id="dx140-190010"></a> <b>unread-char</b> <i>character</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>input-stream</i>
</div>
<b>
<!--l. 3603--><p class="indent" >   <a 
href="symbols.html#x188-375971r971">unread-char</a></b> puts the <em>character</em> onto the front of <em>input-stream</em>. The
<em>character</em> must be the same character that was most recently read from the
<em>input-stream</em>. The <em>input-stream</em> “backs up” over this character; when a
character is next read from <em>input-stream</em>, it will be the speciﬁed character
followed by the previous contents of <em>input-stream</em>. <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b> returns
<b><a 
href="symbols.html#x188-375658r658">nil</a></b>.
<!--l. 3610--><p class="indent" >   One may apply <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b> only to the character most recently read from
<em>input-stream</em>. Moreover, one may not invoke <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b> twice consecutively
without an intervening <b><a 
href="symbols.html#x188-375768r768">read-char</a></b> operation. The result is that one may back up
only by one character, and one may not insert any characters into the input
stream that were not already there.
<div class="new">
<!--l. 3617--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx140-190011"></a>to clarify that one also may not invoke
<b><a 
href="symbols.html#x188-375971r971">unread-char</a></b> after invoking <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b> without an intervening <b><a 
href="symbols.html#x188-375768r768">read-char</a></b>
operation. This is consistent with the notion that <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b> behaves much like
<b><a 
href="symbols.html#x188-375768r768">read-char</a></b> followed by <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b>.
</div>__________________________________________________________________________<div class="rationale">
<!--l. 3626--><p class="noindent" ><b>Обоснование:</b> This is not intended to be a general mechanism, but rather an
eﬃcient mechanism for allowing the Lisp reader and other parsers to perform
one-character lookahead in the input stream. This protocol admits a wide variety
of eﬃcient implementations, such as simply decrementing a buﬀer pointer.
To have to specify the character in the call to <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b> is admittedly
                                                                          

                                                                          
redundant, since at any given time there is only one character that may be legally
speciﬁed. The redundancy is intentional, again to give the implementation
latitude.
</div>
__________________________________________________________________________
<div class="new">
<!--l. 3640--><p class="indent" >     X3J13 voted in January 1989 <a 
 id="dx140-190012"></a>to clarify the interaction of <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b> with
echo streams (as created by <b><a 
href="symbols.html#x188-375581r581">make-echo-stream</a></b>). When a character is “unread”
from an echo stream, no attempt is made to “unecho” the character. However, a
character placed back into an echo stream by <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b> will not be re-echoed
when it is subsequently re-read by <b><a 
href="symbols.html#x188-375768r768">read-char</a></b>.
</div>
<hr></div>
<!--l. 3650--><p class="indent" >
                                                                          

                                                                          
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3653--><p class="noindent" >[Function]</em><a 
 id="dx140-190013"></a> <b>peek-char</b> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>peek-type</i> <i>input-stream</i> <i>eof-error-p</i> <i>eof-value</i>
<i>recursive-p</i>
</div>
<!--l. 3655--><p class="indent" >   What <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b> does depends on the <em>peek-type</em>, which defaults to <b><a 
href="symbols.html#x188-375658r658">nil</a></b>. With a
<em>peek-type</em> of <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b> returns the next character to be read from
<em>input-stream</em>, without actually removing it from the input stream. The
next time input is done from <em>input-stream</em>, the character will still be
there. It is as if one had called <b><a 
href="symbols.html#x188-375768r768">read-char</a></b> and then <b><a 
href="symbols.html#x188-375971r971">unread-char</a></b> in
succession.
<!--l. 3663--><p class="indent" >   If <em>peek-type</em> is <b><a 
href="symbols.html#x188-375939r939">t</a></b>, then <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b> skips over whitespace characters (but not
comments) and then performs the peeking operation on the next character. This
is useful for ﬁnding the (possible) beginning of the next printed representation of
a Lisp object. The last character examined (the one that starts an object) is not
removed from the input stream.
<!--l. 3672--><p class="indent" >   If <em>peek-type</em> is a character object, then <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b> skips over input characters
until a character that is <b><a 
href="symbols.html#x188-375219r219">char=</a></b> to that object is found; that character is left in
the input stream.
<div class="new">
<!--l. 3678--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx140-190014"></a>to clarify the interaction of <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b> with echo
streams (as created by <b><a 
href="symbols.html#x188-375581r581">make-echo-stream</a></b>). When a character from an echo
stream is only peeked at, it is not echoed at that time. The character remains in
the input stream and may be echoed when read by <b><a 
href="symbols.html#x188-375768r768">read-char</a></b> at a later time.
Note, however, that if the <em>peek-type</em> is not <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, then characters skipped over
(and therefore consumed) by <b><a 
href="symbols.html#x188-375715r715">peek-char</a></b> are treated as if they had been
read by <b><a 
href="symbols.html#x188-375768r768">read-char</a></b>, and will be echoed if <b><a 
href="symbols.html#x188-375768r768">read-char</a></b> would have echoed
them.
</div>
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
                                                                          

                                                                          
<!--l. 3691--><p class="noindent" >[Function]</em><a 
 id="dx140-190015"></a> <b>listen</b> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>input-stream</i>
</div>
<!--l. 3693--><p class="indent" >   The predicate <b><a 
href="symbols.html#x188-375539r539">listen</a></b> is true if there is a character immediately available from
<em>input-stream</em>, and is false if not. This is particularly useful when the stream
obtains characters from an interactive device such as a keyboard. A call to
<b><a 
href="symbols.html#x188-375768r768">read-char</a></b> would simply wait until a character was available, but <b><a 
href="symbols.html#x188-375539r539">listen</a></b> can sense
whether or not input is available and allow the program to decide whether or not
to attempt input. On a non-interactive stream, the general rule is that <b><a 
href="symbols.html#x188-375539r539">listen</a></b> is
true except when at end-of-ﬁle.
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3705--><p class="noindent" >[Function]</em><a 
 id="dx140-190016"></a> <b>read-char-no-hang</b> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>input-stream</i> <i>eof-error-p</i> <i>eof-value</i>
<i>recursive-p</i>
</div>
<!--l. 3707--><p class="indent" >   This function is exactly like <b><a 
href="symbols.html#x188-375768r768">read-char</a></b>, except that if it would be necessary to
wait in order to get a character (as from a keyboard), <b><a 
href="symbols.html#x188-375658r658">nil</a></b> is immediately returned
without waiting. This allows one to eﬃciently check for input availability and get
the input if it is available. This is diﬀerent from the <b><a 
href="symbols.html#x188-375539r539">listen</a></b> operation in two ways.
First, <b><a 
href="symbols.html#x188-375769r769">read-char-no-hang</a></b> potentially reads a character, whereas <b><a 
href="symbols.html#x188-375539r539">listen</a></b>
never inputs a character. Second, <b><a 
href="symbols.html#x188-375539r539">listen</a></b> does not distinguish between
end-of-ﬁle and no input being available, whereas <b><a 
href="symbols.html#x188-375769r769">read-char-no-hang</a></b>
does make that distinction, returning <em>eof-value</em> at end-of-ﬁle (or signaling
an error if no <em>eof-error-p</em> is true) but always returning <b><a 
href="symbols.html#x188-375658r658">nil</a></b> if no input is
available.
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3723--><p class="noindent" >[Function]</em><a 
 id="dx140-190017"></a> <b>clear-input</b> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>input-stream</i>
</div>
<!--l. 3725--><p class="indent" >   This clears any buﬀered input associated with <em>input-stream</em>. It is primarily
useful for clearing type-ahead from keyboards when some kind of asynchronous
                                                                          

                                                                          
error has occurred. If this operation doesn&#x2019;t make sense for the stream involved,
then <b><a 
href="symbols.html#x188-375238r238">clear-input</a></b> does nothing. <b><a 
href="symbols.html#x188-375238r238">clear-input</a></b> returns <b><a 
href="symbols.html#x188-375658r658">nil</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3733--><p class="noindent" >[Function]</em><a 
 id="dx140-190018"></a> <b>read-from-string</b> <i>string</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>eof-error-p</i> <i>eof-value</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;key</a></tt>
<i>:start</i> <i>:end</i> <i>:preserve-whitespace</i>
</div>
<!--l. 3735--><p class="indent" >   The characters of <em>string</em> are given successively to the Lisp reader, and the Lisp
object built by the reader is returned. Macro characters and so on will all take
eﬀect.
<!--l. 3739--><p class="indent" >   The arguments <b>:start</b> and <b>:end</b> delimit a substring of <em>string</em> beginning at the
character indexed by <b>:start</b> and up to but not including the character indexed by
<b>:end</b>. By default <b>:start</b> is <b>0</b> (the beginning of the string) and <b>:end</b> is <b>(length
<em>string</em>)</b>. This is the same as for other string functions.
<!--l. 3745--><p class="indent" >   The ﬂag <b>:preserve-whitespace</b>, if provided and not <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, indicates that the
operation should preserve whitespace as for <b><a 
href="symbols.html#x188-375773r773">read-preserving-whitespace</a></b>. It
defaults to <b><a 
href="symbols.html#x188-375658r658">nil</a></b>.
<!--l. 3749--><p class="indent" >   As with other reading functions, the arguments <em>eof-error-p</em> and <em>eof-value</em>
control the action if the end of the (sub)string is reached before the operation is
completed; reaching the end of the string is treated as any other end-of-ﬁle
event.
<b>
<!--l. 3755--><p class="indent" >   <a 
href="symbols.html#x188-375771r771">read-from-string</a></b> returns two values: the ﬁrst is the object read, and the
second is the index of the ﬁrst character in the string not read. If the entire string
was read, the second result will be either the length of the string or one greater
than the length of the string. The parameter <b>:preserve-whitespace</b> may aﬀect
this second value.
<div class="lisp">
<tt>
<!--l. 3762--><p class="indent" >   <div class="tabbing">
(read-from-string &#x0022;(a b c)&#x0022;) <span class="math"> ⇒</span> (a b c) and 7
   <br>
                                                                          

                                                                          
<!--l. 3764--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3768--><p class="noindent" >[Function]</em><a 
 id="dx140-190019"></a> <b>parse-integer</b> <i>string</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;key</a></tt> <i>:start</i> <i>:end</i> <i>:radix</i> <i>:junk-allowed</i>
</div>
<!--l. 3770--><p class="indent" >   This function examines the substring of <em>string</em> delimited by <b>:start</b> and
<b>:end</b> (which default to the beginning and end of the string). It skips
over whitespace characters and then attempts to parse an integer. The
<b>:radix</b> parameter defaults to <b>10</b> and must be an integer between 2 and
36.
<!--l. 3776--><p class="indent" >   If <b>:junk-allowed</b> is not <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, then the ﬁrst value returned is the value of the
number parsed as an integer or <b><a 
href="symbols.html#x188-375658r658">nil</a></b> if no syntactically correct integer was
seen.
<!--l. 3781--><p class="indent" >   If <b>:junk-allowed</b> is <b><a 
href="symbols.html#x188-375658r658">nil</a></b> (the default), then the entire substring is scanned. The
returned value is the value of the number parsed as an integer. An error is
signaled if the substring does not consist entirely of the representation of an
integer, possibly surrounded on either side by whitespace characters.
<!--l. 3787--><p class="indent" >   In either case, the second value is the index into the string of the delimiter
that terminated the parse, or it is the index beyond the substring if the
parse terminated at the end of the substring (as will always be the case if
<b>:junk-allowed</b> is false).
<!--l. 3792--><p class="indent" >   Note that <b><a 
href="symbols.html#x188-375702r702">parse-integer</a></b> does not recognize the syntactic radix-speciﬁer
preﬁxes <b>#O</b>, <b>#B</b>, <b>#X</b>, and <b>#<em>n</em>R</b>, nor does it recognize a trailing decimal point.
It permits only an optional sign (<b><a 
href="symbols.html#x188-375054r54">+</a></b> or <b><a 
href="symbols.html#x188-375057r57">-</a></b>) followed by a non-empty sequence of
digits in the speciﬁed radix.
<hr></div>
<div class="defun">
<div class="defunheader">
<em>
                                                                          

                                                                          
<!--l. 3800--><p class="noindent" >[Function]</em><a 
 id="dx140-190020"></a> <b>read-sequence</b> <i>sequence</i> <i>input-stream</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;key</a></tt> <i>:start</i> <i>:end</i>
</div>
<!--l. 3802--><p class="indent" >   This function reads elements from input-stream into sequence. The position of
the ﬁrst unchanged element of sequence is returned.
<hr></div>
   <h4 class="subsectionHead"><span class="titlemark">22.2.2   </span> <a 
href="frontmatter.html#QQ2-140-229" id="x140-19100022.2.2">Input from Binary Streams</a></h4>
<!--l. 3808--><p class="noindent" >Common Lisp currently speciﬁes only a very simple facility for binary input: the
reading of a single byte as an integer.
<div class="defun">
<div class="defunheader">
<em>
<!--l. 3812--><p class="noindent" >[Function]</em><a 
 id="dx140-191001"></a> <b>read-byte</b> <i>binary-input-stream</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>eof-error-p</i> <i>eof-value</i>
</div>
<b>
<!--l. 3814--><p class="indent" >   <a 
href="symbols.html#x188-375767r767">read-byte</a></b> reads one byte from the <em>binary-input-stream</em> and returns it in the
form of an integer.
<hr></div>
                                                                          

                                                                          
<!--l. 3818--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse114.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse112.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse112.html#tailclmse112.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse113.html" >В-начало</a>&#x003E;&#x003C;<a 
href="io.html#clmse113.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse113.html"></a>
 
</body></html> 
