<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Установка новых связываний переменных</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 16:17:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 6302--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse40.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse38.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse38.html#tailclmse38.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse39.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html#clmse39.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">7.5   </span> <a 
href="clm.html#QQ2-51-545" id="x51-5370007.5">Установка новых
связываний переменных</a></h3>
<!--l. 6305--><p class="noindent" >В течение вызова функции представленной лямбда-выражением (или
замыканием лямбда-выражения возвращённым функцией <tt><a 
href="symbols.html#x187-2604399r399">function</a></tt>),
для переменных параметров лямбда-выражения устанавливаются
новые связывания. Эти связывания первоначально имеют значения
установленные с помощью протокола связывания параметров, описанного
в <a 
href="clmse29.html#x39-2240005.2.2">5.2.2<!--tex4ht:ref: LAMBDA-EXPRESSIONS-SECTION --></a>.
<!--l. 6311--><p class="indent" >   Для установки связываний переменных, обычных и функциональных,
также полезны следующие конструкции.
<div class="defspec">
<div class="defmacheader">
<!--l. 6315--><p class="indent" >   <div class="tabbing">
 <i>[Специальный оператор]</i> <b>let</b> <a 
 id="dx51-537001"></a><a 
 id="x51-537002r79"></a> ({var | (var [value])}*) {declaration}* {form}*
   <br>
<!--l. 6316--><p class="noindent" ></div>
<!--l. 6316--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5380007.5" id="x51-5380007.5"></a></span>
</div>
<!--l. 6317--><p class="indent" >   Форма <tt><a 
href="symbols.html#x187-2604487r487">let</a></tt> может быть использована для связи множества переменных со
значениями соответствующего множества форм.
<!--l. 6320--><p class="indent" >   Если быть точнее, форма <div class="lisp"><div class="tabbing">
(let ((<i>var1</i> <i>value1</i>)
   <br>                                  (<i>var2</i> <i>value2</i>)<br>                                  ...<br>
      (<i>varm</i> <i>valuem</i>))<br>                                       <i>declaration1</i><br>
  <i>declaration2</i><br>                                                          ...<br>
  <i>declarationp</i><br>                                                      <i>body1</i><br>
  <i>body2</i><br>                                                                ...<br>
                                                                          

                                                                          
  <i>bodyn</i>)<br>
<!--l. 6334--><p class="noindent" ></div>
<!--l. 6334--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5390007.5" id="x51-5390007.5"></a></span>
<!--l. 6334--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5400007.5" id="x51-5400007.5"></a></span>
</div>
<!--l. 6335--><p class="indent" >   сначала последовательно выполняет выражения <i>value1</i>, <i>value2</i> и
т.д., сохраняя результаты. Затем все переменные <i>varj</i> параллельно
привязываются к сохранённым значениям. Каждое связывание будет
является лексическим, кроме тех, для которых указана декларация <tt>special</tt>.
Затем последовательно выполняются выражения <i>bodyk</i>. Все из значения,
кроме последнего, игнорируются (другими словами, тело <tt><a 
href="symbols.html#x187-2604487r487">let</a></tt> является
неявным <tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt>). Форма <tt><a 
href="symbols.html#x187-2604487r487">let</a></tt> возвращает значение <i>bodyn</i> (если тело
пустое, что в принципе бесполезно, то <tt><a 
href="symbols.html#x187-2604487r487">let</a></tt> возвращает <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>). Связывания
переменных имеют лексическую область видимости и неограниченную
продолжительность.
<!--l. 6348--><p class="indent" >   Вместо списка <tt>(<i>varj</i> <i>valuej</i>)</tt>, можно записать просто <i>varj</i>. В таком
случае <i>varj</i> инициализируется значением <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>. В целях хорошего стиля
рекомендуется, записывать <i>varj</i> только, если в неё будет что-нибудь записано
(с помощью <tt><a 
href="symbols.html#x187-2604777r777">setq</a></tt> например), перед первым использованием. Если
важно, чтобы первоначальное значение было <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>, вместо некоторого
неопределённого значения, тогда будет лучше записать <tt>(<i>varj</i> <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>)</tt> или
<tt>(<i>varj</i> &#x2019;())</tt>, если значение должно обозначать пустой список. Обратите
внимание, что код <div class="lisp"><div class="tabbing">
(let (x)
   <br>                      (declare (integer x))<br>                      (setq x (gcd y z))<br>
  ...)<br>
<!--l. 6363--><p class="noindent" ></div>
<!--l. 6363--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5410007.5" id="x51-5410007.5"></a></span>
                                                                          

                                                                          
<!--l. 6363--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5420007.5" id="x51-5420007.5"></a></span>
</div>
<!--l. 6364--><p class="indent" >   неправильный. Так как <i>x</i> объявлен без первоначального значения и также
объявлено, что <i>x</i> это целое число, то произойдёт исключение, так как <i>x</i> при
связывании получает <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> значение, которое не принадлежит целочисленному
типу.
<!--l. 6369--><p class="indent" >   Декларации могут использоваться в начале тела <tt><a 
href="symbols.html#x187-2604487r487">let</a></tt>. Смотрите
<tt><a 
href="symbols.html#x187-2604271r271">declare</a></tt>.
<!--l. 6371--><p class="indent" >   Смотрите также <tt><a 
href="symbols.html#x187-2604303r303">destructuring-bind</a></tt>.
</div>
<div class="defspec">
<div class="defmacheader">
<!--l. 6375--><p class="indent" >   <div class="tabbing">
 <i>[Специальный оператор]</i> <b>let*</b> <a 
 id="dx51-542001"></a><a 
 id="x51-542002r80"></a> ({var | (var [value])}*) {declaration}* {form}*
   <br>
<!--l. 6376--><p class="noindent" ></div>
<!--l. 6376--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5430007.5" id="x51-5430007.5"></a></span>
</div>
<tt>
<!--l. 6377--><p class="indent" >   <a 
href="symbols.html#x187-2604488r488">let*</a></tt> похожа на <tt><a 
href="symbols.html#x187-2604487r487">let</a></tt>, но связывания переменных осуществляются
последовательно, а не параллельно. Это позволяет выражениям для значений
переменных ссылаться на ранее связанные переменные.
<!--l. 6381--><p class="indent" >   Если точнее, форма <div class="lisp"><div class="tabbing">
(let* ((<i>var1</i> <i>value1</i>)
   <br>                                 (<i>var2</i> <i>value2</i>)<br>                                 ...<br>
       (<i>varm</i> <i>valuem</i>))<br>                                      <i>declaration1</i><br>
  <i>declaration2</i><br>                                                          ...<br>
  <i>declarationp</i><br>                                                      <i>body1</i><br>
  <i>body2</i><br>                                                                ...<br>
  <i>bodyn</i>)<br>
<!--l. 6395--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 6395--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5440007.5" id="x51-5440007.5"></a></span>
<!--l. 6395--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5450007.5" id="x51-5450007.5"></a></span>
</div>
<!--l. 6396--><p class="indent" >   сначала вычисляет выражение <i>value1</i>, затем с этим значением
связывает переменную <i>var1</i>, затем вычисляет <i>value2</i> и связывает с
результатом переменную <i>var2</i>, и так далее. Затем последовательно
вычисляются выражения <i>bodyj</i>. Значения всех выражений, кроме последнего,
игнорируются. То есть тело формы <tt><a 
href="symbols.html#x187-2604488r488">let*</a></tt> является неявным <tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt>.
Форма <tt><a 
href="symbols.html#x187-2604488r488">let*</a></tt> возвращает результаты вычисления <i>bodyn</i> (если тело
пустое, что, в принципе, бесполезно, <tt><a 
href="symbols.html#x187-2604488r488">let*</a></tt> возвращает <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>). Связывания
переменных имеют лексическую область видимости и неограниченную
продолжительность.
<!--l. 6406--><p class="indent" >   Вместо списка <tt>(<i>varj</i> <i>valuej</i>)</tt>, можно записать просто <i>varj</i>. В таком
случае <i>varj</i> будет инициализирована в <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>. В целях стиля, рекомендуется
записывать <i>varj</i>, только ей будет что-нибудь присвоено с помощью <tt><a 
href="symbols.html#x187-2604777r777">setq</a></tt>
перед первым использованием. Если необходимо инициализировать
переменную значением <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>, а не неопределённым, лучше писать <tt>(<i>varj</i> <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>)</tt>
для инициализации «ложью» или <tt>(<i>varj</i> &#x2019;())</tt> для инициализации пустым
списком.
<!--l. 6416--><p class="indent" >   В начале тела <tt>let*</tt> могут использоваться декларации. Смотрите
<tt><a 
href="symbols.html#x187-2604271r271">declare</a></tt>.
</div>
<div class="defspec">
<div class="defmacheader">
<!--l. 6420--><p class="indent" >   <div class="tabbing">
 <i>[Специальный оператор]</i> <b>progv</b> <a 
 id="dx51-545001"></a><a 
 id="x51-545002r81"></a> symbols values {form}*
   <br>
<!--l. 6421--><p class="noindent" ></div>
<!--l. 6421--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5460007.5" id="x51-5460007.5"></a></span>
</div>
<tt>
<!--l. 6422--><p class="indent" >   <a 
href="symbols.html#x187-2604700r700">progv</a></tt> является специальной формой, которая позволяет создавать
                                                                          

                                                                          
связывания одной и более динамических переменных, чьи имена
устанавливаются во время выполнения. Последовательность форм (неявный
<tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt>) выполняется с динамическими переменными, что имена в списке
<i>symbols</i> связаны с соответствующими значениями в списке <i>values</i>. (Если
значений меньше, чем переменных, то соответствующие переменные
получают соответствующие значения, а оставшиеся остаются без значений.
Смотрите <tt><a 
href="symbols.html#x187-2604554r554">makunbound</a></tt>. Если значений больше, чем переменных, они
игнорируются.) Результатом <tt><a 
href="symbols.html#x187-2604700r700">progv</a></tt> является результат последней формы.
Связывания динамических переменных упраздняются при выходе из формы
<tt><a 
href="symbols.html#x187-2604700r700">progv</a></tt>. Списки переменных и значений это вычисляемые значения. Это то,
что отличает <tt><a 
href="symbols.html#x187-2604700r700">progv</a></tt> от, например, <tt><a 
href="symbols.html#x187-2604487r487">let</a></tt>, в которой имена переменных
указываются явно в тексте программы.
<tt>
<!--l. 6436--><p class="indent" >   <a 
href="symbols.html#x187-2604700r700">progv</a></tt> полезна, в частности, для написания интерпретаторов языков
встраиваемых в Lisp. Она предоставляет управление механизмом связывания
динамических переменных.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6442--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>ﬂet</b> <a 
 id="dx51-546001"></a><a 
 id="x51-546002r82"></a> ({(name lambda-list
   <br>                                       [[{declaration}* | doc-string]] {form}*)}*)<br>
   {declaration}* {form}*<br>
<!--l. 6444--><p class="noindent" ></div>
<!--l. 6444--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5470007.5" id="x51-5470007.5"></a></span>
</div>
<div class="defmacheader">
<!--l. 6444--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>labels</b> <a 
 id="dx51-547001"></a><a 
 id="x51-547002r83"></a> ({(name lambda-list
   <br>                                       [[{declaration}* | doc-string]] {form}*)}*)<br>
   {declaration}* {form}*<br>
                                                                          

                                                                          
<!--l. 6447--><p class="noindent" ></div>
<!--l. 6447--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5480007.5" id="x51-5480007.5"></a></span>
</div>
<div class="defmacheader">
<!--l. 6447--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>macrolet</b> <a 
 id="dx51-548001"></a><a 
 id="x51-548002r84"></a> ({(name varlist
   <br>                                       [[{declaration}* | doc-string]] {form}*)}*)<br>
   {declaration}* {form}*<br>
<!--l. 6451--><p class="noindent" ></div>
<!--l. 6451--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5490007.5" id="x51-5490007.5"></a></span>
</div>
<tt>
<!--l. 6452--><p class="indent" >   <a 
href="symbols.html#x187-2604379r379">flet</a></tt> может быть использована для определения локальных именованных
функций. Внутри тела формы <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt>, имена функций, совпадающие с именами
определёнными в <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt>, ссылаются на локально определённые функции, а не
на глобальные определения функции с теми же именами.
<!--l. 6457--><p class="indent" >   Может быть определено любое количество функций. Каждое определение
осуществляется формате, как в форме <tt><a 
href="symbols.html#x187-2604291r291">defun</a></tt>: сначала имя, затем список
параметров (который может содержать <tt>&#x0026;optional</tt>, <tt>&#x0026;rest</tt> или <tt>&#x0026;key</tt>
параметры), затем необязательные декларации и строка документации, и,
наконец, тело. <div class="lisp"><div class="tabbing">
(ﬂet ((safesqrt (x) (sqrt (abs x))))
   <br>                            ;; Функция safesqrt используется в двух местах.<br>
  (safesqrt (apply #&#x2019;+ (map &#x2019;list #&#x2019;safesqrt longlist))))<br>
<!--l. 6466--><p class="noindent" ></div>
<!--l. 6466--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5500007.5" id="x51-5500007.5"></a></span>
                                                                          

                                                                          
<!--l. 6466--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5510007.5" id="x51-5510007.5"></a></span>
</div>
<!--l. 6468--><p class="indent" >   Конструкция <tt><a 
href="symbols.html#x187-2604461r461">labels</a></tt> идентична по форме конструкции <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt>. Эти
конструкции различаются в том, что область видимости определённых
функций для <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt> заключена только в теле, тогда как видимость в <tt><a 
href="symbols.html#x187-2604461r461">labels</a></tt>
охватывает даже определения этих функций. Это значит, что <tt><a 
href="symbols.html#x187-2604461r461">labels</a></tt> может
быть использована для определения взаимно рекурсивных функций, а <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt>
не может. Это различие бывает полезно. Использование <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt> может локально
переопределить глобальную функцию, и новое определение может ссылаться
на глобальное. Однако такая же конструкция <tt><a 
href="symbols.html#x187-2604461r461">labels</a></tt> не будет обладать этим
свойством. <div class="lisp"><div class="tabbing">
(defun integer-power (n k)       ; Быстрое возведение
   <br>                  (declare (integer n))          ; целого числа в степень<br>
  (declare (type (integer 0 *) k))<br>                    (labels ((expt0 (x k a)<br>
             (declare (integer x a) (type (integer 0 *) k))<br>
             (cond ((zerop k) a)<br>
                   ((evenp k) (expt1 (* x x) (ﬂoor k 2) a))<br>
                   (t (expt0 (* x x) (ﬂoor k 2) (* x a)))))<br>
           (expt1 (x k a)<br>
             (declare (integer x a) (type (integer 1 *) k))<br>
             (cond ((evenp k) (expt1 (* x x) (ﬂoor k 2) a))<br>
                   (t (expt0 (* x x) (ﬂoor k 2) (* x a))))))<br>
    (expt0 n k 1)))<br>
<!--l. 6491--><p class="noindent" ></div>
<!--l. 6491--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5520007.5" id="x51-5520007.5"></a></span>
<!--l. 6491--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5530007.5" id="x51-5530007.5"></a></span>
</div>
<tt>
<!--l. 6493--><p class="indent" >   <a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> похожа на форму <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt>, но определяет локальные макросы,
используя тот же формат записи, что и <tt><a 
href="symbols.html#x187-2604284r284">defmacro</a></tt>. Имена для макросов,
установленные с помощью <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt>, имеют лексическую область
видимости.
                                                                          

                                                                          
<div class="new">
<!--l. 6499--><p class="indent" >   I have observed that, while most Common Lisp users pronounce <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> to
rhyme with “silhouette,” a small but vocal minority pronounce it to rhyme with
“Chevrolet.” A very few extremists furthermore adjust their pronunciation of <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt>
similarly: they say “ﬂay.” Hey, hey! <i>Tr`es outr´e.</i>
</div>
<!--l. 6507--><p class="indent" >   Макросы часто должны быть раскрыты во «время компиляции» (общими
словами, во время перед тем, как сама программа будет выполнена), таким
образом, значения переменных во время выполнения не доступны для
макросов, определённых с помощью <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt>.
<div class="newer">
<!--l. 6513--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx51-553001"></a>to retract the previous sentence and specify that
the macro-expansion functions created by <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> are deﬁned in the lexical
environment in which the <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> form appears, not in the null lexical
environment. Declarations, <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> deﬁnitions, and <tt><a 
href="symbols.html#x187-2604861r861">symbol-macrolet</a></tt>
deﬁnitions aﬀect code within the expansion functions in a <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt>, but the
consequences are undeﬁned if such code attempts to refer to any local variable or
function bindings that are visible in that lexical environment.
</div>
<!--l. 6524--><p class="indent" >   Однако, сущности, имеющие лексическую область видимости, <i>видны</i>
внутри тела формы <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> и <i>видны</i> в коде, который является результатом
раскрытия макровызова. Следующий пример должен помочь в понимании:
<div class="lisp"><div class="tabbing">
;;; Пример macrolet.
   <br>                                                                                               <br>
(defun foo (x ﬂag)<br>                                   (macrolet ((fudge (z)<br>
                ;;Параметры <tt>x</tt> и <tt>flag</tt> в данной точке<br>
                ;; недоступны; ссылка на <tt>flag</tt> была бы<br>
                ;; одноимённую глобальную переменную.<br>
                ‘(if ﬂag<br>                                     (* ,z ,z)<br>
                     ,z)))<br>     ;;Параметры <tt>x</tt> и <tt>flag</tt> доступны здесь.<br>
    (+ x<br>                                                       (fudge x)<br>
       (fudge (+ x 1)))))<br>
<!--l. 6542--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 6542--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5540007.5" id="x51-5540007.5"></a></span>
<!--l. 6542--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5550007.5" id="x51-5550007.5"></a></span>
</div>
<!--l. 6543--><p class="indent" >   Тело данного примера после разворачивания макросов превращается в
<div class="lisp"><div class="tabbing">
(+ x
   <br>                                                                                     (if ﬂag<br>
       (* x x)<br>                                                       x))<br>
   (if ﬂag<br>                                            (* (+ x 1) (+ x 1))<br>
       (+ x 1)))<br>
<!--l. 6552--><p class="noindent" ></div>
<!--l. 6552--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5560007.5" id="x51-5560007.5"></a></span>
<!--l. 6552--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5570007.5" id="x51-5570007.5"></a></span>
</div>
<tt>
<!--l. 6553--><p class="indent" >   x</tt> и <tt>flag</tt> легитимно ссылаются на параметры функции <tt>foo</tt>, потому что
эти параметры видимы в месте макровызова.
<div class="newer">
<!--l. 6557--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx51-557001"></a>to specify that the body of each function or
expander function deﬁned by <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt>, <tt><a 
href="symbols.html#x187-2604461r461">labels</a></tt>, or <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> is implicitly enclosed in
a <tt><a 
href="symbols.html#x187-2604128r128">block</a></tt> construct whose name is the same as the <i>name</i> of the function. Therefore
<tt><a 
href="symbols.html#x187-2604750r750">return-from</a></tt> may be used to exit from the function.
</div>
<div class="newer">
<!--l. 6566--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx51-557002"></a>to extend <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt> and <tt><a 
href="symbols.html#x187-2604461r461">labels</a></tt> to accept any
function-name (a symbol or a list whose <i>car</i> is <tt><a 
href="symbols.html#x187-2604776r776">setf</a></tt>—see section <a 
href="clmse35.html#x47-3850007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>) as a <i>name</i>
for a function to be locally deﬁned. In this way one can create local deﬁnitions for
<tt><a 
href="symbols.html#x187-2604776r776">setf</a></tt> expansion functions. (X3J13 explicitly declined to extend <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> in the
same manner.)
                                                                          

                                                                          
</div>
<div class="new">
<!--l. 6575--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx51-557003"></a>to change <tt><a 
href="symbols.html#x187-2604379r379">flet</a></tt>, <tt><a 
href="symbols.html#x187-2604461r461">labels</a></tt>, and <tt><a 
href="symbols.html#x187-2604531r531">macrolet</a></tt> to allow
declarations to appear before the body. The new descriptions are therefore as
follows:
</div>
</div>
<div class="defspec">
<div class="defmacheader">
<!--l. 6584--><p class="indent" >   <div class="tabbing">
 <i>[Специальный оператор]</i> <b>symbol-macrolet</b> <a 
 id="dx51-557004"></a><a 
 id="x51-557005r85"></a> ({(var expansion)}*)
   <br>                                                               {declaration}* {form}*<br>
<!--l. 6586--><p class="noindent" ></div>
<!--l. 6586--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5580007.5" id="x51-5580007.5"></a></span>
</div>
<!--l. 6587--><p class="indent" >   X3J13 проголосовал в июне 1988 <a 
 id="dx51-558001"></a>адаптировать Common Lisp&#x2019;овую систему
объектов (CLOS). Часть этого является общий механизм, <tt><a 
href="symbols.html#x187-2604861r861">symbol-macrolet</a></tt>,
для обработки заданных имён переменным, как если бы они были
макровызовами без параметров. Эта функциональность полезно независимо
от CLOS.
<!--l. 6594--><p class="indent" >   Формы <i>forms</i> выполняются как неявный <tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt> в лексическом окружении,
в котором любая ссылка на обозначенную переменную <i>var</i> будет заменена на
соответствующее выражение <i>expansion</i>. Это происходит, как будто ссылка на
переменную <i>var</i> является макровызовом без параметров. Выражение
<i>expansion</i> вычисляется или обрабатывается в месте появления ссылки.
Однако, следует отметить, что имена таких макросимволов работает в
пространстве имен переменных, не в пространстве функций. Использование
<tt><a 
href="symbols.html#x187-2604861r861">symbol-macrolet</a></tt> может быть в свою очередь перекрыто с помощью
<tt><a 
href="symbols.html#x187-2604487r487">let</a></tt> или другой конструкцией, связывающей переменные. Например:
<div class="lisp"><div class="tabbing">
(symbol-macrolet ((pollyanna &#x2019;goody))
                                                                          

                                                                          
   <br>                   (list pollyanna (let ((pollyanna &#x2019;two-shoes)) pollyanna)))<br>
 <span class="math"> ⇒</span> (goody two-shoes), <i>not</i> (goody goody)<br>
<!--l. 6607--><p class="noindent" ></div>
<!--l. 6607--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5590007.5" id="x51-5590007.5"></a></span>
<!--l. 6607--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5600007.5" id="x51-5600007.5"></a></span>
</div>
<!--l. 6609--><p class="indent" >   Выражение <i>expansion</i> для каждой переменной <i>var</i> вычисляется не во
время связывания, а во время подстановки вместо ссылок на <i>var</i>.
Конструкция возвращает значения последней вычисленной формы, или <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>,
если таких значений не было.
<!--l. 6614--><p class="indent" >   Смотрите документация <tt><a 
href="symbols.html#x187-2604529r529">macroexpand</a></tt> и <tt><a 
href="symbols.html#x187-2604530r530">macroexpand-1</a></tt>. Они раскрывают
макросы символов, также как и обычные макросы.
<!--l. 6617--><p class="indent" >   Указанные декларации <i>declarations</i> перед телом обрабатываются так как
описано в разделе <a 
href="clmse51.html#x65-7610009.1">9.1<!--tex4ht:ref: DECLARE-SYNTAX-SECTION --></a>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6623--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>deﬁne-symbol-macro</b> <a 
 id="dx51-560001"></a><a 
 id="x51-560002r86"></a> symbol {form}
   <br>
<!--l. 6624--><p class="noindent" ></div>
<!--l. 6624--><p class="noindent" ><span class="paragraphHead"><a 
href="#x51-5610007.5" id="x51-5610007.5"></a></span>
</div>
<!--l. 6625--><p class="indent" >   Символ <i>symbol</i> выступает в качестве макровызова. Одинарная форма
содержит тело раскрытия. Символы не может являться определённой
специальной переменной.
</div>
                                                                          

                                                                          
<!--l. 6630--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse40.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse38.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse38.html#tailclmse38.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse39.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html#clmse39.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse39.html"></a>   </div> </div> 
</body></html> 
