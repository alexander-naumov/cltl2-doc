<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Информация о массиве</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 1300--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse94.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse92.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse92.html#tailclmse92.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse93.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="array.html#clmse93.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">17.3   </span> <a 
href="clm.html#QQ2-115-1407" id="x115-137700017.3">Информация о
массиве</a></h3>
<!--l. 1302--><p class="noindent" >Следующие функции извлекают интересную информацию, и это не элементы
массива.
<div class="defun">
<!--l. 1305--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx115-1377001"></a><a 
 id="x115-1377002r529"></a> <b>array-element-type</b>  <i>array</i>
</div>
<tt>
<!--l. 1308--><p class="indent" >   <a 
href="symbols.html#x185-2605094r94">array-element-type</a></tt> возвращает спецификатор типа для множества
объектов, которые могут быть сохранены в массиве <i>array</i>. Это множество
может быть больше чем то, которое запрашивалось в функции <tt><a 
href="symbols.html#x185-2605533r533">make-array</a></tt>.
Например, результат <div class="lisp"><div class="tabbing">
(array-element-type (make-array 5 :element-type &#x2019;(mod 5)))
   <br>
<!--l. 1314--><p class="noindent" ></div>
<!--l. 1314--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-137800017.3" id="x115-137800017.3"></a></span>
<!--l. 1314--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-137900017.3" id="x115-137900017.3"></a></span>
</div>
<!--l. 1315--><p class="indent" >   может быть <tt>(mod 5)</tt>, <tt>(mod 8)</tt>, <tt>fixnum</tt>, <tt><a 
href="symbols.html#x185-2605871r871">t</a></tt> или любой другой тип, для
которого <tt>(mod 5)</tt> является подтипом. Смотрите <tt><a 
href="symbols.html#x185-2605858r858">subtypep</a></tt>.
</div>
<div class="defun">
<!--l. 1319--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx115-1379001"></a><a 
 id="x115-1379002r530"></a> <b>array-rank</b>  <i>array</i>
                                                                          

                                                                          
</div>
<!--l. 1322--><p class="indent" >   Эта функция возвращает количество измерений (осей) массива <i>array</i>.
Результат будет неотрицательным целым. Смотрите <tt><a 
href="symbols.html#x185-2605098r98">array-rank-limit</a></tt>.
</div>
<div class="defun">
<!--l. 1327--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx115-1379003"></a><a 
 id="x115-1379004r531"></a> <b>array-dimension</b>  <i>array</i> <i>axis-number</i>
</div>
<!--l. 1330--><p class="indent" >   Данная функция возвращает размер измерения <i>axis-number</i> массива <i>array</i>.
<i>array</i> может быть любым видом массива, и <i>axis-number</i> должен быть
неотрицательным целым меньшим чем ранг массива <i>array</i>. Если <i>array</i>
является вектором с указателем заполнения, <tt><a 
href="symbols.html#x185-2605090r90">array-dimension</a></tt> возвращает
общий размер вектора, включая неактивные элементы, а не размер
ограниченный указателем заполнения. (Функция <tt><a 
href="symbols.html#x185-2605487r487">length</a></tt> будет возвращать
размер ограниченный указателем заполнения.)
</div>
<div class="defun">
<!--l. 1341--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx115-1379005"></a><a 
 id="x115-1379006r532"></a> <b>array-dimensions</b>  <i>array</i>
</div>
<tt>
<!--l. 1344--><p class="indent" >   <a 
href="symbols.html#x185-2605092r92">array-dimensions</a></tt> возвращает список, элементы которого являются
размерами измерений массива <i>array</i>.
</div>
<div class="defun">
<!--l. 1348--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx115-1379007"></a><a 
 id="x115-1379008r533"></a> <b>array-total-size</b>  <i>array</i>
</div>
<tt>
<!--l. 1351--><p class="indent" >   <a 
href="symbols.html#x185-2605100r100">array-total-size</a></tt> возвращает общее количество элементов массива
<i>array</i>, которое вычислено как произведение размеров всех измерений.
<div class="lisp"><div class="tabbing">
(array-total-size <i>x</i>)
                                                                          

                                                                          
   <br>                                             <span class="math"> ≡</span> (apply #&#x2019;* (array-dimensions <i>x</i>))<br>
   <span class="math"> ≡</span> (reduce #&#x2019;* (array-dimensions <i>x</i>))<br>
<!--l. 1357--><p class="noindent" ></div>
<!--l. 1357--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-138000017.3" id="x115-138000017.3"></a></span>
<!--l. 1357--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-138100017.3" id="x115-138100017.3"></a></span>
</div>
<!--l. 1358--><p class="indent" >   Следует отметить, что общий размер нульмерного (FIXME) массива равен
<tt>1</tt>. Общий размер одномерного массива вычисляется без учёта указателя
заполнения.
</div>
<div class="defun">
<!--l. 1362--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx115-1381001"></a><a 
 id="x115-1381002r534"></a> <b>array-in-bounds-p</b>  <i>array</i> <b>&#x0026;rest</b>  <i>subscripts</i>
</div>
<!--l. 1365--><p class="indent" >   Данный предикат проверяет, являются ли индексы <i>subscripts</i> для массива
<i>array</i> корректными. Если они корректны, предикат истинен, иначе ложен.
<i>subscripts</i> должен быть целыми числами. Количество индексов <i>subscripts</i>
должно равняться рангу массива. Как и <tt><a 
href="symbols.html#x185-2605085r85">aref</a></tt>, <tt><a 
href="symbols.html#x185-2605096r96">array-in-bounds-p</a></tt> игнорирует
указатели заполнения.
</div>
<div class="defun">
<!--l. 1373--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx115-1381003"></a><a 
 id="x115-1381004r535"></a> <b>array-row-major-index</b>  <i>array</i> <b>&#x0026;rest</b>  <i>subscripts</i>
</div>
<!--l. 1376--><p class="indent" >   Данная функция принимает массив и корректные для него индексы и
возвращает одиночное неотрицательное целое значение меньшее чем
общий размер массива, которое идентифицирует элемент, полагаясь на
построчный порядок хранения элементов. Количество указанных индексов
<i>subscripts</i> должно равняться рангу массива. Каждый индекс должен быть
неотрицательным целым числом меньшим чем соответствующий размер
измерения. Как и <tt><a 
href="symbols.html#x185-2605085r85">aref</a></tt>, <tt><a 
href="symbols.html#x185-2605099r99">array-row-major-index</a></tt> игнорирует указатели
заполнения.
                                                                          

                                                                          
<!--l. 1385--><p class="indent" >   Возможно определение <tt><a 
href="symbols.html#x185-2605099r99">array-row-major-index</a></tt>, без проверки на ошибки,
может выглядеть так: <div class="lisp"><div class="tabbing">
(defun array-row-major-index (a <tt>&#x0026;rest</tt> subscripts)
   <br>                                            (apply #&#x2019;+ (maplist #&#x2019;(lambda (x y)<br>
                          (* (car x) (apply #&#x2019;* (cdr y))))<br>
                      subscripts<br>
                      (array-dimensions a))))<br>
<!--l. 1393--><p class="noindent" ></div>
<!--l. 1393--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-138200017.3" id="x115-138200017.3"></a></span>
<!--l. 1393--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-138300017.3" id="x115-138300017.3"></a></span>
</div>
<!--l. 1394--><p class="indent" >   Для одномерного массива, результат <tt><a 
href="symbols.html#x185-2605099r99">array-row-major-index</a></tt> всегда равен
переданному индексу.
</div>
<div class="defun">
<!--l. 1398--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx115-1383001"></a><a 
 id="x115-1383002r536"></a> <b>row-major-aref</b>  <i>array</i> <i>index</i>
</div>
<!--l. 1401--><p class="indent" >   Данная функция позволяет получить доступ к элементу, как если бы
массив был одномерный. Аргумент <i>index</i> должен быть неотрицательным
целым меньшим чем общий размер массива <i>array</i>. Данная функция
индексирует массив, как если бы он был одномерный с построчным
порядком. Эту функцию можно понять в терминах <tt><a 
href="symbols.html#x185-2605085r85">aref</a></tt>: <div class="lisp"><div class="tabbing">
(row-major-aref <i>array</i> <i>index</i>) <span class="math"> ≡</span>
   <br>                  (aref (make-array (array-total-size array))<br>
                    :displaced-to array<br>
                    :element-type (array-element-type array))<br>
        index)<br>
<!--l. 1413--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1413--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-138400017.3" id="x115-138400017.3"></a></span>
<!--l. 1413--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-138500017.3" id="x115-138500017.3"></a></span>
</div>
<!--l. 1414--><p class="indent" >   Другими словами, можно обработать массив как одномерный с помощью
создания нового одномерного массива, который <i>соединён</i> с исходным, и
получить доступ к новому массиву. И наоборот, <tt><a 
href="symbols.html#x185-2605085r85">aref</a></tt> может быть описана в
терминах <tt><a 
href="symbols.html#x185-2605758r758">row-major-aref</a></tt>: <div class="lisp"><div class="tabbing">
(aref <i>array</i> <span class="math"><i>i</i><sub>0</sub></span> <span class="math"><i>i</i><sub>1</sub></span> ... <span class="math"><i>i</i><sub>n−1</sub></span>) <span class="math"> ≡</span>
   <br>                             (row-major-aref array<br>
                  (array-row-major-index array <span class="math"><i>i</i><sub>0</sub></span> <span class="math"><i>i</i><sub>1</sub></span> ... <span class="math"><i>i</i><sub>n−1</sub></span>)<br>
<!--l. 1422--><p class="noindent" ></div>
<!--l. 1422--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-138600017.3" id="x115-138600017.3"></a></span>
<!--l. 1422--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-138700017.3" id="x115-138700017.3"></a></span>
</div>
<!--l. 1424--><p class="indent" >   Как и <tt><a 
href="symbols.html#x185-2605085r85">aref</a></tt>, <tt><a 
href="symbols.html#x185-2605758r758">row-major-aref</a></tt> полностью игнорирует указатели
заполнения. Для изменения элемента массива, можно комбинировать вызов
<tt><a 
href="symbols.html#x185-2605758r758">row-major-aref</a></tt> с формой <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>.
<!--l. 1429--><p class="indent" >   Эта операция облегчает написание кода, который обрабатывает массивы
различных рангов. Предположим, что необходимо обнулить содержимое
массива <tt>tennis-scores</tt>. Можно решить это так: <div class="lisp"><div class="tabbing">
(ﬁll (make-array (array-total-size tennis-scores)
   <br>                     :element-type (array-element-type tennis-scores)<br>
                  :displaced-to tennis-scores)<br>                        0)<br>
<!--l. 1437--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1437--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-138800017.3" id="x115-138800017.3"></a></span>
<!--l. 1437--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-138900017.3" id="x115-138900017.3"></a></span>
</div>
<!--l. 1438--><p class="indent" >   К сожалению, так как <tt><a 
href="symbols.html#x185-2605365r365">fill</a></tt> не может принимать многомерные массивы, в
данном примере создаётся <i>соединённый</i> массив, что является лишней
операцией. Другим способом является отдельная обработка каждого
измерения многомерного массива: <div class="lisp"><div class="tabbing">
(ecase (array-rank tennis-scores)
   <br>                                                      (0 (setf (aref tennis-scores) 0))<br>
  (1 (dotimes (i0 (array-dimension tennis-scores 0))<br>
       (setf (aref tennis-scores i0) 0)))<br>  (2 (dotimes (i0 (array-dimension tennis-scores 0))<br>
       (dotimes (i1 (array-dimension tennis-scores 1))<br>
         (setf (aref tennis-scores i0 i1) 0))))<br>                            ...<br>
  (7 (dotimes (i0 (array-dimension tennis-scores 0))<br>
       (dotimes (i1 (array-dimension tennis-scores 1))<br>
         (dotimes (i2 (array-dimension tennis-scores 1))<br>
           (dotimes (i3 (array-dimension tennis-scores 1))<br>
             (dotimes (i4 (array-dimension tennis-scores 1))<br>
               (dotimes (i5 (array-dimension tennis-scores 1))<br>
                 (dotimes (i6 (array-dimension tennis-scores 1))<br>
                   (setf (aref tennis-scores i0 i1 i2 i3 i4 i5 i6)<br>
                         0)))))))))<br>                                   )<br>
<!--l. 1461--><p class="noindent" ></div>
<!--l. 1461--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-139000017.3" id="x115-139000017.3"></a></span>
<!--l. 1461--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-139100017.3" id="x115-139100017.3"></a></span>
</div>
<!--l. 1462--><p class="indent" >   От такого кода быстро приходит усталость. Кроме того, данный подход
не желателен, так как некоторые реализации Common Lisp&#x2019;а будут
фактически поддерживать не более 7 измерений. Рекурсивно вложенные
                                                                          

                                                                          
циклы справляются с задачей лучше, но код всё ещё выглядит как лапша:
<div class="lisp"><div class="tabbing">
(labels
   <br>                                                     ((grok-any-rank (&#x0026;rest indices)<br>
     (let ((d (- (array-rank tennis-scores) (length indices)))<br>
       (if (= d 0)<br>              (setf (apply #&#x2019;row-major-aref indices) 0)<br>
           (dotimes (i (array-dimension tennis-scores (- d 1)))<br>
             (apply #&#x2019;grok-any-rank i indices))))))<br>     (grok-any-rank))<br>
<!--l. 1475--><p class="noindent" ></div>
<!--l. 1475--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-139200017.3" id="x115-139200017.3"></a></span>
<!--l. 1475--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-139300017.3" id="x115-139300017.3"></a></span>
</div>
<!--l. 1476--><p class="indent" >   Является ли этот код эффективным зависит от многих параметров
реализации, таких как способ обработки <tt>&#x0026;rest</tt> аргументов и компиляции
<tt><a 
href="symbols.html#x185-2605081r81">apply</a></tt> вызовов. Только посмотрите как просто использовать для задачи
<tt><a 
href="symbols.html#x185-2605758r758">row-major-aref</a></tt>! <div class="lisp"><div class="tabbing">
(dotimes (i (array-total-size tennis-scores))
   <br>                                         (setf (row-major-aref tennis-scores i) 0))<br>
<!--l. 1482--><p class="noindent" ></div>
<!--l. 1482--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-139400017.3" id="x115-139400017.3"></a></span>
<!--l. 1482--><p class="noindent" ><span class="paragraphHead"><a 
href="#x115-139500017.3" id="x115-139500017.3"></a></span>
</div>
<!--l. 1483--><p class="indent" >   Нет сомнения, что этот код, слаще любых медовых сот.
</div>
                                                                          

                                                                          
<div class="defun">
<!--l. 1486--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx115-1395001"></a><a 
 id="x115-1395002r537"></a> <b>adjustable-array-p</b>  <i>array</i>
</div>
<!--l. 1489--><p class="indent" >   Если аргумент, который должен быть массивом, может быть расширен,
данный предикат истинен, иначе ложен.
<div class="newer">
<!--l. 1493--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx115-1395003"></a>to clarify that <tt><a 
href="symbols.html#x185-2605074r74">adjustable-array-p</a></tt> is true of
an array if and only if <tt><a 
href="symbols.html#x185-2605073r73">adjust-array</a></tt>, when applied to that array, will
return the same array, that is, an array <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt> to the original array. If the
<tt>:adjustable</tt> argument to <tt><a 
href="symbols.html#x185-2605533r533">make-array</a></tt> is non-<tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> when an array is created, then
<tt><a 
href="symbols.html#x185-2605074r74">adjustable-array-p</a></tt> must be true of that array. If an array is created with the
<tt>:adjustable</tt> argument <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> (or omitted), then <tt><a 
href="symbols.html#x185-2605074r74">adjustable-array-p</a></tt> may
be true or false of that array, depending on the implementation. X3J13
further voted to <i>deﬁne</i> the terminology “adjustable array” to mean precisely
“an array of which <tt><a 
href="symbols.html#x185-2605074r74">adjustable-array-p</a></tt> is true.” See <tt><a 
href="symbols.html#x185-2605533r533">make-array</a></tt> and
<tt><a 
href="symbols.html#x185-2605073r73">adjust-array</a></tt>.
</div>
</div>
<div class="defun">
<!--l. 1511--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx115-1395004"></a><a 
 id="x115-1395005r538"></a> <b>array-displacement</b>  <i>array</i>
</div>
<!--l. 1514--><p class="indent" >   функция возвращает два значение. Первое значение является массивом
соединенным с данным, и второе значение обозначает смещение соединения.
Если массив не был соединен ни с одним массивом возвращаются значения
<tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> и <tt>0</tt>.
</div>
                                                                          

                                                                          
<!--l. 1519--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse94.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse92.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse92.html#tailclmse92.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse93.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="array.html#clmse93.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse93.html"></a>   </div> </div> 
</body></html> 
