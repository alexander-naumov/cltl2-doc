<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Точность, неявное приведение и явное приведение</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 16:17:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 3746--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse65.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html#tailnumber.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse64.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html#clmse64.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">12.1   </span> <a 
href="clm.html#QQ2-81-934" id="x81-92500012.1">Точность, неявное
приведение и явное приведение</a></h3>
<!--l. 3749--><p class="noindent" >Вычисления с числами с плавающей точкой являются приблизительными.
<i>Точность</i> чисел с плавающей точкой не обязательно коррелирует с
<i>«аккуратностью»</i> числа. Например, 3.142857142857142857 имеет более точное
приближение к <span class="math">pi</span> чем 3.14159, но последнее число более «аккуратно».
Точность указывает на количество бит используемых при представлении
числа. Если операция объединяла числа с плавающей точкой короткого
формата и длинного, то результат будет иметь длинный формат. Это
правило создано для уверенности, что при вычислениях аккуратности
будет как можно больше. Однако это не гарантированно. Однако,
численные процедуры Common Lisp&#x2019;а предполагают, что аккуратность
аргумента не превышает его точность. Поэтому, когда объединяются
два числа с плавающей точкой небольшой точности, результатом
всегда будет число с плавающей точкой небольшой точности. Это
предположение может быть изменено первым же явным преобразованием
число с плавающей точкой в более точное представление. (Common
Lisp никогда не преобразует числа из более точного формата в менее
точный.)
                                                                          

                                                                          
<!--l. 3767--><p class="indent" >   Вычисления рациональных чисел не может вызвать переполнения в
обычном смысле этого слова (хотя, конечно, может быть возникнуть
недостаток места для представления), целые и дробные числа в принципе
могут быть любой величины. Вычисления с плавающей точкой могут вызвать
переполнение экспоненты. Это является ошибкой.
<div class="newer">
<!--l. 3774--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx81-925001"></a>to address certain problems relating to ﬂoating-point
overﬂow and underﬂow, but certain parts of the proposed solution were not
adopted, namely to add the macro <tt>without-floating-underflow-traps</tt> to the
language and to require certain behavior of ﬂoating-point overﬂow and underﬂow.
The committee agreed that this area of the language requires more discussion
before a solution is standardized.
<!--l. 3782--><p class="indent" >   For the record, the proposal that was considered and rejected (for the nonce)
introduced a macro <tt>without-floating-underflow-traps</tt> that would execute its
body in such a way that, within its dynamic extent, a ﬂoating-point underﬂow
must not signal an error but instead must produce either a denormalized number
or zero as the result. The rejected proposal also speciﬁed the following treatment
of overﬂow and underﬂow:
      <ul class="itemize1">
      <li class="itemize">A ﬂoating-point computation that overﬂows should signal an error of
      type <tt><a 
href="symbols.html#x187-2604385r385">floating-point-overflow</a></tt>.
      </li>
      <li class="itemize">Unless
      the dynamic extent of a use of <tt>without-floating-underflow-traps</tt>,
      a ﬂoating-point computation that underﬂows should signal an error
      of type <tt><a 
href="symbols.html#x187-2604386r386">floating-point-underflow</a></tt>. A result that can be represented
      only  in  denormalized  form  must  be  considered  an  underﬂow  in
      implementations that support denormalized ﬂoating-point numbers.</li></ul>
<!--l. 3800--><p class="noindent" >These points refer to conditions <tt><a 
href="symbols.html#x187-2604385r385">floating-point-overflow</a></tt> and
<tt><a 
href="symbols.html#x187-2604386r386">floating-point-underflow</a></tt> that were approved by X3J13 and are described in
section <a 
href="clmse151.html#x184-259900028.5">28.5<!--tex4ht:ref: PREDEFINED-CONDITIONS-SECTION --></a>.
</div>
<!--l. 3806--><p class="indent" >   Когда числовой функцией между собой сравниваются или объединяются
рациональное и число с плавающей точкой, то вступает в силу правило
<i>неявного приведения к плавающей точке</i>. Когда рациональное встречает
число с плавающей точкой, то рациональное преобразуется в тот же
                                                                          

                                                                          
формат второго числа. Для функций, например <tt><a 
href="symbols.html#x187-2604051r51">+</a></tt>, которые принимает
более двух аргументов, может быть, что все рациональные будут
вычислены и результат будет преобразован в число с плавающей
точкой.
<div class="new">
<!--l. 3816--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx81-925002"></a>to apply the rule of ﬂoating-point contagion
stated above to the case of <i>combining</i> rational and ﬂoating-point numbers. For
<i>comparing</i>, the following rule is to be used instead: When a rational number and a
ﬂoating-point number are to be compared by a numerical function, in eﬀect the
ﬂoating-point number is ﬁrst converted to a rational number as if by the function
<tt>rational</tt>, and then an exact comparison of two rational numbers is performed. It
is of course valid to use a more eﬃcient implementation than actually calling the
function <tt>rational</tt>, as long as the result of the comparison is the same. In
the case of complex numbers, the real and imaginary parts are handled
separately.________________________________________________________________<div class="rationale">
<!--l. 3831--><p class="noindent" ><b>Обоснование:</b> In general, accuracy cannot be preserved in combining operations, but
it can be preserved in comparisons, and preserving it makes that part of Common Lisp
algebraically a bit more tractable. In particular, this change prevents the breakdown of
transitivity. Let <tt>a</tt> be the result of <tt>(/ 10.0 single-float-epsilon)</tt>, and let <tt>j</tt> be the
result of <tt>(floor a)</tt>. (Note that <tt>(= a (+ a 1.0))</tt> is true, by the deﬁnition of
<tt><a 
href="symbols.html#x187-2604798r798">single-float-epsilon</a></tt>.) Under the old rules, all of <tt>(&#x003C;= a j)</tt>, <tt>(&#x003C; j (+ j 1))</tt>, and
<tt>(&#x003C;= (+ j 1) a)</tt> would be true; transitivity would then imply that <tt>(&#x003C; a a)</tt> ought to be
true, but of course it is false, and therefore transitivity fails. Under the new rule,
however, <tt>(&#x003C;= (+ j 1) a)</tt> is false.
</div>___________________________________________________________________________________________________________
</div>
<!--l. 3848--><p class="indent" >     Для функций, которые математически ассоциативны (и возможно
коммутативны), реализация Common Lisp&#x2019;а может обрабатывать аргументы
любым подходящим методом с ассоциативной (и возможно коммутативной)
перестановкой. Это конечно не влияет на порядок вычисления форм, данный
порядок всегда слева направо, как и во всех Common Lisp&#x2019;овых вызовах
функций. Порядок, который может быть изменён, это обработка значений
аргументов. Смысл всего этого в том, что реализация может отличаться
в том, какие автоматические приведения типов и в каком порядке
производятся. Например, рассмотрим выражение: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(+ 1/3 2/3 1.0D0 1.0 1.0E-15)
   <br>
<!--l. 3859--><p class="noindent" ></div>
<!--l. 3859--><p class="noindent" ><span class="paragraphHead"><a 
href="#x81-92600012.1" id="x81-92600012.1"></a></span>
<!--l. 3859--><p class="noindent" ><span class="paragraphHead"><a 
href="#x81-92700012.1" id="x81-92700012.1"></a></span>
</div>
<!--l. 3860--><p class="indent" >   Одна реализация может обрабатывать аргументы слева направо,
складывая сначала <tt>1/3</tt> и <tt>2/3</tt> для получения <tt>1</tt>, затем преобразовывая
результат в число с плавающей точкой двойной точности для сложения с
<tt>1.0D0</tt>, затем преобразовывая и добавляя <tt>1.0</tt> и <tt>1.0E-15</tt>. Другая реализация
может обрабатывать значения аргументов справа налево, сначала выполняя
сложение чисел с плавающей точкой <tt>1.0</tt> и <tt>1.0E-15</tt> (и возможно теряя
аккуратность в процессе!), затем преобразовывая результат в число двойной
точности и прибавляя <tt>1.0D0</tt>, затем преобразовывая <tt>2/3</tt> к числу с
плавающей точкой двойной точности, и затем преобразовывая <tt>1/3</tt>
и добавляя его. Третья реализация может сначала просканировать
все аргументы, и сгруппировав их по типам, выполнить сложения
сначала одинаковых типов, затем преобразовать результаты к наиболее
точному типу и сложить их. В этом случае все три стратегии являются
допустимыми. Пользователь конечно может контролировать порядок
обработки аргументов явно задавая вызовы вычислений, например:
<div class="lisp"><div class="tabbing">
(+ (+ 1/3 2/3) (+ 1.0D0 1.0E-15) 1.0)
   <br>
<!--l. 3876--><p class="noindent" ></div>
<!--l. 3876--><p class="noindent" ><span class="paragraphHead"><a 
href="#x81-92800012.1" id="x81-92800012.1"></a></span>
                                                                          

                                                                          
<!--l. 3876--><p class="noindent" ><span class="paragraphHead"><a 
href="#x81-92900012.1" id="x81-92900012.1"></a></span>
</div>
<!--l. 3877--><p class="indent" >   Пользователь может также контролировать приведения, явно используя
для этого функцию.
<!--l. 3880--><p class="indent" >   В целом, тип результата числовой функции является числом с плавающей
точкой наиболее точного формата, который был в аргументах данной
функции. Но если все аргументы были рационального типа, тогда результат
будет рациональным (за исключением функций, который математически
возвращают иррациональные результаты, в случае который используется
одинарная точность с плавающей точкой)
<!--l. 3887--><p class="indent" >   Другое правило для комплексных чисел. Комплексные числа никогда не
возвращаются из числовых функций, если только в аргументах не было
использовано хоть одно комплексное число. (Исключением из этого правила
являются иррациональные и трансцендентальные функции, в частности
<tt><a 
href="symbols.html#x187-2604350r350">expt</a></tt>, <tt><a 
href="symbols.html#x187-2604501r501">log</a></tt>, <tt><a 
href="symbols.html#x187-2604814r814">sqrt</a></tt>, <tt><a 
href="symbols.html#x187-2604105r105">asin</a></tt>, <tt><a 
href="symbols.html#x187-2604069r69">acos</a></tt>, <tt><a 
href="symbols.html#x187-2604070r70">acosh</a></tt> и <tt><a 
href="symbols.html#x187-2604112r112">atanh</a></tt>. Смотрите раздел <a 
href="clmse68.html#x85-96600012.5">12.5<!--tex4ht:ref: TRANSCENDENTAL-SECTION --></a>.)
Когда некомплексное число встречает комплексно, то первое сначала
конвертируется во второе с нулевой мнимой частью, а потом вычисляется
результат.
<!--l. 3896--><p class="indent" >   Если любое вычисление привело к дробному результату, в котором
числитель нацело делится на знаменатель, то результат немедленно
преобразуется к эквивалентному целому числу. Это правило называется
<i>канонизацией дробей</i>.
<!--l. 3900--><p class="indent" >   Если результат любого вычисления должен быть комплексным числом с
рациональными частями и нулевой мнимой частью, то результат немедленно
преобразуется в некомплексное рациональное число и равен действительной
части исходного. Это называется правилом <i>канонизации комплексного числа</i>.
Следует отметить, что это правило <i>не</i> применяется к комплексным числам
с компонентами из чисел с плавающими точками. Таким образом
<tt>#C(5 0)</tt> и <tt>5</tt> равны <tt><a 
href="symbols.html#x187-2604338r338">eql</a></tt>, а <tt>#C(5.0 0.0)</tt> и <tt>5.0</tt> не равны <tt><a 
href="symbols.html#x187-2604338r338">eql</a></tt>, но равны
<tt><a 
href="symbols.html#x187-2604340r340">equalp</a></tt>.
                                                                          

                                                                          
<!--l. 3909--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse65.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html#tailnumber.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse64.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html#clmse64.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse64.html"></a>    </div> </div> 
</body></html> 
