<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Survey of Concepts</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 16:17:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 191--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse150.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse148.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse148.html#tailclmse148.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse149.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="condition.html#clmse149.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">28.3   </span> <a 
href="clm.html#QQ2-182-2443" id="x182-240200028.3">Survey of
Concepts</a></h3>
<!--l. 193--><p class="noindent" >This section discusses various aspects of the condition system by topic, illustrating
them with extensive examples. The next section contains deﬁnitions of speciﬁc
functions, macros, and other facilities.
<!--l. 197--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.1   </span> <a 
href="frontmatter.html#QQ2-182-2444" id="x182-240300028.3.1">Signaling Errors</a></h4>
<!--l. 199--><p class="noindent" >Conceptually, signaling an error in a program is an admission by that program
that it does not know how to continue and requires external intervention. Once an
error is signaled, any decision about how to continue must come from the
“outside.”
<!--l. 204--><p class="indent" >   The simplest way to signal an error is to use the <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> function with
<tt><a 
href="symbols.html#x187-2604392r392">format</a></tt>-style arguments describing the error for the sake of the user interface. If
<tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> is called and there are no active handlers (described in sections <a 
href="#x182-241000028.3.2">28.3.2<!--tex4ht:ref: TRAPPING-ERRORS --></a>
and <a 
href="#x182-241700028.3.3">28.3.3<!--tex4ht:ref: HANDLING-CONDITIONS --></a>), the debugger will be entered and the error message will be typed out.
For example: <div class="lisp"><div class="tabbing">
Lisp&#x003E; (defun factorial (x)
   <br>                             (cond ((or (not (typep x &#x2019;integer)) (minusp x))<br>
               (error &#x0022;~S is not a valid argument to FACTORIAL.&#x0022;<br>
                      x))<br>                              ((zerop x) 1)<br>
              (t (* x (factorial (- x 1))))))<br>             <span class="math"> ⇒</span> FACTORIAL<br>
Lisp&#x003E; (factorial 20)<br>                             <span class="math"> ⇒</span> 2432902008176640000<br>
Lisp&#x003E; (factorial -1)<br>      Error: -1 is not a valid argument to FACTORIAL.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Return to Lisp Toplevel.<br>                                       Debug&#x003E;<br>
<!--l. 224--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 224--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-240400028.3.1" id="x182-240400028.3.1"></a></span>
<!--l. 224--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-240500028.3.1" id="x182-240500028.3.1"></a></span>
</div>
<!--l. 225--><p class="indent" >   In general, a call to <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> cannot directly return. Unless special work has been
done to override this behavior, the debugger will be entered and there will be no
option to simply continue.
<!--l. 229--><p class="indent" >   The only exception may be that some implementations may provide debugger
commands for interactively returning from individual stack frames; even then,
however, such commands should never be used except by someone who has read
the erring code and understands the consequences of continuing from that point.
In particular, the programmer should feel conﬁdent about writing code like this:
<div class="lisp"><div class="tabbing">
(defun wargames:no-win-scenario ()
   <br>              (when (true) (error &#x0022;Pushing the button would be stupid.&#x0022;))<br>
  (push-the-button))<br>
<!--l. 239--><p class="noindent" ></div>
<!--l. 239--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-240600028.3.1" id="x182-240600028.3.1"></a></span>
<!--l. 239--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-240700028.3.1" id="x182-240700028.3.1"></a></span>
</div>
<!--l. 240--><p class="indent" >   In this scenario, there should be no chance that the function <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> will return
and the button will be pushed.____________________________________________
<!--l. 244--><p class="noindent" ><b>Примечание:</b> It should be noted that the notion of “no chance” that the button will be
pushed is relative only to the language model; it assumes that the language is accurately
implemented. In practice, compilers have bugs, computers have glitches, and users have
been known to interrupt at inopportune moments and use the debugger to return from
arbitrary stack frames. Such violations of the language model are beyond the scope of
the condition system but not necessarily beyond the scope of potential failures that the
programmer should consider and defend against. The possibility of such unusual
failures may of course also inﬂuence the design of code meant to handle less
                                                                          

                                                                          
drastic situations, such as maintaining a database uncorrupted.—KMP and GLS
_
<!--l. 259--><p class="indent" >     In some cases, the programmer may have a single, well-deﬁned idea of a
reasonable recovery strategy for this particular error. In that case, he can use the
function <tt><a 
href="symbols.html#x187-2604193r193">cerror</a></tt>, which speciﬁes information about what would happen
if the user did simply continue from the call to <tt><a 
href="symbols.html#x187-2604193r193">cerror</a></tt>. For example:
<div class="lisp"><div class="tabbing">
Lisp&#x003E; (defun factorial (x)
     <br>                                                  (cond ((not (typep x &#x2019;integer))<br>
               (error &#x0022;~S is not a valid argument to FACTORIAL.&#x0022;<br>
                      x))<br>
              ((minusp x)<br>                    (let ((x-magnitude (- x)))<br>
                 (cerror &#x0022;Compute -(~D!) instead.&#x0022;<br>
                         &#x0022;(-~D)! is not deﬁned.&#x0022; x-magnitude)<br>
                 (- (factorial x-magnitude))))<br>
              ((zerop x) 1)<br>                (t (* x (factorial (- x 1))))))<br>
 <span class="math"> ⇒</span> FACTORIAL<br>        Lisp&#x003E; (factorial -3)<br>        Error: (-3)! is not deﬁned.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Compute -(3!) instead.<br>  2: Return to Lisp Toplevel.<br> Debug&#x003E; :continue 1<br>
 <span class="math"> ⇒</span> -6<br>
<!--l. 283--><p class="noindent" ></div>
<!--l. 283--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-240800028.3.1" id="x182-240800028.3.1"></a></span>
<!--l. 283--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-240900028.3.1" id="x182-240900028.3.1"></a></span>
</div>
<!--l. 286--><p class="noindent" >
     <h4 class="subsectionHead"><span class="titlemark">28.3.2   </span> <a 
href="frontmatter.html#QQ2-182-2451" id="x182-241000028.3.2">Trapping Errors</a></h4>
                                                                          

                                                                          
<!--l. 289--><p class="noindent" >By default, a call to <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> will force entry into the debugger. You can override
that behavior in a variety of ways. The simplest (and most blunt) tool for
inhibiting entry to the debugger on an error is to use <tt><a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt>. In the
normal situation, forms in the body of <tt><a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt> are evaluated sequentially
and the last value is returned. If a condition of type <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> is signaled,
<tt><a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt> immediately returns two values, namely <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> and the condition
that was signaled; the debugger is not entered and no error message is printed.
For example: <div class="lisp"><div class="tabbing">
Lisp&#x003E; (setq ﬁlename &#x0022;nosuchﬁle&#x0022;)
   <br> <span class="math"> ⇒</span> &#x0022;nosuchﬁle&#x0022;<br>Lisp&#x003E; (ignore-errors (open ﬁlename :direction :input))<br>
 <span class="math"> ⇒</span> NIL and #&#x003C;FILE-ERROR 3437523&#x003E;<br>
<!--l. 302--><p class="noindent" ></div>
<!--l. 302--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-241100028.3.2" id="x182-241100028.3.2"></a></span>
<!--l. 302--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-241200028.3.2" id="x182-241200028.3.2"></a></span>
</div>
<!--l. 303--><p class="indent" >   The second return value is an object that represents the kind of error. This is
explained in greater detail in section <a 
href="#x182-242200028.3.4">28.3.4<!--tex4ht:ref: OBJECT-0RIENTED-BASIS --></a>.
<!--l. 306--><p class="indent" >   In many cases, however, <tt><a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt> is not desirable because it deals with
too many kinds of errors. Contrary to the belief of some, a program that does not
enter the debugger is not necessarily better than one that does. Excessive
use of <tt><a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt> may keep the program out of the debugger, but
it may not increase the program&#x2019;s reliability, because the program may
continue to run after encountering errors other than those you meant
to work past. In general, it is better to attempt to deal only with the
particular kinds of errors that you believe could legitimately happen. That
way, if an unexpected error comes along, you will still ﬁnd out about
it.
<tt>
<!--l. 316--><p class="indent" >   <a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt> is a useful special case built from a more general facility,
<tt><a 
href="symbols.html#x187-2604426r426">handler-case</a></tt>, that allows the programmer to deal with particular kinds of
conditions (including non-error conditions) without aﬀecting what happens when
                                                                          

                                                                          
other kinds of conditions are signaled. For example, an eﬀect equivalent
to that of <tt><a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt> above is achieved in the following example:
<div class="lisp"><div class="tabbing">
Lisp&#x003E; (setq ﬁlename &#x0022;nosuchﬁle&#x0022;)
   <br>  <span class="math"> ⇒</span> &#x0022;nosuchﬁle&#x0022;<br> Lisp&#x003E; (handler-case (open ﬁlename :direction :input)<br>
        (error (condition)<br>                       (values nil condition)))<br>
 <span class="math"> ⇒</span> NIL and #&#x003C;FILE-ERROR 3437525&#x003E;<br>
<!--l. 328--><p class="noindent" ></div>
<!--l. 328--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-241300028.3.2" id="x182-241300028.3.2"></a></span>
<!--l. 328--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-241400028.3.2" id="x182-241400028.3.2"></a></span>
</div>
<!--l. 329--><p class="indent" >   However, using <tt><a 
href="symbols.html#x187-2604426r426">handler-case</a></tt>, one can indicate a more speciﬁc condition type
than just “error.” Condition types are explained in detail later, but the syntax
looks roughly like the following: <div class="lisp"><div class="tabbing">
Lisp&#x003E; (makunbound &#x2019;ﬁlename)
   <br>  <span class="math"> ⇒</span> FILENAME<br> Lisp&#x003E; (handler-case (open ﬁlename :direction :input)<br>
        (ﬁle-error (condition)<br>                    (values nil condition)))<br>
Error: The variable FILENAME is unbound.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Retry getting the value of FILENAME.<br>
 2: Specify a value of FILENAME to use this time.<br>
 3: Specify a value of FILENAME to store and use.<br>
 4: Return to Lisp Toplevel.<br>                                       Debug&#x003E;<br>
<!--l. 345--><p class="noindent" ></div>
<!--l. 345--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-241500028.3.2" id="x182-241500028.3.2"></a></span>
                                                                          

                                                                          
<!--l. 345--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-241600028.3.2" id="x182-241600028.3.2"></a></span>
</div>
<!--l. 348--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.3   </span> <a 
href="frontmatter.html#QQ2-182-2458" id="x182-241700028.3.3">Handling Conditions</a></h4>
<!--l. 351--><p class="noindent" >Blind transfer of control to a <tt><a 
href="symbols.html#x187-2604426r426">handler-case</a></tt> is only one possible kind of
recovery action that can be taken when a condition is signaled. The low-level
mechanism oﬀers great ﬂexibility in how to continue once a condition has been
signaled.
<!--l. 356--><p class="indent" >   The basic idea behind condition handling is that a piece of code called the
<i>signaler</i> recognizes and announces the existence of an exceptional situation using
<tt><a 
href="symbols.html#x187-2604786r786">signal</a></tt> or some function built on <tt><a 
href="symbols.html#x187-2604786r786">signal</a></tt> (such as <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>).
<!--l. 360--><p class="indent" >   The process of signaling involves the search for and invocation of a
<i>handler</i>, a piece of code that will attempt to deal appropriately with the
situation.
<!--l. 364--><p class="indent" >   If a handler is found, it may either <i>handle</i> the situation, by performing
some non-local transfer of control, or <i>decline</i> to handle it, by failing to
perform a non-local transfer of control. If it declines, other handlers are
sought.
<!--l. 368--><p class="indent" >   Since the lexical environment of the signaler might not be available to
handlers, a data structure called a <i>condition</i> is created to represent explicitly the
relevant state of the situation. A condition either is created explicitly using
<tt><a 
href="symbols.html#x187-2604535r535">make-condition</a></tt> and then passed to a function such as <tt><a 
href="symbols.html#x187-2604786r786">signal</a></tt>, or is created
implicitly by a function such as <tt><a 
href="symbols.html#x187-2604786r786">signal</a></tt> when given appropriate non-condition
arguments.
<!--l. 375--><p class="indent" >   In order to handle the error, a handler is permitted to use any non-local
transfer of control such as <tt><a 
href="symbols.html#x187-2604423r423">go</a></tt> to a tag in a <tt><a 
href="symbols.html#x187-2604869r869">tagbody</a></tt>, <tt><a 
href="symbols.html#x187-2604749r749">return</a></tt> from a <tt><a 
href="symbols.html#x187-2604128r128">block</a></tt>, or
<tt>throw</tt> to a <tt>catch</tt>. In addition, structured abstractions of these primitives are
provided for convenience in exception handling.
<!--l. 381--><p class="indent" >   A handler can be made dynamically accessible to a program by use of
<tt><a 
href="symbols.html#x187-2604425r425">handler-bind</a></tt>. For example, to create a handler for a condition of type
<tt><a 
href="symbols.html#x187-2604086r86">arithmetic-error</a></tt>, one might write:  <div class="lisp"><div class="tabbing">
(handler-bind ((arithmetic-error <i>handler</i>))<i>body</i>)
   <br>
                                                                          

                                                                          
<!--l. 393--><p class="noindent" ></div>
<!--l. 393--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-241800028.3.3" id="x182-241800028.3.3"></a></span>
<!--l. 393--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-241900028.3.3" id="x182-241900028.3.3"></a></span>
</div>
<!--l. 394--><p class="indent" >   The handler is a function of one argument, the condition. If a condition of the
designated type is signaled while the <i>body</i> is executing (and there are no
intervening handlers), the handler would be invoked on the given condition,
allowing it the option of transferring control. For example, one might write a
macro that executes a body, returning either its value(s) or the two values <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>
and the condition: <div class="lisp"><div class="tabbing">
(defmacro without-arithmetic-errors (&#x0026;body forms)
   <br>                                                                  (let ((tag (gensym)))<br>
    ‘(block ,tag<br>                          (handler-bind ((arithmetic-error<br>
                         #&#x2019;(lambda (c)     ;Argument <tt>c</tt> is a condition<br>
                             (return-from ,tag (values nil c)))))<br>
         ,@body))))<br>                                                     <br>
<!--l. 408--><p class="noindent" ></div>
<!--l. 408--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-242000028.3.3" id="x182-242000028.3.3"></a></span>
<!--l. 408--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-242100028.3.3" id="x182-242100028.3.3"></a></span>
</div>
<!--l. 410--><p class="indent" >   The handler is executed in the dynamic context of the signaler, except
that the set of available condition handlers will have been rebound to
the value that was active at the time the condition handler was made
active. If a handler declines (that is, it does not transfer control), other
handlers are sought. If no handler is found and the condition was signaled by
<tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> or <tt><a 
href="symbols.html#x187-2604193r193">cerror</a></tt> (or some function such as <tt><a 
href="symbols.html#x187-2604107r107">assert</a></tt> that behaves like these
functions), the debugger is entered, still in the dynamic context of the
signaler.
                                                                          

                                                                          
<!--l. 419--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.4   </span> <a 
href="frontmatter.html#QQ2-182-2463" id="x182-242200028.3.4">Object-Oriented Basis of Condition Handling</a></h4>
<!--l. 422--><p class="noindent" >Of course, the ability of the handler to usefully handle an exceptional situation is
related to the quality of the information it is provided. For example, if all errors
were signaled by <div class="lisp"><div class="tabbing">
(error &#x0022;<i>some format string</i>&#x0022;)
   <br>
<!--l. 427--><p class="noindent" ></div>
<!--l. 427--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-242300028.3.4" id="x182-242300028.3.4"></a></span>
<!--l. 427--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-242400028.3.4" id="x182-242400028.3.4"></a></span>
</div>
<!--l. 428--><p class="indent" >   then the only piece of information that would be accessible to the handler
would be an object of type <tt><a 
href="symbols.html#x187-2604792r792">simple-error</a></tt> that had a slot containing the format
string.
<!--l. 432--><p class="indent" >   If this were done, <tt><a 
href="symbols.html#x187-2604828r828">string-equal</a></tt> would be the preferred way to tell one error
from another, and it would be very hard to allow ﬂexibility in the presentation of
error messages because existing handlers would tend to be broken by even tiny
variations in the wording of an error message. This phenomenon has been
the major failing of most error systems previously available in Lisp. It is
fundamentally important to decouple the error message string (the human
interface) from the objects that formally represent the error state (the program
interface). We therefore have the notion of typed conditions, and of formal
operations on those conditions that make them inspectable in a structured
way.
<!--l. 443--><p class="indent" >   This object-oriented approach to condition handling has the following
important advantages over a text-based approach:
      <ul class="itemize1">
      <li class="itemize">Conditions are classiﬁed according to subtype relationships, making it
      easy to test for categories of conditions.
                                                                          

                                                                          
      </li>
      <li class="itemize">Conditions  have  named  slot  values  through  which  parameters  are
      conveyed from the program that signals the condition to the program
      that handles it.
      </li>
      <li class="itemize">Inheritance  of  methods  and  slots  reduces  the  amount  of  explicit
      speciﬁcation necessary to achieve various interesting eﬀects.</li></ul>
<!--l. 459--><p class="indent" >   Some condition types are deﬁned by this document, but the set of condition
types is extensible using <tt><a 
href="symbols.html#x187-2604278r278">define-condition</a></tt>. Common Lisp condition types are in
fact CLOS classes, and condition objects are ordinary CLOS objects;
<tt><a 
href="symbols.html#x187-2604278r278">define-condition</a></tt> merely provides an abstract interface that is a bit more
convenient than <tt><a 
href="symbols.html#x187-2604274r274">defclass</a></tt> for deﬁning conditions.
<!--l. 466--><p class="indent" >   Here, as an example, we deﬁne a two-argument function called <tt>divide</tt> that
is patterned after the <tt><a 
href="symbols.html#x187-2604055r55">/</a></tt> function but does some stylized error checking:
<div class="lisp"><div class="tabbing">
(defun divide (numerator denominator)
   <br>                                           (cond ((or (not (numberp numerator))<br>
             (not (numberp denominator)))<br>
         (error &#x0022;(DIVIDE &#x2019;~S &#x2019;~S) - Bad arguments.&#x0022;<br>
                numerator denominator))<br>        ((zerop denominator)<br>
         (error &#x2019;division-by-zero<br>                      :operator &#x2019;divide<br>
                :operands (list numerator denominator)))<br>
        (t ...)))<br>
<!--l. 480--><p class="noindent" ></div>
<!--l. 480--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-242500028.3.4" id="x182-242500028.3.4"></a></span>
<!--l. 480--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-242600028.3.4" id="x182-242600028.3.4"></a></span>
</div>
<!--l. 481--><p class="indent" >   Note that in the ﬁrst clause we have used <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> with a string argument and in
the second clause we have named a particular condition type, <tt><a 
href="symbols.html#x187-2604309r309">division-by-zero</a></tt>.
In the case of a string argument, the condition type that will be signaled is
<tt><a 
href="symbols.html#x187-2604792r792">simple-error</a></tt>.
                                                                          

                                                                          
<!--l. 486--><p class="indent" >   The particular kind of error that is signaled may be important in
cases where handlers are active. For example, <tt><a 
href="symbols.html#x187-2604792r792">simple-error</a></tt> inherits from
type <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>, which in turn inherits from type <tt><a 
href="symbols.html#x187-2604246r246">condition</a></tt>. On the other
hand, <tt><a 
href="symbols.html#x187-2604309r309">division-by-zero</a></tt> inherits from <tt><a 
href="symbols.html#x187-2604086r86">arithmetic-error</a></tt>, which inherits
from <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>, which inherits from <tt><a 
href="symbols.html#x187-2604246r246">condition</a></tt>. So if a handler existed for
<tt><a 
href="symbols.html#x187-2604086r86">arithmetic-error</a></tt> while a <tt><a 
href="symbols.html#x187-2604309r309">division-by-zero</a></tt> condition was signaled, that
handler would be tried; however, if a <tt><a 
href="symbols.html#x187-2604792r792">simple-error</a></tt> condition were signaled in
the same context, the handler for type <tt><a 
href="symbols.html#x187-2604086r86">arithmetic-error</a></tt> would not be
tried.
<!--l. 497--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.5   </span> <a 
href="frontmatter.html#QQ2-182-2468" id="x182-242700028.3.5">Restarts</a></h4>
<!--l. 500--><p class="noindent" >In older Lisp dialects (such as MacLisp), an attempt to signal an error of a given
type often carried with it an implicit promise to support the standard recovery
strategy for that type of error. If the signaler knew the type of error but for
whatever reason was unable to deal with the standard recovery strategy for that
kind of error, it was necessary to signal an untyped error (for which there was no
deﬁned recovery strategy). This sometimes led to confusion when people signaled
typed errors without realizing the full implications of having done so,
but more often than not it meant that users simply avoided typed errors
altogether.
<!--l. 510--><p class="indent" >   The Common Lisp Condition System, which is modeled after the Zetalisp
condition system, corrects this troublesome aspect of previous Lisp dialects by
creating a clear separation between the act of signaling an error of a particular
type and the act of saying that a particular way of recovery is appropriate.
In the <tt>divide</tt> example above, simply signaling an error does not imply
a willingness on the part of the signaler to cooperate in any corrective
action. For example, the following sample interaction illustrates that the
only recovery action oﬀered for this error is “Return to Lisp Toplevel”:
<div class="lisp"><div class="tabbing">
Lisp&#x003E; (+ (divide 3 0) 7)
   <br>                                                    Error: Attempt to divide 3 by 0.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Return to Lisp Toplevel.<br> Debug&#x003E; :continue 1<br> Returned to Lisp Toplevel.<br>
                                                                          

                                                                          
Lisp&#x003E;<br>
<!--l. 526--><p class="noindent" ></div>
<!--l. 526--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-242800028.3.5" id="x182-242800028.3.5"></a></span>
<!--l. 526--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-242900028.3.5" id="x182-242900028.3.5"></a></span>
</div>
<!--l. 527--><p class="indent" >   When an error is detected and the function <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> is called, execution cannot
continue normally because <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> will not directly return. Control can be
transferred to other points in the program, however, by means of specially
established “restarts.”
<!--l. 532--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.6   </span> <a 
href="frontmatter.html#QQ2-182-2471" id="x182-243000028.3.6">Anonymous Restarts</a></h4>
<!--l. 534--><p class="noindent" >The simplest kind of restart involves structured transfer of control using a macro
called <tt><a 
href="symbols.html#x187-2604747r747">restart-case</a></tt>. The <tt><a 
href="symbols.html#x187-2604747r747">restart-case</a></tt> form allows execution of a piece of code
in a context where zero or more restarts are active, and where if one of those
restarts is “invoked,” control will be transferred to the corresponding clause in the
<tt><a 
href="symbols.html#x187-2604747r747">restart-case</a></tt> form. For example, we could rewrite the previous <tt>divide</tt> example
as follows. <div class="lisp"><div class="tabbing">
(defun divide (numerator denominator)
   <br>                                 (loop<br>                                   (restart-case<br>
        (return<br>                  (cond ((or (not (numberp numerator))<br>
                     (not (numberp denominator)))<br>
                 (error &#x0022;(DIVIDE &#x2019;~S &#x2019;~S) - Bad arguments.&#x0022;<br>
                         numerator denominator))<br>
                ((zerop denominator)<br>                 (error &#x2019;division-by-zero<br>
                        :operator &#x2019;divide<br>                        :operands (list numerator denominator)))<br>
                (t ...)))<br>                                (nil (arg1 arg2)<br>
          :report &#x0022;Provide new arguments for use by DIVIDE.&#x0022;<br>
          :interactive<br>                                       (lambda ()<br>
               (list (prompt-for &#x2019;number &#x0022;Numerator: &#x0022;)<br>
                                                                          

                                                                          
                     (prompt-for &#x2019;number &#x0022;Denominator: &#x0022;)))<br>
        (setq numerator arg1 denominator arg2))<br>            (nil (result)<br>
          :report &#x0022;Provide a value to return from DIVIDE.&#x0022;<br>
          :interactive<br>            (lambda () (list (prompt-for &#x2019;number &#x0022;Result: &#x0022;)))<br>
        (return result)))))<br>
<!--l. 566--><p class="noindent" ></div>
<!--l. 566--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-243100028.3.6" id="x182-243100028.3.6"></a></span>
<!--l. 566--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-243200028.3.6" id="x182-243200028.3.6"></a></span>
</div>__________________________________________________________________________<!--l. 569--><p class="noindent" ><b>Примечание:</b> The function <tt> prompt-for</tt> used in this chapter in a number of places is
not a part of Common Lisp. It is used in the examples in this chapter only
to keep the presentation simple. It is assumed to accept a type speciﬁer and
optionally a format string and associated arguments. It uses the format string and
associated arguments as part of an interactive prompt, and uses <tt><a 
href="symbols.html#x187-2604715r715">read</a></tt> to read a Lisp
object; however, only an object of the type indicated by the type speciﬁer is
accepted.
<!--l. 578--><p class="indent" >     The question of whether or not <tt>prompt-for</tt> (or something like it) would be
a useful addition to Common Lisp is under consideration by X3J13, but as
of January 1989 no action has been taken. In spite of its use in a number of
examples, nothing in the Common Lisp Condition System depends on this function.
<!--l. 585--><p class="indent" >     In the example, the <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> at the head of each clause means that it is
an “anonymous” restart. Anonymous restarts are typically invoked only
from within the debugger. As we shall see later, it is possible to have
“named restarts” that may be invoked from code without the need for user
intervention.
<!--l. 591--><p class="indent" >     If the arguments to anonymous restarts are not optional, then special
information must be provided about what the debugger should use as arguments.
Here the <tt>:interactive</tt> keyword is used to specify that information.
<!--l. 595--><p class="indent" >     The <tt>:report</tt> keyword introduces information to be used when presenting the
restart option to the user (by the debugger, for example).
<!--l. 598--><p class="indent" >     Here is a sample interaction that takes advantage of the restarts provided by
the revised deﬁnition of <tt>divide</tt>: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
Lisp&#x003E; (+ (divide 3 0) 7)
   <br>                                                    Error: Attempt to divide 3 by 0.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Provide new arguments for use by the DIVIDE function.<br>
 2: Provide a value to return from the DIVIDE function.<br>
 3: Return to Lisp Toplevel.<br>             Debug&#x003E; :continue 1<br>             1<br>
Numerator: 4<br>                                              Denominator: 2<br>
 <span class="math"> ⇒</span> 9<br>
<!--l. 612--><p class="noindent" ></div>
<!--l. 612--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-243300028.3.6" id="x182-243300028.3.6"></a></span>
<!--l. 612--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-243400028.3.6" id="x182-243400028.3.6"></a></span>
</div>
<!--l. 614--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.7   </span> <a 
href="frontmatter.html#QQ2-182-2476" id="x182-243500028.3.7">Named Restarts</a></h4>
<!--l. 616--><p class="noindent" >In addition to anonymous restarts, one can have named restarts, which can be
invoked by name from within code. As a trivial example, one could write
<div class="lisp"><div class="tabbing">
(restart-case (invoke-restart &#x2019;foo 3)
   <br>                                                                       (foo (x) (+ x 1)))<br>
<!--l. 621--><p class="noindent" ></div>
<!--l. 621--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-243600028.3.7" id="x182-243600028.3.7"></a></span>
                                                                          

                                                                          
<!--l. 621--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-243700028.3.7" id="x182-243700028.3.7"></a></span>
</div>
<!--l. 622--><p class="indent" >   to add <tt>3</tt> to <tt>1</tt>, returning <tt>4</tt>. This trivial example is conceptually analogous to
writing: <div class="lisp"><div class="tabbing">
(+ (catch &#x2019;something (throw &#x2019;something 3)) 1)
   <br>
<!--l. 626--><p class="noindent" ></div>
<!--l. 626--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-243800028.3.7" id="x182-243800028.3.7"></a></span>
<!--l. 626--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-243900028.3.7" id="x182-243900028.3.7"></a></span>
</div>
<!--l. 628--><p class="indent" >   For a more realistic example, the code for the function <tt><a 
href="symbols.html#x187-2604865r865">symbol-value</a></tt> might
signal an unbound variable error as follows: <div class="lisp"><div class="tabbing">
(restart-case (error &#x0022;The variable ~S is unbound.&#x0022; variable)
   <br>                                                                              (continue ()<br>
      :report<br>                  (lambda (s)     ;Argument <tt>s</tt> is a stream<br>
          (format s &#x0022;Retry getting the value of ~S.&#x0022; variable))<br>
    (symbol-value variable))<br>                            (use-value (value)<br>
      :report<br>                  (lambda (s)     ;Argument <tt>s</tt> is a stream<br>
          (format s &#x0022;Specify a value of ~S to use this time.&#x0022;<br>
                  variable))<br>          value)<br>        (store-value (value)<br>
      :report<br>                  (lambda (s)     ;Argument <tt>s</tt> is a stream<br>
          (format s &#x0022;Specify a value of ~S to store and use.&#x0022;<br>
                  variable))<br>        (setf (symbol-value variable) value)<br>
    value))<br>
<!--l. 650--><p class="noindent" ></div>
<!--l. 650--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-244000028.3.7" id="x182-244000028.3.7"></a></span>
                                                                          

                                                                          
<!--l. 650--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-244100028.3.7" id="x182-244100028.3.7"></a></span>
</div>
<!--l. 651--><p class="indent" >   If this were part of the implementation of <tt><a 
href="symbols.html#x187-2604865r865">symbol-value</a></tt>, then it would be
possible for users to write a variety of automatic handlers for unbound variable
errors. For example, to make unbound variables evaluate to themselves, one might
write <div class="lisp"><div class="tabbing">
(handler-bind ((unbound-variable
   <br>                       #&#x2019;(lambda (c)     ;Argument <tt>c</tt> is a condition<br>
                     (when (ﬁnd-restart &#x2019;use-value)<br>
                       (invoke-restart &#x2019;use-value<br>
                                       (cell-error-name c))))))<br>
  <i>body</i>)<br>
<!--l. 662--><p class="noindent" ></div>
<!--l. 662--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-244200028.3.7" id="x182-244200028.3.7"></a></span>
<!--l. 662--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-244300028.3.7" id="x182-244300028.3.7"></a></span>
</div>
<!--l. 664--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.8   </span> <a 
href="frontmatter.html#QQ2-182-2485" id="x182-244400028.3.8">Restart Functions</a></h4>
<!--l. 666--><p class="noindent" >For commonly used restarts, it is conventional to deﬁne a program interface that
hides the use of <tt><a 
href="symbols.html#x187-2604456r456">invoke-restart</a></tt>. Such program interfaces to restarts are called
<i>restart functions</i>.
<!--l. 670--><p class="indent" >   The normal convention is for the function to share the name of the
restart. The pre-deﬁned functions <tt><a 
href="symbols.html#x187-2604066r66">abort</a></tt>, <tt><a 
href="symbols.html#x187-2604252r252">continue</a></tt>, <tt><a 
href="symbols.html#x187-2604592r592">muffle-warning</a></tt>,
<tt><a 
href="symbols.html#x187-2604819r819">store-value</a></tt>, and <tt><a 
href="symbols.html#x187-2604912r912">use-value</a></tt> are restart functions. With <tt><a 
href="symbols.html#x187-2604912r912">use-value</a></tt> the above
example of <tt><a 
href="symbols.html#x187-2604425r425">handler-bind</a></tt> could have been written more concisely as
<div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(handler-bind ((unbound-variable
   <br>                      #&#x2019;(lambda (c)     ;Argument <tt>c</tt> is a condition<br>
                       (use-value (cell-error-name c)))))<br>         <i>body</i>)<br>
<!--l. 679--><p class="noindent" ></div>
<!--l. 679--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-244500028.3.8" id="x182-244500028.3.8"></a></span>
<!--l. 679--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-244600028.3.8" id="x182-244600028.3.8"></a></span>
</div>
<!--l. 681--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.9   </span> <a 
href="frontmatter.html#QQ2-182-2488" id="x182-244700028.3.9">Comparison of Restarts and Catch/Throw</a></h4>
<!--l. 683--><p class="noindent" >One important feature that <tt><a 
href="symbols.html#x187-2604747r747">restart-case</a></tt> (or <tt><a 
href="symbols.html#x187-2604746r746">restart-bind</a></tt>) oﬀers that <tt>catch</tt>
does not is the ability to reason about the available points to which control might
be transferred without actually attempting the transfer. One could, for example,
write <div class="lisp"><div class="tabbing">
(ignore-errors (throw ...))
   <br>
<!--l. 689--><p class="noindent" ></div>
<!--l. 689--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-244800028.3.9" id="x182-244800028.3.9"></a></span>
<!--l. 689--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-244900028.3.9" id="x182-244900028.3.9"></a></span>
</div>
<!--l. 690--><p class="indent" >   which is a sort of poor man&#x2019;s variation of <div class="lisp"><div class="tabbing">
(when (ﬁnd-restart &#x2019;something)
   <br>                                                         (invoke-restart &#x2019;something))<br>
<!--l. 694--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 694--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-245000028.3.9" id="x182-245000028.3.9"></a></span>
<!--l. 694--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-245100028.3.9" id="x182-245100028.3.9"></a></span>
</div>
<!--l. 695--><p class="indent" >   but there is no way to use <tt><a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt> and <tt>throw</tt> to simulate something
like <div class="lisp"><div class="tabbing">
(when (and (ﬁnd-restart &#x2019;something)
   <br>                                                  (ﬁnd-restart &#x2019;something-else))<br>
  (invoke-restart &#x2019;something))<br>
<!--l. 701--><p class="noindent" ></div>
<!--l. 701--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-245200028.3.9" id="x182-245200028.3.9"></a></span>
<!--l. 701--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-245300028.3.9" id="x182-245300028.3.9"></a></span>
</div>
<!--l. 702--><p class="indent" >   or even just <div class="lisp"><div class="tabbing">
(when (and (ﬁnd-restart &#x2019;something)
   <br>                                              (yes-or-no-p &#x0022;Do something? &#x0022;))<br>
  (invoke-restart &#x2019;something))<br>
<!--l. 707--><p class="noindent" ></div>
<!--l. 707--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-245400028.3.9" id="x182-245400028.3.9"></a></span>
<!--l. 707--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-245500028.3.9" id="x182-245500028.3.9"></a></span>
</div>
<!--l. 708--><p class="indent" >   because the degree of inspectability that comes with simply writing
<div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(ignore-errors (throw ...))
   <br>
<!--l. 711--><p class="noindent" ></div>
<!--l. 711--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-245600028.3.9" id="x182-245600028.3.9"></a></span>
<!--l. 711--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-245700028.3.9" id="x182-245700028.3.9"></a></span>
</div>
<!--l. 712--><p class="indent" >   is too primitive—getting the desired information also forces transfer of control,
perhaps at a time when it is not desirable.
<!--l. 715--><p class="indent" >   Many programmers have previously evolved strategies like the following on a
case-by-case basis: <div class="lisp"><div class="tabbing">
(defvar *foo-tag-is-available* nil)
   <br>                                                                                               <br>
(defun fn-1 ()<br>                                                  (catch &#x2019;foo<br>
    (let ((*foo-tag-is-available* t))<br>                         ... (fn-2) ...)))<br>
<br>                                                             (defun fn-2 ()<br>
  ...<br>                               (if *foo-tag-is-available* (throw &#x2019;foo t))<br>
  ...)<br>
<!--l. 729--><p class="noindent" ></div>
<!--l. 729--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-245800028.3.9" id="x182-245800028.3.9"></a></span>
<!--l. 729--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-245900028.3.9" id="x182-245900028.3.9"></a></span>
</div>
<!--l. 730--><p class="indent" >   The facility provided by <tt><a 
href="symbols.html#x187-2604747r747">restart-case</a></tt> and <tt><a 
href="symbols.html#x187-2604375r375">find-restart</a></tt> is intended to
provide a standardized protocol for this sort of information to be communicated
between programs that were developed independently so that individual variations
from program to program do not thwart the overall modularity and debuggability
of programs.
                                                                          

                                                                          
<!--l. 736--><p class="indent" >   Another diﬀerence between the restart facility and the <tt>catch</tt>/<tt>throw</tt> facility is
that a <tt>catch</tt> with any given tag completely shadows any outer pending <tt>catch</tt>
that uses the same tag. Because of the presence of <tt><a 
href="symbols.html#x187-2604242r242">compute-restarts</a></tt>, however, it
is possible to see shadowed restarts, which may be very useful in some situations
(particularly in an interactive debugger).
                                                                          

                                                                          
<!--l. 745--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.10   </span> <a 
href="frontmatter.html#QQ2-182-2501" id="x182-246000028.3.10">Generalized Restarts</a></h4>
<tt>
<!--l. 748--><p class="noindent" ><a 
href="symbols.html#x187-2604747r747">restart-case</a></tt> is a mechanism that allows only imperative transfer of control for
its associated restarts. <tt><a 
href="symbols.html#x187-2604747r747">restart-case</a></tt> is built on a lower-level mechanism called
<tt><a 
href="symbols.html#x187-2604746r746">restart-bind</a></tt>, which does not force transfer of control.
<tt>
<!--l. 752--><p class="indent" >   <a 
href="symbols.html#x187-2604746r746">restart-bind</a></tt> is to <tt><a 
href="symbols.html#x187-2604747r747">restart-case</a></tt> as <tt><a 
href="symbols.html#x187-2604425r425">handler-bind</a></tt> is to <tt>handler-case</tt>. The
syntax is <div class="lisp"><div class="tabbing">
(restart-bind ((<i>name</i> <i>function</i> . <i>options</i>)) . <i>body</i>)
   <br>
<!--l. 757--><p class="noindent" ></div>
<!--l. 757--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-246100028.3.10" id="x182-246100028.3.10"></a></span>
<!--l. 757--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-246200028.3.10" id="x182-246200028.3.10"></a></span>
</div>
<!--l. 758--><p class="indent" >   The <i>body</i> is executed in a dynamic context within which the <i>function</i> will be
called whenever <tt>(invoke-restart &#x2019;<i>name</i>)</tt> is executed. The <i>options</i> are
keyword-style and are used to pass information such as that provided with the
<tt>:report</tt> keyword in <tt><a 
href="symbols.html#x187-2604747r747">restart-case</a></tt>.
<!--l. 764--><p class="indent" >   A <tt><a 
href="symbols.html#x187-2604747r747">restart-case</a></tt> expands into a call to <tt><a 
href="symbols.html#x187-2604746r746">restart-bind</a></tt> where the function
simply does an unconditional transfer of control to a particular body of code,
passing along “argument” information in a structured way.
<!--l. 768--><p class="indent" >   It is also possible to write restarts that do not transfer control. Such restarts
may be useful in implementing various special commands for the debugger that
are of interest only in certain situations. For example, one might imagine a
situation where ﬁle space was exhausted and the following was done in an attempt
to free space in directory <tt>dir</tt>: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(restart-bind ((nil #&#x2019;(lambda () (expunge-directory dir))
   <br>                                                               :report-function<br>
                      #&#x2019;(lambda (stream)<br>
                          (format stream &#x0022;Expunge ~A.&#x0022;<br>
                                  (directory-namestring dir)))))<br>
  (cerror &#x0022;Try this ﬁle operation again.&#x0022;<br>
          &#x2019;directory-full :directory dir))<br>
<!--l. 781--><p class="noindent" ></div>
<!--l. 781--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-246300028.3.10" id="x182-246300028.3.10"></a></span>
<!--l. 781--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-246400028.3.10" id="x182-246400028.3.10"></a></span>
</div>
<!--l. 782--><p class="indent" >   In this case, the debugger might be entered and the user could ﬁrst perform
the expunge (which would not transfer control from the debugger context) and
then retry the ﬁle operation: <div class="lisp"><div class="tabbing">
Lisp&#x003E; (open &#x0022;FOO&#x0022; :direction :output)
   <br>                                         Error: The directory PS:&#x003C;JDOE&#x003E; is full.<br>
To continue, type :CONTINUE followed by an option number:<br>
 1: Try this ﬁle operation again.<br>                 2: Expunge PS:&#x003C;JDOE&#x003E;.<br>
 3: Return to Lisp Toplevel.<br>                           Debug&#x003E; :continue 2<br>
Expunging PS:&#x003C;JDOE&#x003E; ... 3 records freed.<br>            Debug&#x003E; :continue 1<br>
 <span class="math"> ⇒</span> #&#x003C;OUTPUT-STREAM &#x0022;PS:&#x003C;JDOE&#x003E;FOO.LSP&#x0022; 2323473&#x003E;<br>
<!--l. 796--><p class="noindent" ></div>
<!--l. 796--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-246500028.3.10" id="x182-246500028.3.10"></a></span>
<!--l. 796--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-246600028.3.10" id="x182-246600028.3.10"></a></span>
</div>
                                                                          

                                                                          
<!--l. 799--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.11   </span> <a 
href="frontmatter.html#QQ2-182-2508" id="x182-246700028.3.11">Interactive Condition Handling</a></h4>
<!--l. 801--><p class="noindent" >When a program does not know how to continue, and no active handler is able to
advise it, the “interactive condition handler,” or “debugger,” can be entered. This
happens implicitly through the use of functions such as <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> and <tt><a 
href="symbols.html#x187-2604193r193">cerror</a></tt>, or
explicitly through the use of the function <tt><a 
href="symbols.html#x187-2604455r455">invoke-debugger</a></tt>.
<!--l. 806--><p class="indent" >   The interactive condition handler never returns directly; it returns only
through structured non-local transfer of control to specially deﬁned restart points
that can be set up either by the system or by user code. The mechanisms that
support the establishment of such structured restart points for portable code are
outlined in sections <a 
href="#x182-242700028.3.5">28.3.5<!--tex4ht:ref: RESTARTS --></a> through <a 
href="#x182-246000028.3.10">28.3.10<!--tex4ht:ref: LAST-RESTARTS-SECTION --></a>.
<!--l. 813--><p class="indent" >   Actually, implementations may also provide extended debugging facilities that
allow return from arbitrary stack frames. Although such commands are frequently
useful in practice, their eﬀects are implementation-dependent because they violate
the Common Lisp program abstraction. The eﬀect of using such commands is
undeﬁned with respect to Common Lisp.
<!--l. 820--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.12   </span> <a 
href="frontmatter.html#QQ2-182-2509" id="x182-246800028.3.12">Serious Conditions</a></h4>
<!--l. 822--><p class="noindent" >The <tt><a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt> macro will trap conditions of type <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>. There are,
however, conditions that are not of type <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>.
<!--l. 825--><p class="indent" >   Some conditions are not considered errors but are still very serious, so we call
them <i>serious conditions</i> and we use the type <tt><a 
href="symbols.html#x187-2604768r768">serious-condition</a></tt> to represent
them. Conditions such as those that might be signaled for “stack overﬂow” or
“storage exhausted” are in this category.
<!--l. 830--><p class="indent" >   The type <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> is a subtype of <tt><a 
href="symbols.html#x187-2604768r768">serious-condition</a></tt>, and it would
technically be correct to use the term “serious condition” to refer to all serious
conditions whether errors or not. However, normally we use the term “serious
condition” to refer to things of type <tt><a 
href="symbols.html#x187-2604768r768">serious-condition</a></tt> but not of type
<tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>.
<!--l. 836--><p class="indent" >   The point of the distinction between errors and other serious conditions is
that some conditions are known to occur for reasons that are beyond the
scope of Common Lisp to specify clearly. For example, we know that a
stack will generally be used to implement function calling, and we know
that stacks tend to be of ﬁnite size and are prone to overﬂow. Since the
available stack size may vary from implementation to implementation,
                                                                          

                                                                          
from session to session, or from function call to function call, it would be
confusing to have expressions such as <tt>(ignore-errors (+ a b))</tt> return a
number sometimes and <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> other times if <tt>a</tt> and <tt>b</tt> were always bound to
numbers and the stack just happened to overﬂow on a particular call.
For this reason, only conditions of type <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> and not all conditions of
type <tt><a 
href="symbols.html#x187-2604768r768">serious-condition</a></tt> are trapped by <tt><a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt>. To trap other
conditions, a lower-level facility must be used (such as <tt><a 
href="symbols.html#x187-2604425r425">handler-bind</a></tt> or
<tt><a 
href="symbols.html#x187-2604426r426">handler-case</a></tt>).
<!--l. 850--><p class="indent" >   By convention, the function <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> is preferred over <tt><a 
href="symbols.html#x187-2604786r786">signal</a></tt> to signal
conditions of type <tt><a 
href="symbols.html#x187-2604768r768">serious-condition</a></tt> (including those of type <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>). It is the
use of the function <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>, and not the type of the condition being signaled, that
actually causes the debugger to be entered.________________________________<div class="incompatibility">
<!--l. 856--><p class="noindent" ><b>Несовместимость:</b> The Common Lisp Condition System diﬀers from that of Zetalisp
in this respect. In Zetalisp the debugger is entered for an unhandled signal if the <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>
function is used <i>or</i> if the condition is of type <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>.
</div>___________________________________________________________________________________________________________
<!--l. 863--><p class="noindent" >
     <h4 class="subsectionHead"><span class="titlemark">28.3.13   </span> <a 
href="frontmatter.html#QQ2-182-2510" id="x182-246900028.3.13">Non-Serious Conditions</a></h4>
<!--l. 865--><p class="noindent" >Some conditions are neither errors nor serious conditions. They are signaled to
give other programs a chance to intervene, but if no action is taken, computation
simply continues normally.
<!--l. 869--><p class="indent" >     For example, an implementation might choose to signal a non-serious (and
implementation-dependent) condition called <tt>end-of-line</tt> when output
reaches the last character position on a line of character output. In such an
implementation, the signaling of this condition might allow a convenient way for
other programs to intervene, producing output that is truncated at the end of a
line.
<!--l. 876--><p class="indent" >     By convention, the function <tt><a 
href="symbols.html#x187-2604786r786">signal</a></tt> is used to signal conditions that are not
serious. It would be possible to signal serious conditions using <tt><a 
href="symbols.html#x187-2604786r786">signal</a></tt>, and the
debugger would not be entered if the condition went unhandled. However, by
convention, handlers will generally tend to assume that serious conditions and
errors were signaled by calling the <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> function (and will therefore force entry
to the interactive condition handler) and that they should work to avoid
this.
                                                                          

                                                                          
<!--l. 886--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.14   </span> <a 
href="frontmatter.html#QQ2-182-2511" id="x182-247000028.3.14">Condition Types</a></h4>
<!--l. 888--><p class="noindent" >Some types of conditions are predeﬁned by the system. All types of conditions are
subtypes of <tt><a 
href="symbols.html#x187-2604246r246">condition</a></tt>. That is, <tt>(typep <i>x</i> &#x2019;condition)</tt> is true if and only if the
value of <i>x</i> is a condition.
<!--l. 892--><p class="indent" >   Implementations supporting multiple (or non-hierarchical) type inheritance are
expressly permitted to exploit multiple inheritance in the tree of condition types
as implementation-dependent extensions, as long as such extensions are
compatible with the speciﬁcations in this chapter. [X3J13 voted in March 1989 <a 
 id="dx182-2470001"></a>to
integrate the Condition System and the Object System, so multiple inheritance is
always available for condition types.—GLS]
<!--l. 900--><p class="indent" >   In order to avoid problems in portable code that runs both in systems with
multiple type inheritance and in systems without it, programmers are
explicitly warned that while all correct Common Lisp implementations
will ensure that <tt>(typep <i>c</i> &#x2019;condition)</tt> is true for all conditions <i>c</i> (and
all subtype relationships indicated in this chapter will also be true), it
should <i>not</i> be assumed that two condition types speciﬁed to be subtypes of
the same third type are disjoint. (In some cases, disjoint subtypes are
identiﬁed explicitly, but such disjointness is not to be assumed by default.)
For example, it follows from the subtype descriptions contained in this
chapter that in all implementations <tt>(typep <i>c</i> &#x2019;control-error)</tt> implies
<tt>(typep <i>c</i> &#x2019;error)</tt>, but note that <tt>(typep <i>c</i> &#x2019;control-error)</tt> does <i>not</i> imply
<tt>(not (typep <i>c</i> &#x2019;cell-error))</tt>.
<!--l. 917--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.15   </span> <a 
href="frontmatter.html#QQ2-182-2512" id="x182-247100028.3.15">Signaling Conditions</a></h4>
<!--l. 919--><p class="noindent" >When a condition is signaled, the system tries to locate the most appropriate
handler for the condition and to invoke that handler.
<!--l. 922--><p class="indent" >   Handlers are established dynamically using <tt><a 
href="symbols.html#x187-2604425r425">handler-bind</a></tt> or abstractions
built on <tt><a 
href="symbols.html#x187-2604425r425">handler-bind</a></tt>.
<!--l. 925--><p class="indent" >   If an appropriate handler is found, it is called. In some circumstances, the
handler may <i>decline</i> simply by returning without performing a non-local transfer
of control. In such cases, the search for an appropriate handler is picked up where
it left oﬀ, as if the called handler had never been present.
<!--l. 931--><p class="indent" >   If no handler is found, or if all handlers that were found decline, <tt><a 
href="symbols.html#x187-2604786r786">signal</a></tt>
returns <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>.
                                                                          

                                                                          
<!--l. 934--><p class="indent" >   Although it follows from the description above, it is perhaps worth noting
explicitly that the lookup procedure described here will prefer a general but more
(dynamically) local handler over a speciﬁc but less (dynamically) local handler.
Experience with existing condition systems suggests that this is a reasonable
approach and works adequately in most situations. Some care should be taken
when binding handlers for very general kinds of conditions, such as is done in
<tt><a 
href="symbols.html#x187-2604436r436">ignore-errors</a></tt>. Often, binding for a more speciﬁc condition type than <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt> is
more appropriate.
<!--l. 944--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.16   </span> <a 
href="frontmatter.html#QQ2-182-2513" id="x182-247200028.3.16">Resignaling Conditions</a></h4>
<!--l. 946--><p class="noindent" >[The contents of this section are still a subject of some debate within X3J13. The
reader may wish to take this section with a grain of salt.—GLS]
<!--l. 949--><p class="indent" >   Note that signaling a condition has no side eﬀect on that condition,
and that there is no dynamic state contained in a condition object. As
such, it may at times be reasonable and appropriate to consider caching
condition objects for repeated use, re-signaling conditions from within
handlers, or saving conditions away somewhere and re-signaling them
later.
<!--l. 955--><p class="indent" >   For example, it may be desirable for the system to pre-allocate objects of type
<tt><a 
href="symbols.html#x187-2604818r818">storage-condition</a></tt> so that they can be signaled when needed without
attempting to allocate more storage.
<!--l. 960--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.17   </span> <a 
href="frontmatter.html#QQ2-182-2514" id="x182-247300028.3.17">Condition Handlers</a></h4>
<!--l. 963--><p class="noindent" >A <i>handler</i> is a function of one argument, the condition to be handled. The
handler may inspect the object to be sure it is “interested” in handling the
condition.
<!--l. 967--><p class="indent" >   A handler is executed in the dynamic context of the signaler, except that the
set of available condition handlers will have been rebound to the value that was
active at the time the condition handler was made active. The intent
of this is to prevent inﬁnite recursion because of errors in a condition
handler.
<!--l. 972--><p class="indent" >   After inspecting the condition, the handler should take one of the following
actions:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">It might <i>decline</i> to handle the condition (by simply returning). When
      this happens, the returned values are ignored and the eﬀect is the same
      as if the handler had been invisible to the mechanism seeking to ﬁnd
      a handler. The next handler in line will be tried, or if no such handler
      exists, the condition will go unhandled.
      </li>
      <li class="itemize">It might <i>handle</i> the condition (by performing some non-local transfer
      of  control).  This  may  be  done  either  primitively  using  <tt><a 
href="symbols.html#x187-2604423r423">go</a></tt>,  <tt><a 
href="symbols.html#x187-2604749r749">return</a></tt>,
      or  <tt>throw</tt>,  or  more  abstractly  using  a  function  such  as  <tt><a 
href="symbols.html#x187-2604066r66">abort</a></tt> or
      <tt><a 
href="symbols.html#x187-2604456r456">invoke-restart</a></tt>.
      </li>
      <li class="itemize">It might signal another condition.
      </li>
      <li class="itemize">It might invoke the interactive debugger.</li></ul>
<!--l. 993--><p class="noindent" >In fact, the latter two actions (signaling another condition or entering the debugger)
are really just ways of putting oﬀ the decision to either handle or decline, or
trying to get someone else to make such a decision. Ultimately, all a handler can
do is to handle or decline to handle.
<!--l. 998--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.3.18   </span> <a 
href="frontmatter.html#QQ2-182-2515" id="x182-247400028.3.18">Printing Conditions</a></h4>
<!--l. 1000--><p class="noindent" >When <tt><a 
href="symbols.html#x187-2604028r28">*print-escape*</a></tt> is <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> (for example, when the <tt><a 
href="symbols.html#x187-2604686r686">princ</a></tt> function or the
<tt>~A</tt> directive is used with <tt><a 
href="symbols.html#x187-2604392r392">format</a></tt>), the report method for the condition
will be invoked. This will be done automatically by functions such as
<tt><a 
href="symbols.html#x187-2604455r455">invoke-debugger</a></tt>, <tt><a 
href="symbols.html#x187-2604148r148">break</a></tt>, and <tt><a 
href="symbols.html#x187-2604922r922">warn</a></tt>, but there may still be situations in which it
is desirable to have a condition report under explicit user control. For example,
<div class="lisp"><div class="tabbing">
(let ((form &#x2019;(open &#x0022;nosuchﬁle&#x0022;)))
   <br>              (handler-case (eval form)<br>                (serious-condition (c)<br>
      (format t &#x0022;~&#x0026;Evaluation of ~S failed:~%~A&#x0022; form c))))<br>
<!--l. 1011--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1011--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-247500028.3.18" id="x182-247500028.3.18"></a></span>
<!--l. 1011--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-247600028.3.18" id="x182-247600028.3.18"></a></span>
</div>
<!--l. 1012--><p class="indent" >   might print something like <div class="lisp"><div class="tabbing">
Evaluation of (OPEN &#x0022;nosuchﬁle&#x0022;) failed:
   <br>                                                The ﬁle &#x0022;nosuchﬁle&#x0022; was not found.<br>
<!--l. 1016--><p class="noindent" ></div>
<!--l. 1016--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-247700028.3.18" id="x182-247700028.3.18"></a></span>
<!--l. 1016--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-247800028.3.18" id="x182-247800028.3.18"></a></span>
</div>
<!--l. 1017--><p class="indent" >   Some suggestions about the form of text typed by report methods:
      <ul class="itemize1">
      <li class="itemize">The message should generally be a complete sentence, beginning with
      a capital letter and ending with appropriate punctuation (usually a
      period).
      </li>
      <li class="itemize">The message should <i>not</i> include any introductory text such as “<tt>Error:</tt>”
      or “<tt>Warning:</tt>” and should not be followed by a trailing newline. Such
      text will be added as may be appropriate to context by the routine
      invoking the report method.
      </li>
      <li class="itemize">Except   where   unavoidable,   the   tab   character   (which   is   only
      semi-standard anyway) should not be used in error messages. Its eﬀect
      may vary from one implementation to another and may cause problems
      even  within  an  implementation  because  it  may  do  diﬀerent  things
      depending on the column at which the error report begins.
                                                                          

                                                                          
      </li>
      <li class="itemize">Single-line messages are preferred, but newlines in the middle of long
      messages are acceptable.
      </li>
      <li class="itemize">If any program (for example, the debugger) displays messages indented
      from the prevailing left margin (for example, indented seven spaces
      because they are preﬁxed by the seven-character herald “<tt>Error: </tt>”),
      then  that  program  will  take  care  of  inserting  the  appropriate
      indentation into the extra lines of a multi-line error message. Similarly,
      a program that preﬁxes error messages with semicolons so that they
      appear to be comments should take care of inserting a semicolon at
      the beginning of each line in a multi-line error message. (These rules
      are important because, even within a single implementation, there may
      be more than one program that presents error messages to the user,
      and they may use diﬀerent styles of presentation. The caller of <tt><a 
href="symbols.html#x187-2604341r341">error</a></tt>
      cannot anticipate all such possible styles, and so it is incumbent upon
      the presenter of the message to make any necessary adjustments.)</li></ul>
<!--l. 1055--><p class="noindent" >[Note: These recommendations expand upon those in section ??.—GLS]
<!--l. 1057--><p class="indent" >   When <tt><a 
href="symbols.html#x187-2604028r28">*print-escape*</a></tt> is not <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>, the object should print in some
useful (but usually fairly abbreviated) fashion according to the style of the
implementation. It is not expected that a condition will be printed in a
form suitable for <tt><a 
href="symbols.html#x187-2604715r715">read</a></tt>. Something like <tt>#&#x003C;ARITHMETIC-ERROR 1734&#x003E;</tt> is
ﬁne.
<!--l. 1064--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx182-2478001"></a>to integrate the Condition System and the Object
System. In the original Condition System proposal, no function was provided for
directly accessing or setting the printer for a condition type, or for invoking it; the
techniques described above were the sole interface to reporting. The vote speciﬁed
that, in CLOS terms, condition reporting is mediated through the <tt><a 
href="symbols.html#x187-2604689r689">print-object</a></tt>
method for the condition type (that is, class) in question, with <tt><a 
href="symbols.html#x187-2604028r28">*print-escape*</a></tt>
bound to <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>. Specifying <tt>(:report <i>fn</i>)</tt> to <tt><a 
href="symbols.html#x187-2604278r278">define-condition</a></tt> when
deﬁning condition type <i>C</i> is equivalent to a separate method deﬁnition:
<div class="lisp"><div class="tabbing">
(defmethod print-object ((x <i>C</i>) stream)
                                                                          

                                                                          
   <br>                    (if *print-escape*<br>                        (call-next-method)<br>
      (funcall #&#x2019;<i>fn</i> x stream)))<br>
<!--l. 1080--><p class="noindent" ></div>
<!--l. 1080--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-247900028.3.18" id="x182-247900028.3.18"></a></span>
<!--l. 1080--><p class="noindent" ><span class="paragraphHead"><a 
href="#x182-248000028.3.18" id="x182-248000028.3.18"></a></span>
</div>
<!--l. 1081--><p class="indent" >   Note that the method uses <i>fn</i> to print the condition only when <tt><a 
href="symbols.html#x187-2604028r28">*print-escape*</a></tt>
has the value <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>.
                                                                          

                                                                          
<!--l. 1086--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse150.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse148.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse148.html#tailclmse148.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse149.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="condition.html#clmse149.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse149.html"></a>   </div> </div> 
</body></html> 
