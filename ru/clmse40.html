<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Операторы условных переходов</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 16:17:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 6630--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse41.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse39.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse39.html#tailclmse39.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse40.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html#clmse40.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">7.6   </span> <a 
href="clm.html#QQ2-52-570" id="x52-5620007.6">Операторы
условных переходов</a></h3>
<!--l. 6632--><p class="noindent" >Традиционная условная конструкция в Lisp&#x2019;е это <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt>. Однако, <tt><a 
href="symbols.html#x187-2604435r435">if</a></tt>
гораздо проще и очень похожа на условные конструкции в других
языках программирования. Она сделана примитивом в Common Lisp&#x2019;е.
Common Lisp также предоставляет конструкции диспетчеризации
(распределения) <tt><a 
href="symbols.html#x187-2604172r172">case</a></tt> и <tt><a 
href="symbols.html#x187-2604892r892">typecase</a></tt>, которые часто более удобны, чем
<tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt>.
<div class="defspec">
<div class="defmacheader">
<!--l. 6639--><p class="indent" >   <div class="tabbing">
 <i>[Специальный оператор]</i> <b>if</b> <a 
 id="dx52-562001"></a><a 
 id="x52-562002r87"></a> test then [else]
   <br>
<!--l. 6640--><p class="noindent" ></div>
<!--l. 6640--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5630007.6" id="x52-5630007.6"></a></span>
</div>
<!--l. 6641--><p class="indent" >   Специальная формы <tt><a 
href="symbols.html#x187-2604435r435">if</a></tt> обозначает то же, что и конструкция <b>if</b>-<b>then</b>-<b>else</b>
в большинстве других языках программирования. Сначала выполняется
форма <i>test</i>. Если результат не равен <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>, тогда выбирается форма <i>then</i>.
Иначе выбирается форма <i>else</i>. Выбранная ранее форма выполняется, и <tt><a 
href="symbols.html#x187-2604435r435">if</a></tt>
возвращает то, что вернула это форма. <div class="lisp"><div class="tabbing">
(if <i>test</i> <i>then</i> <i>else</i>) <span class="math"> ≡</span> (cond (<i>test</i> <i>then</i>) (<tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> <i>else</i>))
   <br>
<!--l. 6650--><p class="noindent" ></div>
<!--l. 6650--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5640007.6" id="x52-5640007.6"></a></span>
                                                                          

                                                                          
<!--l. 6650--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5650007.6" id="x52-5650007.6"></a></span>
</div>
<!--l. 6651--><p class="indent" >   Но в некоторых ситуациях <tt><a 
href="symbols.html#x187-2604435r435">if</a></tt> оказывается более читабельным.
<!--l. 6653--><p class="indent" >   Форма <i>else</i> может быть опущена. В таком случае, если значение формы
<i>test</i> является <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>, тогда ничего не будет выполнено и возвращаемое значение
формы <tt><a 
href="symbols.html#x187-2604435r435">if</a></tt> будет <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>. Если в этой ситуации значение формы <tt><a 
href="symbols.html#x187-2604435r435">if</a></tt> важно, тогда
в зависимости от контекста стилистически удобнее использовать форму <tt><a 
href="symbols.html#x187-2604078r78">and</a></tt>.
Если значение не важно, тогда удобнее использовать конструкцию
<tt><a 
href="symbols.html#x187-2604924r924">when</a></tt>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6662--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>when</b> <a 
 id="dx52-565001"></a><a 
 id="x52-565002r88"></a> test {form}*
   <br>
<!--l. 6663--><p class="noindent" ></div>
<!--l. 6663--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5660007.6" id="x52-5660007.6"></a></span>
</div>
<tt>
<!--l. 6664--><p class="indent" >   (when <i>test</i> <i>form1</i> <i>form2</i> ... )</tt> сначала выполняет <i>test</i>. Если
результат <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>, тогда ничего не выполняется и возвращается <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>. Иначе,
последовательно выполняются формы <i>form</i> слева направо (как неявный
<tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt>), и возвращается значение последней формы. <div class="lisp"><div class="tabbing">
(when <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (and <i>p</i> (progn <i>a</i> <i>b</i> <i>c</i>))
   <br>                                                (when <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (cond (<i>p</i> <i>a</i> <i>b</i> <i>c</i>))<br>
(when <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (if <i>p</i> (progn <i>a</i> <i>b</i> <i>c</i>) <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>)<br>
(when <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (unless (not <i>p</i>) <i>a</i> <i>b</i> <i>c</i>)<br>
<!--l. 6675--><p class="noindent" ></div>
<!--l. 6675--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5670007.6" id="x52-5670007.6"></a></span>
                                                                          

                                                                          
<!--l. 6675--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5680007.6" id="x52-5680007.6"></a></span>
</div>
<!--l. 6676--><p class="indent" >   В целях хорошего стиля, <tt><a 
href="symbols.html#x187-2604924r924">when</a></tt> обычно используется для выполнения
побочных эффектов при некоторых условиях, и значение <tt><a 
href="symbols.html#x187-2604924r924">when</a></tt> не используется.
Если значение все-таки важно, тогда, может быть, стилистически функции
<tt><a 
href="symbols.html#x187-2604078r78">and</a></tt> или <tt><a 
href="symbols.html#x187-2604435r435">if</a></tt> более подходят.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6683--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>unless</b> <a 
 id="dx52-568001"></a><a 
 id="x52-568002r89"></a> test {form}*
   <br>
<!--l. 6684--><p class="noindent" ></div>
<!--l. 6684--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5690007.6" id="x52-5690007.6"></a></span>
</div>
<tt>
<!--l. 6685--><p class="indent" >   (unless <i>test</i> <i>form1</i> <i>form2</i> ... )</tt> сначала выполняет <i>test</i>. Если
результат <i>не</i> <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>, тогда ничего не выполняется и возвращается <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>.
Иначе, последовательно выполняются формы <i>form</i> слева направо
(как неявный <tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt>), и возвращается значение последней формы.
<div class="lisp"><div class="tabbing">
(unless <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (cond ((not <i>p</i>) <i>a</i> <i>b</i> <i>c</i>))
   <br>                                     (unless <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (if <i>p</i> <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> (progn <i>a</i> <i>b</i> <i>c</i>))<br>
(unless <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (when (not <i>p</i>) <i>a</i> <i>b</i> <i>c</i>)<br>
<!--l. 6695--><p class="noindent" ></div>
<!--l. 6695--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5700007.6" id="x52-5700007.6"></a></span>
                                                                          

                                                                          
<!--l. 6695--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5710007.6" id="x52-5710007.6"></a></span>
</div>
<!--l. 6696--><p class="indent" >   В целях хорошего стиля, <tt><a 
href="symbols.html#x187-2604899r899">unless</a></tt> обычно используется для выполнения
побочных эффектов при некоторых условиях, и значение <tt><a 
href="symbols.html#x187-2604899r899">unless</a></tt> не
используется. Если значение все-таки важно, тогда может быть стилистически
более подходящая функция <tt><a 
href="symbols.html#x187-2604435r435">if</a></tt>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6703--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>cond</b> <a 
 id="dx52-571001"></a><a 
 id="x52-571002r90"></a> {(test {form}*)}*
   <br>
<!--l. 6704--><p class="noindent" ></div>
<!--l. 6704--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5720007.6" id="x52-5720007.6"></a></span>
</div>
<!--l. 6705--><p class="indent" >   Форма <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt> содержит некоторое (возможно нулевое) количество
подвыражений, которые является списками форм. Каждое подвыражение
содержит форму условия и ноль и более форм для выполнения. Например:
<div class="lisp"><div class="tabbing">
(cond (<i>test-1</i> <i>consequent-1-1</i> <i>consequent-1-2</i> ...)
   <br>                      (<i>test-2</i>)<br>                      (<i>test-3</i> <i>consequent-3-1</i> ...)<br>
      ... )<br>
<!--l. 6714--><p class="noindent" ></div>
<!--l. 6714--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5730007.6" id="x52-5730007.6"></a></span>
<!--l. 6714--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5740007.6" id="x52-5740007.6"></a></span>
</div>
                                                                          

                                                                          
<!--l. 6716--><p class="indent" >   Отбирается первое подвыражение, чья форма условия вычисляется в
не-<tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>. Все остальные подвыражения игнорируются. Формы отобранного
подвыражения последовательно выполняются (как неявный <tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt>).
<!--l. 6720--><p class="indent" >   Если быть точнее, <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt> обрабатывает свои подвыражения слева направо.
Для каждого подвыражения, вычисляется форма условия. Если результат
<tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>, <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt> переходит к следующему подвыражению. Если результат <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt>, <i>cdr</i>
подвыражения обрабатывается, как список форм. Этот список выполняется
слева направо, как неявный <tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt>. После выполнения списка форм, <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt>
возвращает управление без обработки оставшихся подвыражений.
Специальная форма <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt> возвращает результат выполнения последней
формы из списка. Если этот список пустой, тогда возвращается значение
формы условия. Если <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt> вернула управление без вычисления какой-либо
ветки (все условные формы вычислялись в <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>), возвращается значение
<tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>.
<!--l. 6732--><p class="indent" >   Для того, чтобы выполнить последнее подвыражение, в случае если
раньше ничего не выполнилось, можно использовать <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> для формы условия. В
целях стиля, если значение <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt> будет для чего-то использоваться,
желательно записывать последнее выражение так: <tt>(<tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>)</tt>. Также вопросом
вкуса является запись последнего подвыражения <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt> как «синглтон», в
таком случае, используется неявный <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt>. (Следует отметить, если <i>x</i> может
возвращать несколько значений, то <tt>(cond ... (<i>x</i>))</tt> может вести себя
отлично от <tt>(cond ... (<tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> <i>x</i>))</tt>. Первое выражение всегда возвращает одно
выражение, тогда как второе возвращает все то же, что и <i>x</i>. В зависимости
от стиля, можно указывать поведение явно <tt>(cond ... (t (values <i>x</i>)))</tt>,
используя функцию <tt><a 
href="symbols.html#x187-2604914r914">values</a></tt> для явного указания возврата одного значения.)
Например: <div class="lisp"><div class="tabbing">
(setq z (cond (a &#x2019;foo) (b &#x2019;bar)))                                ;Возможна неопределённость
   <br>      (setq z (cond (a &#x2019;foo) (b &#x2019;bar) (<tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>)))                     ;Уже лучше<br>
(cond (a b) (c d) (e))                                             ;Возможна неопределённость<br>
(cond (a b) (c d) (<tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> e))                                          ;Уже лучше<br>
(cond (a b) (c d) (<tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> (values e)))                               ;Неплохо (если необходимо<br>
                                                      ; одно значение)<br>
(cond (a b) (c))                                                    ;Возможна неопределённость<br>
(cond (a b) (t c))                                                  ;Уже лучше<br>
(if a b c)                                                             ;Тоже неплохо<br>
                                                                          

                                                                          
<!--l. 6756--><p class="noindent" ></div>
<!--l. 6756--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5750007.6" id="x52-5750007.6"></a></span>
<!--l. 6756--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5760007.6" id="x52-5760007.6"></a></span>
</div>
<!--l. 6757--><p class="indent" >   Lisp&#x2019;овая форма <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt> сравнима с последовательностью <b>if</b>-<b>then</b>-<b>else</b>,
используемой в большинстве алгебраических языках программирования:
<div class="lisp"><div class="tabbing">
(cond (<i>p</i> ...)                                                 <b>if</b> <i>p</i> <b>тогда</b> ...
<br>        (<i>q</i> ...)               roughly                       <b>иначе</b> <b>если</b> <i>q</i> <b>тогда</b> ...<br>
      (<i>r</i> ...)               corresponds                  <b>иначе</b> <b>если</b> <i>r</i> <b>тогда</b> ...<br>
      ...                    to                               ...<br>
      (<tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> ...))                                               <b>иначе</b> ...<br>
<!--l. 6767--><p class="noindent" ></div>
<!--l. 6767--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5770007.6" id="x52-5770007.6"></a></span>
<!--l. 6767--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5780007.6" id="x52-5780007.6"></a></span>
</div>
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6771--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>case</b> <a 
 id="dx52-578001"></a><a 
 id="x52-578002r91"></a> keyform {({({key}*) | key} {form}*)}*
   <br>
<!--l. 6772--><p class="noindent" ></div>
<!--l. 6772--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5790007.6" id="x52-5790007.6"></a></span>
                                                                          

                                                                          
</div>
<tt>
<!--l. 6773--><p class="indent" >   <a 
href="symbols.html#x187-2604172r172">case</a></tt> условный оператор, который выбирает ветку для выполнения, в
зависимости от равенства некоторой переменной некоторой константе.
Константа обычно представляет собой ключевой символ, целое число или
строковый символ (но может быть и любой другой объект). Вот развёрнутая
форма: <div class="lisp"><div class="tabbing">
(case <i>keyform</i>
   <br>                                  (<i>keylist-1</i> <i>consequent-1-1</i> <i>consequent-1-2</i> ...)<br>
  (<i>keylist-2</i> <i>consequent-2-1</i> ...)<br>                (<i>keylist-3</i> <i>consequent-3-1</i> ...)<br>
  ...)<br>
<!--l. 6783--><p class="noindent" ></div>
<!--l. 6783--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5800007.6" id="x52-5800007.6"></a></span>
<!--l. 6783--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5810007.6" id="x52-5810007.6"></a></span>
</div>
<!--l. 6784--><p class="indent" >   Структурно <tt><a 
href="symbols.html#x187-2604172r172">case</a></tt> очень похож на <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt>, и поведение такое же: выбрать
список форм и выполнить их. Однако <tt><a 
href="symbols.html#x187-2604172r172">case</a></tt> отличается механизмом выбора
подвыражения.
<!--l. 6788--><p class="indent" >   Сперва <tt><a 
href="symbols.html#x187-2604172r172">case</a></tt> вычисляет форму <i>keyform</i> для получения объекта, который
называется <i>ключевой объект</i>. Затем <tt><a 
href="symbols.html#x187-2604172r172">case</a></tt> рассматривает все подвыражения.
Если <i>ключевой объект</i> присутствует в списке <i>keylist</i> (то есть, если <i>ключевой
объект</i> равен <tt><a 
href="symbols.html#x187-2604338r338">eql</a></tt> хотя бы одному элементу из списка <i>keylist</i>), то список форм
выбранного подвыражения вычисляется, как неявный <tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt>. <tt><a 
href="symbols.html#x187-2604172r172">case</a></tt>
возвращает то же, что и последняя форма списка (или <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> если список форм
был пустой). Если ни одно подвыражение не удовлетворило условию, то <tt><a 
href="symbols.html#x187-2604172r172">case</a></tt>
возвращает <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>.
<!--l. 6799--><p class="indent" >   Ключи в списке ключей <i>keylist</i> <i>не</i> выполняются. В данном списке должны
быть указаны литеральные ключи. Если один ключ попадается более чем в
одном подвыражении, это считается ошибкой. Следствием является то, что
порядок этих подвыражений не влияет на поведение конструкции
<tt><a 
href="symbols.html#x187-2604172r172">case</a></tt>.
                                                                          

                                                                          
<!--l. 6806--><p class="indent" >   Вместо <i>keylist</i> можно записать один из символов: <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> или <tt>otherwise</tt>.
Подвыражение с одним из таких символов всегда удовлетворяет условию
выбора. Такое подвыражение должно быть последним (это исключение из
правила о произвольности положения подвыражений). Смотрите также
<tt><a 
href="symbols.html#x187-2604324r324">ecase</a></tt> и <tt><a 
href="symbols.html#x187-2604174r174">ccase</a></tt>, каждая из которых предоставляет неявное <tt>otherwise</tt>
подвыражение для сигнализирования об ошибке, если ни одно подвыражение
не удовлетворило условию.
<!--l. 6814--><p class="indent" >   Если в подвыражении только один ключ, тогда этот ключ может быть
записан вместо списка. Такой «синглтоновый ключ» не может быть <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> (так
как возникают конфликты с (), который означает список без ключей), <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt>,
<tt>otherwise</tt> или cons-ячейкой.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6822--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>typecase</b> <a 
 id="dx52-581001"></a><a 
 id="x52-581002r92"></a> keyform {(type {form}*)}*
   <br>
<!--l. 6823--><p class="noindent" ></div>
<!--l. 6823--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5820007.6" id="x52-5820007.6"></a></span>
</div>
<tt>
<!--l. 6824--><p class="indent" >   <a 
href="symbols.html#x187-2604892r892">typecase</a></tt> условный оператор, который выбирает подвыражение на основе
типа объекта. Развёрнутая форма: <div class="lisp"><div class="tabbing">
(typecase <i>keyform</i>
   <br>                                    (<i>type-1</i> <i>consequent-1-1</i> <i>consequent-1-2</i> ...)<br>
  (<i>type-2</i> <i>consequent-2-1</i> ...)<br>                    (<i>type-3</i> <i>consequent-3-1</i> ...)<br>
  ...)<br>
<!--l. 6833--><p class="noindent" ></div>
<!--l. 6833--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5830007.6" id="x52-5830007.6"></a></span>
                                                                          

                                                                          
<!--l. 6833--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5840007.6" id="x52-5840007.6"></a></span>
</div>
<!--l. 6834--><p class="indent" >   Структура <tt><a 
href="symbols.html#x187-2604892r892">typecase</a></tt> похожа на <tt><a 
href="symbols.html#x187-2604245r245">cond</a></tt> или <tt><a 
href="symbols.html#x187-2604172r172">case</a></tt>. Поведение также схоже в
том, что выбирается подвыражение в зависимости от условия. Различие
заключается в механизме выбора подвыражения.
<!--l. 6838--><p class="indent" >   Сперва <tt><a 
href="symbols.html#x187-2604892r892">typecase</a></tt> вычисляет форму <i>keyform</i> для создания объекта,
называемого ключевым объектом. Далее <tt><a 
href="symbols.html#x187-2604892r892">typecase</a></tt> друг за другом
рассматривает каждое подвыражение. Форма <i>type</i>, которая встречается
в каждом подвыражении, является спецификатором типа. Данный
спецификатор не вычисляется, поэтому должен быть литеральным. Когда
ключевой объект принадлежит некоторый типу, то выделенный список форм
<i>consequent</i> выполняется последовательно (как неявный <tt><a 
href="symbols.html#x187-2604698r698">progn</a></tt>). <tt><a 
href="symbols.html#x187-2604892r892">typecase</a></tt>
возвращает то, что вернула последняя форма из списка (или <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> если список
был пуст). Если не одно подвыражение не было выбрано, <tt><a 
href="symbols.html#x187-2604892r892">typecase</a></tt>
возвращает <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>.
<!--l. 6849--><p class="indent" >   Как и для <tt><a 
href="symbols.html#x187-2604172r172">case</a></tt> можно использовать <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> или <tt>otherwise</tt> на позиции <i>типа</i>
для задания подвыражений, которые будут выполняться, только если не
было выполнено других подвыражений. Смотрите также <tt><a 
href="symbols.html#x187-2604342r342">etypecase</a></tt> и
<tt><a 
href="symbols.html#x187-2604267r267">ctypecase</a></tt>, каждая из которых предоставляет неявную ветку <tt>otherwise</tt> для
сигнализирования об ошибке, что ни одно подвыражение не удовлетворило
условию.
<!--l. 6856--><p class="indent" >   Допустимо указывать более одного подвыражение, тип условия которого
уже является подтипом условия другого подвыражения. В таком случае
будет выбрано первое встретившееся подвыражение. Таким образом в
<tt><a 
href="symbols.html#x187-2604892r892">typecase</a></tt>, в отличие от <tt><a 
href="symbols.html#x187-2604172r172">case</a></tt>, порядок следования подвыражений влияет на
поведение всей конструкции. <div class="lisp"><div class="tabbing">
(typecase an-object
   <br>   (string ...)                             ;Подвыражение обрабатывает строки<br>
   ((array t) ...)                          ;Подвыражение обрабатывает общие массивы<br>
   ((array bit) ...)                       ;Подвыражение обрабатывает битовые массивы<br>
   (array ...)                              ;Обрабатывает все остальные массивы<br>
   ((or list number) ...)                ;Подвыражение обрабатывает списки и числа<br>
   (t ...))                                   ;Подвыражение обрабатывает все остальные объекты<br>
<!--l. 6870--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 6870--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5850007.6" id="x52-5850007.6"></a></span>
<!--l. 6870--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-5860007.6" id="x52-5860007.6"></a></span>
</div>
</div>
                                                                          

                                                                          
<!--l. 6873--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse41.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse39.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse39.html#tailclmse39.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse40.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html#clmse40.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse40.html"></a>   </div> </div> 
</body></html> 
