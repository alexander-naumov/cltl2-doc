<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Операторы условных переходов</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-06-05 16:10:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="clmse41.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse39.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse39.html#tailclmse39.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse40.html">В-конец</a>&#x003E;&#x003C;<a 
href="contrl.html#clmse40.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">7.6
</span> <a 
href="clm.html#QQ2-52-90" id="x52-820007.6">Операторы условных переходов</a></h3>
<!--l. 6632--><p class="noindent" >Традиционная условная конструкция в Lisp&#x2019;е это <b><a 
href="symbols.html#x188-375269r269">cond</a></b>. Однако, <b><a 
href="symbols.html#x188-375476r476">if</a></b>
гораздо проще и очень похожа на условные конструкции в других
языках программирования. Она сделана примитивом в Common Lisp&#x2019;е.
Common Lisp также предоставляет конструкции диспетчеризации
(распределения) <b><a 
href="symbols.html#x188-375180r180">case</a></b> и <b><a 
href="symbols.html#x188-375963r963">typecase</a></b>, которые часто более удобны, чем
<b><a 
href="symbols.html#x188-375269r269">cond</a></b>.
<div class="defspec">
<div class="defmacheader">
<!--l. 6639--><p class="indent" >   <div class="tabbing">
 <em>[Специальный оператор]</em> <b>if</b> <a 
 id="dx52-82001"></a>test then [else]
   <br>
<!--l. 6640--><p class="noindent" ></div>
</div>
<!--l. 6641--><p class="indent" >   Специальная формы <b><a 
href="symbols.html#x188-375476r476">if</a></b> обозначает то же, что и конструкция <b>if</b>-<b>then</b>-<b>else</b> в
большинстве других языках программирования. Сначала выполняется форма
<em>test</em>. Если результат не равен <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, тогда выбирается форма <em>then</em>. Иначе
выбирается форма <em>else</em>. Выбранная ранее форма выполняется, и <b><a 
href="symbols.html#x188-375476r476">if</a></b>
возвращает то, что вернула это форма. <div class="lisp"><tt><div class="tabbing">
(if <em>test</em> <em>then</em> <em>else</em>) <span class="math"> ≡</span> (cond (<em>test</em> <em>then</em>) (<b><a 
href="symbols.html#x188-375939r939">t</a></b> <em>else</em>))
   <br>
<!--l. 6650--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6651--><p class="indent" >   Но в некоторых ситуациях <b><a 
href="symbols.html#x188-375476r476">if</a></b> оказывается более читабельным.
                                                                          

                                                                          
<!--l. 6653--><p class="indent" >   Форма <em>else</em> может быть опущена. В таком случае, если значение формы
<em>test</em> является <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, тогда ничего не будет выполнено и возвращаемое значение
формы <b><a 
href="symbols.html#x188-375476r476">if</a></b> будет <b><a 
href="symbols.html#x188-375658r658">nil</a></b>. Если в этой ситуации значение формы <b><a 
href="symbols.html#x188-375476r476">if</a></b> важно, тогда в
зависимости от контекста стилистически удобнее использовать форму <b><a 
href="symbols.html#x188-375086r86">and</a></b>.
Если значение не важно, тогда удобнее использовать конструкцию
<b><a 
href="symbols.html#x188-375997r997">when</a></b>.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6662--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>when</b> <a 
 id="dx52-82002"></a>test {form}*
   <br>
<!--l. 6663--><p class="noindent" ></div>
</div>
<b>
<!--l. 6664--><p class="indent" >   (when <em>test</em> <em>form1</em> <em>form2</em> ... )</b> сначала выполняет <em>test</em>. Если результат
<b><a 
href="symbols.html#x188-375658r658">nil</a></b>, тогда ничего не выполняется и возвращается <b><a 
href="symbols.html#x188-375658r658">nil</a></b>. Иначе, последовательно
выполняются формы <em>form</em> слева направо (как неявный <b><a 
href="symbols.html#x188-375749r749">progn</a></b>), и
возвращается значение последней формы. <div class="lisp"><tt><div class="tabbing">
(when <em>p</em> <em>a</em> <em>b</em> <em>c</em>) <span class="math"> ≡</span> (and <em>p</em> (progn <em>a</em> <em>b</em> <em>c</em>))
   <br>                                                (when <em>p</em> <em>a</em> <em>b</em> <em>c</em>) <span class="math"> ≡</span> (cond (<em>p</em> <em>a</em> <em>b</em> <em>c</em>))<br>
(when <em>p</em> <em>a</em> <em>b</em> <em>c</em>) <span class="math"> ≡</span> (if <em>p</em> (progn <em>a</em> <em>b</em> <em>c</em>) <b><a 
href="symbols.html#x188-375658r658">nil</a></b>)<br>
(when <em>p</em> <em>a</em> <em>b</em> <em>c</em>) <span class="math"> ≡</span> (unless (not <em>p</em>) <em>a</em> <em>b</em> <em>c</em>)<br>
<!--l. 6675--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6676--><p class="indent" >   В целях хорошего стиля, <b><a 
href="symbols.html#x188-375997r997">when</a></b> обычно используется для выполнения
побочных эффектов при некоторых условиях, и значение <b><a 
href="symbols.html#x188-375997r997">when</a></b> не используется.
Если значение все-таки важно, тогда, может быть, стилистически функции
<b><a 
href="symbols.html#x188-375086r86">and</a></b> или <b><a 
href="symbols.html#x188-375476r476">if</a></b> более подходят.
<hr></div>
<div class="defmac">
                                                                          

                                                                          
<div class="defmacheader">
<!--l. 6683--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>unless</b> <a 
 id="dx52-82003"></a>test {form}*
   <br>
<!--l. 6684--><p class="noindent" ></div>
</div>
<b>
<!--l. 6685--><p class="indent" >   (unless <em>test</em> <em>form1</em> <em>form2</em> ... )</b> сначала выполняет <em>test</em>. Если
результат <em>не</em> <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, тогда ничего не выполняется и возвращается <b><a 
href="symbols.html#x188-375658r658">nil</a></b>.
Иначе, последовательно выполняются формы <em>form</em> слева направо
(как неявный <b><a 
href="symbols.html#x188-375749r749">progn</a></b>), и возвращается значение последней формы.
<div class="lisp"><tt><div class="tabbing">
(unless <em>p</em> <em>a</em> <em>b</em> <em>c</em>) <span class="math"> ≡</span> (cond ((not <em>p</em>) <em>a</em> <em>b</em> <em>c</em>))
   <br>                                      (unless <em>p</em> <em>a</em> <em>b</em> <em>c</em>) <span class="math"> ≡</span> (if <em>p</em> <b><a 
href="symbols.html#x188-375658r658">nil</a></b> (progn <em>a</em> <em>b</em> <em>c</em>))<br>
(unless <em>p</em> <em>a</em> <em>b</em> <em>c</em>) <span class="math"> ≡</span> (when (not <em>p</em>) <em>a</em> <em>b</em> <em>c</em>)<br>
<!--l. 6695--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6696--><p class="indent" >   В целях хорошего стиля, <b><a 
href="symbols.html#x188-375970r970">unless</a></b> обычно используется для выполнения
побочных эффектов при некоторых условиях, и значение <b><a 
href="symbols.html#x188-375970r970">unless</a></b> не
используется. Если значение все-таки важно, тогда может быть стилистически
более подходящая функция <b><a 
href="symbols.html#x188-375476r476">if</a></b>.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6703--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>cond</b> <a 
 id="dx52-82004"></a>{(test {form}*)}*
   <br>
<!--l. 6704--><p class="noindent" ></div>
</div>
                                                                          

                                                                          
<!--l. 6705--><p class="indent" >   Форма <b><a 
href="symbols.html#x188-375269r269">cond</a></b> содержит некоторое (возможно нулевое) количество
подвыражений, которые является списками форм. Каждое подвыражение
содержит форму условия и ноль и более форм для выполнения. Например:
<div class="lisp"><tt><div class="tabbing">
(cond (<em>test-1</em> <em>consequent-1-1</em> <em>consequent-1-2</em> ...)
   <br>                      (<em>test-2</em>)<br>                      (<em>test-3</em> <em>consequent-3-1</em> ...)<br>
      ... )<br>
<!--l. 6714--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6716--><p class="indent" >   Отбирается первое подвыражение, чья форма условия вычисляется в
не-<b><a 
href="symbols.html#x188-375658r658">nil</a></b>. Все остальные подвыражения игнорируются. Формы отобранного
подвыражения последовательно выполняются (как неявный <b><a 
href="symbols.html#x188-375749r749">progn</a></b>).
<!--l. 6720--><p class="indent" >   Если быть точнее, <b><a 
href="symbols.html#x188-375269r269">cond</a></b> обрабатывает свои подвыражения слева направо.
Для каждого подвыражения, вычисляется форма условия. Если результат
<b><a 
href="symbols.html#x188-375658r658">nil</a></b>, <b><a 
href="symbols.html#x188-375269r269">cond</a></b> переходит к следующему подвыражению. Если результат <b><a 
href="symbols.html#x188-375939r939">t</a></b>, <em>cdr</em>
подвыражения обрабатывается, как список форм. Этот список выполняется
слева направо, как неявный <b><a 
href="symbols.html#x188-375749r749">progn</a></b>. После выполнения списка форм, <b><a 
href="symbols.html#x188-375269r269">cond</a></b>
возвращает управление без обработки оставшихся подвыражений.
Специальная форма <b><a 
href="symbols.html#x188-375269r269">cond</a></b> возвращает результат выполнения последней
формы из списка. Если этот список пустой, тогда возвращается значение
формы условия. Если <b><a 
href="symbols.html#x188-375269r269">cond</a></b> вернула управление без вычисления какой-либо
ветки (все условные формы вычислялись в <b><a 
href="symbols.html#x188-375658r658">nil</a></b>), возвращается значение
<b><a 
href="symbols.html#x188-375658r658">nil</a></b>.
<!--l. 6732--><p class="indent" >   Для того, чтобы выполнить последнее подвыражение, в случае если
раньше ничего не выполнилось, можно использовать <b><a 
href="symbols.html#x188-375939r939">t</a></b> для формы условия. В
целях стиля, если значение <b><a 
href="symbols.html#x188-375269r269">cond</a></b> будет для чего-то использоваться,
желательно записывать последнее выражение так: <b>(<b><a 
href="symbols.html#x188-375939r939">t</a></b> <b><a 
href="symbols.html#x188-375658r658">nil</a></b>)</b>. Также вопросом
вкуса является запись последнего подвыражения <b><a 
href="symbols.html#x188-375269r269">cond</a></b> как «синглтон», в
таком случае, используется неявный <b><a 
href="symbols.html#x188-375939r939">t</a></b>. (Следует отметить, если <em>x</em> может
возвращать несколько значений, то <b>(cond ... (<em>x</em>))</b> может вести себя отлично
от <b>(cond ... (<b><a 
href="symbols.html#x188-375939r939">t</a></b> <em>x</em>))</b>. Первое выражение всегда возвращает одно выражение,
тогда как второе возвращает все то же, что и <em>x</em>. В зависимости от стиля,
можно указывать поведение явно <b>(cond ... (t (values <em>x</em>)))</b>, используя
функцию <b><a 
href="symbols.html#x188-375987r987">values</a></b> для явного указания возврата одного значения.) Например:
                                                                          

                                                                          
<div class="lisp"><tt><div class="tabbing">
(setq z (cond (a &#x2019;foo) (b &#x2019;bar)))                                ;Возможна неопределённость
   <br>      (setq z (cond (a &#x2019;foo) (b &#x2019;bar) (<b><a 
href="symbols.html#x188-375939r939">t</a></b> <b><a 
href="symbols.html#x188-375658r658">nil</a></b>)))                      ;Уже лучше<br>
(cond (a b) (c d) (e))                                             ;Возможна неопределённость<br>
(cond (a b) (c d) (<b><a 
href="symbols.html#x188-375939r939">t</a></b> e))                                          ;Уже лучше<br>
(cond (a b) (c d) (<b><a 
href="symbols.html#x188-375939r939">t</a></b> (values e)))                               ;Неплохо (если необходимо<br>
                                                      ; одно значение)<br>
(cond (a b) (c))                                                    ;Возможна неопределённость<br>
(cond (a b) (t c))                                                  ;Уже лучше<br>
(if a b c)                                                             ;Тоже неплохо<br>
<!--l. 6756--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6757--><p class="indent" >   Lisp&#x2019;овая форма <b><a 
href="symbols.html#x188-375269r269">cond</a></b> сравнима с последовательностью <b>if</b>-<b>then</b>-<b>else</b>,
используемой в большинстве алгебраических языках программирования:
<div class="lisp"><tt><div class="tabbing">
(cond (<em>p</em> ...)                                                 <b>if</b> <em>p</em> <b>тогда</b> ...
<br>        (<em>q</em> ...)               roughly                       <b>иначе</b> <b>если</b> <em>q</em> <b>тогда</b> ...<br>
      (<em>r</em> ...)               corresponds                  <b>иначе</b> <b>если</b> <em>r</em> <b>тогда</b> ...<br>
      ...                    to                               ...<br>
      (<b><a 
href="symbols.html#x188-375939r939">t</a></b> ...))                                               <b>иначе</b> ...<br>
<!--l. 6767--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6771--><p class="indent" >   <div class="tabbing">
                                                                          

                                                                          
 <em>[Макрос]</em> <b>case</b> <a 
 id="dx52-82005"></a>keyform {({({key}*) | key} {form}*)}*
   <br>
<!--l. 6772--><p class="noindent" ></div>
</div>
<b>
<!--l. 6773--><p class="indent" >   <a 
href="symbols.html#x188-375180r180">case</a></b> условный оператор, который выбирает ветку для выполнения, в
зависимости от равенства некоторой переменной некоторой константе.
Константа обычно представляет собой ключевой символ, целое число или
строковый символ (но может быть и любой другой объект). Вот развёрнутая
форма: <div class="lisp"><tt><div class="tabbing">
(case <em>keyform</em>
   <br>                                  (<em>keylist-1</em> <em>consequent-1-1</em> <em>consequent-1-2</em> ...)<br>
  (<em>keylist-2</em> <em>consequent-2-1</em> ...)<br>                (<em>keylist-3</em> <em>consequent-3-1</em> ...)<br>
  ...)<br>
<!--l. 6783--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6784--><p class="indent" >   Структурно <b><a 
href="symbols.html#x188-375180r180">case</a></b> очень похож на <b><a 
href="symbols.html#x188-375269r269">cond</a></b>, и поведение такое же: выбрать
список форм и выполнить их. Однако <b><a 
href="symbols.html#x188-375180r180">case</a></b> отличается механизмом выбора
подвыражения.
<!--l. 6788--><p class="indent" >   Сперва <b><a 
href="symbols.html#x188-375180r180">case</a></b> вычисляет форму <em>keyform</em> для получения объекта, который
называется <em>ключевой объект</em>. Затем <b><a 
href="symbols.html#x188-375180r180">case</a></b> рассматривает все подвыражения.
Если <em>ключевой объект</em> присутствует в списке <em>keylist</em> (то есть, если <em>ключевой
объект</em> равен <b><a 
href="symbols.html#x188-375367r367">eql</a></b> хотя бы одному элементу из списка <em>keylist</em>), то список форм
выбранного подвыражения вычисляется, как неявный <b><a 
href="symbols.html#x188-375749r749">progn</a></b>. <b><a 
href="symbols.html#x188-375180r180">case</a></b>
возвращает то же, что и последняя форма списка (или <b><a 
href="symbols.html#x188-375658r658">nil</a></b> если список форм
был пустой). Если ни одно подвыражение не удовлетворило условию, то <b><a 
href="symbols.html#x188-375180r180">case</a></b>
возвращает <b><a 
href="symbols.html#x188-375658r658">nil</a></b>.
<!--l. 6799--><p class="indent" >   Ключи в списке ключей <em>keylist</em> <em>не</em> выполняются. В данном списке должны
быть указаны литеральные ключи. Если один ключ попадается более чем в
одном подвыражении, это считается ошибкой. Следствием является то, что
порядок этих подвыражений не влияет на поведение конструкции
<b><a 
href="symbols.html#x188-375180r180">case</a></b>.
<!--l. 6806--><p class="indent" >   Вместо <em>keylist</em> можно записать один из символов: <b><a 
href="symbols.html#x188-375939r939">t</a></b> или <b>otherwise</b>.
                                                                          

                                                                          
Подвыражение с одним из таких символов всегда удовлетворяет условию
выбора. Такое подвыражение должно быть последним (это исключение из
правила о произвольности положения подвыражений). Смотрите также <b><a 
href="symbols.html#x188-375349r349">ecase</a></b>
и <b><a 
href="symbols.html#x188-375182r182">ccase</a></b>, каждая из которых предоставляет неявное <b>otherwise</b> подвыражение
для сигнализирования об ошибке, если ни одно подвыражение не
удовлетворило условию.
<!--l. 6814--><p class="indent" >   Если в подвыражении только один ключ, тогда этот ключ может быть
записан вместо списка. Такой «синглтоновый ключ» не может быть <b><a 
href="symbols.html#x188-375658r658">nil</a></b> (так
как возникают конфликты с (), который означает список без ключей), <b><a 
href="symbols.html#x188-375939r939">t</a></b>,
<b>otherwise</b> или cons-ячейкой.
<hr></div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6822--><p class="indent" >   <div class="tabbing">
 <em>[Макрос]</em> <b>typecase</b> <a 
 id="dx52-82006"></a>keyform {(type {form}*)}*
   <br>
<!--l. 6823--><p class="noindent" ></div>
</div>
<b>
<!--l. 6824--><p class="indent" >   <a 
href="symbols.html#x188-375963r963">typecase</a></b> условный оператор, который выбирает подвыражение на основе
типа объекта. Развёрнутая форма: <div class="lisp"><tt><div class="tabbing">
(typecase <em>keyform</em>
   <br>                                    (<em>type-1</em> <em>consequent-1-1</em> <em>consequent-1-2</em> ...)<br>
  (<em>type-2</em> <em>consequent-2-1</em> ...)<br>                    (<em>type-3</em> <em>consequent-3-1</em> ...)<br>
  ...)<br>
<!--l. 6833--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6834--><p class="indent" >   Структура <b><a 
href="symbols.html#x188-375963r963">typecase</a></b> похожа на <b><a 
href="symbols.html#x188-375269r269">cond</a></b> или <b><a 
href="symbols.html#x188-375180r180">case</a></b>. Поведение также схоже в
том, что выбирается подвыражение в зависимости от условия. Различие
заключается в механизме выбора подвыражения.
<!--l. 6838--><p class="indent" >   Сперва <b><a 
href="symbols.html#x188-375963r963">typecase</a></b> вычисляет форму <em>keyform</em> для создания объекта,
                                                                          

                                                                          
называемого ключевым объектом. Далее <b><a 
href="symbols.html#x188-375963r963">typecase</a></b> друг за другом
рассматривает каждое подвыражение. Форма <em>type</em>, которая встречается
в каждом подвыражении, является спецификатором типа. Данный
спецификатор не вычисляется, поэтому должен быть литеральным. Когда
ключевой объект принадлежит некоторый типу, то выделенный список форм
<em>consequent</em> выполняется последовательно (как неявный <b><a 
href="symbols.html#x188-375749r749">progn</a></b>). <b><a 
href="symbols.html#x188-375963r963">typecase</a></b>
возвращает то, что вернула последняя форма из списка (или <b><a 
href="symbols.html#x188-375658r658">nil</a></b> если список
был пуст). Если не одно подвыражение не было выбрано, <b><a 
href="symbols.html#x188-375963r963">typecase</a></b>
возвращает <b><a 
href="symbols.html#x188-375658r658">nil</a></b>.
<!--l. 6849--><p class="indent" >   Как и для <b><a 
href="symbols.html#x188-375180r180">case</a></b> можно использовать <b><a 
href="symbols.html#x188-375939r939">t</a></b> или <b>otherwise</b> на позиции <em>типа</em>
для задания подвыражений, которые будут выполняться, только если не
было выполнено других подвыражений. Смотрите также <b><a 
href="symbols.html#x188-375372r372">etypecase</a></b> и
<b><a 
href="symbols.html#x188-375291r291">ctypecase</a></b>, каждая из которых предоставляет неявную ветку <b>otherwise</b> для
сигнализирования об ошибке, что ни одно подвыражение не удовлетворило
условию.
<!--l. 6856--><p class="indent" >   Допустимо указывать более одного подвыражение, тип условия которого
уже является подтипом условия другого подвыражения. В таком случае
будет выбрано первое встретившееся подвыражение. Таким образом в
<b><a 
href="symbols.html#x188-375963r963">typecase</a></b>, в отличие от <b><a 
href="symbols.html#x188-375180r180">case</a></b>, порядок следования подвыражений влияет на
поведение всей конструкции. <div class="lisp"><tt><div class="tabbing">
(typecase an-object
   <br>   (string ...)                             ;Подвыражение обрабатывает строки<br>
   ((array t) ...)                          ;Подвыражение обрабатывает общие массивы<br>
   ((array bit) ...)                       ;Подвыражение обрабатывает битовые массивы<br>
   (array ...)                              ;Обрабатывает все остальные массивы<br>
   ((or list number) ...)                ;Подвыражение обрабатывает списки и числа<br>
   (t ...))                                   ;Подвыражение обрабатывает все остальные объекты<br>
<!--l. 6870--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
                                                                          

                                                                          
<!--l. 6873--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse41.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse39.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse39.html#tailclmse39.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse40.html" >В-начало</a>&#x003E;&#x003C;<a 
href="contrl.html#clmse40.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse40.html"></a>
 
</body></html> 
