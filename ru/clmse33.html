<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Предикаты равенства</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 1486--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse34.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse33.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="preds.html#clmse33.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
href="clm.html#QQ2-44-370" id="x44-3620006.3">Предикаты
равенства</a></h3>
<!--l. 1488--><p class="noindent" >Common Lisp предоставляет ряд предикатов для проверки равенства
двух объектов: <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt> (наиболее частный), <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt>, <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt> и <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> (наиболее
общий). <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt> и <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt> имеют значения традиционные в Lisp&#x2019;е. <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt> был
добавлен, потому что он часто бывает необходим, и <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> был добавлен
преимущественно, как версия <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt>, которая игнорирует различия типов при
сравнении двух чисел и различия регистров при сравнении строковых
символов. Если два объекта удовлетворяют любому из этих предикатов,
то они также удовлетворяют всем тем, которые носят более общий
характер.
<div class="defun">
<!--l. 1498--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx44-362001"></a><a 
 id="x44-362002r44"></a> <b>eq</b>  <i>x</i> <i>y</i>
</div>
<tt>
<!--l. 1501--><p class="indent" >   (eq <i>x</i> <i>y</i>)</tt> является истиной тогда и только тогда, когда, <i>x</i> и <i>y</i>
являются идентичными объектами. (В реализациях, <i>x</i> и <i>y</i> обычно
равны <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt> тогда и только тогда, когда обращаются к одной ячейке
памяти.)
<!--l. 1506--><p class="indent" >   Необходимо отметить, что вещи, которые выводят одно и то же,
необязательно равны <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt> друг другу. Символы с одинаковым именем обычно
равны <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt> друг другу, потому что используется функция <tt><a 
href="symbols.html#x185-2605451r451">intern</a></tt>. Однако,
одинаковые значения чисел могут быть не равны <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>, и два похожих списка
обычно не равны <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>. Например: <div class="lisp"><div class="tabbing">
(eq &#x2019;a &#x2019;b) ложь
   <br>                                                                         (eq &#x2019;a &#x2019;a) истина<br>
(eq 3 3) может быть истина или ложь, в зависимости от реализации<br>
(eq 3 3.0) ложь<br>(eq 3.0 3.0) может быть истина или ложь, в зависимости от реализации<br>
(eq #c(3 -4) #c(3 -4))<br>  может быть истина или ложь, в зависимости от реализации<br>
                                                                          

                                                                          
(eq #c(3 -4.0) #c(3 -4)) ложь<br>           (eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь<br>
(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) ложь<br>(eq &#x2019;(a . b) &#x2019;(a . b)) может быть истина или ложь<br>
(progn (setq x (cons &#x2019;a &#x2019;b)) (eq x x)) истина<br>(progn (setq x &#x2019;(a . b)) (eq x x)) истина<br>
(eq #\A #\A) может быть истина или ложь, в зависимости от реализации<br>
(eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) может быть истина или ложь<br>
(eq &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) ложь<br>                 (eq &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) ложь<br>
<!--l. 1530--><p class="noindent" ></div>
<!--l. 1530--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3630006.3" id="x44-3630006.3"></a></span>
<!--l. 1530--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3640006.3" id="x44-3640006.3"></a></span>
</div>
<!--l. 1532--><p class="indent" >   В Common Lisp&#x2019;е, в отличие от других диалектов, реализация в любое
время может создавать «копии» строковых символов и чисел. (Это сделано
для возможности в повышении производительности.) Из этого следует
правило, что Common Lisp не гарантирует для строковых символов и чисел
то, что <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt> будет истинен, когда оба аргумента являются «одним и тем же».
Например: <div class="lisp"><div class="tabbing">
(let ((x 5)) (eq x x)) может быть истиной или ложью
   <br>
<!--l. 1540--><p class="noindent" ></div>
<!--l. 1540--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3650006.3" id="x44-3650006.3"></a></span>
<!--l. 1540--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3660006.3" id="x44-3660006.3"></a></span>
</div>
<!--l. 1542--><p class="indent" >   Предикат <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt> означает то же, что и <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>, за исключением того, что если
аргументы являются строковыми символами или числами одинакового типа,
тогда сравниваются их значения. Таким образом <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt> говорит, являются ли
два объекта «концептуально (conceptually)» одинаковыми, тогда как <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>
указывает, являются ли два объекта «реализационно (implementationally)»
                                                                          

                                                                          
одинаковыми. По этой причине сравнительным предикатом для функций
работы с последовательностями, описанными в главе <a 
href="kseque.html#x96-115800014">14<!--tex4ht:ref: KSEQUE --></a>, является <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt>, а не
<tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>._______________________________________________________________________<div class="implementation">
<!--l. 1551--><p class="noindent" ><b>Заметка для реализации:</b> <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt> simply compares the two given pointers, so any
kind of object that is represented in an “immediate” fashion will indeed have
like-valued instances satisfy <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>. In some implementations, for example, ﬁxnums and
characters happen to “work.” However, no program should depend on this, as other
implementations of Common Lisp might not use an immediate representation for these
data types.
</div>___________________________________________________________________________________________________________
<div class="obsolete">
<!--l. 1563--><p class="indent" >     An additional problem with <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt> is that the implementation is permitted to
“collapse” constants (or portions thereof) appearing in code to be compiled if they
are <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt>. An object is considered to be a constant in code to be compiled if it is
a self-evaluating form or is contained in a <tt><a 
href="symbols.html#x185-2605707r707">quote</a></tt> form. This is why <tt>(eq &#x0022;Foo&#x0022;
&#x0022;Foo&#x0022;)</tt> might be true or false; in interpreted code it would normally be false,
because reading in the form <tt>(eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;)</tt> would construct distinct strings
for the two arguments to <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>, but the compiler might choose to use the same
identical string or two distinct copies as the two arguments in the call to <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>.
Similarly, <tt>(eq &#x2019;(a . b) &#x2019;(a . b))</tt> might be true or false, depending on whether
the constant conses appearing in the <tt><a 
href="symbols.html#x185-2605707r707">quote</a></tt> forms were collapsed by the compiler.
However, <tt>(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b))</tt> is always false, because every
distinct call to the <tt>cons</tt> function necessarily produces a new and distinct
cons.
</div>
<div class="newer">
<!--l. 1581--><p class="indent" >     X3J13 voted in March 1989 <a 
 id="dx44-366001"></a>to clarify that <tt><a 
href="symbols.html#x185-2605343r343">eval</a></tt> and <tt><a 
href="symbols.html#x185-2605231r231">compile</a></tt> are not
permitted either to copy or to coalesce (“collapse”) constants (see <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>) appearing in
the code they process; the resulting program behavior must refer to objects
that are <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt> to the corresponding objects in the source code. Only the
<tt><a 
href="symbols.html#x185-2605232r232">compile-file</a></tt>/<tt><a 
href="symbols.html#x185-2605498r498">load</a></tt> process is permitted to copy or coalesce constants (see
section <a 
href="clmse121.html#x150-195000024.1">24.1<!--tex4ht:ref: COMPILER-SECTION --></a>).
</div>
</div>
<div class="defun">
<!--l. 1592--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx44-366002"></a><a 
 id="x44-366003r45"></a> <b>eql</b>  <i>x</i> <i>y</i>
                                                                          

                                                                          
</div>
<!--l. 1595--><p class="indent" >   Предикат <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt> истинен, если его аргументы равны <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>, или если это числа
одинакового типа и с одинаковыми значениями, или если это одинаковые
строковые символы. Например: <div class="lisp"><div class="tabbing">
(eql &#x2019;a &#x2019;b) ложь
   <br>                         (eql &#x2019;a &#x2019;a) истина<br>                         (eql 3 3) истина<br>
(eql 3 3.0) ложь<br>                                       (eql 3.0 3.0) истина<br>
(eql #c(3 -4) #c(3 -4)) истина<br>             (eql #c(3 -4.0) #c(3 -4)) ложь<br>
(eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь<br>      (eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) ложь<br>
(eql &#x2019;(a . b) &#x2019;(a . b)) может быть истиной или ложью<br>
(progn (setq x (cons &#x2019;a &#x2019;b)) (eql x x)) истина<br>
(progn (setq x &#x2019;(a . b)) (eql x x)) истина<br>           (eql #\A #\A) истина<br>
(eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) может быть истиной или ложью<br>
(eql &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) ложь<br>               (eql &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) ложь<br>
<!--l. 1616--><p class="noindent" ></div>
<!--l. 1616--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3670006.3" id="x44-3670006.3"></a></span>
<!--l. 1616--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3680006.3" id="x44-3680006.3"></a></span>
</div>
<!--l. 1618--><p class="indent" >   Обычно <tt>(eql 1.0s0 1.0d0)</tt> будет ложью, так как <tt>1.0s0</tt> и <tt>1.0d0</tt>
не принадлежат одному типу данных. Однако в реализация может
отсутствовать полный набор чисел с плавающей точкой, поэтому в такой
ситуации <tt>(eql 1.0s0 1.0d0)</tt> может быть истиной. Предикат <tt><a 
href="symbols.html#x185-2605061r61">=</a></tt> будет
сравнивать значения двух чисел, даже если числа принадлежат разным
типам.
<!--l. 1624--><p class="indent" >   Если реализация поддерживает положительный и отрицательный нули,
как различные значения (так IEEE стандарт предлагает реализовывать
формат числа с плавающей точкой), тогда <tt>(eql 0.0 -0.0)</tt> будет
ложью. В противном случае, когда синтаксис <tt>-0.0</tt> интерпретируется,
как значение <tt>0.0</tt>, тогда <tt>(eql 0.0 -0.0)</tt> будет истиной. Предикат <tt><a 
href="symbols.html#x185-2605061r61">=</a></tt>
отличается от <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt> в том, что <tt>(= 0.0 -0.0)</tt> будет всегда истинно, потому
что <tt><a 
href="symbols.html#x185-2605061r61">=</a></tt> сравнивает математические значения операндов, тогда как <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt>
                                                                          

                                                                          
сравнивает, так сказать, репрезентативные (representational) значения.
FIXME.
<!--l. 1633--><p class="indent" >   Два комплексных числа будут равны <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt>, если их действительные части
равны <tt>eql</tt> и мнимые части равны <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt>. Например, <tt>(eql #C(4 5) #C(4 5))</tt>
является истиной и <tt>(eql #C(4 5) #C(4.0 5.0))</tt> является ложью. Следует
отметить, что <tt>(eql #C(5.0 0.0) 5.0)</tt> ложь, а <tt>(eql #C(5 0) 5)</tt> истина. В
случае с <tt>(eql #C(5.0 0.0) 5.0)</tt> два аргумента принадлежат разным типам
и не равны <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt>, Однако, в случае <tt>(eql #C(5 0) 5)</tt>, <tt>#C(5 0)</tt> не является
комплексным числом, и автоматически преобразуется, по правилу
канонизации комплексных чисел, в целое <tt>5</tt>, так как дробное число <tt>20/4</tt>
всегда упрощается до <tt>5</tt>.
<!--l. 1646--><p class="indent" >   Случай <tt>(eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;)</tt> обсуждался выше в описании <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>. Тогда как
<tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt> сравнивает значения чисел и строковых символов, он не сравнивает
содержимое строк. Сравнение символов двух строк может быть выполнено с
помощью <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt>, <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt>, <tt><a 
href="symbols.html#x185-2605844r844">string=</a></tt> или <tt><a 
href="symbols.html#x185-2605831r831">string-equal</a></tt>.
</div>
<div class="defun">
<!--l. 1652--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx44-368001"></a><a 
 id="x44-368002r46"></a> <b>equal</b>  <i>x</i> <i>y</i>
</div>
<!--l. 1655--><p class="indent" >   Предикат <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt> истинен, если его аргументы это структурно похожие
(изоморфные) объекты. Грубое правило такое, что два объекта равны <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt>
тогда и только тогда, когда одинаково их выводимое представление.
<!--l. 1659--><p class="indent" >   Числа и строковые символы сравниваются также как и в <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt>.
Символы сравниваются как в <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>. Этот метод сравнения символов
может нарушать правило и сравнении выводимого представления,
в случае если различия двух символов с одинаковым выводимым
представлением.
<!--l. 1664--><p class="indent" >   Объекты, которые содержат другие элементы, будут равны <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt>, если
они принадлежат одному типу и содержащиеся элементы равны <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt>. Эта
проверка реализована в рекурсивном стиле и может быть зациклиться на
закольцованных структурах.
<!--l. 1669--><p class="indent" >   Для cons-ячеек, <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt> определён рекурсивно, как сравнение <tt>equal</tt>
сначала <i>car</i> элементов, а затем <i>cdr</i>.
<!--l. 1672--><p class="indent" >   Два массива равны <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt> только, если они равны <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>, с одним
исключением: строки и битовые вектора сравниваются поэлементно. Если
какой-либо аргумент или оба содержат указатель заполнения (ﬁll pointer),
                                                                          

                                                                          
данный указатель ограничит количество проверяемых с помощью <tt>equal</tt>
элементов. Буквы верхнего и нижнего регистров в строках расцениваются
предикатом <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt> как разные. (А <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> игнорирует различие в регистрах в
строках.)
<!--l. 1681--><p class="indent" >   Два объекта имени файла (pathname objects) равны <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt> тогда и только
тогда, когда все элементы (хост, устройство, и т.д.) равны. (Будут
ли равны буквы разных регистров зависит от файловой системы.)
Имена файлов, которые равны <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt>, должны быть функционально
эквивалентны.
<tt>
<!--l. 1686--><p class="indent" >   <a 
href="symbols.html#x185-2605339r339">equal</a></tt> рекурсивно рассматривает только следующие типы данных:
cons-ячейки, битовые вектора, строки и имена файлов. Числа и строковые
символы сравниваются так, как если бы сравнивались с помощью <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt>, а
все остальные типы данных сравниваются как если бы с помощью
<tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>.
<div class="lisp">
<!--l. 1691--><p class="indent" >   <div class="tabbing">
(equal &#x2019;a &#x2019;b) ложь
   <br>                                                                     (equal &#x2019;a &#x2019;a) истина<br>
(equal 3 3) истина<br>                                     (equal 3 3.0) ложь<br>
(equal 3.0 3.0) истина<br>                    (equal #c(3 -4) #c(3 -4)) истина<br>
(equal #c(3 -4.0) #c(3 -4)) ложь<br>     (equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь<br>
(equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) истина<br>      (equal &#x2019;(a . b) &#x2019;(a . b)) истина<br>
(progn (setq x (cons &#x2019;a &#x2019;b)) (equal x x)) истина<br>
(progn (setq x &#x2019;(a . b)) (equal x x)) истина<br>      (equal #\A #\A) истина<br>
(equal &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) истина<br>        (equal &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) истина<br>
(equal &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) ложь<br>
<!--l. 1708--><p class="noindent" ></div>
<!--l. 1708--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3690006.3" id="x44-3690006.3"></a></span>
<!--l. 1708--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3700006.3" id="x44-3700006.3"></a></span>
</div>
                                                                          

                                                                          
<!--l. 1709--><p class="indent" >   Для сравнения дерева cons-ячеек применяя <tt><a 
href="symbols.html#x185-2605338r338">eql</a></tt> (или любой другой
желаемый предикат) для листьев, используйте <tt><a 
href="symbols.html#x185-2605886r886">tree-equal</a></tt>.
</div>
<div class="defun">
<!--l. 1713--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx44-370001"></a><a 
 id="x44-370002r47"></a> <b>equalp</b>  <i>x</i> <i>y</i>
</div>
<!--l. 1716--><p class="indent" >   Два объекта равны <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt>, если они равны <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt>, если они строковые
символы и удовлетворяют предикату <tt><a 
href="symbols.html#x185-2605199r199">char-equal</a></tt>, который игнорирует
регистр и другие атрибуты символов, если они числа и имеют одинаковое
значение, даже если числа разных типов, если они включает в себя элементы,
которые также равны <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt>.
<!--l. 1722--><p class="indent" >   Объекты, которые включают в себя элементы, равны <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt>, если они
принадлежат одному типу и содержащиеся элементы равны <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt>.
Проверка осуществляется в рекурсивном стиле и может не завершится
на закольцованных структурах. Для cons-ячеек, предикат <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt>
определён рекурсивно и сравнивает сначала <i>car</i> элементы, а затем
<i>cdr</i>.
<!--l. 1729--><p class="indent" >   Два массива равны <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> тогда и только тогда, когда они имеют
одинаковое количество измерений, и размеры измерений совпадают, и все
элементы равны <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt>. Специализация массива не сравнивается. Например,
строка и общий массив, случилось так, имеют одинаковые строковые
символы, тогда они будут равны <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> (но определённо не равны <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt>).
Если какой-либо аргумент содержит указатель заполнения, этот указатель
ограничивает число сравниваемых элементов. Так как <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> сравнивает
строки побуквенно, и не различает разных регистров букв, то сравнение
строк регистронезависимо.
<!--l. 1739--><p class="indent" >   Два символа могут быть равны <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> только тогда, когда они <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>, т.е.
являются идентичными объектами.
<div class="new">
<!--l. 1743--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx44-370003"></a>to specify that <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> compares components of
hash tables (see below), and to clarify that otherwise <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> never recursively
descends any structure or data type other than the ones explicitly described
above: conses, arrays (including bit-vectors and strings), and pathnames. Numbers
are compared for numerical equality (see <tt><a 
href="symbols.html#x185-2605061r61">=</a></tt>), characters are compared
as if by <tt><a 
href="symbols.html#x185-2605199r199">char-equal</a></tt>, and all other data objects are compared as if by
<tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>.
                                                                          

                                                                          
<!--l. 1754--><p class="indent" >   Two hash tables are considered the same by <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> if and only if they satisfy
a four-part test:
      <ul class="itemize1">
      <li class="itemize">They must be of the same kind; that is, equivalent <tt>:test</tt> arguments
      were given to <tt><a 
href="symbols.html#x185-2605539r539">make-hash-table</a></tt> when the two hash tables were created.
      </li>
      <li class="itemize">They must have the same number of entries (see <tt><a 
href="symbols.html#x185-2605427r427">hash-table-count</a></tt>).
      </li>
      <li class="itemize">For  every  entry  (<i>key1</i>,  <i>value1</i>)  in  one  hash  table  there  must  be  a
      corresponding entry (<i>key2</i>, <i>value2</i>) in the other, such that <i>key1</i> and
      <i>key2</i> are considered to be the same by the <tt>:test</tt> function associated
      with the hash tables.
      </li>
      <li class="itemize">For every entry (<i>key1</i>, <i>value1</i>) in one hash table and its corresponding
      entry (<i>key2</i>, <i>value2</i>) in the other, such that <i>key1</i> and <i>key2</i> are the
      same, <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> must be true of <i>value1</i> and <i>value2</i>.</li></ul>
<!--l. 1773--><p class="noindent" >The four parts of this test are carried out in the order shown, and if some part of
the test fails, <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> returns <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> and the other parts of the test are not
attempted.
<!--l. 1777--><p class="indent" >   If <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> must compare two structures and the <tt><a 
href="symbols.html#x185-2605289r289">defstruct</a></tt> deﬁnition for
one used the <tt>:type</tt> option and the other did not, then <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> returns
<tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>.
<!--l. 1781--><p class="indent" >   If <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> must compare two structures and neither <tt><a 
href="symbols.html#x185-2605289r289">defstruct</a></tt> deﬁnition used
the <tt>:type</tt> option, then <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> returns <tt><a 
href="symbols.html#x185-2605871r871">t</a></tt> if and only if the structures have the
same type (that is, the same <tt><a 
href="symbols.html#x185-2605289r289">defstruct</a></tt> name) and the values of all corresponding
slots (slots having the same name) are <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt>.
<!--l. 1787--><p class="indent" >   As part of the X3J13 discussion of this issue the following observations were
made. Object equality is not a concept for which there is a uniquely determined
correct algorithm. The appropriateness of an equality predicate can be judged
only in the context of the needs of some particular program. Although
these functions take any type of argument and their names sound very
generic, <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt> and <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> are not appropriate for every application. Any
decision to use or not use them should be determined by what they are
documented to do rather than by any abstract characterization of their function.
                                                                          

                                                                          
If neither <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt> nor <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> is found to be appropriate in a particular
situation, programmers are encouraged to create another operator that is
appropriate rather than blame <tt><a 
href="symbols.html#x185-2605339r339">equal</a></tt> or <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> for “doing the wrong
thing.”
</div>
<div class="new">
<!--l. 1804--><p class="indent" >   Note that one consequence of the vote to change the rules of ﬂoating-point
contagion <a 
 id="dx44-370004"></a>(described in section <a 
href="clmse64.html#x81-92500012.1">12.1<!--tex4ht:ref: PRECISION-CONTAGION-COERCION-SECTION --></a>) is to make <tt><a 
href="symbols.html#x185-2605340r340">equalp</a></tt> a true equivalence
relation on numbers.
</div>
<div class="lisp">
<!--l. 1813--><p class="indent" >   <div class="tabbing">
(equalp &#x2019;a &#x2019;b) ложь
   <br>                                                                   (equalp &#x2019;a &#x2019;a) истина<br>
(equalp 3 3) истина<br>                                 (equalp 3 3.0) истина<br>
(equalp 3.0 3.0) истина<br>                 (equalp #c(3 -4) #c(3 -4)) истина<br>
(equalp #c(3 -4.0) #c(3 -4)) истина<br> (equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь<br>
(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) истина<br>    (equalp &#x2019;(a . b) &#x2019;(a . b)) истина<br>
(progn (setq x (cons &#x2019;a &#x2019;b)) (equalp x x)) истина<br>
(progn (setq x &#x2019;(a . b)) (equalp x x)) истина<br>    (equalp #\A #\A) истина<br>
(equalp &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) истина<br>      (equalp &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) истина<br>
(equalp &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) истина<br>
<!--l. 1830--><p class="noindent" ></div>
<!--l. 1830--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3710006.3" id="x44-3710006.3"></a></span>
<!--l. 1830--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3720006.3" id="x44-3720006.3"></a></span>
</div>
</div>
                                                                          

                                                                          
<!--l. 1833--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse34.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="preds.html#clmse33.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse33.html"></a>   </div> </div> 
</body></html> 
