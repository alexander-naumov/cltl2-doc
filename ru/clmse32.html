<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Предикаты типов данных</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 16:17:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 1067--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse33.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html#tailclmse31.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse32.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="preds.html#clmse32.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">6.2   </span> <a 
href="clm.html#QQ2-43-312" id="x43-3040006.2">Предикаты типов
данных</a></h3>
<!--l. 1069--><p class="noindent" >Возможно наиболее важными предикатами в Lisp&#x2019;е это предикаты, которые
различают типы данных. То есть позволяют узнать принадлежит ли
заданный объект данному типу. Также предикаты могут сравнивать два
спецификатора типов.
<!--l. 1073--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.1   </span> <a 
href="frontmatter.html#QQ2-43-313" id="x43-3050006.2.1">Основные предикаты</a></h4>
<!--l. 1075--><p class="noindent" >Если тип данных рассматривать, как множество все объектов, принадлежащих
этому типу, тогда функция <tt><a 
href="symbols.html#x187-2604893r893">typep</a></tt> проверяет принадлежность множеству,
тогда как <tt>subtypep</tt> — принадлежность подмножеству.
<div class="defun">
<!--l. 1079--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-305001"></a><a 
 id="x43-305002r20"></a> <b>typep</b>  <i>object</i> <i>type</i>
</div>
<tt>
<!--l. 1082--><p class="indent" >   <a 
href="symbols.html#x187-2604893r893">typep</a></tt> является предикатом, который истинен, если объект <i>object</i>
принадлежит типу <i>type</i>, и ложен в противном случае. Следует отметить, что
объект может принадлежать нескольким типам, так как один тип может
включать другой. <i>type</i> может быть любым спецификатором типа, описанным
в главе <a 
href="dtspec.html#x26-1430004">4<!--tex4ht:ref: DTSPEC --></a>, за исключением того, что он не может быть или включать список
спецификатор типа, у которого первый элемент равен <tt><a 
href="symbols.html#x187-2604399r399">function</a></tt> или
<tt><a 
href="symbols.html#x187-2604914r914">values</a></tt>. Спецификатор формы <tt>(satisfies <i>fn</i>)</tt> обрабатывается просто
как применение функции <i>fn</i> к объекту <i>object</i> (смотрите <tt><a 
href="symbols.html#x187-2604398r398">funcall</a></tt>).
Объект <i>object</i> принадлежит заданному типу, если результат не равен
<tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>.
<div class="new">
<!--l. 1094--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx43-305003"></a>to change <tt><a 
href="symbols.html#x187-2604893r893">typep</a></tt> to give specialized
<tt>array</tt> and <tt><a 
href="symbols.html#x187-2604239r239">complex</a></tt> type speciﬁers the same meaning for purposes of type
discrimination as they have for declaration purposes. Of course, this also applies
                                                                          

                                                                          
to such type speciﬁers as <tt><a 
href="symbols.html#x187-2604917r917">vector</a></tt> and <tt>simple-array</tt> (see section <a 
href="clmse22.html#x31-1580004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>). Thus
<div class="lisp"><div class="tabbing">
(typep foo &#x2019;(array bignum))
   <br>
<!--l. 1105--><p class="noindent" ></div>
<!--l. 1105--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3060006.2.1" id="x43-3060006.2.1"></a></span>
<!--l. 1105--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3070006.2.1" id="x43-3070006.2.1"></a></span>
</div>
<!--l. 1106--><p class="indent" >   in the ﬁrst edition asked the question, Is <tt>foo</tt> an array specialized to hold
bignums? but under the new interpretation asks the question, Could the array <tt>foo</tt>
have resulted from giving <tt>bignum</tt> as the <tt>:element-type</tt> argument to
<tt><a 
href="symbols.html#x187-2604532r532">make-array</a></tt>?
</div>
</div>
<div class="defun">
<!--l. 1114--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-307001"></a><a 
 id="x43-307002r21"></a> <b>subtypep</b>  <i>type1</i> <i>type2</i>
</div>
<!--l. 1117--><p class="indent" >   Аргументы должны быть спецификаторами типов, но только теми,
которые могут использоваться и для <tt><a 
href="symbols.html#x187-2604893r893">typep</a></tt>. Два спецификатора типа
сравниваются. Данный предикат истинен, если тип <i>type1</i> точно является
подтипом типа <i>type2</i>, иначе предикат ложен. Если результат <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>, тогда тип
<i>type1</i> может быть, а может и не быть подтипом типа <i>type2</i> (иногда это
невозможно определить, особенно когда используется тип <tt>satisfies</tt>). Второе
возвращаемое значение указывает на точность результата. Если оно является
истиной, значит первое значение указывает на точную принадлежность
типов. Таким образом возможны следующие комбинации результатов:
<div class="tabbing">
                                                                          

                                                                          
<tt><a 
href="symbols.html#x187-2604868r868">t</a></tt>       <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt>       <i>type1</i> точно является подтипом <i>type2</i>
   <br>             <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>     <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt>       <i>type1</i> точно не является подтипом <i>type2</i><br>
<tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>     <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>     <tt><a 
href="symbols.html#x187-2604855r855">subtypep</a></tt> не может определить отношение<br>
<!--l. 1132--><p class="noindent" ></div>
<!--l. 1132--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3080006.2.1" id="x43-3080006.2.1"></a></span>
<div class="new">
   X3J13 voted in January 1989 <a 
 id="dx43-308001"></a>to place certain requirements upon the
implementation of <tt><a 
href="symbols.html#x187-2604855r855">subtypep</a></tt>, for it noted that implementations in many cases
simply “give up” and return the two values <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> and <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> when in fact it would
have been possible to determine the relationship between the given types. The
requirements are as follows, where it is understood that a type speciﬁer <i>s</i> <i>involves</i>
a type speciﬁer <i>u</i> if either <i>s</i> contains an occurrence of <i>u</i> directly or <i>s</i>
contains a type speciﬁer <i>w</i> deﬁned by <tt><a 
href="symbols.html#x187-2604290r290">deftype</a></tt> whose expansion involves
<i>u</i>.
      <ul class="itemize1">
      <li class="itemize"><tt><a 
href="symbols.html#x187-2604855r855">subtypep</a></tt> is not permitted to return a second value of <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt> unless one
      or both of its arguments involves <tt>satisfies</tt>, <tt><a 
href="symbols.html#x187-2604078r78">and</a></tt>, <tt><a 
href="symbols.html#x187-2604641r641">or</a></tt>, <tt><a 
href="symbols.html#x187-2604614r614">not</a></tt>, or <tt><a 
href="symbols.html#x187-2604569r569">member</a></tt>.
      </li>
      <li class="itemize"><tt><a 
href="symbols.html#x187-2604855r855">subtypep</a></tt> should signal an error when one or both of its arguments
      involves <tt><a 
href="symbols.html#x187-2604914r914">values</a></tt> or the list form of the <tt><a 
href="symbols.html#x187-2604399r399">function</a></tt> type speciﬁer.
      </li>
      <li class="itemize"><tt><a 
href="symbols.html#x187-2604855r855">subtypep</a></tt> must always return the two values <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> and <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> in the case where
      its arguments, after expansion of speciﬁers deﬁned by <tt><a 
href="symbols.html#x187-2604290r290">deftype</a></tt>, are
      <tt><a 
href="symbols.html#x187-2604339r339">equal</a></tt>.</li></ul>
<!--l. 1155--><p class="noindent" >In addition, X3J13 voted to clarify that in some cases the relationships between types
as reﬂected by <tt><a 
href="symbols.html#x187-2604855r855">subtypep</a></tt> may be implementation-speciﬁc. For example, in an
implementation supporting only one type of ﬂoating-point number, <tt>(subtypep
&#x2019;float &#x2019;long-float)</tt> would return <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt> and <tt><a 
href="symbols.html#x187-2604868r868">t</a></tt>, since the two types would be
identical.
<!--l. 1162--><p class="indent" >   Note that <tt>satisfies</tt> is an exception because relationships between types
involving <tt>satisfies</tt> are undecidable in general, but (as X3J13 noted) <tt><a 
href="symbols.html#x187-2604078r78">and</a></tt>, <tt><a 
href="symbols.html#x187-2604641r641">or</a></tt>,
<tt><a 
href="symbols.html#x187-2604614r614">not</a></tt>, and <tt><a 
href="symbols.html#x187-2604569r569">member</a></tt> are merely very messy to deal with. In all likelihood these will
not be addressed unless and until someone is willing to write a careful
                                                                          

                                                                          
speciﬁcation that covers all the cases for the processing of these type speciﬁers by
<tt><a 
href="symbols.html#x187-2604855r855">subtypep</a></tt>. The requirements stated above were easy to state and probably suﬃce
for most cases of interest.
</div>
<div class="new">
   X3J13 voted in January 1989 <a 
 id="dx43-308002"></a>to change <tt><a 
href="symbols.html#x187-2604855r855">subtypep</a></tt> to give specialized
<tt>array</tt> and <tt><a 
href="symbols.html#x187-2604239r239">complex</a></tt> type speciﬁers the same meaning for purposes of
type discrimination as they have for declaration purposes. Of course, this
also applies to such type speciﬁers as <tt><a 
href="symbols.html#x187-2604917r917">vector</a></tt> and <tt>simple-array</tt> (see
section <a 
href="clmse22.html#x31-1580004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>).
<!--l. 1182--><p class="indent" >   If <i>A</i> and <i>B</i> are type speciﬁers (other than <tt><a 
href="symbols.html#x187-2604002r2">*</a></tt>, which technically is not a type
speciﬁer anyway), then <tt>(array <i>A</i>)</tt> and <tt>(array <i>B</i>)</tt> represent the same type in
a given implementation if and only if they denote arrays of the same
specialized representation in that implementation; otherwise they are
disjoint. To put it another way, they represent the same type if and only if
<tt>(upgraded-array-element-type &#x2019;<i>A</i>)</tt> and <tt>(upgraded-array-element-type &#x2019;<i>B</i>)</tt>
are the same type. Therefore <div class="lisp"><div class="tabbing">
(subtypep &#x2019;(array <i>A</i>) &#x2019;(array <i>B</i>))
   <br>
<!--l. 1196--><p class="noindent" ></div>
<!--l. 1196--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3090006.2.1" id="x43-3090006.2.1"></a></span>
<!--l. 1196--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3100006.2.1" id="x43-3100006.2.1"></a></span>
</div>
<!--l. 1197--><p class="indent" >   is true if and only if <tt>(upgraded-array-element-type &#x2019;<i>A</i>)</tt> is the same type
as <tt>(upgraded-array-element-type &#x2019;<i>B</i>)</tt>.
<!--l. 1202--><p class="indent" >   The <tt><a 
href="symbols.html#x187-2604239r239">complex</a></tt> type speciﬁer is treated in a similar but subtly diﬀerent manner.
If <i>A</i> and <i>B</i> are two type speciﬁers (but not <tt><a 
href="symbols.html#x187-2604002r2">*</a></tt>, which technically is not a type
speciﬁer anyway), then <tt>(complex <i>A</i>)</tt> and <tt>(complex <i>B</i>)</tt> represent the same type
in a given implementation if and only if they refer to complex numbers of the
same specialized representation in that implementation; otherwise they are
disjoint. Note, however, that there is no function called <tt>make-complex</tt> that
                                                                          

                                                                          
allows one to specify a particular element type (then to be upgraded);
instead, one must describe specialized complex numbers in terms of the
actual types of the parts from which they were constructed. There is no
number of type (or rather, <i>representation</i>) <tt><a 
href="symbols.html#x187-2604380r380">float</a></tt> as such; there are only
numbers of type <tt>single-float</tt>, numbers of type <tt>double-float</tt>, and so on.
Therefore we want <tt>(complex single-float)</tt> to be a subtype of <tt>(complex
float)</tt>.
<!--l. 1220--><p class="indent" >   The rule, then, is that <tt>(complex <i>A</i>)</tt> and <tt>(complex <i>B</i>)</tt> represent the same
type (and otherwise are disjoint) in a given implementation if and only if <i>either</i>
the type <i>A</i> is a subtype of <i>B</i>, <i>or</i> <tt>(upgraded-complex-part-type &#x2019;<i>A</i>)</tt> and
<tt>(upgraded-complex-part-type &#x2019;<i>B</i>)</tt> are the same type. In the latter
case <tt>(complex <i>A</i>)</tt> and <tt>(complex <i>B</i>)</tt> in fact refer to the same specialized
representation. Therefore <div class="lisp"><div class="tabbing">
(subtypep &#x2019;(complex <i>A</i>) &#x2019;(complex <i>B</i>))
   <br>
<!--l. 1231--><p class="noindent" ></div>
<!--l. 1231--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3110006.2.1" id="x43-3110006.2.1"></a></span>
<!--l. 1231--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3120006.2.1" id="x43-3120006.2.1"></a></span>
</div>
<!--l. 1232--><p class="indent" >   is true if and only if the results of <tt>(upgraded-complex-part-type &#x2019;<i>A</i>)</tt> and
<tt>(upgraded-complex-part-type &#x2019;<i>B</i>)</tt> are the same type.
<!--l. 1236--><p class="indent" >   Under this interpretation <div class="lisp"><div class="tabbing">
(subtypep &#x2019;(complex single-ﬂoat) &#x2019;(complex ﬂoat))
   <br>
<!--l. 1239--><p class="noindent" ></div>
<!--l. 1239--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3130006.2.1" id="x43-3130006.2.1"></a></span>
                                                                          

                                                                          
<!--l. 1239--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3140006.2.1" id="x43-3140006.2.1"></a></span>
</div>
<!--l. 1240--><p class="indent" >   must be true in all implementations; but <div class="lisp"><div class="tabbing">
(subtypep &#x2019;(array single-ﬂoat) &#x2019;(array ﬂoat))
   <br>
<!--l. 1243--><p class="noindent" ></div>
<!--l. 1243--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3150006.2.1" id="x43-3150006.2.1"></a></span>
<!--l. 1243--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3160006.2.1" id="x43-3160006.2.1"></a></span>
</div>
<!--l. 1244--><p class="indent" >   is true only in implementations that do not have a specialized array
representation for <tt>single-float</tt> elements distinct from that for <tt><a 
href="symbols.html#x187-2604380r380">float</a></tt> elements
in general.
</div>
</div>
<!--l. 1250--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.2   </span> <a 
href="frontmatter.html#QQ2-43-325" id="x43-3170006.2.2">Специальные предикаты</a></h4>
<!--l. 1252--><p class="noindent" >Следующие предикаты осуществляют проверку определённых типов
данных.
<div class="defun">
<!--l. 1254--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-317001"></a><a 
 id="x43-317002r22"></a> <b>null</b>  <i>object</i>
</div>
<tt>
<!--l. 1257--><p class="indent" >   <a 
href="symbols.html#x187-2604634r634">null</a></tt> истинен, если аргумент является (), иначе является ложью. Похожая
операция производится <tt><a 
href="symbols.html#x187-2604614r614">not</a></tt>, однако <tt><a 
href="symbols.html#x187-2604614r614">not</a></tt> используется для отрицания булевых
значение, тогда как <tt><a 
href="symbols.html#x187-2604634r634">null</a></tt> используется для проверки того, пустой ли список.
Таким образом программист может выразить свои намерения, выбрав
нужное имя функции. <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(null x) <span class="math"> ≡</span> (typep x &#x2019;null) <span class="math"> ≡</span> (eq x &#x2019;())
   <br>
<!--l. 1264--><p class="noindent" ></div>
<!--l. 1264--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3180006.2.2" id="x43-3180006.2.2"></a></span>
<!--l. 1264--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3190006.2.2" id="x43-3190006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1267--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-319001"></a><a 
 id="x43-319002r23"></a> <b>symbolp</b>  <i>object</i>
</div>
<tt>
<!--l. 1270--><p class="indent" >   <a 
href="symbols.html#x187-2604866r866">symbolp</a></tt> истинен, если её аргумент является символом, в противном
случае ложен. <div class="lisp"><div class="tabbing">
(symbolp x) <span class="math"> ≡</span> (typep x &#x2019;symbol)
   <br>
<!--l. 1274--><p class="noindent" ></div>
<!--l. 1274--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3200006.2.2" id="x43-3200006.2.2"></a></span>
<!--l. 1274--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3210006.2.2" id="x43-3210006.2.2"></a></span>
</div>
</div>
<div class="defun">
                                                                          

                                                                          
<!--l. 1277--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-321001"></a><a 
 id="x43-321002r24"></a> <b>atom</b>  <i>object</i>
</div>
<!--l. 1280--><p class="indent" >   Предикат <tt><a 
href="symbols.html#x187-2604113r113">atom</a></tt> истинен, если аргумент не является cons-ячейкой, в
противном случае ложен. Следует отметить <tt>(atom &#x2019;())</tt> являет истиной,
потому что ()<span class="math">  ≡</span><tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>. <div class="lisp"><div class="tabbing">
(atom x) <span class="math"> ≡</span> (typep x &#x2019;atom) <span class="math"> ≡</span> (not (typep x &#x2019;cons))
   <br>
<!--l. 1286--><p class="noindent" ></div>
<!--l. 1286--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3220006.2.2" id="x43-3220006.2.2"></a></span>
<!--l. 1286--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3230006.2.2" id="x43-3230006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1289--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-323001"></a><a 
 id="x43-323002r25"></a> <b>consp</b>  <i>object</i>
</div>
<!--l. 1292--><p class="indent" >   Предикат <tt><a 
href="symbols.html#x187-2604249r249">consp</a></tt> истинен, если его аргумент является cons-ячейкой, в
противном случае ложен. Следует отметить, пустой список не является
cons-ячейкой, так <tt>(consp &#x2019;())</tt> <span class="math"> ≡</span> <tt>(consp &#x2019;<tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>)</tt> <span class="math"> ⇒</span> <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>. <div class="lisp"><div class="tabbing">
(consp x) <span class="math"> ≡</span> (typep x &#x2019;cons) <span class="math"> ≡</span> (not (typep x &#x2019;atom))
   <br>
<!--l. 1298--><p class="noindent" ></div>
<!--l. 1298--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3240006.2.2" id="x43-3240006.2.2"></a></span>
                                                                          

                                                                          
<!--l. 1298--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3250006.2.2" id="x43-3250006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1301--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-325001"></a><a 
 id="x43-325002r26"></a> <b>listp</b>  <i>object</i>
</div>
<tt>
<!--l. 1304--><p class="indent" >   <a 
href="symbols.html#x187-2604496r496">listp</a></tt> истинен, если его аргумент является cons-ячейкой или пустым
списком (), в противном случае ложен. Она не проверяет является ли «список
Ъ (true list)» (завершающийся <tt><a 
href="symbols.html#x187-2604608r608">nil</a></tt>) или «с точкой (dotted)» (завершающийся
не-null атомом). <div class="lisp"><div class="tabbing">
(listp x) <span class="math"> ≡</span> (typep x &#x2019;list) <span class="math"> ≡</span> (typep x &#x2019;(or cons null))
   <br>
<!--l. 1310--><p class="noindent" ></div>
<!--l. 1310--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3260006.2.2" id="x43-3260006.2.2"></a></span>
<!--l. 1310--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3270006.2.2" id="x43-3270006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1313--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-327001"></a><a 
 id="x43-327002r27"></a> <b>numberp</b>  <i>object</i>
</div>
<tt>
<!--l. 1316--><p class="indent" >   <a 
href="symbols.html#x187-2604635r635">numberp</a></tt> истинен, если аргумент это любой вид числа, в противном случае
ложен. <div class="lisp"><div class="tabbing">
(numberp x) <span class="math"> ≡</span> (typep x &#x2019;number)
   <br>
<!--l. 1320--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1320--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3280006.2.2" id="x43-3280006.2.2"></a></span>
<!--l. 1320--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3290006.2.2" id="x43-3290006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1323--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-329001"></a><a 
 id="x43-329002r28"></a> <b>integerp</b>  <i>object</i>
</div>
<i>
<!--l. 1326--><p class="indent" >   integerp</i> истинен, если аргумент целое число, в противном случае ложен.
<div class="lisp"><div class="tabbing">
(integerp x) <span class="math"> ≡</span> (typep x &#x2019;integer)
   <br>
<!--l. 1330--><p class="noindent" ></div>
<!--l. 1330--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3300006.2.2" id="x43-3300006.2.2"></a></span>
<!--l. 1330--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3310006.2.2" id="x43-3310006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1333--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-331001"></a><a 
 id="x43-331002r29"></a> <b>rationalp</b>  <i>object</i>
</div>
<tt>
<!--l. 1336--><p class="indent" >   <a 
href="symbols.html#x187-2604714r714">rationalp</a></tt> истинен, если аргумент рациональное число (дробь или целое),
в противном случае ложен. <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(rationalp x) <span class="math"> ≡</span> (typep x &#x2019;rational)
   <br>
<!--l. 1340--><p class="noindent" ></div>
<!--l. 1340--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3320006.2.2" id="x43-3320006.2.2"></a></span>
<!--l. 1340--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3330006.2.2" id="x43-3330006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1343--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-333001"></a><a 
 id="x43-333002r30"></a> <b>ﬂoatp</b>  <i>object</i>
</div>
<tt>
<!--l. 1346--><p class="indent" >   <a 
href="symbols.html#x187-2604387r387">floatp</a></tt> истинен, если аргумент число с плавающей точкой, в противном
случае ложен. <div class="lisp"><div class="tabbing">
(ﬂoatp x) <span class="math"> ≡</span> (typep x &#x2019;ﬂoat)
   <br>
<!--l. 1350--><p class="noindent" ></div>
<!--l. 1350--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3340006.2.2" id="x43-3340006.2.2"></a></span>
<!--l. 1350--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3350006.2.2" id="x43-3350006.2.2"></a></span>
</div>
</div>
<div class="defun">
                                                                          

                                                                          
<!--l. 1353--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-335001"></a><a 
 id="x43-335002r31"></a> <b>realp</b>  <i>object</i>
</div>
<tt>
<!--l. 1356--><p class="indent" >   <a 
href="symbols.html#x187-2604727r727">realp</a></tt> истинна, если аргумент является действительным числом, иначе
ложна. <div class="lisp"><div class="tabbing">
(realp x) <span class="math"> ≡</span> (typep x &#x2019;real)
   <br>
<!--l. 1360--><p class="noindent" ></div>
<!--l. 1360--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3360006.2.2" id="x43-3360006.2.2"></a></span>
<!--l. 1360--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3370006.2.2" id="x43-3370006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1363--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-337001"></a><a 
 id="x43-337002r32"></a> <b>complexp</b>  <i>object</i>
</div>
<i>
<!--l. 1366--><p class="indent" >   complexp</i> истинен, если аргумент комплексное число, в противном случае
ложен. <div class="lisp"><div class="tabbing">
(complexp x) <span class="math"> ≡</span> (typep x &#x2019;complex)
   <br>
<!--l. 1370--><p class="noindent" ></div>
<!--l. 1370--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3380006.2.2" id="x43-3380006.2.2"></a></span>
                                                                          

                                                                          
<!--l. 1370--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3390006.2.2" id="x43-3390006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1373--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-339001"></a><a 
 id="x43-339002r33"></a> <b>characterp</b>  <i>object</i>
</div>
<tt>
<!--l. 1376--><p class="indent" >   <a 
href="symbols.html#x187-2604215r215">characterp</a></tt> истинен, если аргумент строковый символ, иначе ложен.
<div class="lisp"><div class="tabbing">
(characterp x) <span class="math"> ≡</span> (typep x &#x2019;character)
   <br>
<!--l. 1380--><p class="noindent" ></div>
<!--l. 1380--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3400006.2.2" id="x43-3400006.2.2"></a></span>
<!--l. 1380--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3410006.2.2" id="x43-3410006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1383--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-341001"></a><a 
 id="x43-341002r34"></a> <b>stringp</b>  <i>object</i>
</div>
<tt>
<!--l. 1386--><p class="indent" >   <a 
href="symbols.html#x187-2604844r844">stringp</a></tt> истинен, если аргумент строка, иначе ложен. <div class="lisp"><div class="tabbing">
(stringp x) <span class="math"> ≡</span> (typep x &#x2019;string)
   <br>
<!--l. 1389--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1389--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3420006.2.2" id="x43-3420006.2.2"></a></span>
<!--l. 1389--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3430006.2.2" id="x43-3430006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1392--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-343001"></a><a 
 id="x43-343002r35"></a> <b>bit-vector-p</b>  <i>object</i>
</div>
<tt>
<!--l. 1395--><p class="indent" >   <a 
href="symbols.html#x187-2604126r126">bit-vector-p</a></tt> истинен, если аргумент битовый вектор, иначе ложен.
<div class="lisp"><div class="tabbing">
(bit-vector-p x) <span class="math"> ≡</span> (typep x &#x2019;bit-vector)
   <br>
<!--l. 1398--><p class="noindent" ></div>
<!--l. 1398--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3440006.2.2" id="x43-3440006.2.2"></a></span>
<!--l. 1398--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3450006.2.2" id="x43-3450006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1401--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-345001"></a><a 
 id="x43-345002r36"></a> <b>vectorp</b>  <i>object</i>
</div>
<tt>
<!--l. 1404--><p class="indent" >   <a 
href="symbols.html#x187-2604921r921">vectorp</a></tt> истинен, если аргумент вектор, иначе ложен. <div class="lisp"><div class="tabbing">
(vectorp x) <span class="math"> ≡</span> (typep x &#x2019;vector)
   <br>
<!--l. 1407--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1407--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3460006.2.2" id="x43-3460006.2.2"></a></span>
<!--l. 1407--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3470006.2.2" id="x43-3470006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1410--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-347001"></a><a 
 id="x43-347002r37"></a> <b>simple-vector-p</b>  <i>object</i>
</div>
<tt>
<!--l. 1413--><p class="indent" >   <a 
href="symbols.html#x187-2604921r921">vectorp</a></tt> истинен, если аргумент простой общий вектор, иначе ложен.
<div class="lisp"><div class="tabbing">
(simple-vector-p x) <span class="math"> ≡</span> (typep x &#x2019;simple-vector)
   <br>
<!--l. 1417--><p class="noindent" ></div>
<!--l. 1417--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3480006.2.2" id="x43-3480006.2.2"></a></span>
<!--l. 1417--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3490006.2.2" id="x43-3490006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1420--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-349001"></a><a 
 id="x43-349002r38"></a> <b>simple-string-p</b>  <i>object</i>
</div>
<tt>
<!--l. 1423--><p class="indent" >   <a 
href="symbols.html#x187-2604793r793">simple-string-p</a></tt> истинен, если аргумент простая строка, иначе ложен.
<div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(simple-string-p x) <span class="math"> ≡</span> (typep x &#x2019;simple-string)
   <br>
<!--l. 1427--><p class="noindent" ></div>
<!--l. 1427--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3500006.2.2" id="x43-3500006.2.2"></a></span>
<!--l. 1427--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3510006.2.2" id="x43-3510006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1430--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-351001"></a><a 
 id="x43-351002r39"></a> <b>simple-bit-vector-p</b>  <i>object</i>
</div>
<tt>
<!--l. 1433--><p class="indent" >   <a 
href="symbols.html#x187-2604788r788">simple-bit-vector-p</a></tt> истинен, если аргумент простой битовый вектор,
иначе ложен. <div class="lisp"><div class="tabbing">
(simple-bit-vector-p x) <span class="math"> ≡</span> (typep x &#x2019;simple-bit-vector)
   <br>
<!--l. 1437--><p class="noindent" ></div>
<!--l. 1437--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3520006.2.2" id="x43-3520006.2.2"></a></span>
<!--l. 1437--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3530006.2.2" id="x43-3530006.2.2"></a></span>
</div>
</div>
<div class="defun">
                                                                          

                                                                          
<!--l. 1440--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-353001"></a><a 
 id="x43-353002r40"></a> <b>arrayp</b>  <i>object</i>
</div>
<tt>
<!--l. 1443--><p class="indent" >   <a 
href="symbols.html#x187-2604102r102">arrayp</a></tt> истинен, если аргумент массив, иначе ложен. <div class="lisp"><div class="tabbing">
(arrayp x) <span class="math"> ≡</span> (typep x &#x2019;array)
   <br>
<!--l. 1446--><p class="noindent" ></div>
<!--l. 1446--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3540006.2.2" id="x43-3540006.2.2"></a></span>
<!--l. 1446--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3550006.2.2" id="x43-3550006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1449--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-355001"></a><a 
 id="x43-355002r41"></a> <b>packagep</b>  <i>object</i>
</div>
<tt>
<!--l. 1452--><p class="indent" >   <a 
href="symbols.html#x187-2604650r650">packagep</a></tt> истинен, если аргумент является пакетом, иначе является
ложью. <div class="lisp"><div class="tabbing">
(packagep x) <span class="math"> ≡</span> (typep x &#x2019;package)
   <br>
<!--l. 1456--><p class="noindent" ></div>
<!--l. 1456--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3560006.2.2" id="x43-3560006.2.2"></a></span>
                                                                          

                                                                          
<!--l. 1456--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3570006.2.2" id="x43-3570006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1459--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-357001"></a><a 
 id="x43-357002r42"></a> <b>functionp</b>  <i>object</i>
</div>
<div class="lisp">
<!--l. 1462--><p class="indent" >   <div class="tabbing">
(functionp x) <span class="math"> ≡</span> (typep x &#x2019;function)
   <br>
<!--l. 1464--><p class="noindent" ></div>
<!--l. 1464--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3580006.2.2" id="x43-3580006.2.2"></a></span>
<!--l. 1464--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3590006.2.2" id="x43-3590006.2.2"></a></span>
</div>
<!--l. 1465--><p class="indent" >   Типы <tt>cons</tt> и <tt>symbol</tt> непересекаются с типом <tt><a 
href="symbols.html#x187-2604399r399">function</a></tt>. <tt><a 
href="symbols.html#x187-2604403r403">functionp</a></tt>
является ложной для символов и списков.
</div>
<div class="defun">
<!--l. 1471--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-359001"></a><a 
 id="x43-359002r43"></a> <b>compiled-function-p</b>  <i>object</i>
</div>
<tt>
<!--l. 1474--><p class="indent" >   <a 
href="symbols.html#x187-2604234r234">compiled-function-p</a></tt> истинен, если аргумент — скомпилированный
объект кода, иначе ложен. <div class="lisp"><div class="tabbing">
(compiled-function-p x) <span class="math"> ≡</span> (typep x &#x2019;compiled-function)
   <br>
<!--l. 1478--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1478--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3600006.2.2" id="x43-3600006.2.2"></a></span>
<!--l. 1478--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3610006.2.2" id="x43-3610006.2.2"></a></span>
</div>
</div>
<!--l. 1481--><p class="indent" >   Смотрите также <tt><a 
href="symbols.html#x187-2604816r816">standard-char-p</a></tt>, <tt>string-char-p</tt>, <tt><a 
href="symbols.html#x187-2604824r824">streamp</a></tt>, <tt><a 
href="symbols.html#x187-2604707r707">random-state-p</a></tt>,
<tt><a 
href="symbols.html#x187-2604726r726">readtablep</a></tt>, <tt><a 
href="symbols.html#x187-2604428r428">hash-table-p</a></tt> и <tt><a 
href="symbols.html#x187-2604664r664">pathnamep</a></tt>.
                                                                          

                                                                          
<!--l. 1486--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse33.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html#tailclmse31.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="preds.html#clmse32.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse32.html"></a>   </div> </div> 
</body></html> 
