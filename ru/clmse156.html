<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Gatherers</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-19 23:41:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 87--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse157.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse155.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse155.html#tailclmse155.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse156.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="generators.html#clmse156.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">B.3   </span> <a 
href="clm.html#QQ2-191-2800" id="x191-2753000B.3">Gatherers</a></h3>
<!--l. 89--><p class="noindent" >These functions create and process gatherers.
<div class="defun">
<!--l. 91--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx191-2753001"></a><a 
 id="x191-2753002r1069"></a> <b>gatherer</b>  <i>collector</i>
</div>
<!--l. 94--><p class="indent" >   The collector must be a function of type <tt>(function ((series <span class="math">t<sub>1</sub></span>)) <span class="math">t<sub>2</sub></span>)</tt>.
Given this function, <tt><a 
href="symbols.html#x196-2871430r430">gatherer</a></tt> returns a gatherer that accepts elements of type <span class="math">t<sub>1</sub></span>
and returns a ﬁnal result of type <span class="math">t<sub>2</sub></span>. The method for combining elements used by
the gatherer is the same as the one used by the collector.
</div>
<div class="defun">
<!--l. 102--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx191-2753003"></a><a 
 id="x191-2753004r1070"></a> <b>next-out</b>  <i>gatherer</i> <i>item</i>
</div>
<!--l. 105--><p class="indent" >   Given a gatherer and a value, <tt><a 
href="symbols.html#x196-2871643r643">next-out</a></tt> enters the value into the gatherer.
</div>
<div class="defun">
<!--l. 110--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx191-2753005"></a><a 
 id="x191-2753006r1071"></a> <b>result-of</b>  <i>gatherer</i>
</div>
<tt>
<!--l. 113--><p class="indent" >   <a 
href="symbols.html#x196-2871791r791">result-of</a></tt> retrieves the net result from a gatherer. <tt><a 
href="symbols.html#x196-2871791r791">result-of</a></tt> can be applied
at any time. However, it is an error to apply <tt><a 
href="symbols.html#x196-2871791r791">result-of</a></tt> twice to the same
gatherer or to apply <tt><a 
href="symbols.html#x196-2871643r643">next-out</a></tt> to a gatherer once <tt><a 
href="symbols.html#x196-2871791r791">result-of</a></tt> has been applied.
<div class="lisp"><div class="tabbing">
(let ((g (gatherer #&#x2019;collect-sum)))
   <br>                       (dolist (i &#x2019;(1 2 3 4))<br>                         (next-out g i)<br>
    (if (evenp i) (next-out g (* 10 i))))<br>                       (result-of g))<br>
 <span class="math"> ⇒</span> 70<br>
<!--l. 124--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 124--><p class="noindent" ><span class="paragraphHead"><a 
href="#x191-2754000B.3" id="x191-2754000B.3"></a></span>
<!--l. 124--><p class="noindent" ><span class="paragraphHead"><a 
href="#x191-2755000B.3" id="x191-2755000B.3"></a></span>
</div>
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 128--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>gathering</b> <a 
 id="dx191-2755001"></a><a 
 id="x191-2755002r1072"></a> ({(var fn)}*) {form}*
   <br>
<!--l. 129--><p class="noindent" ></div>
<!--l. 129--><p class="noindent" ><span class="paragraphHead"><a 
href="#x191-2756000B.3" id="x191-2756000B.3"></a></span>
</div>
<!--l. 130--><p class="indent" >   The ﬁrst subform must be a list of pairs. The ﬁrst element of each pair, var,
must be a variable name. The second element of each pair, fn, must be a form
that when wrapped in <tt>(function ...)</tt> is acceptable as an argument
to <tt><a 
href="symbols.html#x196-2871430r430">gatherer</a></tt>. Each symbol is bound to a gatherer constructed from the
corresponding collector. The body (consisting of the forms) is evaluated in the
scope of these bindings. When this evaluation is complete, <tt><a 
href="symbols.html#x196-2871431r431">gathering</a></tt> returns the
<tt><a 
href="symbols.html#x196-2871791r791">result-of</a></tt> each gatherer. If there are <span class="math">n</span> pairs in the binding list, <tt><a 
href="symbols.html#x196-2871431r431">gathering</a></tt>
returns <span class="math">n</span> values. For example: <div class="lisp"><div class="tabbing">
(defun examp (data)
   <br>   (gathering ((x collect) (y collect-sum))<br>     (iterate ((i (scan data)))<br>
      (case (ﬁrst i)<br>                        (:slot (next-out x (second i)))<br>
        (:part (dolist (j (second i)) (next-out x j))))<br>
      (next-out y (third i)))))<br>                                            <br>
(examp &#x2019;((:slot a 10) (:part (c d) 40))) <span class="math"> ⇒</span> (a c d) and 50<br>
<!--l. 150--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 150--><p class="noindent" ><span class="paragraphHead"><a 
href="#x191-2757000B.3" id="x191-2757000B.3"></a></span>
<!--l. 150--><p class="noindent" ><span class="paragraphHead"><a 
href="#x191-2758000B.3" id="x191-2758000B.3"></a></span>
</div>
<!--l. 152--><p class="indent" >   As a further illustration of gatherers, consider the following deﬁnition for
a simpliﬁed version of <tt><a 
href="symbols.html#x196-2871431r431">gathering</a></tt> that handles only one binding pair.
<div class="lisp"><div class="tabbing">
(defmacro simple-gathering (((var collector)) &#x0026;body body)
   <br>           ‘(let ((,var (gatherer (function ,collector))))<br>              ,@body<br>
     (result-of ,var)))<br>
<!--l. 159--><p class="noindent" ></div>
<!--l. 159--><p class="noindent" ><span class="paragraphHead"><a 
href="#x191-2759000B.3" id="x191-2759000B.3"></a></span>
<!--l. 159--><p class="noindent" ><span class="paragraphHead"><a 
href="#x191-2760000B.3" id="x191-2760000B.3"></a></span>
</div>
<!--l. 160--><p class="indent" >   The full capabilities of <tt><a 
href="symbols.html#x196-2871431r431">gathering</a></tt> can be supported in much the same
way.
</div>
                                                                          

                                                                          
<!--l. 164--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse157.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse155.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse155.html#tailclmse155.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse156.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="generators.html#clmse156.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse156.html"></a>   </div> </div> 
</body></html> 
