<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Обобщённые переменные</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 4942--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse37.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html#tailclmse35.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse36.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html#clmse36.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">7.2   </span> <a 
href="clm.html#QQ2-48-434" id="x48-4260007.2">Обобщённые
переменные</a></h3>
<!--l. 4945--><p class="noindent" >В Lisp&#x2019;е, переменная может запомнить одну часть данных, а точнее, один
Lisp объект. Главные операции над переменной это получить её значение и
задать ей другое значение. Их часто называют операциями <i>доступа</i> и
<i>изменения</i>. Концепция переменных с именем в виде символа может быть
обобщена до того, что любое место может сохранять в себе части данных вне
зависимости от того, как данное место именуется. Примерами таких мест
хранения являются <i>car</i> и <i>cdr</i> элементы cons-ячейки, элементы массива, и
компоненты структуры.
<!--l. 4955--><p class="indent" >   Для каждого вида обобщённых переменных существуют две функции,
которые реализуют операции <i>доступа</i> и <i>изменения</i>. Для переменных это имя
переменной для доступа, а для изменения специальная форма <tt><a 
href="symbols.html#x185-2605779r779">setq</a></tt>. Функция
<tt><a 
href="symbols.html#x185-2605171r171">car</a></tt> получает доступ к <i>car</i> элементу cons-ячейки, а функция <tt><a 
href="symbols.html#x185-2605759r759">rplaca</a></tt> изменяет
этот элемент ячейки. Функция <tt><a 
href="symbols.html#x185-2605868r868">symbol-value</a></tt> получает динамическое
значение переменной именованной некоторым символом, а функция <tt><a 
href="symbols.html#x185-2605771r771">set</a></tt>
изменяет эту переменную.
<!--l. 4963--><p class="indent" >   Вместо того, чтобы думать о двух разных функциях, которые
соответственно получают доступ и изменяют некоторое место хранения в
зависимости от своих аргументов, мы может думать просто о вызове
функции доступа с некоторыми аргументами, как о <i>имени</i> данного места
хранения. Таким образом, просто <tt>x</tt> является именем места хранения
(переменной), <tt>(car x)</tt> имя для <i>car</i> элементы для некоторой cons-ячейки
(которая в свою очередь именуется символом <tt>x</tt>). Теперь вместо того, чтобы
запоминать по две функции для каждого вида обобщённых переменных
(например <tt><a 
href="symbols.html#x185-2605759r759">rplaca</a></tt> для <tt><a 
href="symbols.html#x185-2605171r171">car</a></tt>), мы адаптировали единый синтаксис для
изменения некоторого места хранения с помощью макроса <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>. Это
аналогично способу, где мы используем специальную форму <tt><a 
href="symbols.html#x185-2605779r779">setq</a></tt> для
преобразования имени переменной (которая является также формой для
доступа к ней) в форму, которая изменяет переменную FIXME. Эта
универсальной отображения в следующей таблице.
<div class="flushleft" 
>
                                                                          

                                                                          
<!--l. 4977--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Функция доступа  </td><td align="left" >Функция изменения</td><td align="left" >Изменения с помощью <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>     </td>
</tr><tr><td align="left" ><tt>x</tt>                </td><td align="left" ><tt>(setq x datum)</tt>    </td><td align="left" ><tt>(setf x datum)</tt>               </td>
</tr><tr><td align="left" ><tt>(car x)</tt>          </td><td align="left" ><tt>(rplaca x datum)</tt>  </td><td align="left" ><tt>(setf (car x) datum)</tt>         </td>
</tr><tr><td align="left" ><tt>(symbol-value x)</tt> </td><td align="left" ><tt>(set x datum)</tt>     </td><td align="left" ><tt>(setf (symbol-value x) datum)</tt></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" >  </td></tr></table>
</div></div>
<tt>
<!--l. 4987--><p class="noindent" ><a 
href="symbols.html#x185-2605778r778">setf</a></tt> это макрос, который анализирует форму доступа, и производит вызов
соответствующей функции изменения.
<!--l. 4990--><p class="indent" >   С появление в Common Lisp&#x2019;е <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>, необходимость в <tt><a 
href="symbols.html#x185-2605779r779">setq</a></tt>, <tt><a 
href="symbols.html#x185-2605759r759">rplaca</a></tt> и <tt><a 
href="symbols.html#x185-2605771r771">set</a></tt>
отпала. Они оставлены в Common Lisp из-за их исторической важности в
Lisp&#x2019;е. Однако, большинство других функций изменения (например
<tt>putprop</tt>, функция изменения для <tt><a 
href="symbols.html#x185-2605410r410">get</a></tt>) были устранены из Common
Lisp&#x2019;а в расчёте на то, что везде на их месте будет использоваться
<tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>.
<div class="defmac">
<div class="defmacheader">
<!--l. 4998--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>setf</b> <a 
 id="dx48-426001"></a><a 
 id="x48-426002r64"></a> {place newvalue}*
   <br>
<!--l. 4999--><p class="noindent" ></div>
<!--l. 4999--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4270007.2" id="x48-4270007.2"></a></span>
</div>
<tt>
<!--l. 5000--><p class="indent" >   (setf <i>place</i> <i>newvalue</i>)</tt> принимает форму <i>place</i>, которая при своём
вычислении получает доступ к объекту в некотором месте хранения и
«инвертирует» эту форму в соответствующую форму <i>изменения</i>. Таким
образом вызов макроса <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> разворачивается в форму изменения, которая
сохраняет результат вычисления формы <i>newvalue</i> в место хранения, на
которое ссылалась форма доступа.
<!--l. 5007--><p class="indent" >   Если пар <i>place</i>-<i>newvalue</i> указано более одной, эти пары обрабатываются
последовательно. Таким образом: <div class="lisp"><div class="tabbing">
(setf <i>place1</i> <i>newvalue1</i>
                                                                          

                                                                          
   <br>                             <i>place2</i> <i>newvalue2</i>)<br>                               ...<br>
      <i>placen</i> <i>newvaluen</i>)<br>
<!--l. 5014--><p class="noindent" ></div>
<!--l. 5014--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4280007.2" id="x48-4280007.2"></a></span>
<!--l. 5014--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4290007.2" id="x48-4290007.2"></a></span>
</div>
<!--l. 5015--><p class="indent" >   эквивалентно <div class="lisp"><div class="tabbing">
(setf <i>place1</i> <i>newvalue1</i>
   <br>                             <i>place2</i> <i>newvalue2</i>)<br>                               ...<br>
      <i>placen</i> <i>newvaluen</i>)<br>
<!--l. 5021--><p class="noindent" ></div>
<!--l. 5021--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4300007.2" id="x48-4300007.2"></a></span>
<!--l. 5021--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4310007.2" id="x48-4310007.2"></a></span>
</div>
<!--l. 5022--><p class="indent" >   Следует отметить, что запись <tt>(setf)</tt> является корректной и возвращает
<tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>.
<!--l. 5024--><p class="indent" >   Форма <i>place</i> может быть одной из следующих:
      <ul class="itemize1">
      <li class="itemize">Имя переменной (лексической и динамической).
      </li>
      <li class="itemize">Формой вызова функции, у которой первый элемент принадлежит
      множеству указанному в следующей таблице:
                                                                          

                                                                          
      <div class="flushleft" 
>
<!--l. 5034--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605085r85">aref</a></tt>          </td><td align="left" ><tt><a 
href="symbols.html#x185-2605171r171">car</a></tt>                    </td><td align="left" ><tt><a 
href="symbols.html#x185-2605861r861">svref</a></tt>        </td><td align="left" >               </td></tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605632r632">nth</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605189r189">cdr</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605410r410">get</a></tt> </td> <td align="left" ></td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605329r329">elt</a></tt>           </td><td align="left" ><tt><a 
href="symbols.html#x185-2605160r160">caar</a></tt>                   </td><td align="left" ><tt><a 
href="symbols.html#x185-2605421r421">getf</a></tt>         </td><td align="left" ><tt><a 
href="symbols.html#x185-2605868r868">symbol-value</a></tt>   </td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605746r746">rest</a></tt>          </td><td align="left" ><tt><a 
href="symbols.html#x185-2605167r167">cadr</a></tt>                   </td><td align="left" ><tt><a 
href="symbols.html#x185-2605422r422">gethash</a></tt>      </td><td align="left" ><tt><a 
href="symbols.html#x185-2605863r863">symbol-function</a></tt></td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605378r378">first</a></tt>         </td><td align="left" ><tt><a 
href="symbols.html#x185-2605181r181">cdar</a></tt>                   </td><td align="left" ><tt><a 
href="symbols.html#x185-2605315r315">documentation</a></tt></td><td align="left" ><tt><a 
href="symbols.html#x185-2605867r867">symbol-plist</a></tt>   </td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605769r769">second</a></tt>        </td><td align="left" ><tt><a 
href="symbols.html#x185-2605188r188">cddr</a></tt>                   </td><td align="left" ><tt><a 
href="symbols.html#x185-2605366r366">fill-pointer</a></tt> </td><td align="left" ><tt><a 
href="symbols.html#x185-2605529r529">macro-function</a></tt> </td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605880r880">third</a></tt>         </td><td align="left" ><tt><a 
href="symbols.html#x185-2605156r156">caaar</a></tt>                  </td><td align="left" ><tt><a 
href="symbols.html#x185-2605154r154">caaaar</a></tt>       </td><td align="left" ><tt><a 
href="symbols.html#x185-2605175r175">cdaaar</a></tt>         </td></tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605394r394">fourth</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605159r159">caadr</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605155r155">caaadr</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605176r176">cdaadr</a></tt></td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605356r356">fifth</a></tt>         </td><td align="left" ><tt><a 
href="symbols.html#x185-2605163r163">cadar</a></tt>                  </td><td align="left" ><tt><a 
href="symbols.html#x185-2605157r157">caadar</a></tt>       </td><td align="left" ><tt><a 
href="symbols.html#x185-2605178r178">cdadar</a></tt>         </td></tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605803r803">sixth</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605166r166">caddr</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605158r158">caaddr</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605179r179">cdaddr</a></tt></td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605780r780">seventh</a></tt>       </td><td align="left" ><tt><a 
href="symbols.html#x185-2605177r177">cdaar</a></tt>                  </td><td align="left" ><tt><a 
href="symbols.html#x185-2605161r161">cadaar</a></tt>       </td><td align="left" ><tt><a 
href="symbols.html#x185-2605182r182">cddaar</a></tt>         </td></tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605328r328">eighth</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605180r180">cdadr</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605162r162">cadadr</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605183r183">cddadr</a></tt></td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605611r611">ninth</a></tt>         </td><td align="left" ><tt><a 
href="symbols.html#x185-2605184r184">cddar</a></tt>                  </td><td align="left" ><tt><a 
href="symbols.html#x185-2605164r164">caddar</a></tt>       </td><td align="left" ><tt><a 
href="symbols.html#x185-2605185r185">cdddar</a></tt>         </td></tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605876r876">tenth</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605187r187">cdddr</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605165r165">cadddr</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605186r186">cddddr</a></tt></td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605758r758">row-major-aref</a></tt></td><td align="left" ><tt><a 
href="symbols.html#x185-2605235r235">compiler-macro-function</a></tt></td><td align="left" >             </td><td align="left" >               </td></tr></table>
</div></div>
      <!--l. 5054--><p class="noindent" >Это правило применяется только тогда, когда имя функции ссылается
      глобальное определение функции, и не ссылается на локальное
      определение или макрос.
      </li>
      <li class="itemize">Формой вызова функции, у которой первый элемент является именем
      функции-селектора созданной с помощью <tt><a 
href="symbols.html#x185-2605289r289">defstruct</a></tt>.
      <!--l. 5061--><p class="noindent" >Это правило применяется только тогда, когда имя функции ссылается
      глобальное определение функции, и не ссылается на локальное
      определение или макрос.
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of any one of the
      following functions, provided that the new value
      <!--l. 5068--><p class="noindent" >is of the speciﬁed type so that it can be used to replace the speciﬁed
      “location” (which is in each of these cases not truly a generalized
      variable):
      <div class="flushleft" 
>
<!--l. 5072--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Имя функции</td><td align="left" >Требуемый тип</td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605115r115">bit</a></tt>         </td><td align="left" ><tt><a 
href="symbols.html#x185-2605115r115">bit</a></tt>          </td></tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605765r765">sbit</a></tt> </td> <td align="left" ><tt><a 
href="symbols.html#x185-2605115r115">bit</a></tt></td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605849r849">subseq</a></tt>      </td><td align="left" ><tt>sequence</tt>     </td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
                                                                          

                                                                          
<div class="newer">
      <!--l. 5085--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-431001"></a>to eliminate the type <tt>string-char</tt>
      and to redeﬁne <tt><a 
href="symbols.html#x185-2605828r828">string</a></tt> to be the union of one or more specialized
      vector types, the types of whose elements are subtypes of the type
      <tt><a 
href="symbols.html#x185-2605214r214">character</a></tt>. In the preceding table, the type <tt>string-char</tt> should be
      replaced by some such phrase as “the element-type of the argument
      vector.”
      </div>
      <!--l. 5093--><p class="noindent" >Это правило применяется только когда имя функции ссылается на
      глобальное, а не локальное определение функции.
      <!--l. 5096--><p class="noindent" >In the case of <tt><a 
href="symbols.html#x185-2605849r849">subseq</a></tt>, the replacement value must be a sequence whose
      elements may be contained by the sequence argument to <tt><a 
href="symbols.html#x185-2605849r849">subseq</a></tt>. (Note that
      this is not so stringent as to require that the replacement value be a
      sequence of the same type as the sequence of which the subsequence is
      speciﬁed.) If the length of the replacement value does not equal the
      length of the subsequence to be replaced, then the shorter length
      determines the number of elements to be stored, as for the function
      <tt><a 
href="symbols.html#x185-2605745r745">replace</a></tt>.
      </li>
      <li class="itemize">Форма вызова функции, первый элемент которой является именем
      одной из следующих функций при условии, что указанный аргумент
      этой функции в свою очередь является формой <i>place</i>. in this case the
      new <i>place</i> has stored back into it the result of applying the speciﬁed
      “update” function (which is in each of these cases not a true update
      function): FIXME
      <div class="flushleft" 
>
<!--l. 5113--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Имя функции</td><td align="left" >Аргумент являющийся <i>местом</i></td><td align="left" >Функция изменения</td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605468r468">ldb</a></tt>         </td><td align="left" >second                                   </td><td align="left" ><tt><a 
href="symbols.html#x185-2605321r321">dpb</a></tt>               </td>
</tr><tr><td align="left" ><tt><a 
href="symbols.html#x185-2605566r566">mask-field</a></tt>  </td><td align="left" >second                                   </td><td align="left" ><tt><a 
href="symbols.html#x185-2605300r300">deposit-field</a></tt>     </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
      <!--l. 5123--><p class="noindent" >Это правило применяется только тогда, когда имя функции ссылается
      глобальное определение функции, и не ссылается на локальное
      определение или макрос.
                                                                          

                                                                          
      </li>
      <li class="itemize">Форма декларации типа <tt><a 
href="symbols.html#x185-2605878r878">the</a></tt>, в таком случае декларация переносится на
      форму <i>newvalue</i>, и анализируется результирующая <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> форма.
      Например: <div class="lisp"><div class="tabbing">
      (setf (the integer (cadr x)) (+ y 3))
      <br>
      <!--l. 5131--><p class="noindent" ></div>
      <!--l. 5131--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4320007.2" id="x48-4320007.2"></a></span>
      <!--l. 5131--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4330007.2" id="x48-4330007.2"></a></span>
</div>
      <!--l. 5132--><p class="noindent" >будет обработана как <div class="lisp"><div class="tabbing">
      (setf (cadr x) (the integer (+ y 3)))
      <br>
      <!--l. 5135--><p class="noindent" ></div>
      <!--l. 5135--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4340007.2" id="x48-4340007.2"></a></span>
                                                                          

                                                                          
      <!--l. 5135--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4350007.2" id="x48-4350007.2"></a></span>
</div>
      </li>
      <li class="itemize">Вызов функции <tt><a 
href="symbols.html#x185-2605081r81">apply</a></tt>, в которой первый аргумент является функцией,
      которая может является <i>местом</i> для <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>. That is, <tt>(function <i>name</i>)</tt>,
      where <i>name</i> is the name of a function, calls to which are recognized as
      places by <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>. Suppose that the use of <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> with <tt><a 
href="symbols.html#x185-2605081r81">apply</a></tt> looks like this:
      <div class="lisp"><div class="tabbing">
      (setf (apply #&#x2019;<i>name</i> <i>x1</i> <i>x2</i> ... <i>xn</i> <i>rest</i>) <i>x0</i>)
      <br>
      <!--l. 5145--><p class="noindent" ></div>
      <!--l. 5145--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4360007.2" id="x48-4360007.2"></a></span>
      <!--l. 5145--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4370007.2" id="x48-4370007.2"></a></span>
</div>
      <!--l. 5146--><p class="noindent" >The <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method for the function <i>name</i> must be such that <div class="lisp"><div class="tabbing">
      (setf (<i>name</i> <i>z1</i> <i>z2</i> ... <i>zm</i>) <i>z0</i>)
      <br>
      <!--l. 5149--><p class="noindent" ></div>
      <!--l. 5149--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4380007.2" id="x48-4380007.2"></a></span>
                                                                          

                                                                          
      <!--l. 5149--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4390007.2" id="x48-4390007.2"></a></span>
</div>
      <!--l. 5150--><p class="noindent" >expands into a store form <div class="lisp"><div class="tabbing">
      (<i>storefn</i> <i>zi<span class="math"><sub>1</sub></span></i> <i>zi<span class="math"><sub>2</sub></span></i> ... <i>zi<span class="math"><sub>k</sub></span></i> <i>zm</i>)
      <br>
      <!--l. 5153--><p class="noindent" ></div>
      <!--l. 5153--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4400007.2" id="x48-4400007.2"></a></span>
      <!--l. 5153--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4410007.2" id="x48-4410007.2"></a></span>
</div>
      <!--l. 5154--><p class="noindent" >That is, it must expand into a function call such that all arguments but the
      last may be any permutation or subset of the new value <i>z0</i> and
      the arguments of the access form, but the <i>last</i> argument of the
      storing call must be the same as the last argument of the access call.
      See <tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt> for more details on accessing and storing
      forms.
      <!--l. 5161--><p class="noindent" >Given this, the <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>-of-<tt><a 
href="symbols.html#x185-2605081r81">apply</a></tt> form shown above expands into <div class="lisp"><div class="tabbing">
      (apply #&#x2019;<i>storefn</i> <i>xi<span class="math"><sub>1</sub></span></i> <i>xi<span class="math"><sub>2</sub></span></i> ... <i>xi<span class="math"><sub>k</sub></span></i> <i>rest</i>)
      <br>
      <!--l. 5164--><p class="noindent" ></div>
      <!--l. 5164--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4420007.2" id="x48-4420007.2"></a></span>
                                                                          

                                                                          
      <!--l. 5164--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4430007.2" id="x48-4430007.2"></a></span>
</div>
      <!--l. 5165--><p class="noindent" >As an example, suppose that the variable <tt>indexes</tt> contains a list of
      subscripts for a multidimensional array <i>foo</i> whose rank is not known until
      run time. One may access the indicated element of the array by writing
      <div class="lisp"><div class="tabbing">
      (apply #&#x2019;aref foo indexes)
      <br>
      <!--l. 5171--><p class="noindent" ></div>
      <!--l. 5171--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4440007.2" id="x48-4440007.2"></a></span>
      <!--l. 5171--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4450007.2" id="x48-4450007.2"></a></span>
</div>
      <!--l. 5172--><p class="noindent" >and one may alter the value of the indicated element to that of <tt>newvalue</tt> by
      writing <div class="lisp"><div class="tabbing">
      (setf (apply #&#x2019;aref foo indexes) newvalue)
      <br>
      <!--l. 5176--><p class="noindent" ></div>
      <!--l. 5176--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4460007.2" id="x48-4460007.2"></a></span>
                                                                          

                                                                          
      <!--l. 5176--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4470007.2" id="x48-4470007.2"></a></span>
</div>
      <!--l. 5178--><p class="noindent" >Это правило применяется только тогда, когда имя функции ссылается
      глобальное определение функции, и не ссылается на локальное
      определение или макрос.
      </li>
      <li class="itemize">Макровызов, в случае чего <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> разворачивает макровызов и затем
      анализирует полученную форму.
      <!--l. 5185--><p class="noindent" >Этот шаг используется <tt><a 
href="symbols.html#x185-2605531r531">macroexpand-1</a></tt>, но не <tt><a 
href="symbols.html#x185-2605530r530">macroexpand</a></tt>. Это
      позволяет пременить какое-либо из предшествующих правил.
      </li>
      <li class="itemize">Любая форма, для которой было сделано определение с помощью
      <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> или <tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt>.
      <!--l. 5192--><p class="noindent" >Это правило применяется только тогда, когда имя функции ссылается
      глобальное определение функции, и не ссылается на локальное
      определение или макрос.</li></ul>
<div class="newer">
<!--l. 5197--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-447001"></a>to add one more rule to the preceding list, coming
after all those listed above:
      <ul class="itemize1">
      <li class="itemize">Any other list whose ﬁrst element is a symbol (call it <i>f </i>). In this case, the
      call to <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> expands into a call to the function named by the list <tt>(setf <i>f</i>)</tt>
      (see section <a 
href="clmse35.html#x47-3850007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). The ﬁrst argument is the new value and the remaining
      arguments are the values of the remaining elements of <i>place</i>. This
      expansion occurs regardless of whether either <i>f </i> or <tt>(setf <i>f</i>)</tt> is
      deﬁned as a function locally, globally, or not at all. For example,
      <div class="lisp"><div class="tabbing">
      (setf (<i>f </i> <i>arg1</i> <i>arg2</i> ...) <i>newvalue</i>)
      <br>
      <!--l. 5211--><p class="noindent" ></div>
                                                                          

                                                                          
      <!--l. 5211--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4480007.2" id="x48-4480007.2"></a></span>
      <!--l. 5211--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4490007.2" id="x48-4490007.2"></a></span>
</div>
      <!--l. 5212--><p class="noindent" >expands into a form with the same eﬀect and value as <div class="lisp"><div class="tabbing">
      (let ((#:temp1 <i>arg1</i>)     ;Force correct order of evaluation
      <br>                               (#:temp2 <i>arg2</i>)<br>                               ...<br>
                 (#:temp0 newvalue))<br>         (funcall (function (setf <i>f </i>))<br>
                      #:temp0<br>                               #:temp1<br>
                      #:temp2 ...))<br>
      <!--l. 5222--><p class="noindent" ></div>
      <!--l. 5222--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4500007.2" id="x48-4500007.2"></a></span>
      <!--l. 5222--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4510007.2" id="x48-4510007.2"></a></span>
</div>
      <!--l. 5223--><p class="noindent" >By convention, any function named <tt>(setf <i>f</i>)</tt> should return its ﬁrst
      argument as its only value, in order to preserve the speciﬁcation that <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>
      returns its <i>newvalue</i>.</li></ul>
</div>
<div class="new">
<!--l. 5230--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-451001"></a>to add this case as well:
      <ul class="itemize1">
      <li class="itemize">A variable reference that refers to a symbol macro deﬁnition made by
      <tt>symbol-macrolet</tt>, in which case <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> expands the reference and then
      analyzes the resulting form.</li></ul>
                                                                          

                                                                          
</div>
<tt>
<!--l. 5239--><p class="indent" >   <a 
href="symbols.html#x185-2605778r778">setf</a></tt> тщательно сохраняет обычный порядок выполнения подформ слева
направо. С другой стороны, точное раскрытие для какой-нибудь частной
формы не гарантируется и может зависеть от реализации. Все, что
гарантируется, это раскрытие <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> формы в некоторую функцию
изменения, используемую данной реализацией, и выполнение подформ слева
направо.
<!--l. 5246--><p class="indent" >   Конечным результатом вычисления формы <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> является значение
<i>newvalue</i>. Таким образом <tt>(setf (car x) y)</tt> раскрывается не прямо в
<tt>(rplaca x y)</tt>, а в что-то вроде <div class="lisp"><div class="tabbing">
(let ((G1 x) (G2 y)) (rplaca G1 G2) G2)
   <br>
<!--l. 5251--><p class="noindent" ></div>
<!--l. 5251--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4520007.2" id="x48-4520007.2"></a></span>
<!--l. 5251--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4530007.2" id="x48-4530007.2"></a></span>
</div>
<!--l. 5252--><p class="indent" >   точное раскрытие зависит от реализации.
<!--l. 5254--><p class="indent" >   Пользователь может определить новое раскрытие для <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> используя
<tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt>.
<div class="newer">
<!--l. 5258--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-453001"></a>to extend the speciﬁcation of <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> to allow a <i>place</i>
whose <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method has more than one store variable (see <tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt>).
In such a case as many values are accepted from the <i>newvalue</i> form as there are
store variables; extra values are ignored and missing values default to <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>, as is
usual in situations involving multiple values.
<!--l. 5266--><p class="indent" >   A proposal was submitted to X3J13 in September 1989 to add a <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method
for <tt><a 
href="symbols.html#x185-2605917r917">values</a></tt> so that one could in fact write, for example, <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(setf (values quotient remainder)
   <br>                                                     (truncate linewidth tabstop))<br>
<!--l. 5272--><p class="noindent" ></div>
<!--l. 5272--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4540007.2" id="x48-4540007.2"></a></span>
<!--l. 5272--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4550007.2" id="x48-4550007.2"></a></span>
</div>
<!--l. 5273--><p class="indent" >   but unless this proposal is accepted users will have to deﬁne a <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method for
<tt><a 
href="symbols.html#x185-2605917r917">values</a></tt> themselves (not a diﬃcult task).
</div>
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 5279--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>psetf</b> <a 
 id="dx48-455001"></a><a 
 id="x48-455002r65"></a> {place newvalue}*
   <br>
<!--l. 5280--><p class="noindent" ></div>
<!--l. 5280--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4560007.2" id="x48-4560007.2"></a></span>
</div>
<tt>
<!--l. 5281--><p class="indent" >   <a 
href="symbols.html#x185-2605703r703">psetf</a></tt> похожа на <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> за исключением того, что если указано более одной
пары <i>place</i>-<i>newvalue</i> , то присваивание местам новых значений происходит
параллельно. Если говорить точнее, то все подформы, которые должны
быть вычислены, вычисляются слева направо. После выполнения всех
вычислений, выполняются все присваивания в неопределённом порядке.
(Неопределённый порядок влияет на поведение в случае, если более одной
формы <i>place</i> ссылаются на одно и то же место.) <tt><a 
href="symbols.html#x185-2605703r703">psetf</a></tt> всегда возвращает
<tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>.
<div class="newer">
<!--l. 5292--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-456001"></a>to extend the speciﬁcation of <tt><a 
href="symbols.html#x185-2605703r703">psetf</a></tt> to
allow a <i>place</i> whose <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method has more than one store variable (see
<tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt>). In such a case as many values are accepted from the
                                                                          

                                                                          
<i>newvalue</i> form as there are store variables; extra values are ignored and
missing values default to <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>, as is usual in situations involving multiple
values.
</div>
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 5303--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>shiftf</b> <a 
 id="dx48-456002"></a><a 
 id="x48-456003r66"></a> {place}+ newvalue
   <br>
<!--l. 5304--><p class="noindent" ></div>
<!--l. 5304--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4570007.2" id="x48-4570007.2"></a></span>
</div>
<!--l. 5305--><p class="indent" >   Каждая форма <i>place</i> может быть любой обобщённой переменной, как
для <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>. В форме <tt>(shiftf <i>place1</i> <i>place2</i> ... <i>placen</i> <i>newvalue</i>)</tt>,
вычисляются и сохраняются значения с <i>place1</i> по <i>placen</i> и вычисляется
<i>newvalue</i>, как значение с номером <span class="math"><i>n</i> + 1</span>. Значения с 2-го по <span class="math"><i>n</i> + 1</span> сохраняются
в интервале с <i>place1</i> по <i>placen</i> и возвращается 1-ое значение (оригинальное
значение <i>place1</i>). Механизм работает как сдвиг регистров. <i>newvalue</i>
сдвигается с правой стороны, все значения сдвигаются влево на одну
позицию, и возвращается сдвигаемое самое левое значение <i>place1</i>. Например:
<div class="lisp"><div class="tabbing">
(setq x (list &#x2019;a &#x2019;b &#x2019;c)) <span class="math"> ⇒</span> (a b c)
   <br>                                                                                               <br>
(shiftf (cadr x) &#x2019;z) <span class="math"> ⇒</span> b<br>                             and now x <span class="math"> ⇒</span> (a z c)<br>
<br>                                          (shiftf (cadr x) (cddr x) &#x2019;q) <span class="math"> ⇒</span> z<br>
   and now x <span class="math"> ⇒</span> (a (c) . q)<br>
<!--l. 5323--><p class="noindent" ></div>
<!--l. 5323--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4580007.2" id="x48-4580007.2"></a></span>
                                                                          

                                                                          
<!--l. 5323--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4590007.2" id="x48-4590007.2"></a></span>
</div>
<!--l. 5324--><p class="indent" >   Эффект от <tt>(shiftf <i>place1</i> <i>place2</i> ... <i>placen</i> <i>newvalue</i>)</tt> эквивалентен
<div class="lisp"><div class="tabbing">
(let ((<i>var1</i> <i>place1</i>)
   <br>                                                                          (<i>var2</i> <i>place2</i>)<br>
      ...<br>                                                  (<i>varn</i> <i>placen</i>))<br>
  (setf <i>place1</i> <i>var2</i>)<br>                                     (setf <i>place2</i> <i>var3</i>)<br>
  ...<br>                                                (setf <i>placen</i> <i>newvalue</i>)<br>
  <i>var1</i>)<br>
<!--l. 5336--><p class="noindent" ></div>
<!--l. 5336--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4600007.2" id="x48-4600007.2"></a></span>
<!--l. 5336--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4610007.2" id="x48-4610007.2"></a></span>
</div>
<!--l. 5337--><p class="indent" >   за исключением того, что последний вариант выполняет все подформы
для каждого <i>place</i> дважды, тогда как <tt><a 
href="symbols.html#x185-2605784r784">shiftf</a></tt> выполняет только единожды.
Например: <div class="lisp"><div class="tabbing">
(setq n 0)
   <br>         (setq x &#x2019;(a b c d))<br>         (shiftf (nth (setq n (+ n 1)) x) &#x2019;z) <span class="math"> ⇒</span> b<br>
   теперь x <span class="math"> ⇒</span> (a z c d)<br>
<i>but</i>
   <br>
(setq n 0)
   <br>               (setq x &#x2019;(a b c d))<br>               (prog1 (nth (setq n (+ n 1)) x)<br>
       (setf (nth (setq n (+ n 1)) x) &#x2019;z)) <span class="math"> ⇒</span> b<br>
   и теперь x <span class="math"> ⇒</span> (a b z d)<br>
<!--l. 5351--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 5351--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4620007.2" id="x48-4620007.2"></a></span>
<!--l. 5351--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4630007.2" id="x48-4630007.2"></a></span>
</div>
<!--l. 5352--><p class="indent" >   Более того, для заданных форм <i>place</i> <tt><a 
href="symbols.html#x185-2605784r784">shiftf</a></tt> может быть более
производительной, чем версия с <tt><a 
href="symbols.html#x185-2605698r698">prog1</a></tt>.
<div class="newer">
<!--l. 5357--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-463001"></a>to extend the speciﬁcation of <tt><a 
href="symbols.html#x185-2605784r784">shiftf</a></tt> to
allow a <i>place</i> whose <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method has more than one store variable (see
<tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt>). In such a case as many values are accepted from the
<i>newvalue</i> form as there are store variables; extra values are ignored and
missing values default to <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>, as is usual in situations involving multiple
values.
</div>__________________________________________________________________________<div class="rationale">
<!--l. 5367--><p class="noindent" ><b>Обоснование:</b> <tt><a 
href="symbols.html#x185-2605784r784">shiftf</a></tt> and <tt><a 
href="symbols.html#x185-2605756r756">rotatef</a></tt> have been included in Common Lisp as
generalizations of two-argument versions formerly called <tt>swapf</tt> and <tt>exchf</tt>. The
two-argument versions have been found to be very useful, but the names were easily
confused. The generalization to many argument forms and the change of names were
both inspired by the work of Suzuki <span class="cite">[<a 
href="bib.html#XSUZUKI-POINTER-ROTATION">47</a>]</span>, which indicates that use of these primitives can
make certain complex pointer-manipulation programs clearer and easier to prove
correct.
</div>___________________________________________________________________________________________________________
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 5381--><p class="indent" >     <div class="tabbing">
  <i>[Макрос]</i> <b>rotatef</b> <a 
 id="dx48-463002"></a><a 
 id="x48-463003r67"></a> {place}*
     <br>
<!--l. 5382--><p class="noindent" ></div>
<!--l. 5382--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4640007.2" id="x48-4640007.2"></a></span>
</div>
<!--l. 5383--><p class="indent" >     Каждая <i>place</i> может быть обобщённой переменной, как для <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>. В форме
<tt>(rotatef <i>place1</i> <i>place2</i> ... <i>placen</i>)</tt>, вычисляются и сохраняются
                                                                          

                                                                          
значения c <i>place1</i> по <i>placen</i>. Механизм действует как круговой сдвиг
регистров влево, и значение <i>place1</i> сдвигается в конец на <i>placen</i>. Следует
отметить, что <tt>(rotatef <i>place1</i> <i>place2</i>)</tt> меняет значения между <i>place1</i> и
<i>place2</i>.
<!--l. 5391--><p class="indent" >   Эффект от использования <tt>(rotatef <i>place1</i> <i>place2</i> ... <i>placen</i>)</tt>
эквивалентен <div class="lisp"><div class="tabbing">
(psetf <i>place1</i> <i>place2</i>
   <br>                                <i>place2</i> <i>place3</i><br>                                ...<br>
       <i>placen</i> <i>place1</i>)<br>
<!--l. 5398--><p class="noindent" ></div>
<!--l. 5398--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4650007.2" id="x48-4650007.2"></a></span>
<!--l. 5398--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4660007.2" id="x48-4660007.2"></a></span>
</div>
<!--l. 5399--><p class="indent" >   за исключением того, что в последнем вычисление форм происходит
дважды, тогда как <tt><a 
href="symbols.html#x185-2605756r756">rotatef</a></tt> выполняет только единожды. Более того, для
заданных форм <i>place</i> <tt><a 
href="symbols.html#x185-2605756r756">rotatef</a></tt> может быть более производительной, чем
версия с <tt><a 
href="symbols.html#x185-2605698r698">prog1</a></tt>.
<tt>
<!--l. 5403--><p class="indent" >   <a 
href="symbols.html#x185-2605756r756">rotatef</a></tt> всегда возвращает <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>.
<div class="newer">
<!--l. 5406--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-466001"></a>to extend the speciﬁcation of <tt><a 
href="symbols.html#x185-2605756r756">rotatef</a></tt> to
allow a <i>place</i> whose <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method has more than one store variable (see
<tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt>). In such a case as many values are accepted from the
<i>newvalue</i> form as there are store variables; extra values are ignored and
missing values default to <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>, as is usual in situations involving multiple
values.
</div>
</div>
<!--l. 5416--><p class="indent" >   Другие макросы, которые управляют обобщёнными переменными,
включают <tt><a 
href="symbols.html#x185-2605421r421">getf</a></tt>, <tt><a 
href="symbols.html#x185-2605734r734">remf</a></tt>, <tt><a 
href="symbols.html#x185-2605441r441">incf</a></tt>, <tt><a 
href="symbols.html#x185-2605268r268">decf</a></tt>, <tt><a 
href="symbols.html#x185-2605705r705">push</a></tt>, <tt><a 
href="symbols.html#x185-2605670r670">pop</a></tt>, <tt><a 
href="symbols.html#x185-2605107r107">assert</a></tt>, <tt><a 
href="symbols.html#x185-2605267r267">ctypecase</a></tt> и
<tt><a 
href="symbols.html#x185-2605174r174">ccase</a></tt>.
                                                                          

                                                                          
<!--l. 5421--><p class="indent" >   Макросы, которые управляют обобщёнными переменными, должны
гарантировать «явную» семантику: подформы обобщённых переменных
вычисляются точно столько раз, сколько они встречаются в выражении, и в
том же порядке, в котором встречаются.
<!--l. 5426--><p class="indent" >   В ссылках на обобщённые переменные, как в <tt><a 
href="symbols.html#x185-2605784r784">shiftf</a></tt>, <tt><a 
href="symbols.html#x185-2605441r441">incf</a></tt>, <tt><a 
href="symbols.html#x185-2605705r705">push</a></tt> и <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>
или <tt><a 
href="symbols.html#x185-2605468r468">ldb</a></tt>, обобщённые переменные считываются и записываются в одну и ту
же ссылку. Сохранение порядка выполнения исходной программы и
количества выполнений чрезвычайно важно.
<!--l. 5431--><p class="indent" >   As an example of these semantic rules, in the generalized-variable reference
<tt>(setf <i>reference</i> <i>value</i>)</tt> the <i>value</i> form must be evaluated <i>after</i> all the
subforms of the reference because the <i>value</i> form appears to the right of
them.
<!--l. 5436--><p class="indent" >   The expansion of these macros must consist of code that follows these rules or
has the same eﬀect as such code. This is accomplished by introducing temporary
variables bound to the subforms of the reference. As an optimization in
the implementation, temporary variables may be eliminated whenever it
can be proved that removing them has no eﬀect on the semantics of the
program. For example, a constant need never be saved in a temporary
variable. A variable, or for that matter any form that does not have side
eﬀects, need not be saved in a temporary variable if it can be proved
that its value will not change within the scope of the generalized-variable
reference.
<!--l. 5447--><p class="indent" >   Common Lisp provides built-in facilities to take care of these semantic
complications and optimizations. Since the required semantics can be guaranteed
by these facilities, the user does not have to worry about writing correct code for
them, especially in complex cases. Even experts can become confused and make
mistakes while writing this sort of code.
<div class="newer">
<!--l. 5455--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-466002"></a>to clarify the preceding discussion about the order
of evaluation of subforms in calls to <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> and related macros. The general
intent is clear: evaluation proceeds from left to right whenever possible.
However, the left-to-right rule does not remove the obligation on writers of
macros and <tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt> to work to ensure left-to-right order of
evaluation.
<!--l. 5463--><p class="indent" >   Let it be emphasized that, in the following discussion, a <i>form</i> is something
whose syntactic use is such that it will be evaluated. A <i>subform</i> means a form
that is nested inside another form, not merely any Lisp object nested inside a
form regardless of syntactic context.
                                                                          

                                                                          
<!--l. 5468--><p class="indent" >   The evaluation ordering of subforms within a generalized variable
reference is determined by the order speciﬁed by the second value returned by
<tt><a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt>. For all predeﬁned generalized variable references (<tt><a 
href="symbols.html#x185-2605421r421">getf</a></tt>,
<tt><a 
href="symbols.html#x185-2605468r468">ldb</a></tt>), this order of evaluation is exactly left-to-right. When a generalized
variable reference is derived from a macro expansion, this rule is applied
<i>after</i> the macro is expanded to ﬁnd the appropriate generalized variable
reference.
<!--l. 5477--><p class="indent" >   This is intended to make it clear that if the user writes a <tt><a 
href="symbols.html#x185-2605284r284">defmacro</a></tt> or
<tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt> macro that doesn&#x2019;t preserve left-to-right evaluation
order, the order speciﬁed in the user&#x2019;s code holds. For example, given
<div class="lisp"><div class="tabbing">
(defmacro wrong-order (x y) ‘(getf ,y ,x))
   <br>
<!--l. 5483--><p class="noindent" ></div>
<!--l. 5483--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4670007.2" id="x48-4670007.2"></a></span>
<!--l. 5483--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4680007.2" id="x48-4680007.2"></a></span>
</div>
<!--l. 5484--><p class="indent" >   then <div class="lisp"><div class="tabbing">
(push <i>value</i> (wrong-order <i>place1</i> <i>place2</i>))
   <br>
<!--l. 5487--><p class="noindent" ></div>
<!--l. 5487--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4690007.2" id="x48-4690007.2"></a></span>
                                                                          

                                                                          
<!--l. 5487--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4700007.2" id="x48-4700007.2"></a></span>
</div>
<!--l. 5488--><p class="indent" >   will evaluate <i>place2</i> ﬁrst and then <i>place1</i> because that is the order they are
evaluated in the macro expansion.
<!--l. 5491--><p class="indent" >   For the macros that manipulate generalized variables (<tt><a 
href="symbols.html#x185-2605705r705">push</a></tt>, <tt><a 
href="symbols.html#x185-2605706r706">pushnew</a></tt>, <tt><a 
href="symbols.html#x185-2605421r421">getf</a></tt>,
<tt><a 
href="symbols.html#x185-2605734r734">remf</a></tt>, <tt><a 
href="symbols.html#x185-2605441r441">incf</a></tt>, <tt><a 
href="symbols.html#x185-2605268r268">decf</a></tt>, <tt><a 
href="symbols.html#x185-2605784r784">shiftf</a></tt>, <tt><a 
href="symbols.html#x185-2605756r756">rotatef</a></tt>, <tt><a 
href="symbols.html#x185-2605703r703">psetf</a></tt>, <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>, <tt><a 
href="symbols.html#x185-2605670r670">pop</a></tt>, and those deﬁned with
<tt><a 
href="symbols.html#x185-2605281r281">define-modify-macro</a></tt>) the subforms of the macro call are evaluated exactly once
in left-to-right order, with the subforms of the generalized variable references
evaluated in the order speciﬁed above.
<!--l. 5498--><p class="indent" >   Each of <tt><a 
href="symbols.html#x185-2605705r705">push</a></tt>, <tt><a 
href="symbols.html#x185-2605706r706">pushnew</a></tt>, <tt><a 
href="symbols.html#x185-2605421r421">getf</a></tt>, <tt><a 
href="symbols.html#x185-2605734r734">remf</a></tt>, <tt><a 
href="symbols.html#x185-2605441r441">incf</a></tt>, <tt><a 
href="symbols.html#x185-2605268r268">decf</a></tt>, <tt><a 
href="symbols.html#x185-2605784r784">shiftf</a></tt>, <tt><a 
href="symbols.html#x185-2605756r756">rotatef</a></tt>, <tt><a 
href="symbols.html#x185-2605703r703">psetf</a></tt>, and
<tt><a 
href="symbols.html#x185-2605670r670">pop</a></tt> evaluates all subforms before modifying any of the generalized variable
locations. Moreover, <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> itself, in the case when a call on it has more than two
arguments, performs its operation on each pair in sequence. That is, in
<div class="lisp"><div class="tabbing">
(setf <i>place1</i> <i>value1</i> <i>place2</i> <i>value2</i> ...)
   <br>
<!--l. 5507--><p class="noindent" ></div>
<!--l. 5507--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4710007.2" id="x48-4710007.2"></a></span>
<!--l. 5507--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4720007.2" id="x48-4720007.2"></a></span>
</div>
<!--l. 5508--><p class="indent" >   the subforms of <i>place1</i> and <i>value1</i> are evaluated, the location speciﬁed by
<i>place1</i> is modiﬁed to contain the value returned by <i>value1</i>, and then the rest of
the <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> form is processed in a like manner.
<!--l. 5512--><p class="indent" >   For the macros <tt><a 
href="symbols.html#x185-2605216r216">check-type</a></tt>, <tt><a 
href="symbols.html#x185-2605267r267">ctypecase</a></tt>, and <tt><a 
href="symbols.html#x185-2605174r174">ccase</a></tt>, subforms of the
generalized variable reference are evaluated once per test of a generalized variable,
but they may be evaluated again if the type check fails (in the case of
<tt><a 
href="symbols.html#x185-2605216r216">check-type</a></tt>) or if none of the cases holds (in <tt><a 
href="symbols.html#x185-2605267r267">ctypecase</a></tt> or <tt><a 
href="symbols.html#x185-2605174r174">ccase</a></tt>).
<!--l. 5518--><p class="indent" >   For the macro <tt><a 
href="symbols.html#x185-2605107r107">assert</a></tt>, the order of evaluation of the generalized variable
references is not speciﬁed.
</div>
                                                                          

                                                                          
<!--l. 5522--><p class="indent" >   Another reason for building in these functions is that the appropriate
optimizations will diﬀer from implementation to implementation. In some
implementations most of the optimization is performed by the compiler, while in
others a simpler compiler is used and most of the optimization is performed in the
macros. The cost of binding a temporary variable relative to the cost of other Lisp
operations may diﬀer greatly between one implementation and another, and some
implementations may ﬁnd it best never to remove temporary variables except in
the simplest cases.
<!--l. 5532--><p class="indent" >   A good example of the issues involved can be seen in the following
generalized-variable reference: <div class="lisp"><div class="tabbing">
(incf (ldb byte-ﬁeld variable))
   <br>
<!--l. 5536--><p class="noindent" ></div>
<!--l. 5536--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4730007.2" id="x48-4730007.2"></a></span>
<!--l. 5536--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4740007.2" id="x48-4740007.2"></a></span>
</div>
<!--l. 5537--><p class="indent" >   This ought to expand into something like <div class="lisp"><div class="tabbing">
(setq variable
   <br>           (dpb (1+ (ldb byte-ﬁeld variable))<br>                byte-ﬁeld<br>
           variable))<br>
<!--l. 5543--><p class="noindent" ></div>
<!--l. 5543--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4750007.2" id="x48-4750007.2"></a></span>
                                                                          

                                                                          
<!--l. 5543--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4760007.2" id="x48-4760007.2"></a></span>
</div>
<!--l. 5544--><p class="indent" >   In this expansion example we have ignored the further complexity
of returning the correct value, which is the incremented byte, not the
new value of <tt>variable</tt>. Note that the variable <tt>byte-field</tt> is evaluated
twice, and the variable <tt>variable</tt> is referred to three times: once as the
location in which to store a value, and twice during the computation of that
value.
<!--l. 5552--><p class="indent" >   Now consider this expression: <div class="lisp"><div class="tabbing">
(incf (ldb (aref byte-ﬁelds (incf i))
   <br>                                            (aref (determine-words-array) i)))<br>
<!--l. 5556--><p class="noindent" ></div>
<!--l. 5556--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4770007.2" id="x48-4770007.2"></a></span>
<!--l. 5556--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4780007.2" id="x48-4780007.2"></a></span>
</div>
<!--l. 5557--><p class="indent" >   It ought to expand into something like this: <div class="lisp"><div class="tabbing">
(let ((temp1 (aref byte-ﬁelds (incf i)))
   <br>            (temp2 (determine-words-array)))<br>        (setf (aref temp2 i)<br>
        (dpb (1+ (ldb temp1 (aref temp2 i)))<br>                    temp1<br>
             (aref temp2 i))))<br>
<!--l. 5565--><p class="noindent" ></div>
<!--l. 5565--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4790007.2" id="x48-4790007.2"></a></span>
                                                                          

                                                                          
<!--l. 5565--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4800007.2" id="x48-4800007.2"></a></span>
</div>
<!--l. 5566--><p class="indent" >   Again we have ignored the complexity of returning the correct value. What is
important here is that the expressions <tt>(incf i)</tt> and <tt>(determine-words-array)</tt>
must not be duplicated because each may have a side eﬀect or be aﬀected by side
eﬀects.
<div class="newer">
<!--l. 5573--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx48-480001"></a>to specify more precisely the order of evaluation
of subforms when <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> is used with an access function that itself takes a <i>place</i> as
an argument, for example, <tt><a 
href="symbols.html#x185-2605468r468">ldb</a></tt>, <tt><a 
href="symbols.html#x185-2605566r566">mask-field</a></tt>, and <tt><a 
href="symbols.html#x185-2605421r421">getf</a></tt>. (The vote also discussed
the function <tt>char-bit</tt>, but another vote <a 
 id="dx48-480002"></a>removed that function from the
language.) The <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> methods for such accessors produce expansions that
eﬀectively require explicit calls to <tt><a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt>.
<!--l. 5582--><p class="indent" >   The code produced as the macro expansion of a <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> form that itself admits a
generalized variable as an argument must essentially do the following major
steps:
      <ul class="itemize1">
      <li class="itemize">It evaluates the value-producing subforms, in left-to-right order, and
      binds  the  temporary  variables  to  them;  this  is  called  <i>binding  the
      temporaries</i>.
      </li>
      <li class="itemize">It reads the value from the generalized variable, using the supplied
      accessing form, to get the old value; this is called <i>doing the access</i>.
      Note that this is done after all the evaluations of the preceding step,
      including any side eﬀects they may have.
      </li>
      <li class="itemize">It binds the store variable to a new value, and then installs this new
      value into the generalized variable using the supplied storing form; this
      is called <i>doing the store</i>.</li></ul>
<!--l. 5598--><p class="noindent" >Doing the access for a generalized variable reference is not part of the series of
evaluations that must be done in left-to-right order.
<!--l. 5601--><p class="indent" >   The place-speciﬁer forms <tt><a 
href="symbols.html#x185-2605468r468">ldb</a></tt>, <tt><a 
href="symbols.html#x185-2605566r566">mask-field</a></tt>, and <tt><a 
href="symbols.html#x185-2605421r421">getf</a></tt> admit (other) <i>place</i>
speciﬁers as arguments. During the <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> expansion of these forms, it is necessary
to call <tt><a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt> to determine how the inner, nested generalized variable
must be treated.
<!--l. 5606--><p class="indent" >   In a form such as <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(setf (ldb <i>byte-spec</i> <i>place-form</i>) <i>newvalue-form</i>)
   <br>
<!--l. 5609--><p class="noindent" ></div>
<!--l. 5609--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4810007.2" id="x48-4810007.2"></a></span>
<!--l. 5609--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4820007.2" id="x48-4820007.2"></a></span>
</div>
<!--l. 5610--><p class="indent" >   the place referred to by the <i>place-form</i> must always be both accessed and
updated; note that the update is to the generalized variable speciﬁed by
<i>place-form</i>, not to any object of type <tt>integer</tt>.
<!--l. 5614--><p class="indent" >   Thus this call to <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> should generate code to do the following:
      <ul class="itemize1">
      <li class="itemize">Evaluate <i>byte-spec</i> and bind into a temporary
      </li>
      <li class="itemize">Bind the temporaries for <i>place-form</i>
      </li>
      <li class="itemize">Evaluate <i>newvalue-form</i> and bind into the store variable
      </li>
      <li class="itemize">Do the access to <i>place-form</i>
      </li>
      <li class="itemize">Do the store into <i>place-form</i> with the given bit-ﬁeld of the accessed
      integer replaced with the value in the store variable</li></ul>
<!--l. 5623--><p class="noindent" >If the evaluation of <i>newvalue-form</i> alters what is found in the given <i>place</i>—such as
setting a diﬀerent bit-ﬁeld of the integer—then the change of the bit-ﬁeld denoted
by <i>byte-spec</i> will be to that altered integer, because the access step must be
done after the <i>newvalue-form</i> evaluation. Nevertheless, the evaluations
required for binding the temporaries are done before the evaluation of the
<i>newvalue-form</i>, thereby preserving the required left-to-right evaluation
order.
                                                                          

                                                                          
<!--l. 5633--><p class="indent" >   The treatment of <tt><a 
href="symbols.html#x185-2605566r566">mask-field</a></tt> is similar to that of <tt><a 
href="symbols.html#x185-2605468r468">ldb</a></tt>.
<!--l. 5635--><p class="indent" >   In a form such as: <div class="lisp"><div class="tabbing">
(setf (getf <i>place-form</i> <i>ind-form</i>) <i>newvalue-form</i>)
   <br>
<!--l. 5638--><p class="noindent" ></div>
<!--l. 5638--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4830007.2" id="x48-4830007.2"></a></span>
<!--l. 5638--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4840007.2" id="x48-4840007.2"></a></span>
</div>
<!--l. 5639--><p class="indent" >   the place referred to by the <i>place-form</i> must always be both accessed and
updated; note that the update is to the generalized variable speciﬁed by
<i>place-form</i>, not necessarily to the particular list which is the property list in
question.
<!--l. 5644--><p class="indent" >   Thus this call to <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> should generate code to do the following:
      <ul class="itemize1">
      <li class="itemize">Bind the temporaries for <i>place-form</i>
      </li>
      <li class="itemize">Evaluate <i>ind-form</i> and bind into a temporary
      </li>
      <li class="itemize">Evaluate the <i>newvalue-form</i> and bind into the store variable
      </li>
      <li class="itemize">Do the access to <i>place-form</i>
      </li>
      <li class="itemize">Do the store into <i>place-form</i> with a possibly new property list obtained
      by combining the results of the evaluations and the access</li></ul>
<!--l. 5654--><p class="indent" >   If the evaluation of <i>newvalue-form</i> alters what is found in the given
<i>place</i>—such as setting a diﬀerent named property in the list—then the change of
the property denoted by <i>ind-form</i> will be to that altered list, because the access
                                                                          

                                                                          
step is done after the <i>newvalue-form</i> evaluation. Nevertheless, the evaluations
required for binding the temporaries are done before the evaluation of the
<i>newvalue-form</i>, thereby preserving the required left-to-right evaluation
order.
<!--l. 5663--><p class="indent" >   Note that the phrase “possibly new property list” treats the implementation of
property lists as a “black box”; it can mean that the former property list is
somehow destructively re-used, or it can mean partial or full copying of it. A side
eﬀect may or may not occur; therefore <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> must proceed as if the resultant
property list were a diﬀerent copy needing to be stored back into the generalized
variable.
</div>
<!--l. 5672--><p class="indent" >   The Common Lisp facilities provided to deal with these semantic issues
include:
      <ul class="itemize1">
      <li class="itemize">Built-in macros such as <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> and <tt><a 
href="symbols.html#x185-2605705r705">push</a></tt> that follow the semantic rules.
      </li>
      <li class="itemize">The     <tt><a 
href="symbols.html#x185-2605281r281">define-modify-macro</a></tt>   macro,     which     allows     new
      generalized-variable manipulating macros (of a certain restricted kind)
      to be deﬁned easily. It takes care of the semantic rules automatically.
      </li>
      <li class="itemize">The <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> macro, which allows new types of generalized-variable
      references  to  be  deﬁned  easily.  It  takes  care  of  the  semantic  rules
      automatically.
      </li>
      <li class="itemize">The <tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt> macro and the <tt><a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt> function,
      which provide access to the internal mechanisms when it is necessary
      to deﬁne a complicated new type of generalized-variable reference or
      generalized-variable-manipulating macro.</li></ul>
<div class="newer">
<!--l. 5694--><p class="indent" >   Also important are the changes that allow lexical environments to be used in
appropriate ways in <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> methods.
</div>
<div class="defmac">
<div class="defmacheader">
                                                                          

                                                                          
<!--l. 5699--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>deﬁne-modify-macro</b> <a 
 id="dx48-484001"></a><a 
 id="x48-484002r68"></a> name lambda-list function [doc-string]
   <br>
<!--l. 5700--><p class="noindent" ></div>
<!--l. 5700--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4850007.2" id="x48-4850007.2"></a></span>
</div>
<!--l. 5701--><p class="indent" >   This macro deﬁnes a read-modify-write macro named <i>name</i>. An example of such
a macro is <tt><a 
href="symbols.html#x185-2605441r441">incf</a></tt>. The ﬁrst subform of the macro will be a generalized-variable
reference. The <i>function</i> is literally the function to apply to the old contents of the
generalized-variable to get the new contents; it is not evaluated. <i>lambda-list</i>
describes the remaining arguments for the <i>function</i>; these arguments come
from the remaining subforms of the macro after the generalized-variable
reference. <i>lambda-list</i> may contain <tt>&#x0026;optional</tt> and <tt>&#x0026;rest</tt> markers. (The
<tt>&#x0026;key</tt> marker is not permitted here; <tt>&#x0026;rest</tt> suﬃces for the purposes of
<tt><a 
href="symbols.html#x185-2605281r281">define-modify-macro</a></tt>.) <i>doc-string</i> is documentation for the macro <i>name</i> being
deﬁned.
<!--l. 5714--><p class="indent" >   The expansion of a <tt><a 
href="symbols.html#x185-2605281r281">define-modify-macro</a></tt> is equivalent to the following,
except that it generates code that follows the semantic rules outlined above.
<div class="lisp"><div class="tabbing">
(defmacro <i>name</i> (<i>reference</i> . <i>lambda-list</i>)
   <br>                              <i>doc-string</i><br>                            ‘(setf ,<i>reference</i><br>
         (<i>function</i> ,<i>reference</i> ,<i>arg1</i> ,<i>arg2</i> ...)))<br>
<!--l. 5721--><p class="noindent" ></div>
<!--l. 5721--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4860007.2" id="x48-4860007.2"></a></span>
<!--l. 5721--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4870007.2" id="x48-4870007.2"></a></span>
</div>
<!--l. 5722--><p class="indent" >   where <i>arg1</i>, <i>arg2</i>, ..., are the parameters appearing in <i>lambda-list</i>; appropriate
provision is made for a <tt>&#x0026;rest</tt> parameter.
                                                                          

                                                                          
<!--l. 5725--><p class="indent" >   As an example, <tt><a 
href="symbols.html#x185-2605441r441">incf</a></tt> could have been deﬁned by: <div class="lisp"><div class="tabbing">
(deﬁne-modify-macro incf (&#x0026;optional (delta 1)) +)
   <br>
<!--l. 5728--><p class="noindent" ></div>
<!--l. 5728--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4880007.2" id="x48-4880007.2"></a></span>
<!--l. 5728--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4890007.2" id="x48-4890007.2"></a></span>
</div>
<!--l. 5730--><p class="indent" >   An example of a possibly useful macro not predeﬁned in Common Lisp is
<div class="lisp"><div class="tabbing">
(deﬁne-modify-macro unionf (other-set &#x0026;rest keywords) union)
   <br>
<!--l. 5733--><p class="noindent" ></div>
<!--l. 5733--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4900007.2" id="x48-4900007.2"></a></span>
<!--l. 5733--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4910007.2" id="x48-4910007.2"></a></span>
</div>
<div class="newer">
<!--l. 5736--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-491001"></a>to specify that <tt><a 
href="symbols.html#x185-2605281r281">define-modify-macro</a></tt> creates
macros that take <tt>&#x0026;environment</tt> arguments and perform the equivalent of
correctly passing such lexical environments to <tt><a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt> in order to
correctly maintain lexical references.
</div>
</div>
<div class="defmac">
<div class="defmacheader">
                                                                          

                                                                          
<!--l. 5746--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>defsetf</b> <a 
 id="dx48-491002"></a><a 
 id="x48-491003r69"></a> access-fn {update-fn [doc-string] | lambda-list (store-variable) [[{declaration}* | doc-string]] {form}*}
   <br>
<!--l. 5747--><p class="noindent" ></div>
<!--l. 5747--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4920007.2" id="x48-4920007.2"></a></span>
</div>
<!--l. 5748--><p class="indent" >   This deﬁnes how to <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> a generalized-variable reference of the form
<tt>(<i>access-fn</i> ...)</tt>. The value of a generalized-variable reference can always be
obtained simply by evaluating it, so <i>access-fn</i> should be the name of a function or
a macro.
<!--l. 5753--><p class="indent" >   The user of <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> provides a description of how to store into the
generalized-variable reference and return the value that was stored (because <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>
is deﬁned to return this value). The implementation of <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> takes care of
ensuring that subforms of the reference are evaluated exactly once and
in the proper left-to-right order. In order to do this, <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> requires
that <i>access-fn</i> be a function or a macro that evaluates its arguments,
behaving like a function. Furthermore, a <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> of a call on <i>access-fn</i> will also
evaluate all of <i>access-fn</i>&#x2019;s arguments; it cannot treat any of them specially.
This means that <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> cannot be used to describe how to store into a
generalized variable that is a byte, such as <tt>(ldb field reference)</tt>. To
handle situations that do not ﬁt the restrictions imposed by <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt>, use
<tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt>, which gives the user additional control at the cost of
increased complexity.
<!--l. 5769--><p class="indent" >   A <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> declaration may take one of two forms. The simple form is
<div class="lisp"><div class="tabbing">
(defsetf <i>access-fn</i> <i>update-fn</i> [<i><i>doc-string</i></i>] )
   <br>
<!--l. 5773--><p class="noindent" ></div>
<!--l. 5773--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4930007.2" id="x48-4930007.2"></a></span>
                                                                          

                                                                          
<!--l. 5773--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4940007.2" id="x48-4940007.2"></a></span>
</div>
<!--l. 5774--><p class="indent" >   The <i>update-fn</i> must name a function (or macro) that takes one more argument
than <i>access-fn</i> takes. When <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> is given a <i>place</i> that is a call on <i>access-fn</i>, it
expands into a call on <i>update-fn</i> that is given all the arguments to <i>access-fn</i> and
also, as its last argument, the new value (which must be returned by <i>update-fn</i> as
its value). For example, the eﬀect of <div class="lisp"><div class="tabbing">
(defsetf symbol-value set)
   <br>
<!--l. 5783--><p class="noindent" ></div>
<!--l. 5783--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4950007.2" id="x48-4950007.2"></a></span>
<!--l. 5783--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4960007.2" id="x48-4960007.2"></a></span>
</div>
<!--l. 5784--><p class="indent" >   is built into the Common Lisp system. This causes the expansion
<div class="lisp"><div class="tabbing">
(setf (symbol-value foo) fu) <span class="math"> →</span> (set foo fu)
   <br>
<!--l. 5788--><p class="noindent" ></div>
<!--l. 5788--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4970007.2" id="x48-4970007.2"></a></span>
<!--l. 5788--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4980007.2" id="x48-4980007.2"></a></span>
</div>
<!--l. 5789--><p class="indent" >   for example. Note that <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(defsetf car rplaca)
   <br>
<!--l. 5792--><p class="noindent" ></div>
<!--l. 5792--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-4990007.2" id="x48-4990007.2"></a></span>
<!--l. 5792--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5000007.2" id="x48-5000007.2"></a></span>
</div>
<!--l. 5793--><p class="indent" >   would be incorrect because <tt><a 
href="symbols.html#x185-2605759r759">rplaca</a></tt> does not return its last argument.
<!--l. 5795--><p class="indent" >   The complex form of <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> looks like <div class="lisp"><div class="tabbing">
(defsetf <i>access-fn</i> <i>lambda-list</i> (<i>store-variable</i>) . <i>body</i>)
   <br>
<!--l. 5798--><p class="noindent" ></div>
<!--l. 5798--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5010007.2" id="x48-5010007.2"></a></span>
<!--l. 5798--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5020007.2" id="x48-5020007.2"></a></span>
</div>
<!--l. 5799--><p class="indent" >   and resembles <tt><a 
href="symbols.html#x185-2605284r284">defmacro</a></tt>. The <i>body</i> must compute the expansion of a <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> of a
call on <i>access-fn</i>.
<!--l. 5802--><p class="indent" >   The <i>lambda-list</i> describes the arguments of <i>access-fn</i>. <tt>&#x0026;optional</tt>, <tt>&#x0026;rest</tt>, and
<tt>&#x0026;key</tt> markers are permitted in <i>lambda-list</i>. Optional arguments may have defaults
and “supplied-p” ﬂags. The <i>store-variable</i> describes the value to be stored into the
generalized-variable reference._____________________________________________<div class="rationale">
<!--l. 5809--><p class="noindent" ><b>Обоснование:</b> The <i>store-variable</i> is enclosed in parentheses to provide for an extension
to multiple store variables that would receive multiple values from the second subform of
<tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>. The rules given below for coding <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> methods discuss the proper handling of
multiple store variables to allow for the possibility that this extension may be
incorporated into Common Lisp in the future.
                                                                          

                                                                          
</div>
__________________________________________________________________________
<!--l. 5821--><p class="indent" >     The <i>body</i> forms can be written as if the variables in the <i>lambda-list</i> were
bound to subforms of the call on <i>access-fn</i> and the <i>store-variable</i> were bound to
the second subform of <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>. However, this is not actually the case. During the
evaluation of the <i>body</i> forms, these variables are bound to names of temporary
variables, generated as if by <tt><a 
href="symbols.html#x185-2605408r408">gensym</a></tt> or <tt><a 
href="symbols.html#x185-2605409r409">gentemp</a></tt>, that will be bound by the
expansion of <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> to the values of those subforms. This binding permits the
<i>body</i> forms to be written without regard for order-of-evaluation issues.
<tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> arranges for the temporary variables to be optimized out of the
ﬁnal result in cases where that is possible. In other words, an attempt
is made by <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> to generate the best code possible in a particular
implementation.
<!--l. 5836--><p class="indent" >     Note that the code generated by the <i>body</i> forms must include provision for
returning the correct value (the value of <i>store-variable</i>). This is handled by the
<i>body</i> forms rather than by <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> because in many cases this value can be
returned at no extra cost, by calling a function that simultaneously stores into the
generalized variable and returns the correct value.
<!--l. 5843--><p class="indent" >     An example of the use of the complex form of <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt>: <div class="lisp"><div class="tabbing">
(defsetf subseq (sequence start &#x0026;optional end) (new-sequence)
     <br>                                        ‘(progn (replace ,sequence ,new-sequence<br>
                   :start1 ,start :end1 ,end)<br>           ,new-sequence))<br>
<!--l. 5849--><p class="noindent" ></div>
<!--l. 5849--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5030007.2" id="x48-5030007.2"></a></span>
<!--l. 5849--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5040007.2" id="x48-5040007.2"></a></span>
</div>
<div class="newer">
<!--l. 5852--><p class="indent" >     X3J13 voted in March 1988 <a 
 id="dx48-504001"></a>to specify that the body of the expander function
deﬁned by the complex form of <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> is implicitly enclosed in a <tt><a 
href="symbols.html#x185-2605128r128">block</a></tt>
construct whose name is the same as the <i>name</i> of the <i>access-fn</i>. Therefore
<tt><a 
href="symbols.html#x185-2605752r752">return-from</a></tt> may be used to exit from the function.
</div>
                                                                          

                                                                          
<div class="newer">
<!--l. 5860--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-504002"></a>to clarify that, while deﬁning forms normally
appear at top level, it is meaningful to place them in non-top-level contexts; the
complex form of <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> must deﬁne the expander function within the enclosing
lexical environment, not within the global environment.
</div>
</div>
<!--l. 5869--><p class="indent" >   The underlying theory by which <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> and related macros arrange to conform
to the semantic rules given above is that from any generalized-variable reference
one may derive its “<tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method,” which describes how to store into that
reference and which subforms of it are evaluated.
<!--l. 5875--><p class="indent" >   Given knowledge of the subforms of the reference, it is possible to avoid
evaluating them multiple times or in the wrong order. A <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method for a given
access form can be expressed as ﬁve values:
      <ul class="itemize1">
      <li class="itemize">A list of <i>temporary variables</i>
      </li>
      <li class="itemize">A list of <i>value forms</i> (subforms of the given form) to whose values the
      temporary variables are to be bound
      </li>
      <li class="itemize">A second list of temporary variables, called <i>store variables</i>
      </li>
      <li class="itemize">A <i>storing form</i>
      </li>
      <li class="itemize">An <i>accessing form</i></li></ul>
<!--l. 5897--><p class="indent" >   The temporary variables will be bound to the values of the value forms as if by
<tt><a 
href="symbols.html#x185-2605489r489">let*</a></tt>; that is, the value forms will be evaluated in the order given and
may refer to the values of earlier value forms by using the corresponding
variables.
<!--l. 5903--><p class="indent" >   The store variables are to be bound to the values of the <i>newvalue</i> form,
that is, the values to be stored into the generalized variable. In almost
all cases only a single value is to be stored, and there is only one store
variable.
                                                                          

                                                                          
<!--l. 5908--><p class="indent" >   The storing form and the accessing form may contain references to the
temporary variables (and also, in the case of the storing form, to the store
variables). The accessing form returns the value of the generalized variable. The
storing form modiﬁes the value of the generalized variable and guarantees to
return the values of the store variables as its values; these are the correct
values for <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> to return. (Again, in most cases there is a single store
variable and thus a single value to be returned.) The value returned by the
accessing form is, of course, aﬀected by execution of the storing form, but
either of these forms may be evaluated any number of times and therefore
should be free of side eﬀects (other than the storing action of the storing
form).
<!--l. 5922--><p class="indent" >   The temporary variables and the store variables are generated names, as if by
<tt><a 
href="symbols.html#x185-2605408r408">gensym</a></tt> or <tt><a 
href="symbols.html#x185-2605409r409">gentemp</a></tt>, so that there is never any problem of name clashes among
them, or between them and other variables in the program. This is necessary to
make the special operators that do more than one <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> in parallel work properly;
these are <tt><a 
href="symbols.html#x185-2605703r703">psetf</a></tt>, <tt><a 
href="symbols.html#x185-2605784r784">shiftf</a></tt>, and <tt><a 
href="symbols.html#x185-2605756r756">rotatef</a></tt>. Computation of the <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method must
always create new variable names; it may not return the same ones every
time.
<!--l. 5931--><p class="indent" >   Some examples of <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> methods for particular forms:
      <ul class="itemize1">
      <li class="itemize">For a variable <tt>x</tt>: <div class="lisp"><div class="tabbing">
      ()
      <br>                                                                                          ()<br>
           (g0001)<br>                                          (setq x g0001)<br>
           x<br>
      <!--l. 5941--><p class="noindent" ></div>
      <!--l. 5941--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5050007.2" id="x48-5050007.2"></a></span>
                                                                          

                                                                          
      <!--l. 5941--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5060007.2" id="x48-5060007.2"></a></span>
</div>
      </li>
      <li class="itemize">For <tt>(car <i>exp</i>)</tt>: <div class="lisp"><div class="tabbing">
      (g0002)
      <br>                                                                                     (<i>exp</i>)<br>
           (g0003)<br>                     (progn (rplaca g0002 g0003) g0003)<br>
           (car g0002)<br>
      <!--l. 5951--><p class="noindent" ></div>
      <!--l. 5951--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5070007.2" id="x48-5070007.2"></a></span>
      <!--l. 5951--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5080007.2" id="x48-5080007.2"></a></span>
</div>
      </li>
      <li class="itemize">For <tt>(subseq <i>seq</i> <i>s</i> <i>e</i>)</tt>: <div class="lisp"><div class="tabbing">
      (g0004 g0005 g0006)
      <br>                                   (<i>seq</i> <i>s</i> <i>e</i>)<br>                                   (g0007)<br>
           (progn (replace g0004 g0007 :start1 g0005 :end1 g0006)<br>
                  g0007)<br>                     (subseq g0004 g0005 g0006)<br>
      <!--l. 5962--><p class="noindent" ></div>
      <!--l. 5962--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5090007.2" id="x48-5090007.2"></a></span>
                                                                          

                                                                          
      <!--l. 5962--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5100007.2" id="x48-5100007.2"></a></span>
</div>
      </li></ul>
<div class="defmac">
<div class="defmacheader">
<!--l. 5966--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i> <b>deﬁne-setf-method</b> <a 
 id="dx48-510001"></a><a 
 id="x48-510002r70"></a> access-fn lambda-list [[{declaration}* | doc-string]] {form}*
   <br>
<!--l. 5967--><p class="noindent" ></div>
<!--l. 5967--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5110007.2" id="x48-5110007.2"></a></span>
</div>
<!--l. 5968--><p class="indent" >   This deﬁnes how to <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> a generalized-variable reference that is of the form
<tt>(<i>access-fn</i>...)</tt>. The value of a generalized-variable reference can always be
obtained simply by evaluating it, so <i>access-fn</i> should be the name of a function or
a macro.
<!--l. 5974--><p class="indent" >   The <i>lambda-list</i> describes the subforms of the generalized-variable reference, as
with <tt><a 
href="symbols.html#x185-2605284r284">defmacro</a></tt>. The result of evaluating the <i>forms</i> in the body must be
ﬁve values representing the <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method, as described above. Note that
<tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt> diﬀers from the complex form of <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt> in that while the
body is being executed the variables in <i>lambda-list</i> are bound to parts of the
generalized-variable reference, not to temporary variables that will be
bound to the values of such parts. In addition, <tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt> does
not have <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt>&#x2019;s restriction that <i>access-fn</i> must be a function or a
function-like macro; an arbitrary <tt><a 
href="symbols.html#x185-2605284r284">defmacro</a></tt> destructuring pattern is permitted in
<i>lambda-list</i>.
<!--l. 5987--><p class="indent" >   By deﬁnition there are no good small examples of <tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt>
because the easy cases can all be handled by <tt><a 
href="symbols.html#x185-2605288r288">defsetf</a></tt>. A typical use is to deﬁne
the <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method for <tt><a 
href="symbols.html#x185-2605468r468">ldb</a></tt>: <div class="obsolete"> <div class="lisp"><div class="tabbing">
;;; SETF method for the form (LDB bytespec int).
   <br>                ;;; Recall that the int form must itself be suitable for SETF.<br>
(deﬁne-setf-method ldb (bytespec int)<br>  (multiple-value-bind (temps vals stores<br>
                                                                          

                                                                          
                        store-form access-form)<br>
      (get-setf-method int)         ;Get SETF method for int<br>
    (let ((btemp (gensym))          ;Temp var for byte speciﬁer<br>
          (store (gensym))          ;Temp var for byte to store<br>
          (stemp (ﬁrst stores)))   ;Temp var for int to store<br>
      ;; Return the SETF method for LDB as ﬁve values.<br>
      (values (cons btemp temps)    ;Temporary variables<br>
              (cons bytespec vals)  ;Value forms<br>
              (list store)          ;Store variables<br>
              ‘(let ((,stemp (dpb ,store ,btemp ,access-form)))<br>
                 ,store-form<br>                 ,store)                     ;Storing form<br>
              ‘(ldb ,btemp ,access-form)     ;Accessing form<br>
              ))))<br>
<!--l. 6010--><p class="noindent" ></div>
<!--l. 6010--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5120007.2" id="x48-5120007.2"></a></span>
<!--l. 6010--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5130007.2" id="x48-5130007.2"></a></span>
</div>
</div>
<div class="newer">
<!--l. 6014--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-513001"></a>to specify that the <tt>&#x0026;environment</tt> lambda-list
keyword may appear in the <i>lambda-list</i> in the same manner as for <tt><a 
href="symbols.html#x185-2605284r284">defmacro</a></tt> in
order to obtain the lexical environment of the call to the <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> macro. The
preceding example should be modiﬁed to take advantage of this new feature. The
<tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method must accept an <tt>&#x0026;environment</tt> parameter, which will receive the
lexical environment of the call to <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>; this environment must then be given to
<tt><a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt> in order that it may correctly use any locally bound <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>
method that might be applicable to the <i>place</i> form that appears as the second
argument to <tt><a 
href="symbols.html#x185-2605468r468">ldb</a></tt> in the call to <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>.
<div class="lisp">
<!--l. 6026--><p class="indent" >   <div class="tabbing">
;;; SETF method for the form (LDB bytespec int).
                                                                          

                                                                          
   <br>                ;;; Recall that the int form must itself be suitable for SETF.<br>
;;; Note the use of an &#x0026;environment parameter to receive the<br>
;;; lexical environment of the call for use with GET-SETF-METHOD.<br>
(deﬁne-setf-method ldb (bytespec int &#x0026;environment env)<br>
  (multiple-value-bind (temps vals stores<br>                        store-form access-form)<br>
      (get-setf-method int env)     ;Get SETF method for int<br>
    (let ((btemp (gensym))          ;Temp var for byte speciﬁer<br>
          (store (gensym))          ;Temp var for byte to store<br>
          (stemp (ﬁrst stores)))   ;Temp var for int to store<br>
      ;; Return the SETF method for LDB as ﬁve values.<br>
      (values (cons btemp temps)    ;Temporary variables<br>
              (cons bytespec vals)  ;Value forms<br>
              (list store)          ;Store variables<br>
              ‘(let ((,stemp (dpb ,store ,btemp ,access-form)))<br>
                 ,store-form<br>                 ,store)                     ;Storing form<br>
              ‘(ldb ,btemp ,access-form)     ;Accessing form<br>
              ))))<br>
<!--l. 6047--><p class="noindent" ></div>
<!--l. 6047--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5140007.2" id="x48-5140007.2"></a></span>
<!--l. 6047--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5150007.2" id="x48-5150007.2"></a></span>
</div>
</div>
<div class="newer">
<!--l. 6051--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-515001"></a>to specify that the body of the expander function
deﬁned by <tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt> is implicitly enclosed in a <tt><a 
href="symbols.html#x185-2605128r128">block</a></tt> construct whose
name is the same as the <i>name</i> of the <i>access-fn</i>. Therefore <tt><a 
href="symbols.html#x185-2605752r752">return-from</a></tt> may be
used to exit from the function.
</div>
<div class="newer">
<!--l. 6059--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-515002"></a>to clarify that, while deﬁning forms normally
appear at top level, it is meaningful to place them in non-top-level contexts;
<tt><a 
href="symbols.html#x185-2605282r282">define-setf-method</a></tt> must deﬁne the expander function within the enclosing
lexical environment, not within the global environment.
</div>
                                                                          

                                                                          
</div>
<div class="newer">
<!--l. 6069--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-515003"></a>to add an optional environment argument to
<tt><a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt>. The revised deﬁnition and example are as follows.
<div class="defun">
<!--l. 6073--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx48-515004"></a><a 
 id="x48-515005r71"></a> <b>get-setf-method</b>  <i>form</i> <b>&#x0026;optional</b>  <i>env</i>
</div>
<tt>
<!--l. 6076--><p class="indent" >   <a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt> returns ﬁve values constituting the <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method for <i>form</i>.
The <i>form</i> must be a generalized-variable reference. The <i>env</i> must be an
environment of the sort obtained through the <tt>&#x0026;environment</tt> lambda-list
keyword; if <i>env</i> is <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> or omitted, the null lexical environment is assumed.
<tt><a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt> takes care of error checking and macro expansion and
guarantees to return exactly one store variable.
<!--l. 6087--><p class="indent" >   As an example, an extremely simpliﬁed version of <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>, allowing no more and
no fewer than two subforms, containing no optimization to remove unnecessary
variables, and not allowing storing of multiple values, could be deﬁned by:
<div class="lisp"><div class="tabbing">
(defmacro setf (reference value &#x0026;environment env)
   <br>              (multiple-value-bind (vars vals stores store-form access-form)<br>
      (get-setf-method reference env)     ;Note use of environment<br>
    (declare (ignore access-form))<br>
    ‘(let* ,(mapcar #&#x2019;list<br>                         (append vars stores)<br>
                    (append vals (list value)))<br>           ,store-form)))<br>
<!--l. 6100--><p class="noindent" ></div>
<!--l. 6100--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5160007.2" id="x48-5160007.2"></a></span>
<!--l. 6100--><p class="noindent" ><span class="paragraphHead"><a 
href="#x48-5170007.2" id="x48-5170007.2"></a></span>
</div>
</div>
                                                                          

                                                                          
</div>
<div class="newer">
<!--l. 6105--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-517001"></a>to add an optional environment argument to
<tt><a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt>. The revised deﬁnition is as follows.
<div class="defun">
<!--l. 6109--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx48-517002"></a><a 
 id="x48-517003r72"></a> <b>get-setf-method-multiple-value</b>  <i>form</i> <b>&#x0026;optional</b>  <i>env</i>
</div>
<tt>
<!--l. 6112--><p class="indent" >   <a 
href="symbols.html#x185-2605419r419">get-setf-method-multiple-value</a></tt> returns ﬁve values constituting the <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt>
method for <i>form</i>. The <i>form</i> must be a generalized-variable reference. The <i>env</i>
must be an environment of the sort obtained through the <tt>&#x0026;environment</tt>
lambda-list keyword; if <i>env</i> is <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> or omitted, the null lexical environment is
assumed.
<!--l. 6120--><p class="indent" >   This is the same as <tt><a 
href="symbols.html#x185-2605418r418">get-setf-method</a></tt> except that it does not check the
number of store variables; use this in cases that allow storing multiple values into
a generalized variable. There are no such cases in standard Common Lisp, but this
function is provided to allow for possible extensions.
</div>
</div>
<div class="newer">
<!--l. 6130--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-517004"></a>to clarify that a <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> method for a functional
name is applicable only when the global binding of that name is lexically
visible. If such a name has a local binding introduced by <tt><a 
href="symbols.html#x185-2605379r379">flet</a></tt>, <tt><a 
href="symbols.html#x185-2605461r461">labels</a></tt>, or
<tt><a 
href="symbols.html#x185-2605532r532">macrolet</a></tt>, then global deﬁnitions of <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> methods for that name do not
apply and are not visible. All of the standard Common Lisp macros that
modify a <tt><a 
href="symbols.html#x185-2605778r778">setf</a></tt> <i>place</i> (for example, <tt><a 
href="symbols.html#x185-2605441r441">incf</a></tt>, <tt><a 
href="symbols.html#x185-2605268r268">decf</a></tt>, <tt><a 
href="symbols.html#x185-2605670r670">pop</a></tt>, and <tt><a 
href="symbols.html#x185-2605756r756">rotatef</a></tt>) obey this
convention.
</div>
                                                                          

                                                                          
<!--l. 6140--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse37.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html#tailclmse35.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse36.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html#clmse36.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse36.html"></a>   </div> </div> 
</body></html> 
