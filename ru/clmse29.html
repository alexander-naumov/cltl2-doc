<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Функции</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 1586--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse30.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html#tailclmse28.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse29.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html#clmse29.html" >Наверх</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">5.2   </span> <a 
href="clm.html#QQ2-39-230" id="x39-2220005.2">Функции</a></h3>
<!--l. 1588--><p class="noindent" >Существуют два метода указать функцию для использования в форме
вызова функции. Один из них заключается в указании символа имени
функции. Это использование символов для обозначения функций
полностью независимо от их использования для обозначения специальных и
лексических переменных. Другой путь заключается в использовании
<i>лямбда-выражения</i>, которое является списком с первым элементом равным
<tt><a 
href="symbols.html#x185-2605462r462">lambda</a></tt>. Лямбда-выражение <i>не</i> является формой, оно не может быть
полноценно вычислено. Лямбда выражения и символы, когда они
используются в программах для обозначения функций, могут быть указаны в
качестве первого элемента формы вызова функции, или только в качестве
второго параметры в специальной форме <tt><a 
href="symbols.html#x185-2605399r399">function</a></tt>. Следует отметить, что в
этих двух контекстах символы и лямбда-выражения обрабатываются, как
<i>имена</i> функций. Необходимо отличать это от обработки символов и
лямбда выражений, как <i>функциональных объектов, или объектов
функций (function objects)</i>, которые удовлетворяют предикату <tt><a 
href="symbols.html#x185-2605403r403">functionp</a></tt>,
как при представлении таких объектов в вызовы функций <tt><a 
href="symbols.html#x185-2605081r81">apply</a></tt> или
<tt><a 
href="symbols.html#x185-2605398r398">funcall</a></tt>.
<!--l. 1604--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.1   </span> <a 
href="frontmatter.html#QQ2-39-231" id="x39-2230005.2.1">Именованные функции</a></h4>
<!--l. 1606--><p class="noindent" >Функция может иметь два типа имена. <i>Глобальное имя</i> может быть дано
функции с помощью конструкции <i>defun</i>. <i>Локальное имя</i> может быть дано
функции с помощью специальных форм <tt><a 
href="symbols.html#x185-2605379r379">flet</a></tt> или <tt><a 
href="symbols.html#x185-2605461r461">labels</a></tt>. Когда для
функции задаётся имя, то с этим именем связывается лямбда-выражение с
информацией о сущностях, которые были лексически доступны на момент
связи. Если в качестве первого элементы формы вызова функции
используется символ, тогда он ссылается на определение функции из
наиболее ближней формы <tt><a 
href="symbols.html#x185-2605379r379">flet</a></tt> или <tt><a 
href="symbols.html#x185-2605461r461">labels</a></tt>, которые в своем тексте содержат
эту форму, иначе символ ссылается на глобальное определение функции, при
отсутствии вышеназванных форм.
                                                                          

                                                                          
<!--l. 1618--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.2   </span> <a 
href="frontmatter.html#QQ2-39-232" id="x39-2240005.2.2">Лямбда-выражения</a></h4>
<i>
<!--l. 1627--><p class="noindent" >Лямбда-выражение</i> является списком со следующим синтаксисом:
<div class="lisp"><div class="tabbing">
(lambda <i>lambda-list</i> . <i>body</i>)
   <br>
<!--l. 1630--><p class="noindent" ></div>
<!--l. 1630--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2250005.2.2" id="x39-2250005.2.2"></a></span>
<!--l. 1630--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2260005.2.2" id="x39-2260005.2.2"></a></span>
</div>
<!--l. 1631--><p class="indent" >   Первый элемент должен быть символом <tt><a 
href="symbols.html#x185-2605462r462">lambda</a></tt>. Второй элемент должен
быть списком. Он называется <i>лямбда-списком</i>, и задаёт имена для
<i>параметров</i> функции. Когда функция, обозначенная лямбда-выражением,
применяется к аргументам, аргументы подставляются в соответствии с
лямбда-списком. <i>body</i> может впоследствии ссылаться на аргументы
используя имена параметров. <i>body</i> состоит из любого количества форм
(возможно нулевого количества). Эти формы выполняются последовательно,
и в качестве значения возвращается результат только <i>последней</i> формы
(в случае отсутствия форм, возвращается <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>). Полный синтаксис
лямбда-выражения:
<div class="lisp">
<!--l. 1646--><p class="indent" >   <div class="tabbing">
(lambda ( {<i><i>var</i></i>}*
                                                                          

                                                                          
   <br>                             [<i><tt>&optional</tt> {<i><i>var</i> | <tt>(</tt><i>var</i>  [<i><i>initform</i>  [<i><i>svar</i></i>]</i>]<tt>)</tt></i>}*</i>] <br>
          [<i><tt>&rest</tt> <i>var</i></i>] <br>          [<i><tt>&key</tt> {<i><i>var</i> | <tt>(</tt>{<i><i>var</i> | <tt>(</tt><i>keyword</i> <i>var</i><tt>)</tt></i>}  [<i><i>initform</i>  [<i><i>svar</i></i>]</i>]<tt>)</tt></i>}*              [<i><tt>&allow-other-keys</tt></i>]</i>] <br>
          [<i><tt>&aux</tt> {<i><i>var</i> | <tt>(</tt><i>var</i>  [<i><i>initform</i></i>]<tt>)</tt></i>}*</i>] )<br>    [[<i> {<i><i></i></i>}*declaration | <i>documentation-string</i></i>]] <br>
    {<i><i>form</i></i>}* )<br>
<!--l. 1655--><p class="noindent" ></div>
<!--l. 1655--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2270005.2.2" id="x39-2270005.2.2"></a></span>
<!--l. 1655--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2280005.2.2" id="x39-2280005.2.2"></a></span>
</div>
<!--l. 1658--><p class="indent" >   Каждый элемент лямбда-списка является или спецификатором параметра
или <i>ключевым символом лямбда-списка</i>. Ключевые символы лямбда-списка
начинаются с символа <tt>&#x0026;</tt>. Следует отметить, что ключевые символы
лямбда-списка не является ключевыми символами в обычном понимании.
Они не принадлежат пакету <tt>keyword</tt>. Они являются обычными символами,
имена которых начинаются амперсандом. Такая терминология запутывает,
но так сложилась история.
<i>
<!--l. 1666--><p class="indent" >   Keyword</i> in the preceding speciﬁcation of a lambda-list may be any
symbol whatsoever, not just a keyword symbol in the <tt>keyword</tt> package. See
below.
<i>
<!--l. 1670--><p class="indent" >   Keyword</i> в предыдущем определении лябмда-списка может быть
любым, а не только ключевым из пакета <tt>keyword</tt>, символом. Смотрите
ниже.
<!--l. 1673--><p class="indent" >   Лямбда-список имеет пять частей, любая или все могут быть пустыми:
      <ul class="itemize1">
      <li class="itemize">Спецификаторы для <i>обязательных параметров</i>. К ним относятся
      все  спецификаторы  параметров  до  первого  ключевого  символа
      лямбда-списка.  Если  такой  ключевой  символ  отсутствует,  все
      спецификаторы считаются обязательными.
      </li>
      <li class="itemize">Спецификаторы  для  <i>необязательных</i>  параметров.  Если  указан
                                                                          

                                                                          
      ключевой       символ       <tt>&#x0026;optional</tt>,       после       него       будут
      следовать спецификаторы <i>необязательных</i> параметров вплоть до
      следующего ключевого слова, или до конца списка.
      </li>
      <li class="itemize">Спецификатор для <i>неопределённого количества или оставшегося
      (rest)</i>  параметра.  Если  указан  ключевой  символ  <tt>&#x0026;rest</tt>,  за  ним
      должен следовать только один спецификатор <i>оставшегося (rest)</i>
      параметра, за которым может следовать другой ключевой символ
      или лямбда-список может заканчиваться.
      </li>
      <li class="itemize">Спецификатор     для     <i>именованных    (keyword)</i>    параметров.
      Если  указан  ключевой  символ  <tt>&#x0026;key</tt>,  все  спецификаторы  после
      данного  символа  до  следующего  ключевого  символа  или  конца
      списка являются спецификаторами <i>именованных</i> параметров. За
      спецификаторами  именованных  параметров  опционально  может
      использовать ключевой символ <tt>&#x0026;allow-others-keys</tt>.
      </li>
      <li class="itemize">Спецификатор  для  <i>вспомогательных (aux)</i> переменных.  Они  не
      являются  параметрами.  Если  указан  ключевой  символ  <tt>&#x0026;aux</tt>,
      все   спецификаторы   после   него   являются   спецификаторами
      вспомогательных переменных.</li></ul>
<!--l. 1707--><p class="indent" >   Когда функция, заданная лямбда-выражением, применяется к
аргументам, то эти аргументы и параметры вычисляются слева направо. В
простейшем случае, в лямбда-списке присутствуют только обязательные
параметры. Каждый из них задаётся просто именем переменной <i>var</i>
параметра. Когда функция применяется, аргументов должно быть столько
же, сколько и параметров, и каждый параметр связывается с одним
аргументом. В общем случае, каждый параметр связывается как лексическая
переменная, если только с помощью декларации не указано, что связь
должна осуществляться, как для специальной переменной. Смотрите <tt><a 
href="symbols.html#x185-2605292r292">defvar</a></tt>,
<tt><a 
href="symbols.html#x185-2605695r695">proclaim</a></tt>, <tt><a 
href="symbols.html#x185-2605271r271">declare</a></tt>.
<!--l. 1718--><p class="indent" >   В более общем случае, если указано <i>n</i> обязательных параметров (<i>n</i> может
равняться нулю), тогда должно быть как минимум <i>n</i> аргументов, и
обязательные параметры будут связаны с <i>n</i> первыми аргументами.
<!--l. 1723--><p class="indent" >   Если указаны необязательные параметры, тогда каждый из них будет
                                                                          

                                                                          
обработан так, как описано ниже. Если осталось некоторое количество
аргументов, тогда переменная параметра <tt>var</tt> будет связана с оставшимся
аргументом. Принцип такой же, как и для обязательных параметров. Если не
осталось аргументов, тогда выполняется часть <i>initform</i>, и переменная
параметра связывается с её результатом (или с <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>, если форма <i>initform</i> не
была задана). Если в спецификаторе указано имя ещё одной переменной <i>svar</i>,
то она связывается с <i>true</i>, если аргумент был задан, и с <i>false</i> аргумент не был
задан (и в таком случае выполнилась <i>initform</i>). Переменная <i>svar</i> называется
<i>supplied-p</i> параметр. Она связывается не с аргументом, а со значением,
которое показывает был ли задан аргумент для данного параметра или
нет.
<!--l. 1737--><p class="indent" >   После того, как все <i>необязательные</i> параметры были обработаны, может
быть указан <i>оставшийся (rest)</i> параметр. Если <i>оставшийся (rest)</i> параметр
указан, он будет связан со списком все оставшихся необработанных
аргументов. Если таких аргументов не осталось, <i>оставшийся (rest)</i> параметр
будет связан с пустым списком. Если в лямбда списке отсутствуют
<i>оставшийся (rest)</i> параметр и <i>именованные (keyword)</i> параметры,
то необработанных аргументов оставаться не должно (иначе будет
ошибка).
<div class="new">
<!--l. 1747--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx39-228001"></a>to clarify that if a function has a <i>rest</i> parameter
and is called using <tt><a 
href="symbols.html#x185-2605081r81">apply</a></tt>, then the list to which the <i>rest</i> parameter is
bound is permitted, but not required, to share top-level list structure with
the list that was the last argument to <tt><a 
href="symbols.html#x185-2605081r81">apply</a></tt>. Programmers should be
careful about performing side eﬀects on the top-level list structure of a <i>rest</i>
parameter.
<!--l. 1756--><p class="indent" >   This was the result of a rather long discussion within X3J13 and the wider
Lisp community. To set it in its historical context, I must remark that in Lisp
Machine Lisp the list to which a <i>rest</i> parameter was bound had only dynamic
extent; this in conjunction with the technique of “cdr-coding” permitted a clever
stack-allocation technique with very low overhead. However, the early designers of
Common Lisp, after a great deal of debate, concluded that it was dangerous for
cons cells to have dynamic extent; as an example, the “obvious” deﬁnition of the
function <tt><a 
href="symbols.html#x185-2605492r492">list</a></tt> <div class="lisp"><div class="tabbing">
(defun list (&#x0026;rest x) x)
                                                                          

                                                                          
   <br>
<!--l. 1767--><p class="noindent" ></div>
<!--l. 1767--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2290005.2.2" id="x39-2290005.2.2"></a></span>
<!--l. 1767--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2300005.2.2" id="x39-2300005.2.2"></a></span>
</div>
<!--l. 1768--><p class="indent" >   could fail catastrophically. Therefore the ﬁrst edition simply implied that the
list for a <i>rest</i> parameter, like all other lists, would have indeﬁnite extent. This still
left open the ﬂip side of the question, namely, Is the list for a <i>rest</i> parameter
guaranteed fresh? This is the question addressed by the X3J13 vote. If it is always
freshly consed, then it is permissible to destroy it, for example by giving it to
<tt><a 
href="symbols.html#x185-2605605r605">nconc</a></tt>. However, the requirement always to cons fresh lists could impose an
unacceptable overhead in many implementations. The clariﬁcation approved by
X3J13 speciﬁes that the programmer may not rely on the list being fresh; if the
function was called using <tt><a 
href="symbols.html#x185-2605081r81">apply</a></tt>, there is no way to know where the list came
from.
</div>
<!--l. 1781--><p class="indent" >   Далее обрабатываются все <i>именованные (keyword)</i> параметры. Для этих
параметров обрабатываются те же аргументы, что и для <i>оставшегося (rest)</i>
параметра. Безусловно, возможно указывать и <tt>&#x0026;rest</tt> и <tt>&#x0026;key</tt>. В таком случае
оставшиеся аргументы используются для обеих целей: все оставшиеся
аргументы составляются в список для <tt>&#x0026;rest</tt> параметра и они также
обрабатываются, как <tt>&#x0026;key</tt> параметры. Только в этой ситуации один аргумент
может обрабатываться более чем для одного параметра. Если указан
<tt>&#x0026;key</tt>, должно остаться чётное количество аргументов. Они будут
обработаны попарно. Первый аргумент в паре должен быть ключевым
символом, который задаёт имя параметра, второй аргумент должен быть
соответствующим значением.
<div class="newer">
<!--l. 1795--><p class="indent" >   А <i>keyword</i> in a lambda-list to be any symbol whatsoever, not just a keyword
symbol in the <tt>keyword</tt> package. If, after <tt>&#x0026;key</tt>, a variable appears alone or
within only one set of parentheses (possibly with an <i>initform</i> and a <i>svar</i>),
then the behavior is as before: a keyword symbol with the same name as
the variable is used as the keyword-name when matching arguments to
parameter speciﬁers. Only a parameter speciﬁer of the form <tt>((<i>keyword</i>
                                                                          

                                                                          
<i>var</i>) ...)</tt> can cause the keyword-name not to be a keyword symbol, by
specifying a symbol not in the <tt>keyword</tt> package as the <i>keyword</i>. For example:
<div class="lisp"><div class="tabbing">
(defun wager (&#x0026;key ((secret password) nil) amount)
   <br>                                                           (format nil &#x0022;You ~A $~D&#x0022;<br>
          (if (eq password &#x2019;joe-sent-me) &#x0022;win&#x0022; &#x0022;lose&#x0022;)<br>
          amount))<br>      <br>        (wager :amount 100) <span class="math"> ⇒</span> &#x0022;You lose $100&#x0022;<br>
(wager :amount 100 &#x2019;secret &#x2019;joe-sent-me) <span class="math"> ⇒</span> &#x0022;You win $100&#x0022;<br>
<!--l. 1815--><p class="noindent" ></div>
<!--l. 1815--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2310005.2.2" id="x39-2310005.2.2"></a></span>
<!--l. 1815--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2320005.2.2" id="x39-2320005.2.2"></a></span>
</div>
<!--l. 1816--><p class="indent" >   The <tt>secret</tt> word could be made even more secret in this example by
placing it in some other <tt>obscure</tt> package, so that one would have to write
<div class="lisp"><div class="tabbing">
(wager :amount 100 &#x2019;obscure:secret &#x2019;joe-sent-me) <span class="math"> ⇒</span> &#x0022;You win $100&#x0022;
   <br>
<!--l. 1821--><p class="noindent" ></div>
<!--l. 1821--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2330005.2.2" id="x39-2330005.2.2"></a></span>
<!--l. 1821--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2340005.2.2" id="x39-2340005.2.2"></a></span>
</div>
<!--l. 1822--><p class="indent" >   to win anything.
</div>
                                                                          

                                                                          
<!--l. 1825--><p class="indent" >   В каждом именованном параметре спецификатор должен быть назван <i>var</i>
для переменной параметра. FIXME Если явно указан ключевой символ, тогда
он будет использоваться для имени параметра. В противном случае
используется имя переменной <tt>var</tt> для поиска ключевого символа в
аргументах. Таким образом: <div class="lisp"><div class="tabbing">
(defun foo (<tt>&#x0026;key</tt> radix (type &#x2019;integer)) ...)
   <br>
<!--l. 1832--><p class="noindent" ></div>
<!--l. 1832--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2350005.2.2" id="x39-2350005.2.2"></a></span>
<!--l. 1832--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2360005.2.2" id="x39-2360005.2.2"></a></span>
</div>
<!--l. 1833--><p class="indent" >   означает то же, что и <div class="lisp"><div class="tabbing">
(defun foo (<tt>&#x0026;key</tt> ((:radix radix)) ((:type type) &#x2019;integer)) ...)
   <br>
<!--l. 1836--><p class="noindent" ></div>
<!--l. 1836--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2370005.2.2" id="x39-2370005.2.2"></a></span>
<!--l. 1836--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2380005.2.2" id="x39-2380005.2.2"></a></span>
</div>
<!--l. 1838--><p class="indent" >   Спецификатор именованного (keyword) параметра, как и все спецификаторы
параметров, обрабатывается слева направо. Для каждого спецификатора
именованного параметра, если в паре аргумента, в которой ключевой
символ совпадает с именем параметра (сравнение производится с
помощью <tt><a 
href="symbols.html#x185-2605337r337">eq</a></tt>), тогда переменная параметра связывается значением из
этой пары. Если имеется более одной пар аргументов с одинаковым
                                                                          

                                                                          
именем, то это не ошибка. В таком случае используется наиболее
левая пара. Если пары аргументов не нашлось, тогда выполняется
<i>initform</i> и переменная параметра связывается с этим значением (или с
<tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>, если <i>initform</i> не задана). Переменная <i>svar</i> используется в тех же
целях, что и для <i>необязательных</i> параметров. Она будет связана
с <i>истиной</i>, если была необходимая пара аргументов, и иначе — с
<i>ложью</i>.
<!--l. 1852--><p class="indent" >   Если пара аргументов содержит ключевой символ, который не
присутствует в спецификаторах параметров в лямбда списке, то или
возникнет ошибка или возможны следующие условия:
      <ul class="itemize1">
      <li class="itemize">В лямбда-списке был указан <tt>&#x0026;allow-other-keys</tt>.
      </li>
      <li class="itemize">Где-то среди именованных аргументов есть пара, в которой есть
      ключевой символ <tt>:allow-other-keys</tt> и значение не равно <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>.</li></ul>
<!--l. 1864--><p class="indent" >   В случае возникновения одного из этих условий, можно использовать
именованные аргументы, которые не имеют соответствующих параметров
(эти аргументы будут доступны, как оставшийся <tt>&#x0026;rest</tt> параметр). Целью
этого механизма является возможность объединять лямбда-списки разных
функции без необходимости копировать все спецификаторы именованных
(keyword) параметров. Например функция обёртка может передать часть
именованных аргументов в обернутую функцию без необходимости явного
ручного указания их всех.
<!--l. 1872--><p class="indent" >   После того как все спецификаторы были обработаны, слева направо
обрабатываются спецификаторы вспомогательных параметров. Для
каждого из них выполняется <i>initform</i> и переменная <i>var</i> связывается с
этим результатом (или с <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>, если <i>initform</i> не определена). С <tt>&#x0026;aux</tt>
переменными можно делать то же, что и со специальной формой <tt><a 
href="symbols.html#x185-2605489r489">let*</a></tt>:
<div class="lisp"><div class="tabbing">
(lambda (x y &#x0026;aux (a (car x)) (b 2) c) ...)
   <br>                              <span class="math"> ≡</span> (lambda (x y) (let* ((a (car x)) (b 2) c) ...))<br>
<!--l. 1880--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1880--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2390005.2.2" id="x39-2390005.2.2"></a></span>
<!--l. 1880--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2400005.2.2" id="x39-2400005.2.2"></a></span>
</div>
<!--l. 1882--><p class="indent" >   Что использовать зависит только от стиля.
<!--l. 1884--><p class="indent" >   Когда какая-либо форма <i>initform</i> выполняется в каком-либо спецификаторе
параметра, данная форма может ссылаться на любую переменную
параметра, стоящую слева от данной формы, включая supplied-p переменные,
и может рассчитывать на то, что другие переменные параметров ещё не
связаны (включая переменную данного параметра).
<!--l. 1890--><p class="indent" >   После того как был обработан лямбда-список, выполняются формы из
тела лямбда-выражения. Эти формы могут ссылаться на аргументы
функции, используя имена параметров. При выходе из функции, как с
помощью нормального возврата, так и с помощью нелокального выхода,
связывания параметров, и лексические, и специальные, упраздняются. В
случае создания «замыкания» над данными связываниями, связи
упраздняются не сразу, а сначала сохраняются, чтобы потом быть вновь
восстановленными.
<!--l. 1898--><p class="noindent" >Примеры использования <tt>&#x0026;optional</tt> и <tt>&#x0026;rest</tt> параметров: <div class="lisp"><div class="tabbing">
((lambda (a b) (+ a (* b 3))) 4 5) <span class="math"> ⇒</span> 19
   <br>                     ((lambda (a <tt>&#x0026;optional</tt> (b 2)) (+ a (* b 3))) 4 5) <span class="math"> ⇒</span> 19<br>
((lambda (a <tt>&#x0026;optional</tt> (b 2)) (+ a (* b 3))) 4) <span class="math"> ⇒</span> 10<br>
((lambda (<tt>&#x0026;optional</tt> (a 2 b) (c 3 d) <tt>&#x0026;rest</tt> x) (list a b c d x)))<br>
   <span class="math"> ⇒</span> (2 <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> 3 <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>)<br>
((lambda (<tt>&#x0026;optional</tt> (a 2 b) (c 3 d) <tt>&#x0026;rest</tt> x) (list a b c d x))<br>
 6)<br>                                                    <span class="math"> ⇒</span> (6 t 3 <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>)<br>
((lambda (<tt>&#x0026;optional</tt> (a 2 b) (c 3 d) <tt>&#x0026;rest</tt> x) (list a b c d x))<br>
 6 3)<br>                                                    <span class="math"> ⇒</span> (6 t 3 t <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>)<br>
((lambda (<tt>&#x0026;optional</tt> (a 2 b) (c 3 d) <tt>&#x0026;rest</tt> x) (list a b c d x))<br>
 6 3 8)<br>                                                   <span class="math"> ⇒</span> (6 t 3 t (8))<br>
((lambda (<tt>&#x0026;optional</tt> (a 2 b) (c 3 d) <tt>&#x0026;rest</tt> x) (list a b c d x))<br>
 6 3 8 9 10 11)<br>                                    <span class="math"> ⇒</span> (6 t 3 t (8 9 10 11))<br>
<!--l. 1918--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1918--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2410005.2.2" id="x39-2410005.2.2"></a></span>
<!--l. 1918--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2420005.2.2" id="x39-2420005.2.2"></a></span>
</div>
<!--l. 1919--><p class="indent" >   Примеры <tt>&#x0026;key</tt> параметров: <div class="lisp"><div class="tabbing">
((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) 1 2)
   <br>     <span class="math"> ⇒</span> (1 2 <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>)<br>  ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) 1 2 :c 6)<br>
   <span class="math"> ⇒</span> (1 2 6 <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>)<br>         ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) 1 2 :d 8)<br>
   <span class="math"> ⇒</span> (1 2 <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> 8)<br>     ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) 1 2 :c 6 :d 8)<br>
   <span class="math"> ⇒</span> (1 2 6 8)<br>       ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) 1 2 :d 8 :c 6)<br>
   <span class="math"> ⇒</span> (1 2 6 8)<br>       ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) :a 1 :d 8 :c 6)<br>
   <span class="math"> ⇒</span> (:a 1 6 8)<br>         ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) :a :b :c :d)<br>
   <span class="math"> ⇒</span> (:a :b :d <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt>)<br>
<!--l. 1935--><p class="noindent" ></div>
<!--l. 1935--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2430005.2.2" id="x39-2430005.2.2"></a></span>
<!--l. 1935--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2440005.2.2" id="x39-2440005.2.2"></a></span>
</div>
<!--l. 1936--><p class="indent" >   Пример смешения всех: <div class="lisp"><div class="tabbing">
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))
   <br>                                                                         (list a b c d x))<br>
 1) <span class="math"> ⇒</span> (1 3 <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> 1 ())<br>
<!--l. 1941--><p class="noindent" ></div>
<!--l. 1941--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2450005.2.2" id="x39-2450005.2.2"></a></span>
                                                                          

                                                                          
<!--l. 1941--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2460005.2.2" id="x39-2460005.2.2"></a></span>
</div>
<div class="lisp">
<!--l. 1943--><p class="indent" >   <div class="tabbing">
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))
   <br>                                                                         (list a b c d x))<br>
 1 2) <span class="math"> ⇒</span> (1 2 <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> 1 ())<br>                                                   <br>
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))<br>        (list a b c d x))<br>
 :c 7) <span class="math"> ⇒</span> (:c 7 <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> :c ())<br>                                                  <br>
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))<br>        (list a b c d x))<br>
 1 6 :c 7) <span class="math"> ⇒</span> (1 6 7 1 (:c 7))<br>                                              <br>
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))<br>        (list a b c d x))<br>
 1 6 :d 8) <span class="math"> ⇒</span> (1 6 <tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> 8 (:d 8))<br>                                           <br>
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))<br>        (list a b c d x))<br>
 1 6 :d 8 :c 9 :d 10) <span class="math"> ⇒</span> (1 6 9 8 (:d 8 :c 9 :d 10))<br>
<!--l. 1963--><p class="noindent" ></div>
<!--l. 1963--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2470005.2.2" id="x39-2470005.2.2"></a></span>
<!--l. 1963--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2480005.2.2" id="x39-2480005.2.2"></a></span>
</div>
<!--l. 1965--><p class="indent" >   В лямбда-выражении, если оно стоит на первом месте в списке формы
вызова функции, допускаются все ключевые символы лямбда-списка,
хотя они и не очень-то полезны в таком контексте. Гораздо полезнее
их использовать в глобальных функциях, определённых с помощью
<tt><a 
href="symbols.html#x185-2605291r291">defun</a></tt>.
<!--l. 1971--><p class="indent" >   Все символы, что начинаются на <tt>&#x0026;</tt> обычно зарезервированы для
использования в качестве ключевых символов лямбда-списка, и не должны
использоваться для имён переменных. Реализации Common Lisp&#x2019;а
могут также предоставлять свои дополнительные ключевые символы
лямбда-списка.
<div class="defun">
                                                                          

                                                                          
<!--l. 1977--><p class="noindent" ><div class="defunheader"> <i>[Константа]</i><a 
 id="dx39-248001"></a><a 
 id="x39-248002r11"></a> <b>lambda-list-keywords</b>
</div>
<!--l. 1980--><p class="indent" >   Значение <tt><a 
href="symbols.html#x185-2605464r464">lambda-list-keywords</a></tt> является списком всех ключевых
символов лямбда-списка, используемых в данной реализации, включая те,
которые используются только в <tt><a 
href="symbols.html#x185-2605284r284">defmacro</a></tt>. Этот список должен содержать
как минимум символы <tt>&#x0026;optional</tt>, <tt>&#x0026;rest</tt>, <tt>&#x0026;key</tt>, <tt>&#x0026;allow-other-keys</tt>, <tt>&#x0026;aux</tt>,
<tt>&#x0026;body</tt>, <tt>&#x0026;whole</tt> и <tt>&#x0026;environment</tt>.
</div>
<!--l. 1987--><p class="indent" >   Вот пример использования <tt>&#x0026;allow-other-keys</tt> и <tt>:allow-other-keys</tt>,
рассматривающий функцию, которая принимает два своих именованных
аргумента и также дополнительные именованные аргументы, которые затем
передаются <tt><a 
href="symbols.html#x185-2605533r533">make-array</a></tt>: <div class="lisp"><div class="tabbing">
(defun array-of-strings (str dims <tt>&#x0026;rest</tt> keyword-pairs
   <br>                            <tt>&#x0026;key</tt> (start 0) end <tt>&#x0026;allow-other-keys</tt>)<br>
  (apply #&#x2019;make-array dims<br>
         :initial-element (subseq str start end)<br>
         :allow-other-keys t<br>                             keyword-pairs))<br>
<!--l. 1998--><p class="noindent" ></div>
<!--l. 1998--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2490005.2.2" id="x39-2490005.2.2"></a></span>
<!--l. 1998--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2500005.2.2" id="x39-2500005.2.2"></a></span>
</div>
<!--l. 2000--><p class="indent" >   Такая функция принимает строку и информацию о размерности и
возвращает массив с заданной размерностью, каждый из элементов
которого равен заданной строке. Именованные аргументы <tt>:start</tt>
и <tt>:end</tt>, как обычно (смотрите главу <a 
href="kseque.html#x96-115800014">14<!--tex4ht:ref: KSEQUE --></a>), можно использовать для
указания того, что должна использоваться подстрока. Кроме того,
использование <tt>&#x0026;allow-other-keys</tt> в лямбда списке указывает на то, что
вызов этой функции может содержать дополнительные именованные
аргументы. Для доступа к ним используется <tt>&#x0026;rest</tt> аргумент. Эти
дополнительные именованные аргументы передаются в <tt><a 
href="symbols.html#x185-2605533r533">make-array</a></tt>.
<tt><a 
href="symbols.html#x185-2605533r533">make-array</a></tt> не принимает именованные аргументы <tt>:start</tt> и <tt>:end</tt>,
                                                                          

                                                                          
и было бы ошибкой допустить их использование. Однако указание
<tt>:allow-other-keys</tt> равное не-<tt><a 
href="symbols.html#x185-2605609r609">nil</a></tt> значению позволяет передавать любые
другие именованные аргументы, включая <tt>:start</tt> и <tt>:end</tt>, и они были бы
приняты и проигнорированы.
<div class="defun">
<!--l. 2014--><p class="noindent" ><div class="defunheader"> <i>[Константа]</i><a 
 id="dx39-250001"></a><a 
 id="x39-250002r12"></a> <b>lambda-parameters-limit</b>
</div>
<!--l. 2017--><p class="indent" >   Значение <tt><a 
href="symbols.html#x185-2605465r465">lambda-parameters-limit</a></tt> является положительным целым,
которое невключительно является верхней границей допустимого количества
имён параметров, которые могут использоваться в лямбда-списке. Значение
зависит от реализации, но не может быть менее 50. Разработчики
поощряются за создание данной границы как можно большей без потери
производительности. Смотрите <tt>call-arguments-list</tt>.
</div>
                                                                          

                                                                          
<!--l. 2026--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse30.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html#tailclmse28.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse29.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html#clmse29.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse29.html"></a>   </div> </div> 
</body></html> 
