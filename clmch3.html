<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>3 Scope and Extent Область и продолжительность видимости</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 6--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch4.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse17.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse17.html#tailclmse17.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmch3.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clm.html#clmch3.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h2 class="chapterHead"><span class="titlemark">Chapter 3</span><br /><a 
 id="x25-430003"></a>Scope and Extent Область и продолжительность видимости</h2>
<!--l. 9--><p class="noindent" >In describing various features of the Common Lisp language, the notions of scope
and extent are frequently useful. These notion arise when some object or construct
must be referred to from some distant part of a program. Scope refers to the
spatial or textual region of the program within which references may
occur. Extent refers to the interval of time during which references may
occur.
<!--l. 16--><p class="indent" >   При описании различных возможностей Common Lisp&#x2019;а очень важными
понятиями являются области и продолжительности видимости. Эти
понятия возникают, когда к некоторому объекту или конструкции
необходимо обратиться где-то далеко в коде. Область видимости отмечает
пространственный или текстовый регион, в котором находящаяся внутри
программа может ссылатся на эти объекты. Продолжительность видимости
обозначает временной интервал, в течении которого программа может
ссылаться к данным.
<!--l. 24--><p class="indent" >   As a simple example, consider this program:
<!--l. 26--><p class="indent" >   Вот простой пример такой программы: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun copy-cell (x) (cons (car x) (cdr x)))
</td></tr></table>
<!--l. 29--><p class="indent" >
</div>
</div>
<!--l. 30--><p class="noindent" >The scope of the parameter named <i>x</i> is the body of the <i>defun</i> form. There is no way
to refer to this parameter from any other place but within the body of the
<i>defun</i>. Similarly, the extent of the parameter <i>x</i> (for any particular call to
<i>copy-cell</i>) is the interval from the time the function is invoked to the
time it is exited. (In the general case, the extent of a parameter may last
beyond the time of function exit, but that cannot occur in this simple
case.)
<!--l. 38--><p class="indent" >   Областью видимости параметра с именем <i>x</i> является тело формы <i>defun</i>.
Способа сослатся на этот параметр из какого-либо другого места
программы нет. Продолжительностью видимости параметра <i>x</i> (для
какого-нибудь вызова <i>copy-cell</i>) является интервал времени, начиная
с вызова функции и заканчивая выходом из нее. (В общем случае
                                                                          

                                                                          
продолжительность видимости параметра может продлиться и после
завершения функции, но в данном простом случае такого не может
быть.)
<!--l. 46--><p class="indent" >   Within Common Lisp, a referenceable entity is established by the execution
of some language construct, and the scope and extent of the entity are
described relative to the construct and the time (during execution of
the construct) at which the entity is established. For the purposes of
this discussion, the term “entity” refers not only to Common Lisp data
objects, such as symbols and conses, but also to variable bindings (both
ordinary and special), catchers, and <i>go</i> targets. It is important to distinguish
between an entity and a name for the entity. In a function deﬁnition such
as
<!--l. 57--><p class="indent" >   В Common Lisp сущность, на которую можно сослаться из кода,
создается с помощью специальных языковых конструкций, и область и
продолжительность видимости описывются в зависимости от этой
конструкции и времени (выполнения конструкции) в которое эта сущносность
была создана. Для предмета данного описания, термин «сущность»
указывает не только на объекты Common Lisp&#x2019;а, такие как символы
и cons-ячейки, но и также на связывания переменных (обычных и
специальных), ловушки, и <i>метки переходов</i>. Важно отметить различие
между сущностью и именем для этой сущности. В определение функции,
такой как:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun foo (x y) (* x (+ y 1)))
</td></tr></table>
<!--l. 69--><p class="indent" >
</div>
</div>
<!--l. 71--><p class="indent" >   there is a single name, <i>x</i>, used to refer to the ﬁrst parameter of the procedure
whenever it is invoked; however, a new binding is established on every invocation.
A binding is a particular parameter instance. The value of a reference to the
name <i>x</i> depends not only on the scope within which it occurs (the one
in the body of <i>foo</i> in the example occurs in the scope of the function
deﬁnition&#x2019;s parameters) but also on the particular binding or instance
involved. (In this case, it depends on the invocation during which the
                                                                          

                                                                          
reference is made). More complicated examples appear at the end of this
chapter.
<!--l. 83--><p class="indent" >   существует только одно имя, <i>x</i>, используемое для ссылки на первый
параметр процедуры, когда бы они не была вызвана. Связывание — это, в
частности, экземпляр параметра. Значение связанное с именем <i>x</i> зависит не
только от области видимости, в которой данная связь возникла (в данном
примере в теле функции <i>foo</i> связь возникла в области видимости определения
параметров функции), но также, в частности, от механизма связывания. (В
данном случае, значение зависит от вызова функции, в течение которого
создается ссылка). Более сложный пример приводится в конце данной
главы.
<!--l. 92--><p class="indent" >   There are a few kinds of scope and extent that are particularly useful in
describing Common Lisp:
<!--l. 95--><p class="indent" >   Вот некоторые виды областей и продолжительностей видимости, которые,
в частности, полезны при описании Common Lisp&#x2019;а:
      <ul class="itemize1">
      <li class="itemize">Lexical scope. Here references to the established entity can occur only
      within certain program portions that are lexically (that is, textually)
      contained within the establishing construct. Typically the construct will
      have a part designated the body, and the scope of all entities established
      will be (or include) the body.
      <!--l. 106--><p class="noindent" >Example: the names of parameters to a function normally are lexically
      scoped.
      </li>
      <li class="itemize">Лексическая область видимости.  В  ней  связи  к  установленным
      сущностям могут использоваться только в той части программы,
      которая                                                                  лексически
      (т.е. текст программы) находится в конструкции устанавливающей
      данные  связи.  Обычно  эта  конструкция  будет  содержать  часть,
      определенную как тело (body), и область видимости всех сущностей
      будет установлена только в этом теле.
      <!--l. 115--><p class="noindent" >Например: имена параметров в функции обычно ограничиваются
      лексической областью видимости.
      </li>
      <li class="itemize">Indeﬁnite scope. References may occur anywhere, in any program.
                                                                          

                                                                          
      </li>
      <li class="itemize">Неограниченная область видимости. Ссылка на сущность может
      производится в любом месте программы.
      </li>
      <li class="itemize">Dynamic extent.  References  may  occur  at  any  time  in  the  interval
      between establishment of the entity and the explicit disestablishment of
      the entity. As a rule, the entity is disestablished when execution of the
      establishing construct completes or is otherwise terminated. Therefore
      entities with dynamic extent obey a stack-like discipline, paralleling the
      nested executions of their establishing constructs.
      <!--l. 133--><p class="noindent" >Example: the <i>with-open-ﬁle</i> construct opens a connection to a ﬁle and
      creates a stream object to represent the connection. The stream object
      has indeﬁnite extent, but the connection to the open ﬁle has dynamic
      extent: when control exits the <i>with-open-ﬁle</i> construct, either normally
      or abnormally, the stream is automatically closed.
      <!--l. 139--><p class="noindent" >Example: the binding of a “special” variable has dynamic extent.
      </li>
      <li class="itemize">Динамическая     продолжительность     видимости.      Ссылки
      на  сущности  могут  производится  в  любое  время  на  интервале
      между установкой сущности и явного упразднения сущности. Как
      правило, сущность упраздняется, когда выполнение конструкции
      завершается или как-либо прерывается. Таким образом, сущности
      с  динамической  продолжительностью  видимости  подчиняются
      механизму  типа  стек,  они  распараллеливают  выполнение  кода,
      вложенного в их конструкции.
      <!--l. 149--><p class="noindent" >Например:   <i>with-open-ﬁle</i>   открывает   соединение   с   файлом   и
      создает объект потока для отображения этого соединения. Объект
      потока имеет неограниченную область видимости, но соединение
      с  открытым  файлом  имеет  динамическую  продолжительность
      видимости: когда выполнение в любом, нормальном или аварийном
      случае, выйдет за рамки конструкции <i>with-open-ﬁle</i>, поток будет
      автоматически закрыт.
      <!--l. 155--><p class="noindent" >Например: связывание «специальной (special)» переменной имеет
      динамическую продолжительность видимости.
                                                                          

                                                                          
      </li>
      <li class="itemize">Indeﬁnite extent. The entity continues to exist as long as the possibility
      of reference remains. (An implementation is free to destroy the entity if
      it can prove that reference to it is no longer possible. Garbage collection
      strategies implicitly employ such proofs.)
      <!--l. 164--><p class="noindent" >Example: most Common Lisp data objects have indeﬁnite extent.
      <!--l. 166--><p class="noindent" >Example: the bindings of lexically scoped parameters of a function have
      indeﬁnite extent. (By contrast, in Algol the bindings of lexically scoped
      parameters of a procedure have dynamic extent.) The function deﬁnition <div class=lisp>
      <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(defun compose (f g)
</td></tr></table>
      <!--l. 171--><p class="noindent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">  #&#x2019;(lambda (x)</td></tr></table>
      <!--l. 172--><p class="noindent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">      (funcall f (funcall g x))))</td></tr></table>
      <!--l. 174--><p class="noindent" >
</div>
</div>
      <!--l. 175--><p class="noindent" >when given two arguments, immediately returns a function as its value. The
      parameter bindings for <i>f </i> and <i>g</i> do not disappear because the returned
      function, when called, could still refer to those bindings. Therefore <div class=lisp>
      <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(funcall (compose #&#x2019;sqrt #&#x2019;abs) -9.0)
</td></tr></table>
      <!--l. 181--><p class="noindent" >
</div>
</div>
      <!--l. 182--><p class="noindent" >produces the value <i>3.0</i>. (An analogous procedure would not necessarily work
      correctly in typical Algol implementations or, for that matter, in most Lisp
      dialects.)
                                                                          

                                                                          
      </li>
      <li class="itemize">Неограниченная продолжительности видимости. Сущность
      продолжает существовать пока существует возможность ссылаться на
      нее. (Реализации разрешается удалить сущность, если она может
      доказать, что ссылка на нее более невозможна. Стратегии сборщика
      мусора неявно используют такие доказательства.)
      <!--l. 192--><p class="noindent" >Например: большинство Common Lisp объектов имеют неограниченную
      продолжительность видимости.
      <!--l. 195--><p class="noindent" >Например: связывание лексически замкнутых параметров функции
      имеет неограниченную продолжительность видимости. (В отличие от
      Algol&#x2019;а, где связывание лексически замкнутых параметров процедуры
      имеют динамическую продолжительность видимости.) Определение
      функции <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(defun compose (f g)
</td></tr></table>
      <!--l. 200--><p class="noindent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">  #&#x2019;(lambda (x)</td></tr></table>
      <!--l. 201--><p class="noindent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">      (funcall f (funcall g x))))</td></tr></table>
      <!--l. 203--><p class="noindent" >
</div>
</div>
      <!--l. 204--><p class="noindent" >при получении двух параметров, немедленно возвращает функции в
      качестве результата. Связи параметров для <i>f </i> и <i>g</i> не теряются, потому
      что возвращенная функция, когда будет вызвана, будет продолжать
      ссылаться на эти связи. Таким образом <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(funcall (compose #&#x2019;sqrt #&#x2019;abs) -9.0)
</td></tr></table>
      <!--l. 211--><p class="noindent" >
</div>
</div>
                                                                          

                                                                          
      <!--l. 212--><p class="noindent" >вернет значение <i>3.0</i>. (Аналогичная процедура не захочет корректно
      работать в типичной реализации Algol&#x2019;а или, даже, в большинстве
      диалектов Lisp&#x2019;а.)</li></ul>
<!--l. 216--><p class="indent" >   In addition to the above terms, it is convenient to deﬁne dynamic scope to
mean indeﬁnite scope and dynamic extent. Thus we speak of “special” variables as
having dynamic scope, or being dynamically scoped, because they have indeﬁnite
scope and dynamic extent: a special variable can be referred to anywhere as long
as its binding is currently in eﬀect.
<!--l. 223--><p class="indent" >   В дополение к вышеназванным терминам, удобно определить динамическую
область видимости, которая означает неограниченную область видимости и
динамическую продолжительность видимости. Следовательно мы говорим
о «специальных (special)» переменных, как об имеющих динамическую
область видимости или будучи динамически замкнутых FIXME, потому
что они имеют неограниченную область видимости и динамическую
продолжительность видимости: к специальным переменным можно
сослаться из любой точки программы на протяжении существования их
связываний.
<div class=newer>
<!--l. 233--><p class="indent" >   The term “dynamic scope” is a misnomer. Nevertheless it is both traditional
and useful.
<!--l. 236--><p class="indent" >   Термин «динамическая область видимости» некорректен. Как бы то ни
было это и устоялось, и удобно.
</div>
<!--l. 240--><p class="indent" >   The above deﬁnitions do not take into account the possibility of shadowing.
Remote reference of entities is accomplished by using names of one kind or
another. If two entities have the same name, then the second may shadow the
ﬁrst, in which case an occurrence of the name will refer to the second and cannot
refer to the ﬁrst.
<!--l. 246--><p class="indent" >   Сказанное выше не рассматривает возможность скрытия (shadowing).
Далекие (FIXME) ссылки на сущности осуществляются с использованием
имен того или иного типа. Если две сущности имеют одинаковое имя, тогда
второе имя может скрыть первое, в таком случае ссылка с помощью
этого имени будет осуществлена на вторую сущность и не может быть
осуществлена на первую.
<!--l. 253--><p class="indent" >   In the case of lexical scope, if two constructs that establish entities with
the same name are textually nested, then references within the inner
construct refer to the entity established by the inner one; the inner one
                                                                          

                                                                          
shadows the outer one. Outside the inner construct but inside the outer
one, references refer to the entity established by the outer construct. For
example:
<!--l. 261--><p class="indent" >   В случае лексической области видимости, если две конструкции, что
устанавливают сущности с одинаковыми именами, расположены в тексте
одна внутри другой, тогда ссылки внутри внутренней конструкции
указывают на сущности внутренней конструкции; внутренние сущности
скрывают внешние. Вне внутренней конструкции, но внутри внешней
конструкции ссылки указывают на сущности, установленные внешней
конструкцией.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun test (x z)
</td></tr></table>
<!--l. 269--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((z (* x 2))) (print z))</td></tr></table>
<!--l. 270--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  z)</td></tr></table>
<!--l. 272--><p class="indent" >
</div>
</div>
<!--l. 274--><p class="indent" >   The binding of the variable <i>z</i> by the <i>let</i> construct shadows the parameter
binding for the function <i>test</i>. The reference to the variable <i>z</i> in the <i>print</i> form
refers to the <i>let</i> binding. The reference to <i>z</i> at the end of the function refers to the
parameter named <i>z</i>.
<!--l. 280--><p class="indent" >   Связывание переменной <i>z</i> с помощью конструкции <i>let</i> скрывает
связывание одноименного параметра функции <i>test</i>. Ссылка на переменную <i>z</i>
в форме <i>print</i> указывает на <i>let</i> связывание. Ссылка на <i>z</i> в конце функции
указывает на параметр с именем <i>z</i>.
<!--l. 285--><p class="indent" >   In the case of dynamic extent, if the time intervals of two entities overlap, then
one interval will necessarily be nested within the other one. This is a property of
the design of Common Lisp.
<!--l. 289--><p class="indent" >   В случае динамической продолжительности видимости, если временные
интервалы двух сущностей перекрываются, тогда они будут обязательно
вложенными один в другого. Это свойство Common Lisp дизайна.
<div class=implementation>
<!--l. 294--><p class="noindent" ><b>Implementation note:</b> Behind the assertion that dynamic extents nest properly is the
assumption that there is only a single program or process. Common Lisp does not
                                                                          

                                                                          
address the problems of multiprogramming (timesharing) or multiprocessing (more than
one active processor) within a single Lisp environment. The documentation for
implementations that extend Common Lisp for multiprogramming or multiprocessing
should be very clear on what modiﬁcations are induced by such extensions to the rules of
extent and scope. Implementors should note that Common Lisp has been carefully
designed to allow special variables to be implemented using either the “deep
binding” technique or the “shallow binding” technique, but the two techniques have
diﬀerent semantic and performance implications for multiprogramming and
multiprocessing.
</div>
<!--l. 313--><p class="indent" >   A reference by name to an entity with dynamic extent will always refer to the
entity of that name that has been most recently established that has not yet been
disestablished. For example:
<!--l. 319--><p class="indent" >   Ссылка по имени на сущность с динамической продолжительностью
жизни всегда указывает на сущность с этим именем, что была установлена
наипозднейшей и еще не была упразднена. Например: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun fun1 (x)
</td></tr></table>
<!--l. 324--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (catch &#x2019;trap (+ 3 (fun2 x))))</td></tr></table>
<!--l. 325--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 326--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun fun2 (y)</td></tr></table>
<!--l. 327--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (catch &#x2019;trap (* 5 (fun3 y))))</td></tr></table>
<!--l. 328--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 329--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun fun3 (z)</td></tr></table>
<!--l. 330--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (throw &#x2019;trap z))</td></tr></table>
<!--l. 332--><p class="indent" >
</div>
</div>
<!--l. 333--><p class="noindent" >Consider the call <i>(fun1 7)</i>. The result will be <i>10</i>. At the time the <i>throw</i> is executed,
there are two outstanding catchers with the name <i>trap</i>: one established within
procedure <i>fun1</i>, and the other within procedure <i>fun2</i>. The latter is the more
recent, and so the value <i>7</i> is returned from the <i>catch</i> form in <i>fun2</i>. Viewed from
within <i>fun3</i>, the <i>catch</i> in <i>fun2</i> shadows the one in <i>fun1</i>. Had <i>fun2</i> been deﬁned
as
<!--l. 342--><p class="indent" >   Рассмотрим вызов <i>(fun1 7)</i>. Результатом будет <i>10</i>. Во время выполнения
<i>throw</i>, существует две ловушки с именем <i>trap</i>: одна установлена в процедуре
<i>fun1</i>, и другая — в <i>fun2</i>. Более поздняя в <i>fun2</i>, и тогда, из формы <i>catch</i>, что в
                                                                          

                                                                          
<i>fun2</i>, возвращается значение <i>7</i>. Рассматриваемая из <i>fun3</i>, <i>catch</i> в <i>fun2</i>
скрывает одноименную в <i>fun1</i>. Если бы <i>fun2</i> была определена как <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun fun2 (y)
</td></tr></table>
<!--l. 350--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (catch &#x2019;snare (* 5 (fun3 y))))</td></tr></table>
<!--l. 352--><p class="indent" >
</div>
</div>
<!--l. 353--><p class="noindent" >then the two catchers would have diﬀerent names, and therefore the one in <i>fun1</i>
would not be shadowed. The result would then have been <i>7</i>.
<!--l. 356--><p class="indent" >   тогда бы две ловушки имели разные имена, и в таком случае одна из них
из <i>fun1</i> не была бы скрыта. Результатом бы стало <i>7</i>.
<!--l. 359--><p class="indent" >   As a rule, this book simply speaks of the scope or extent of an entity; the
possibility of shadowing is left implicit.
<!--l. 362--><p class="indent" >   Как правило, данная книга по простому рассказывает об областях
видимости и продолжительности сущности, возможность скрытия
оставляется без рассмотрения.
<!--l. 365--><p class="indent" >   The important scope and extent rules in Common Lisp follow: Далее
важные правила области и продолжительности видимости в Common
Lisp&#x2019;е:
      <ul class="itemize1">
      <li class="itemize">Variable bindings normally have lexical scope and indeﬁnite extent.
      </li>
      <li class="itemize">Связывания  переменных  обычно  имеют  лексическую  область
      видимости и неограниченную продолжительность видимости.</li></ul>
<div class=newer>
      <ul class="itemize1">
      <li class="itemize">Variable bindings for which there is a <i>dynamic-extent</i> declaration also
      have lexical scope and indeﬁnite extent, but objects that are the values
      of such bindings may have dynamic extent. (The declaration is the
      programmer&#x2019;s guarantee that the program will behave correctly even if
      certain of the data objects have only dynamic extent rather than the
      usual indeﬁnite extent.)
                                                                          

                                                                          
      </li>
      <li class="itemize">Связывания                           переменных,                           для
      которых декларировано <i>dynamic-extent</i> также имеют лексическую
      область  видимости  и  неограниченную  продолжительность,  но
      объекты,  которые  являются  значениями  этих  связываний  могут
      иметь динамическую продолжительность видимости. (Декларация
      является программистской гарантией того, что программа будет
      вести себя корректно, даже если уверенность, что объекты данных
      имеют
      только динамическую продолжительность, предпочтительнее, чем
      обычная неограниченную продолжительность видимости. FIXME)
      </li>
      <li class="itemize">Bindings of variable names to symbol macros by <i>symbol-macrolet</i> have
      lexical scope and indeﬁnite extent.
      </li>
      <li class="itemize">Связывания     имен     переменных     с     символом     макроса
      с помощью <i>symbol-macrolet</i> имеют лексическую область видимости
      и неограниченную продолжительность видимости.</li></ul>
</div>
      <ul class="itemize1">
      <li class="itemize">Variable bindings that are declared to be <i>special</i> have dynamic scope
      (indeﬁnite scope and dynamic extent).
      </li>
      <li class="itemize">Связывания        переменных,        которые        задекларированы
      быть   <i>специальными   (special)</i>,   имеют   динамическую   область
      видимости (неограниченную область видимости и динамическую
      продолжительность).</li></ul>
<div class=newer>
      <ul class="itemize1">
      <li class="itemize">Bindings of function names established, for example, by <i>ﬂet</i> and <i>labels</i>
      have lexical scope and indeﬁnite extent.
      </li>
      <li class="itemize">Связывания имен функций устанавливаются, например, формами
                                                                          

                                                                          
      <i>ﬂet</i>   и   <i>labels</i>   и   имеют   лексическую   область   видимости   и
      неограниченную продолжительность.
      </li>
      <li class="itemize">Bindings  of  function  names  for  which  there  is  a  <i>dynamic-extent</i>
      declaration also have lexical scope and indeﬁnite extent, but function
      objects that are the values of such bindings may have dynamic extent.
      </li>
      <li class="itemize">Связывания   имен   функций,   для   которых   задекларировано
      <i>dynamic-extent</i>,  также  имеют  лексическую  область  видимости
      и  неограниченную  продолжительность,  но  объекты  функции,
      которые  являются  значениями  для  данных  связываний  могут
      иметь динамическую продолжительность видимости.
      </li>
      <li class="itemize">Bindings of function names to macros as established by <i>macrolet</i> have
      lexical scope and indeﬁnite extent.
      </li>
      <li class="itemize">Связывания   имен   функций   с   макросами,   установленными   с
      помощью  <i>macrolet</i>  имеют  лексическую  область  видимости  и
      неограниченную продолжительность.
      </li>
      <li class="itemize">Condition handlers and restarts have dynamic scope (see chapter <a 
href="clmch29.html#x185-31200029">29<!--tex4ht:ref: CONDITION --></a>).
      </li>
      <li class="itemize">Обработчики условий и перезапусков (condition and restarts) имеют
      динамическую область видимости (смотрите главу <a 
href="clmch29.html#x185-31200029">29<!--tex4ht:ref: CONDITION --></a>).</li></ul>
</div>
      <ul class="itemize1">
      <li class="itemize">A catcher established by a <i>catch</i> or <i>unwind-protect</i> special form has
      dynamic scope.
      </li>
      <li class="itemize">Ловушка установленная с помощью специальных форм <i>catch</i> или
      <i>unwind-protect</i> имеет динамическую область видимости.
                                                                          

                                                                          
      </li>
      <li class="itemize">An exit point established by a <i>block</i> construct has lexical scope and
      dynamic extent. (Such exit points are also established by <i>do</i>, <i>prog</i>, and
      other iteration constructs.)
      </li>
      <li class="itemize">Точка выхода установленная с помощью конструкции <i>block</i> имеет
      лексическую       область       видимости       и       динамическую
      продолжительность. (Такие точки выхода, также устанавливаются
      с помощью <i>do</i>, <i>prog</i> и другими конструкциями для итераций.)
      </li>
      <li class="itemize">The <i>go</i> targets established by a <i>tagbody</i>, named by the tags in the
      <i>tagbody</i>, and referred to by <i>go</i> have lexical scope and dynamic extent.
      (Such <i>go</i> targets may also appear as tags in the bodies of <i>do</i>, <i>prog</i>, and
      other iteration constructs.)
      </li>
      <li class="itemize">Цели                для                <i>go</i>,                устанавливающиеся
      с помощью <i>tagbody</i>, именующияся с помощью тегов в <i>tagbody</i>, на
      которые указывает <i>go</i>, имеют лексическую область видимости и
      динамическую продолжительность. (Такие <i>go</i> цели могут также
      появлятся как теги в телах <i>do</i>, <i>prog</i> и других конструкций для
      итераций.)
      </li>
      <li class="itemize">Named constants such as <i>nil</i> and <i>pi</i> have indeﬁnite scope and indeﬁnite
      extent.
      </li>
      <li class="itemize">Именованные константы, такие как <i>nil</i> и <i>pi</i> имеют неограниченную
      область видимости и неограниченную продолжительность.</li></ul>
<!--l. 490--><p class="indent" >   The rules of lexical scoping imply that lambda-expressions appearing in the
<i>function</i> construct will, in general, result in “closures” over those non-special
variables visible to the lambda-expression. That is, the function represented by a
lambda-expression may refer to any lexically apparent non-special variable and
get the correct value, even if the construct that established the binding has been
exited in the course of execution. The <i>compose</i> example shown earlier in this
chapter provides one illustration of this. The rules also imply that special variable
                                                                          

                                                                          
bindings are not “closed over” as they may be in certain other dialects of
Lisp.
<!--l. 503--><p class="indent" >   Правила для лексической области видимости подразумевают, что
лямбда-выражения (анонимные функции), появляющиеся в <i>function</i>, будут, в
общем случае, являться «замыканиями» над этими неспециальными
(non-special) переменными, которые видимы для лямбда-выражения. Это
значит, что функция предоставленная лямбда-выражением может ссылаться
на любую лексически доступную неспециальную (non-special) переменную и
получать корректное значение, даже если выполнение уже вышло из
конструкции, которая устанавливала связи. Пример <i>compose</i>, рассмотренный
в данной главе ранее, предоставлял изображение такого механизма.
Правила также пдразумевают, что связывания специальных переменных
не «замыкаются», как может быть в некоторых других диалектах
Lisp&#x2019;а.
<!--l. 516--><p class="indent" >   Constructs that use lexical scope eﬀectively generate a new name for each
established entity on each execution. Therefore dynamic shadowing cannot occur
(though lexical shadowing may). This is of particular importance when dynamic
extent is involved. For example:
<!--l. 522--><p class="indent" >   Конструкции, которые используют лексическую область видимости
генерируют новое имя для каждой устанавливаемой сущности при
каждом исполнении. Таким образом, динамическое скрытие не может
произойти (тогда как лексическое может). Это, в частности, важно,
когда используется динамическая продолжительность видимости.
Например:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun contorted-example (f g x)
</td></tr></table>
<!--l. 531--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (if (= x 0)</td></tr></table>
<!--l. 532--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (funcall f)</td></tr></table>
<!--l. 533--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (block here</td></tr></table>
<!--l. 534--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (+ 5 (contorted-example g</td></tr></table>
<!--l. 535--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                 #&#x2019;(lambda ()</td></tr></table>
<!--l. 536--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                     (return-from here 4))</td></tr></table>
<!--l. 537--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                 (- x 1))))))</td></tr></table>
<!--l. 539--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 540--><p class="noindent" >Consider the call <i>(contorted-example nil nil 2)</i>. This produces the result <i>4</i>. During
the course of execution, there are three calls on <i>contorted-example</i>, interleaved
with two establishments of blocks:
<!--l. 545--><p class="indent" >   Рассмотрим вызов <i>(contorted-example nil nil 2)</i>. Он вернет результат <i>4</i>. Во
время исполнения, <i>contorted-example</i> будет вызывана три раза, чередуюясь с
двумя блоками:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(contorted-example nil nil 2)
</td></tr></table>
<!--l. 550--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 551--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (block here<sub>1</sub> ...)</td></tr></table>
<!--l. 552--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 553--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (contorted-example nil #&#x2019;(lambda () (return-from here<sub>1</sub> 4)) 1)</td></tr></table>
<!--l. 554--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 555--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (block here<sub>2</sub> ...)</td></tr></table>
<!--l. 556--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 557--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (contorted-example #&#x2019;(lambda () (return-from here<sub>1</sub> 4))</td></tr></table>
<!--l. 558--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                           #&#x2019;(lambda () (return-from here<sub>2</sub> 4))</td></tr></table>
<!--l. 559--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                           0)</td></tr></table>
<!--l. 560--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (funcall f)</td></tr></table>
<!--l. 561--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                where f  ⇒ #&#x2019;(lambda () (return-from here<sub>1</sub> 4))</td></tr></table>
<!--l. 562--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 563--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            (return-from here<sub>1</sub> 4)</td></tr></table>
<!--l. 565--><p class="indent" >
</div>
</div>
<!--l. 567--><p class="indent" >   At the time the <i>funcall</i> is executed there are two <i>block</i> exit points outstanding,
each apparently named <i>here</i>. In the trace above, these exit points are
distinguished for expository purposes by subscripts. The <i>return-from</i> form
executed as a result of the <i>funcall</i> operation refers to the outer outstanding exit
point (<i>here<sub>1</sub></i>), not the inner one (<i>here<sub>2</sub></i>). This is a consequence of the rules of
lexical scoping: it refers to that exit point textually visible at the point of
execution of the <i>function</i> construct (here abbreviated by the <i>#&#x2019;</i> syntax)
                                                                          

                                                                          
that resulted in creation of the function object actually invoked by the
<i>funcall</i>.
<!--l. 582--><p class="indent" >   В время выполнения <i>funcall</i> существует две невыполненные точки выхода
<i>block</i>, каждая с именем <i>here</i>. В стеке вызовов выше, эти две точки для
наглядности проиндексированы. Форма <i>return-from</i>, выполненная как
результат операции <i>funcall</i>, ссылается на внешнюю невыполненную точку
выхода (<i>here<sub>1</sub></i>), но не на (<i>here<sub>2</sub></i>). Это следствие правил лексических областей
видимости: форма ссылается на ту точку выхода, что видима по тексту в
точке вызова создания функции (здесь отмеченной с помощью синтаксиса
<i>#&#x2019;</i>). (FIXME)
<!--l. 592--><p class="indent" >   If, in this example, one were to change the form <i>(funcall f)</i> to <i>(funcall g)</i>, then
the value of the call <i>(contorted-example nil nil 2)</i> would be <i>9</i>. The value would
change because the <i>funcall</i> would cause the execution of <i>(return-from here<sub>2</sub> 4)</i>,
thereby causing a return from the inner exit point (<i>here<sub>2</sub></i>). When that occurs, the
value <i>4</i> is returned from the middle invocation of <i>contorted-example</i>, <i>5</i> is added to
that to get <i>9</i>, and that value is returned from the outer block and the
outermost call to <i>contorted-example</i>. The point is that the choice of exit point
returned from has nothing to do with its being innermost or outermost;
rather, it depends on the lexical scoping information that is eﬀectively
packaged up with a lambda-expression when the <i>function</i> construct is
executed.
<!--l. 607--><p class="indent" >   Если в данном примере, изменить форму <i>(funcall f)</i> на <i>(funcall g)</i>, тогда
значение вызова <i>(contorted-example nil nil 2)</i> будет <i>9</i>. Значение измениться по
сравнению с предыдущим разом, потому что <i>funcall</i> вызовет выполнение
<i>(return-from here<sub>2</sub> 4)</i>, и это в свою очередь вызовет выход из внутренней
точки выхода (<i>here<sub>2</sub></i>). Когда это случиться, значение <i>4</i> будет возвращено из
середины вызова <i>contorted-example</i>, к нему добавится <i>5</i> и резульата
окажется <i>9</i>, и это значение вернется из внешнего блока и вообще из
вызова <i>contorted-example</i>. Цель данного примера, показать что выбор
точки выхода зависит от лексической области, которая была захвачена
лямбда-выражением, когда вызывался код создания этой анонимной
функции.
<!--l. 619--><p class="indent" >   This function <i>contorted-example</i> works only because the function named by <i>f </i>
is invoked during the extent of the exit point. Block exit points are like
non-special variable bindings in having lexical scope, but they diﬀer in
having dynamic extent rather than indeﬁnite extent. Once the ﬂow of
execution has left the block construct, the exit point is disestablished. For
example:
                                                                          

                                                                          
<!--l. 626--><p class="indent" >   Эта функция <i>contorted-example</i> работает только потому, что функция с
именем <i>f </i> вызывается в процессе продолжительности действия точки выхода.
Точки выхода из блока ведут себя, как связывания неспециальных
(non-special) переменных в имеющимся лексическом окружении, но
отличаются тем, что имеют динамическую продолжительность видимости, а
не неограниченную. Как только выполнение покинет блок с этой точкой
выхода, она перестанет существовать. Например:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun illegal-example ()
</td></tr></table>
<!--l. 635--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((y (block here #&#x2019;(lambda (z) (return-from here z)))))</td></tr></table>
<!--l. 636--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (if (numberp y) y (funcall y 5))))</td></tr></table>
<!--l. 638--><p class="indent" >
</div>
</div>
<!--l. 640--><p class="indent" >   One might expect the call <i>(illegal-example)</i> to produce <i>5</i> by the following
incorrect reasoning: the <i>let</i> statement binds the variable <i>y</i> to the value of the
<i>block</i> construct; this value is a function resulting from the lambda-expression.
Because <i>y</i> is not a number, it is invoked on the value <i>5</i>. The <i>return-from</i> should
then return this value from the exit point named <i>here</i>, thereby exiting from the
block again and giving <i>y</i> the value <i>5</i> which, being a number, is then returned as
the value of the call to <i>illegal-example</i>.
<!--l. 651--><p class="indent" >   Можно предположить, что вызов <i>(illegal-example)</i> вернет <i>5</i>: Форма
<i>let</i> связывает переменную <i>y</i> со значением выполнения конструкции
<i>block</i>; ее значение получится равным анонимной функции. Так как
<i>y</i> не является числом, она вызывается с параметром <i>5</i>. <i>return-from</i>
тогда должны вернуть данное значение с помощью точки выхода <i>here</i>,
тогда осуществляется выход из блока еще раз и <i>y</i> получает значение
<i>5</i>, которое будучи числом, возвращается в качестве значения для
<i>illegal-example</i>.
<!--l. 659--><p class="indent" >   The argument fails only because exit points are deﬁned in Common Lisp to
have dynamic extent. The argument is correct up to the execution of the
<i>return-from</i>. The execution of the <i>return-from</i> is an error, however, not because it
cannot refer to the exit point, but because it does correctly refer to an exit point
and that exit point has been disestablished.
                                                                          

                                                                          
<!--l. 666--><p class="indent" >   Рассуждения выше неверны, потому что точки выхода определяемые в
Common Lisp&#x2019;е имеют динамическую продолжительность видимости.
Аргументация верна только до вызова <i>return-from</i>. Вызов формы <i>return-from</i>
является ошибкой, не потому что она не может сослаться на точку выхода,
а потому что она корректно ссылается на точку выхода и эта точка выхода
уже была упразднена.
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
   <!--l. 6--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch4.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse17.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse17.html#tailclmse17.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch3.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clm.html#clmch3.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 6--><p class="indent" >   <a 
 id="tailclmch3.html"></a>  
</body></html> 
