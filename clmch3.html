<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>3 Область и продолжительность видимости</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-30 23:01:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 396--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch4.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse16.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse16.html#tailclmse16.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmch3.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clm.html#clmch3.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h2 class="chapterHead"><span class="titlemark">Глава 3</span><br /><a 
href="clm.html#QQ2-24-48" id="x24-420003">Область и продолжительность видимости</a></h2><div class="chapterTOCS">
   </div>
<!--l. 399--><p class="indent" >   При описании различных возможностей Common Lisp&#x2019;а очень важными
понятиями являются <i>области и продолжительности видимости</i>. Эти
понятия возникают, когда к некоторому объекту или конструкции
необходимо обратиться из некоторой части кода. <i>Область видимости</i>
объектов отмечает пространственный или текстовый регион, в котором
находящаяся внутри программа может обращаться к этим объектам.
<i>Продолжительность видимости</i> обозначает временной интервал, в течение
которого программа может обращаться к данным объектам.
<!--l. 407--><p class="indent" >   Вот простой пример такой программы: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun copy-cell (x) (cons (car x) (cdr x)))
</td></tr></table>
<!--l. 410--><p class="indent" >
</div>
</div>
<!--l. 412--><p class="indent" >   Областью видимости параметра с именем <tt>x</tt> является тело формы <tt><a 
href="clmse29.html#x39-66002r13">defun</a></tt>.
Способа сослаться на этот параметр из какого-либо другого места
программы нет. Продолжительностью видимости параметра <tt>x</tt> (для
какого-нибудь вызова <tt>copy-cell</tt>) является интервал времени, начиная
с вызова функции и заканчивая выходом из неё. (В общем случае
продолжительность видимости параметра может продлиться и после
завершения функции, но в данном простом случае такого не может
быть.)
<!--l. 420--><p class="indent" >   В Common Lisp сущность, на которую можно сослаться из кода,
<i>создаётся</i> с помощью специальных языковых конструкций, и область и
продолжительность видимости описываются в зависимости от этой
конструкции и времени (выполнения конструкции) в которое эта сущность
была создана. Для предмета данного описания, термин «сущность»
указывает не только на объекты Common Lisp&#x2019;а такие как символы
и cons-ячейки, но и также на связывания переменных (обычных и
специальных), ловушки, и <tt>метки переходов</tt>. Важно отметить различие
между сущностью и именем для этой сущности. В определение функции,
такой как:
                                                                          

                                                                          
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun foo (x y) (* x (+ y 1)))
</td></tr></table>
<!--l. 432--><p class="indent" >
</div>
</div>
<!--l. 434--><p class="indent" >   существует только одно имя, <tt>x</tt>, используемое для ссылки на первый
параметр процедуры, когда бы они не была вызвана. <i>Связывание</i> — это, в
частности, экземпляр параметра. Значение связанное с именем <tt>x</tt> зависит не
только от области видимости, в которой данная связь возникла (в данном
примере в теле функции <tt>foo</tt> связь возникла в области видимости
определения параметров функции), но также, в частности, от механизма
связывания. (В данном случае, значение зависит от вызова функции, в
течение которого создаётся ссылка). Более сложный пример приводится в
конце данной главы.
<!--l. 443--><p class="indent" >   Вот некоторые виды областей и продолжительностей видимости, которые,
в частности, полезны при описании Common Lisp&#x2019;а:
      <ul class="itemize1">
      <li class="itemize"><i>Лексическая         область         видимости</i>.          В          ней
      связи к установленным сущностям могут использоваться только в
      той части программы, которая лексически (т.е. текст программы)
      находится в конструкции устанавливающей данные связи. Обычно
      эта конструкция будет содержать часть, определённую как <i>тело
      (body)</i>,  и  область  видимости  всех  сущностей  будет  установлена
      только в этом теле.
      <!--l. 453--><p class="noindent" >Например: имена параметров в функции обычно ограничиваются
      лексической областью видимости.
      </li>
      <li class="itemize"><i>Неограниченная область видимости</i>. Ссылка на сущность может
      производится в любом месте программы.
      </li>
      <li class="itemize"><i>Динамическая     продолжительность     видимости</i>.     Ссылки
      на  сущности  могут  производится  в  любое  время  на  интервале
                                                                          

                                                                          
      между установкой сущности и явного упразднения сущности. Как
      правило, сущность упраздняется, когда выполнение конструкции
      завершается или как-либо прерывается. Таким образом, сущности
      с  динамической  продолжительностью  видимости  подчиняются
      механизму  типа  стек,  они  распараллеливают  выполнение  кода,
      вложенного в их конструкции.
      <!--l. 468--><p class="noindent" >Например:  <tt><a 
href="clmse113.html#x141-276011r698">with-open-file</a></tt> открывает  соединение  с  файлом  и
      создаёт объект потока для отображения этого соединения. Объект
      потока имеет неограниченную область видимости, но соединение
      с  открытым  файлом  имеет  динамическую  продолжительность
      видимости: когда выполнение в любом, нормальном или аварийном
      случае, выйдет за рамки конструкции <tt><a 
href="clmse113.html#x141-276011r698">with-open-file</a></tt>, поток будет
      автоматически закрыт.
      <!--l. 474--><p class="noindent" >Например: связывание «специальной (special)» переменной имеет
      динамическую продолжительность видимости.
      </li>
      <li class="itemize"><i>Неограниченная                                      продолжительности
      видимости</i>. Сущность продолжает существовать пока существует
      возможность ссылаться на неё. (Реализации разрешается удалить
      сущность,  если  она  может  доказать,  что  ссылка  на  неё  более
      невозможна. Стратегии сборщика мусора неявно используют такие
      доказательства.)
      <!--l. 483--><p class="noindent" >Например:    большинство    Common    Lisp    объектов    имеют
      неограниченную продолжительность видимости.
      <!--l. 486--><p class="noindent" >Например: связывание лексически замкнутых параметров функции
      имеет неограниченную продолжительность видимости. (В отличие от
      Algol&#x2019;а, где связывание лексически замкнутых параметров процедуры
      имеют динамическую продолжительность видимости.) Определение
      функции <div class=lisp><div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(defun compose (f g)
</td></tr></table>
      <!--l. 491--><p class="noindent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">  #&#x2019;(lambda (x)</td></tr></table>
      <!--l. 492--><p class="noindent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">      (funcall f (funcall g x))))</td></tr></table>
                                                                          

                                                                          
      <!--l. 494--><p class="noindent" >
</div>
</div>
      <!--l. 495--><p class="noindent" >при получении двух параметров, немедленно возвращает функции в
      качестве результата. Связи параметров для <tt><a 
href="clmse140.html#x172-399004r821">f</a></tt> и <tt>g</tt> не теряются, потому
      что возвращённая функция, когда будет вызвана, будет продолжать
      ссылаться на эти связи. Таким образом <div class=lisp><div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(funcall (compose #&#x2019;sqrt #&#x2019;abs) -9.0)
</td></tr></table>
      <!--l. 502--><p class="noindent" >
</div>
</div>
      <!--l. 503--><p class="noindent" >вернёт значение <tt>3.0</tt>. (Аналогичная процедура не захочет корректно
      работать в типичной реализации Algol&#x2019;а или, даже, в большинстве
      диалектов Lisp&#x2019;а.)</li></ul>
<!--l. 507--><p class="indent" >   В дополнение к вышеназванным терминам, удобно определить
<i>динамическую область видимости</i>, которая означает <i>неограниченную
область видимости и динамическую продолжительность видимости</i>.
Следовательно мы говорим о «специальных (special)» переменных, как об
имеющих динамическую область видимости или будучи динамически
замкнутых FIXME, потому что они имеют неограниченную область
видимости и динамическую продолжительность видимости: к специальным
переменным можно сослаться из любой точки программы на протяжении
существования их связываний.
<div class=newer>
<!--l. 517--><p class="indent" >   Термин «динамическая область видимости» некорректен. Как бы то ни
было это и устоялось, и удобно.
</div>
<!--l. 521--><p class="indent" >   Сказанное выше не рассматривает возможность <i>скрытия (shadowing)</i>.
Далёкие (FIXME) ссылки на сущности осуществляются с использованием
<i>имён</i> того или иного типа. Если две сущности имеют одинаковое имя, тогда
второе имя может скрыть первое, в таком случае ссылка с помощью
этого имени будет осуществлена на вторую сущность и не может быть
осуществлена на первую.
                                                                          

                                                                          
<!--l. 528--><p class="indent" >   В случае лексической области видимости, если две конструкции, которые
устанавливают сущности с одинаковыми именами, расположены в тексте
одна внутри другой, тогда ссылки внутри внутренней конструкции
указывают на сущности внутренней конструкции, то есть внутренние
сущности скрывают внешние. Вне внутренней конструкции, но внутри
внешней конструкции ссылки указывают на сущности, установленные
внешней конструкцией.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun test (x z)
</td></tr></table>
<!--l. 536--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((z (* x 2))) (print z))</td></tr></table>
<!--l. 537--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  z)</td></tr></table>
<!--l. 539--><p class="indent" >
</div>
</div>
<!--l. 541--><p class="indent" >   Связывание переменной <tt>z</tt> с помощью конструкции <tt><a 
href="clmse38.html#x50-99002r74">let</a></tt> скрывает
связывание одноимённого параметра функции <tt>test</tt>. Ссылка на переменную <tt>z</tt>
в форме <tt><a 
href="clmse110.html#x137-258008r650">print</a></tt> указывает на <tt><a 
href="clmse38.html#x50-99002r74">let</a></tt> связывание. Ссылка на <tt>z</tt> в конце функции
указывает на параметр с именем <tt>z</tt>.
<!--l. 546--><p class="indent" >   В случае динамической продолжительности видимости, если временные
интервалы двух сущностей перекрываются, тогда они будут обязательно
вложенными один в другого. Это свойство Common Lisp дизайна.
<!--l. 550--><p class="indent" >   Ссылка по имени на сущность с динамической продолжительностью
жизни всегда указывает на сущность с этим именем, что была установлена
наипозднейшей и ещё не была упразднена. Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun fun1 (x)
</td></tr></table>
<!--l. 555--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (catch &#x2019;trap (+ 3 (fun2 x))))</td></tr></table>
<!--l. 556--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 557--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun fun2 (y)</td></tr></table>
<!--l. 558--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (catch &#x2019;trap (* 5 (fun3 y))))</td></tr></table>
<!--l. 559--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 560--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun fun3 (z)</td></tr></table>
<!--l. 561--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (throw &#x2019;trap z))</td></tr></table>
                                                                          

                                                                          
<!--l. 563--><p class="indent" >
</div>
</div>
<!--l. 565--><p class="indent" >   Рассмотрим вызов <tt>(fun1 7)</tt>. Результатом будет <tt>10</tt>. Во время выполнения
<tt><a 
href="clmse43.html#x55-140002r116">throw</a></tt>, существует две ловушки с именем <tt>trap</tt>: одна установлена в процедуре
<tt>fun1</tt>, и другая — в <tt>fun2</tt>. Более поздняя в <tt>fun2</tt>, и тогда, из формы <tt><a 
href="clmse43.html#x55-138006r114">catch</a></tt>, что
в <tt>fun2</tt>, возвращается значение <tt>7</tt>. Рассматриваемая из <tt>fun3</tt>, <tt><a 
href="clmse43.html#x55-138006r114">catch</a></tt> в <tt>fun2</tt>
скрывает одноимённую в <tt>fun1</tt>. Если бы <tt>fun2</tt> была определена как
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun fun2 (y)
</td></tr></table>
<!--l. 573--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (catch &#x2019;snare (* 5 (fun3 y))))</td></tr></table>
<!--l. 575--><p class="indent" >
</div>
</div>
<!--l. 577--><p class="indent" >   тогда бы две ловушки имели разные имена, и в таком случае одна из них
из <tt>fun1</tt> не была бы скрыта. Результатом бы стало <tt>7</tt>.
<!--l. 580--><p class="indent" >   Как правило, данная книга по простому рассказывает об областях
видимости и продолжительности сущности, возможность скрытия
оставляется без рассмотрения.
<!--l. 583--><p class="indent" >   Далее важные правила области и продолжительности видимости в
Common Lisp&#x2019;е:
      <ul class="itemize1">
      <li class="itemize">Связывания  переменных  обычно  имеют  лексическую  область
      видимости и неограниченную продолжительность видимости.</li></ul>
      <ul class="itemize1">
      <li class="itemize">Связывания              переменных,              для              которых
      декларировано <tt>dynamic-extent</tt> также имеют лексическую область
      видимости  и  неограниченную  продолжительность,  но  объекты,
      которые  являются  значениями  этих  связываний  могут  иметь
      динамическую продолжительность видимости.
      </li>
      <li class="itemize">Связывания  имён  переменных  с  символом  макроса  с  помощью
      <tt><a 
href="clmse38.html#x50-103002r80">symbol-macrolet</a></tt>  имеют   лексическую   область   видимости   и
      неограниченную продолжительность видимости.</li></ul>
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">Связывания        переменных,        которые        задекларированы
      быть   <tt>специальными (special)</tt>,   имеют   динамическую   область
      видимости (неограниченную область видимости и динамическую
      продолжительность).</li></ul>
      <ul class="itemize1">
      <li class="itemize">Связывания имён функций устанавливаются, например, формами
      <tt><a 
href="clmse38.html#x50-102002r77">flet</a></tt>  и   <tt><a 
href="clmse38.html#x50-102004r78">labels</a></tt>  и   имеют   лексическую   область   видимости   и
      неограниченную продолжительность.
      </li>
      <li class="itemize">Связывания   имён   функций,   для   которых   задекларировано
      <tt>dynamic-extent</tt>,  также  имеют  лексическую  область  видимости
      и  неограниченную  продолжительность,  но  объекты  функции,
      которые  являются  значениями  для  данных  связываний  могут
      иметь динамическую продолжительность видимости.
      </li>
      <li class="itemize">Связывания   имён   функций   с   макросами,   установленными   с
      помощью  <tt><a 
href="clmse38.html#x50-102006r79">macrolet</a></tt> имеют  лексическую  область  видимости  и
      неограниченную продолжительность.
      </li>
      <li class="itemize">Обработчики условий и перезапусков (condition and restarts) имеют
      динамическую область видимости (смотрите главу <a 
href="clmch28.html#x173-41100028">28<!--tex4ht:ref: CONDITION --></a>).</li></ul>
      <ul class="itemize1">
      <li class="itemize">Ловушка установленная с помощью специальных форм <tt><a 
href="clmse43.html#x55-138006r114">catch</a></tt> или
      <tt><a 
href="clmse43.html#x55-139004r115">unwind-protect</a></tt> имеет динамическую область видимости.
      </li>
      <li class="itemize">Точка выхода установленная с помощью конструкции <tt><a 
href="clmse40.html#x52-112002r87">block</a></tt> имеет
      лексическую                         область                         видимости
      и динамическую продолжительность. (Такие точки выхода, также
      устанавливаются с помощью <tt><a 
href="clmse131.html#x161-329002r796">do</a></tt>, <tt><a 
href="clmse41.html#x53-126002r102">prog</a></tt> и другими конструкциями
      для итераций.)
      </li>
      <li class="itemize">Цели   для   <tt><a 
href="clmse41.html#x53-127002r104">go</a></tt>,   устанавливающиеся   с   помощью   <tt><a 
href="clmse41.html#x53-125002r101">tagbody</a></tt>  и
                                                                          

                                                                          
      именующиеся с помощью тегов в <tt><a 
href="clmse41.html#x53-125002r101">tagbody</a></tt>, на которые указывает
      <tt><a 
href="clmse41.html#x53-127002r104">go</a></tt>,   имеют   лексическую   область   видимости   и   динамическую
      продолжительность. (Такие <tt><a 
href="clmse41.html#x53-127002r104">go</a></tt> цели могут также появляться как
      теги в телах <tt><a 
href="clmse131.html#x161-329002r796">do</a></tt>, <tt><a 
href="clmse41.html#x53-126002r102">prog</a></tt> и других конструкций для итераций.)
      </li>
      <li class="itemize">Именованные          константы,          такие          как          <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>
      и <tt><a 
href="clmse64.html#x81-181023r207">pi</a></tt> имеют неограниченную область видимости и неограниченную
      продолжительность.</li></ul>
<!--l. 642--><p class="indent" >   Правила для лексической области видимости подразумевают, что
лямбда-выражения (анонимные функции), появляющиеся в <tt><a 
href="clmse34.html#x46-84002r52">function</a></tt>, будут
являться «замыканиями» над этими неспециальными (non-special)
переменными, которые видимы для лямбда-выражения. Это значит, что
функция предоставленная лямбда-выражением может ссылаться на любую
лексически доступную неспециальную (non-special) переменную и
получать корректное значение, даже если выполнение уже вышло из
конструкции, которая устанавливала связи. Пример <tt>compose</tt>, рассмотренный
в данной главе ранее, предоставлял изображение такого механизма.
Правила также подразумевают, что связывания специальных переменных
не «замыкаются», как может быть в некоторых других диалектах
Lisp&#x2019;а.
<!--l. 655--><p class="indent" >   Конструкции, которые используют лексическую область видимости
генерируют новое имя для каждой устанавливаемой сущности при
каждом исполнении. Таким образом, динамическое скрытие не может
произойти (тогда как лексическое может). Это, в частности, важно,
когда используется динамическая продолжительность видимости.
Например:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun contorted-example (f g x)
</td></tr></table>
<!--l. 664--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (if (= x 0)</td></tr></table>
<!--l. 665--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (funcall f)</td></tr></table>
<!--l. 666--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (block here</td></tr></table>
<!--l. 667--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (+ 5 (contorted-example g</td></tr></table>
<!--l. 668--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                 #&#x2019;(lambda ()</td></tr></table>
                                                                          

                                                                          
<!--l. 669--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                     (return-from here 4))</td></tr></table>
<!--l. 670--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                 (- x 1))))))</td></tr></table>
<!--l. 672--><p class="indent" >
</div>
</div>
<!--l. 674--><p class="indent" >   Рассмотрим вызов <tt>(contorted-example nil nil 2)</tt>. Он вернёт результат
<tt>4</tt>. Во время исполнения, <tt>contorted-example</tt> будет вызвана три раза,
чередуясь с двумя блоками:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(contorted-example nil nil 2)
</td></tr></table>
<!--l. 679--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 680--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (block here<span class="math"><sub>1</sub></span> ...)</td></tr></table>
<!--l. 681--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 682--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (contorted-example nil #&#x2019;(lambda () (return-from here<span class="math"><sub>1</sub></span> 4)) 1)</td></tr></table>
<!--l. 683--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 684--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (block here<span class="math"><sub>2</sub></span> ...)</td></tr></table>
<!--l. 685--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 686--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (contorted-example #&#x2019;(lambda () (return-from here<span class="math"><sub>1</sub></span> 4))</td></tr></table>
<!--l. 687--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                           #&#x2019;(lambda () (return-from here<span class="math"><sub>2</sub></span> 4))</td></tr></table>
<!--l. 688--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                           0)</td></tr></table>
<!--l. 689--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (funcall f)</td></tr></table>
<!--l. 690--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                where f <span class="math"> ⇒</span> #&#x2019;(lambda () (return-from here<span class="math"><sub>1</sub></span> 4))</td></tr></table>
<!--l. 691--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 692--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            (return-from here<span class="math"><sub>1</sub></span> 4)</td></tr></table>
<!--l. 694--><p class="indent" >
</div>
</div>
<!--l. 696--><p class="indent" >   В время выполнения <tt><a 
href="clmse36.html#x48-94004r69">funcall</a></tt> существует две невыполненные точки
выхода <tt><a 
href="clmse40.html#x52-112002r87">block</a></tt>, каждая с именем <tt>here</tt>. В стеке вызовов выше, эти две точки
для наглядности проиндексированы. Форма <tt><a 
href="clmse40.html#x52-113002r88">return-from</a></tt>, выполненная как
результат операции <tt><a 
href="clmse36.html#x48-94004r69">funcall</a></tt>, ссылается на <i>внешнюю</i> невыполненную точку
выхода (<tt>here<span class="math"><sub>1</sub></span></tt>), но не на (<tt>here<span class="math"><sub>2</sub></span></tt>). Это следствие правил лексических областей
видимости: форма ссылается на ту точку выхода, что видима по тексту в
                                                                          

                                                                          
точке вызова создания функции (здесь отмеченной с помощью синтаксиса
<tt>#&#x2019;</tt>). (FIXME)
<!--l. 706--><p class="indent" >   Если в данном примере, изменить форму <tt>(funcall f)</tt> на <tt>(funcall g)</tt>,
тогда значение вызова <tt>(contorted-example nil nil 2)</tt> будет <tt>9</tt>. Значение
измениться по сравнению с предыдущим разом, потому что <tt><a 
href="clmse36.html#x48-94004r69">funcall</a></tt> вызовет
выполнение <tt>(return-from here<span class="math"><sub>2</sub></span>  4)</tt>, и это в свою очередь вызовет выход из
внутренней точки выхода (<tt>here<span class="math"><sub>2</sub></span></tt>). Когда это случиться, значение <tt>4</tt> будет
возвращено из середины вызова <tt>contorted-example</tt>, к нему добавится <tt>5</tt> и
результат окажется <tt>9</tt>, и это значение вернётся из внешнего блока и вообще
из вызова <tt>contorted-example</tt>. Цель данного примера, показать что выбор
точки выхода зависит от лексической области, которая была захвачена
лямбда-выражением, когда вызывался код создания этой анонимной
функции.
<!--l. 718--><p class="indent" >   Эта функция <tt>contorted-example</tt> работает только потому, что функция с
именем <tt><a 
href="clmse140.html#x172-399004r821">f</a></tt> вызывается в процессе продолжительности действия точки выхода.
Точки выхода из блока ведут себя, как связывания неспециальных
(non-special) переменных в имеющимся лексическом окружении, но
отличаются тем, что имеют динамическую продолжительность видимости, а
не неограниченную. Как только выполнение покинет блок с этой точкой
выхода, она перестанет существовать. Например:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun illegal-example ()
</td></tr></table>
<!--l. 727--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((y (block here #&#x2019;(lambda (z) (return-from here z)))))</td></tr></table>
<!--l. 728--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (if (numberp y) y (funcall y 5))))</td></tr></table>
<!--l. 730--><p class="indent" >
</div>
</div>
<!--l. 732--><p class="indent" >   Можно предположить, что вызов <tt>(illegal-example)</tt> вернёт <tt>5</tt>: Форма <tt><a 
href="clmse38.html#x50-99002r74">let</a></tt>
связывает переменную <tt>y</tt> со значением выполнения конструкции <tt><a 
href="clmse40.html#x52-112002r87">block</a></tt>;
её значение получится равным анонимной функции. Так как <tt>y</tt> не
является числом, она вызывается с параметром <tt>5</tt>. <tt><a 
href="clmse40.html#x52-113002r88">return-from</a></tt> тогда
должны вернуть данное значение с помощью точки выхода <tt>here</tt>,
тогда осуществляется выход из блока <i>ещё раз</i> и <tt>y</tt> получает значение
<tt>5</tt>, которое будучи числом, возвращается в качестве значения для
                                                                          

                                                                          
<tt>illegal-example</tt>.
<!--l. 740--><p class="indent" >   Рассуждения выше неверны, потому что точки выхода определяемые в
Common Lisp&#x2019;е имеют динамическую продолжительность видимости.
Аргументация верна только до вызова <tt><a 
href="clmse40.html#x52-113002r88">return-from</a></tt>. Вызов формы
<tt><a 
href="clmse40.html#x52-113002r88">return-from</a></tt> является ошибкой, <i>не потому что</i> она не может сослаться на
точку выхода, а потому что она корректно ссылается на точку выхода <i>и</i> эта
точка выхода уже была упразднена.
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
   <!--l. 1161--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch4.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse16.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse16.html#tailclmse16.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch3.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clm.html#clmch3.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 1161--><p class="indent" >   <a 
 id="tailclmch3.html"></a>  
</body></html> 
