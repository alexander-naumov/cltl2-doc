<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Byte Manipulation Functions</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-26 02:27:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 3576--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse74.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse72.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse72.html#tailclmse72.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse73.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse73.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">12.8   </span> <a 
 id="x90-13200012.8"></a>Byte Manipulation Functions</h3>
<!--l. 3578--><p class="noindent" >Several functions are provided for dealing with an arbitrary-width ﬁeld of
contiguous bits appearing anywhere in an integer. Such a contiguous set
of bits is called a byte. Here the term byte does not imply some ﬁxed
number of bits (such as eight), rather a ﬁeld of arbitrary and user-speciﬁable
width.
<!--l. 3584--><p class="indent" >   The byte-manipulation functions use objects called byte speciﬁers to designate
a speciﬁc byte position within an integer. The representation of a byte
speciﬁer is implementation-dependent; in particular, it may or may not be
a number. It is suﬃcient to know that the function <a 
href="#x90-132002r309">byte</a> will construct
one, and that the byte-manipulation functions will accept them. The
function <a 
href="#x90-132002r309">byte</a> accepts two integers representing the position and size of
the byte and returns a byte speciﬁer. Such a speciﬁer designates a byte
whose width is size and whose bits have weights 2<sup>position+size−1</sup> through
2<sup>position</sup>.
<div class=defun>
<!--l. 3597--><p class="noindent" ><i>[Function]</i><a 
 id="dx90-132001"></a><a 
 id="x90-132002r309"></a><b> byte</b>  <i>size</i> <i>position</i>
<!--l. 3599--><p class="noindent" ><a 
href="#x90-132002r309">byte</a> takes two integers representing the size and position of a byte and returns
a byte speciﬁer suitable for use as an argument to byte-manipulation
functions.
</div>
<div class=defun>
<!--l. 3605--><p class="noindent" ><i>[Function]</i><a 
 id="dx90-132003"></a><a 
 id="x90-132004r310"></a><b> byte-size</b>  <i>bytespec</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx90-132005"></a><a 
 id="x90-132006r311"></a><b> byte-position</b>  <i>bytespec</i>
<!--l. 3608--><p class="noindent" >Given a byte speciﬁer, <a 
href="#x90-132004r310">byte-size</a> returns the size speciﬁed as an integer;
<a 
href="#x90-132006r311">byte-position</a> similarly returns the position. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(byte-size (byte j k))  ≡ j
</td></tr></table>
<!--l. 3613--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(byte-position (byte j k))  ≡ k</td></tr></table>
                                                                          

                                                                          
<!--l. 3615--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 3618--><p class="noindent" ><i>[Function]</i><a 
 id="dx90-132007"></a><a 
 id="x90-132008r312"></a><b> ldb</b>  <i>bytespec</i> <i>integer</i>
<!--l. 3620--><p class="noindent" >bytespec speciﬁes a byte of integer to be extracted. The result is returned as a
non-negative integer. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp j (ldb (byte s p) n))  ≡ (and (&#x003C; j s) (logbitp (+ j p) n))
</td></tr></table>
<!--l. 3626--><p class="indent" >
</div>
</div>
<!--l. 3627--><p class="noindent" >The name of the function <a 
href="#x90-132008r312">ldb</a> means “load byte.”
<div class=incompatibility>
<!--l. 3630--><p class="noindent" ><b>Compatibility note:</b> The MacLisp function haipart can be implemented in terms of
<a 
href="#x90-132008r312">ldb</a> as follows: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun haipart (integer count)
</td></tr></table>
<!--l. 3634--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((x (abs integer)))</td></tr></table>
<!--l. 3635--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (if (minusp count)</td></tr></table>
<!--l. 3636--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (ldb (byte (- count) 0) x)</td></tr></table>
<!--l. 3637--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (ldb (byte count (max 0 (- (integer-length x) count)))</td></tr></table>
<!--l. 3638--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             x))))</td></tr></table>
<!--l. 3640--><p class="indent" >
</div>
</div>
</div>
<!--l. 3644--><p class="indent" >   If the argument integer is speciﬁed by a form that is a place form acceptable to
<a 
href="clmse36.html#x48-80002r66">setf</a>, then <a 
href="clmse36.html#x48-80002r66">setf</a> may be used with <a 
href="#x90-132008r312">ldb</a> to modify a byte within the integer that is
stored in that place. The eﬀect is to perform a <a 
href="#x90-132014r315">dpb</a> operation and then store the
result back into the place.
</div>
                                                                          

                                                                          
<div class=defun>
<!--l. 3653--><p class="noindent" ><i>[Function]</i><a 
 id="dx90-132009"></a><a 
 id="x90-132010r313"></a><b> ldb-test</b>  <i>bytespec</i> <i>integer</i>
<!--l. 3655--><p class="noindent" ><a 
href="#x90-132010r313">ldb-test</a> is a predicate that is true if any of the bits designated by the byte
speciﬁer bytespec are 1&#x2019;s in integer; that is, it is true if the designated ﬁeld is
non-zero. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ldb-test bytespec n)  ≡ (not (zerop (ldb bytespec n)))
</td></tr></table>
<!--l. 3661--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 3664--><p class="noindent" ><i>[Function]</i><a 
 id="dx90-132011"></a><a 
 id="x90-132012r314"></a><b> mask-ﬁeld</b>  <i>bytespec</i> <i>integer</i>
<!--l. 3666--><p class="noindent" >This is similar to <a 
href="#x90-132008r312">ldb</a>; however, the result contains the speciﬁed byte of integer in
the position speciﬁed by bytespec, rather than in position 0 as with <a 
href="#x90-132008r312">ldb</a>. The result
therefore agrees with integer in the byte speciﬁed but has zero-bits everywhere
else. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ldb bs (mask-ﬁeld bs n))  ≡ (ldb bs n)
</td></tr></table>
<!--l. 3675--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 3676--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp j (mask-ﬁeld (byte s p) n))</td></tr></table>
<!--l. 3677--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ≡ (and (&#x003E;= j p) (&#x003C; j (+ p s)) (logbitp j n))</td></tr></table>
<!--l. 3678--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 3679--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask-ﬁeld bs n)  ≡ (logand n (dpb -1 bs 0))</td></tr></table>
<!--l. 3681--><p class="indent" >
</div>
</div>
<!--l. 3683--><p class="indent" >   If the argument integer is speciﬁed by a form that is a place form acceptable to
<a 
href="clmse36.html#x48-80002r66">setf</a>, then <a 
href="clmse36.html#x48-80002r66">setf</a> may be used with <a 
href="#x90-132012r314">mask-ﬁeld</a> to modify a byte within the integer
that is stored in that place. The eﬀect is to perform a <a 
href="#x90-132016r316">deposit-ﬁeld</a> operation and
then store the result back into the place.
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 3692--><p class="noindent" ><i>[Function]</i><a 
 id="dx90-132013"></a><a 
 id="x90-132014r315"></a><b> dpb</b>  <i>newbyte</i> <i>bytespec</i> <i>integer</i>
<!--l. 3694--><p class="noindent" >This returns a number that is the same as integer except in the bits speciﬁed by
bytespec. Let s be the size speciﬁed by bytespec; then the low s bits of newbyte
appear in the result in the byte speciﬁed by bytespec. The integer newbyte is
therefore interpreted as being right-justiﬁed, as if it were the result of <a 
href="#x90-132008r312">ldb</a>. For
example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp j (dpb m (byte s p) n))
</td></tr></table>
<!--l. 3703--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:69;" 
class="tabbing">   ≡ (if </td><td  
class="tabbing">(and (&#x003E;= j p) (&#x003C; j (+ p s)))</td></tr></table>
<!--l. 3704--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:69;" 
class="tabbing">            </td><td  
class="tabbing">(logbitp (- j p) m)</td></tr></table>
<!--l. 3705--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:69;" 
class="tabbing">            </td><td  
class="tabbing">(logbitp j n))</td></tr></table>
<!--l. 3707--><p class="indent" >
</div>
</div>
<!--l. 3708--><p class="noindent" >The name of the function <a 
href="#x90-132014r315">dpb</a> means “deposit byte.”
</div>
<div class=defun>
<!--l. 3711--><p class="noindent" ><i>[Function]</i><a 
 id="dx90-132015"></a><a 
 id="x90-132016r316"></a><b> deposit-ﬁeld</b>  <i>newbyte</i> <i>bytespec</i> <i>integer</i>
<!--l. 3713--><p class="noindent" >This function is to <a 
href="#x90-132012r314">mask-ﬁeld</a> as <a 
href="#x90-132014r315">dpb</a> is to <a 
href="#x90-132008r312">ldb</a>. The result is an integer that
contains the bits of newbyte within the byte speciﬁed by bytespec, and elsewhere
contains the bits of integer. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp j (deposit-ﬁeld m (byte s p) n))
</td></tr></table>
<!--l. 3720--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:79;" 
class="tabbing">    ≡ (if </td><td  
class="tabbing">(and (&#x003E;= j p) (&#x003C; j (+ p s)))</td></tr></table>
<!--l. 3721--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:79;" 
class="tabbing">             </td><td  
class="tabbing">(logbitp j m)</td></tr></table>
<!--l. 3722--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:79;" 
class="tabbing">             </td><td  
class="tabbing">(logbitp j n))</td></tr></table>
<!--l. 3724--><p class="indent" >
</div>
</div>
<div class=implementation>
<!--l. 3727--><p class="noindent" ><b>Implementation note:</b> If the bytespec is a constant, one may of course construct, at
compile time, an equivalent mask m, for example by computing (deposit-ﬁeld -1 bytespec
0). Given this mask m, one may then compute <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deposit-ﬁeld newbyte bytespec integer)
</td></tr></table>
<!--l. 3734--><p class="indent" >
</div>
</div>
<!--l. 3735--><p class="noindent" >by computing <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logior (logand newbyte m) (logand integer (lognot m)))
</td></tr></table>
<!--l. 3738--><p class="indent" >
</div>
</div>
<!--l. 3739--><p class="noindent" >where the result of (lognot m) can of course also be computed at compile time. However, the
following expression may also be used and may require fewer temporary registers in some
situations: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logxor integer (logand m (logxor integer newbyte)))
</td></tr></table>
<!--l. 3745--><p class="indent" >
</div>
</div>
<!--l. 3746--><p class="noindent" >A related, though possibly less useful, trick is that <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((z (logand (logxor x y) m)))
</td></tr></table>
<!--l. 3748--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setq x (logxor z x))</td></tr></table>
<!--l. 3749--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setq y (logxor z y)))</td></tr></table>
<!--l. 3751--><p class="indent" >
</div>
</div>
<!--l. 3752--><p class="noindent" >interchanges those bits of x and y for which the mask m is 1, and leaves alone those bits of x
and y for which m is 0.
</div>
</div>
                                                                          

                                                                          
   <!--l. 3759--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse74.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse72.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse72.html#tailclmse72.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse73.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse73.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 3759--><p class="indent" >   <a 
 id="tailclmse73.html"></a>  
</body></html> 
