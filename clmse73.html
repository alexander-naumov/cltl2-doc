<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Byte Manipulation Functions</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-22 17:23:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 3572--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse74.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse72.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse72.html#tailclmse72.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse73.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse73.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">12.8   </span> <a 
 id="x90-13200012.8"></a>Byte Manipulation Functions</h3>
<!--l. 3574--><p class="noindent" >Several functions are provided for dealing with an arbitrary-width ﬁeld of
contiguous bits appearing anywhere in an integer. Such a contiguous set
of bits is called a byte. Here the term byte does not imply some ﬁxed
number of bits (such as eight), rather a ﬁeld of arbitrary and user-speciﬁable
width.
<!--l. 3580--><p class="indent" >   The byte-manipulation functions use objects called byte speciﬁers to designate
a speciﬁc byte position within an integer. The representation of a byte
speciﬁer is implementation-dependent; in particular, it may or may not be
a number. It is suﬃcient to know that the function <a 
href="#x90-132002r307">byte</a> will construct
one, and that the byte-manipulation functions will accept them. The
function <a 
href="#x90-132002r307">byte</a> accepts two integers representing the position and size of
the byte and returns a byte speciﬁer. Such a speciﬁer designates a byte
whose width is size and whose bits have weights 2<sup>position+size−1</sup> through
2<sup>position</sup>.
<div class=defun>
<!--l. 3593--><p class="noindent" > <i>[Function]</i>   <b>byte</b> <a 
 id="dx90-132001"></a><a 
 id="x90-132002r307"></a>   <i>size</i>  <i>position</i>
<!--l. 3595--><p class="noindent" ><a 
href="#x90-132002r307">byte</a> takes two integers representing the size and position of a byte and returns
a byte speciﬁer suitable for use as an argument to byte-manipulation
functions.
</div>
<div class=defun>
<!--l. 3601--><p class="noindent" > <i>[Function]</i>   <b>byte-size</b> <a 
 id="dx90-132003"></a><a 
 id="x90-132004r308"></a>   <i>bytespec</i> <br 
class="newline" /><i>[Function]</i>   <b>byte-position</b> <a 
 id="dx90-132005"></a><a 
 id="x90-132006r309"></a>   <i>bytespec</i>
<!--l. 3604--><p class="noindent" >Given a byte speciﬁer, <a 
href="#x90-132004r308">byte-size</a> returns the size speciﬁed as an integer;
<a 
href="#x90-132006r309">byte-position</a> similarly returns the position. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(byte-size (byte j k))  ≡ j
</td></tr></table>
<!--l. 3609--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(byte-position (byte j k))  ≡ k</td></tr></table>
                                                                          

                                                                          
<!--l. 3611--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 3614--><p class="noindent" > <i>[Function]</i>   <b>ldb</b> <a 
 id="dx90-132007"></a><a 
 id="x90-132008r310"></a>   <i>bytespec</i>  <i>integer</i>
<!--l. 3616--><p class="noindent" >bytespec speciﬁes a byte of integer to be extracted. The result is returned as a
non-negative integer. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp j (ldb (byte s p) n))  ≡ (and (&#x003C; j s) (logbitp (+ j p) n))
</td></tr></table>
<!--l. 3622--><p class="indent" >
</div>
</div>
<!--l. 3623--><p class="noindent" >The name of the function <a 
href="#x90-132008r310">ldb</a> means “load byte.”
<div class=incompatibility>
<!--l. 3626--><p class="noindent" ><b>Compatibility note:</b> The MacLisp function haipart can be implemented in terms of
<a 
href="#x90-132008r310">ldb</a> as follows: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun haipart (integer count)
</td></tr></table>
<!--l. 3630--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((x (abs integer)))</td></tr></table>
<!--l. 3631--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (if (minusp count)</td></tr></table>
<!--l. 3632--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (ldb (byte (- count) 0) x)</td></tr></table>
<!--l. 3633--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (ldb (byte count (max 0 (- (integer-length x) count)))</td></tr></table>
<!--l. 3634--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             x))))</td></tr></table>
<!--l. 3636--><p class="indent" >
</div>
</div>
</div>
<!--l. 3640--><p class="indent" >   If the argument integer is speciﬁed by a form that is a place form acceptable to
<a 
href="clmse36.html#x48-80002r66">setf</a>, then <a 
href="clmse36.html#x48-80002r66">setf</a> may be used with <a 
href="#x90-132008r310">ldb</a> to modify a byte within the integer that is
stored in that place. The eﬀect is to perform a <a 
href="#x90-132014r313">dpb</a> operation and then store the
result back into the place.
</div>
                                                                          

                                                                          
<div class=defun>
<!--l. 3649--><p class="noindent" > <i>[Function]</i>   <b>ldb-test</b> <a 
 id="dx90-132009"></a><a 
 id="x90-132010r311"></a>   <i>bytespec</i>  <i>integer</i>
<!--l. 3651--><p class="noindent" ><a 
href="#x90-132010r311">ldb-test</a> is a predicate that is true if any of the bits designated by the byte
speciﬁer bytespec are 1&#x2019;s in integer; that is, it is true if the designated ﬁeld is
non-zero. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ldb-test bytespec n)  ≡ (not (zerop (ldb bytespec n)))
</td></tr></table>
<!--l. 3657--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 3660--><p class="noindent" > <i>[Function]</i>   <b>mask-ﬁeld</b> <a 
 id="dx90-132011"></a><a 
 id="x90-132012r312"></a>   <i>bytespec</i>  <i>integer</i>
<!--l. 3662--><p class="noindent" >This is similar to <a 
href="#x90-132008r310">ldb</a>; however, the result contains the speciﬁed byte of integer in
the position speciﬁed by bytespec, rather than in position 0 as with <a 
href="#x90-132008r310">ldb</a>. The result
therefore agrees with integer in the byte speciﬁed but has zero-bits everywhere
else. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ldb bs (mask-ﬁeld bs n))  ≡ (ldb bs n)
</td></tr></table>
<!--l. 3671--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 3672--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp j (mask-ﬁeld (byte s p) n))</td></tr></table>
<!--l. 3673--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ≡ (and (&#x003E;= j p) (&#x003C; j (+ p s)) (logbitp j n))</td></tr></table>
<!--l. 3674--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 3675--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask-ﬁeld bs n)  ≡ (logand n (dpb -1 bs 0))</td></tr></table>
<!--l. 3677--><p class="indent" >
</div>
</div>
<!--l. 3679--><p class="indent" >   If the argument integer is speciﬁed by a form that is a place form acceptable to
<a 
href="clmse36.html#x48-80002r66">setf</a>, then <a 
href="clmse36.html#x48-80002r66">setf</a> may be used with <a 
href="#x90-132012r312">mask-ﬁeld</a> to modify a byte within the integer
that is stored in that place. The eﬀect is to perform a <a 
href="#x90-132016r314">deposit-ﬁeld</a> operation and
then store the result back into the place.
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 3688--><p class="noindent" > <i>[Function]</i>   <b>dpb</b> <a 
 id="dx90-132013"></a><a 
 id="x90-132014r313"></a>   <i>newbyte</i>  <i>bytespec</i>  <i>integer</i>
<!--l. 3690--><p class="noindent" >This returns a number that is the same as integer except in the bits speciﬁed by
bytespec. Let s be the size speciﬁed by bytespec; then the low s bits of newbyte
appear in the result in the byte speciﬁed by bytespec. The integer newbyte is
therefore interpreted as being right-justiﬁed, as if it were the result of <a 
href="#x90-132008r310">ldb</a>. For
example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp j (dpb m (byte s p) n))
</td></tr></table>
<!--l. 3699--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:69;" 
class="tabbing">   ≡ (if </td><td  
class="tabbing">(and (&#x003E;= j p) (&#x003C; j (+ p s)))</td></tr></table>
<!--l. 3700--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:69;" 
class="tabbing">            </td><td  
class="tabbing">(logbitp (- j p) m)</td></tr></table>
<!--l. 3701--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:69;" 
class="tabbing">            </td><td  
class="tabbing">(logbitp j n))</td></tr></table>
<!--l. 3703--><p class="indent" >
</div>
</div>
<!--l. 3704--><p class="noindent" >The name of the function <a 
href="#x90-132014r313">dpb</a> means “deposit byte.”
</div>
<div class=defun>
<!--l. 3707--><p class="noindent" > <i>[Function]</i>   <b>deposit-ﬁeld</b> <a 
 id="dx90-132015"></a><a 
 id="x90-132016r314"></a>   <i>newbyte</i>  <i>bytespec</i>  <i>integer</i>
<!--l. 3709--><p class="noindent" >This function is to <a 
href="#x90-132012r312">mask-ﬁeld</a> as <a 
href="#x90-132014r313">dpb</a> is to <a 
href="#x90-132008r310">ldb</a>. The result is an integer that
contains the bits of newbyte within the byte speciﬁed by bytespec, and elsewhere
contains the bits of integer. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp j (deposit-ﬁeld m (byte s p) n))
</td></tr></table>
<!--l. 3716--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:79;" 
class="tabbing">    ≡ (if </td><td  
class="tabbing">(and (&#x003E;= j p) (&#x003C; j (+ p s)))</td></tr></table>
<!--l. 3717--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:79;" 
class="tabbing">             </td><td  
class="tabbing">(logbitp j m)</td></tr></table>
<!--l. 3718--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:79;" 
class="tabbing">             </td><td  
class="tabbing">(logbitp j n))</td></tr></table>
<!--l. 3720--><p class="indent" >
</div>
</div>
<div class=implementation>
<!--l. 3723--><p class="noindent" ><b>Implementation note:</b> If the bytespec is a constant, one may of course construct, at
compile time, an equivalent mask m, for example by computing <i>(deposit-ﬁeld -1 bytespec
0)</i>. Given this mask m, one may then compute <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deposit-ﬁeld newbyte bytespec integer)
</td></tr></table>
<!--l. 3730--><p class="indent" >
</div>
</div>
<!--l. 3731--><p class="noindent" >by computing <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logior (logand newbyte m) (logand integer (lognot m)))
</td></tr></table>
<!--l. 3734--><p class="indent" >
</div>
</div>
<!--l. 3735--><p class="noindent" >where the result of <i>(lognot m)</i> can of course also be computed at compile time. However, the
following expression may also be used and may require fewer temporary registers in some
situations: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logxor integer (logand m (logxor integer newbyte)))
</td></tr></table>
<!--l. 3741--><p class="indent" >
</div>
</div>
<!--l. 3742--><p class="noindent" >A related, though possibly less useful, trick is that <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((z (logand (logxor x y) m)))
</td></tr></table>
<!--l. 3744--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setq x (logxor z x))</td></tr></table>
<!--l. 3745--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setq y (logxor z y)))</td></tr></table>
<!--l. 3747--><p class="indent" >
</div>
</div>
<!--l. 3748--><p class="noindent" >interchanges those bits of x and y for which the mask m is <i>1</i>, and leaves alone those bits of x
and y for which m is <i>0</i>.
</div>
</div>
                                                                          

                                                                          
   <!--l. 3755--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse74.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse72.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse72.html#tailclmse72.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse73.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse73.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 3755--><p class="indent" >   <a 
 id="tailclmse73.html"></a>  
</body></html> 
