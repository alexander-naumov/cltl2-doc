<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Использование списков как множеств</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-28 14:08:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 2106--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse85.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse83.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse83.html#tailclmse83.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse84.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch15.html#clmse84.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">15.5   </span> <a 
href="clm.html#QQ2-104-237" id="x104-20800015.5">Использование списков как множеств</a></h3>
<!--l. 2108--><p class="noindent" >Common Lisp содержит функции, которые позволяют обрабатывать
списки элементов как <i>множества</i>. Сюда входят функции добавления,
удаления и поиска элементов в списке, основанного на различных
критериях. Кроме того, включены функции объединения, пересечения и
разности.
<!--l. 2114--><p class="indent" >   Правила наименования данных функций и их именованных параметров в
основном следуют правилам именования функций для последовательностей.
Смотрите главу <a 
href="clmch14.html#x93-19400014">14<!--tex4ht:ref: KSEQUE --></a>.
<div class=defun>
<!--l. 2118--><p class="noindent" ><i>[Функция]</i><a 
 id="dx104-208001"></a><a 
 id="x104-208002r467"></a><b> member</b>  <i>item</i> <i>list</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx104-208003"></a><a 
 id="x104-208004r468"></a><b> member-if</b>  <i>predicate</i> <i>list</i> &#x0026;key  <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx104-208005"></a><a 
 id="x104-208006r469"></a><b> member-if-not</b>  <i>predicate</i> <i>list</i> &#x0026;key  <i>:key</i>
<!--l. 2122--><p class="noindent" >Функция осуществляет поиск элемента, удовлетворяющего условию, в списке
<i>list</i>. Если элемент не найдёт, возвращается <a 
href="clmse31.html#x42-74002r18">nil</a>. Иначе возвращается часть
списка, начинающаяся с искомого элемента. Поиск осуществляется только в
верхнем уровне списка. Эти функции могут использоваться в качестве
предикатов.
<!--l. 2130--><p class="indent" >   Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(member &#x2019;snerd &#x2019;(a b c d)) <span class="math"> ⇒</span> <a 
href="clmse31.html#x42-74002r18">nil</a>
</td></tr></table>
<!--l. 2132--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(member-if #&#x2019;numberp &#x2019;(a #\Space 5/3 foo)) <span class="math"> ⇒</span> (5/3 foo)</td></tr></table>
<!--l. 2133--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(member &#x2019;a &#x2019;(g (a y) c a d e a f)) <span class="math"> ⇒</span> (a d e a f)</td></tr></table>
<!--l. 2135--><p class="indent" >
</div>
</div>
<!--l. 2136--><p class="noindent" >Следует отметить, что в последнем примере значение, возвращённое <a 
href="#x104-208002r467">member</a>,
равно <a 
href="clmse33.html#x44-78002r44">eq</a> части списка, которая начинается на a. Если <a 
href="#x104-208002r467">member</a> вернула не
<a 
href="clmse31.html#x42-74002r18">nil</a> значение, то для изменения полученного элемента списка можно
                                                                          

                                                                          
использовать <a 
href="clmse82.html#x102-206002r457">rplaca</a>.
<!--l. 2141--><p class="indent" >   Смотрите также <a 
href="clmse78.html#x97-198002r379">ﬁnd</a> и <a 
href="clmse78.html#x97-198008r382">position</a>.
</div>
<div class=defun>
<!--l. 2144--><p class="noindent" ><i>[Функция]</i><a 
 id="dx104-208007"></a><a 
 id="x104-208008r470"></a><b> tailp</b>  <i>sublist</i> <i>list</i>
<!--l. 2146--><p class="noindent" ><a 
href="#x104-208008r470">tailp</a> истинен тогда и только тогда, когда существует такое целое число <i>n</i>,
что выполняется <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql <i>sublist</i> (nthcdr <i>n</i> <i>list</i>))
</td></tr></table>
<!--l. 2151--><p class="indent" >
</div>
</div>
<i>
<!--l. 2152--><p class="noindent" >list</i> может быть списком с точкой (подразумевается, что реализации могут
использовать <a 
href="clmse32.html#x43-77006r24">atom</a> и не могут <a 
href="clmse81.html#x101-202002r425">endp</a> для проверки конца списка <i>list</i>).
FIXME
</div>
<div class=defun>
<!--l. 2157--><p class="noindent" ><i>[Функция]</i><a 
 id="dx104-208009"></a><a 
 id="x104-208010r471"></a><b> adjoin</b>  <i>item</i> <i>list</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2159--><p class="noindent" ><a 
href="#x104-208010r471">adjoin</a> используется для добавления элементов во множество, если этого
элемента во множестве ещё не было. Условие равенства по-умолчанию <a 
href="clmse33.html#x44-78004r45">eql</a>.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(adjoin <i>item</i> <i>list</i>) <span class="math"> ≡</span> (if (member <i>item</i> <i>list</i>) <i>list</i> (cons <i>item</i> <i>list</i>))
</td></tr></table>
<!--l. 2164--><p class="indent" >
</div>
</div>
<!--l. 2165--><p class="noindent" >Условие равенства может быть любым предикатом. <i>item</i> добавляется в список
тогда и только тогда, когда в списке не было ни одного элемента,
«удовлетворяющего условию».
<!--l. 2169--><p class="indent" >   <a 
href="#x104-208010r471">adjoin</a> отклоняется от обычных правил, описанных в главе <a 
href="clmch14.html#x93-19400014">14<!--tex4ht:ref: KSEQUE --></a> в части
обработки параметров <i>item</i> и :key. Если указана :key функция, то она
применяется к параметру <i>item</i>, также как и к каждому элементу
                                                                          

                                                                          
списка. Обоснование в том, что если <i>item</i> ещё не был в списке и если
он там появится, то применение функции :key к нему как элементу
списка не будет корректным, если этого не было при его добавлении.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(adjoin <i>item</i> <i>list</i> :key <i>fn</i>)
</td></tr></table>
<!--l. 2176--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ≡</span> (if (member (funcall <i>fn</i> <i>item</i>) <i>list</i> :key <i>fn</i>) <i>list</i> (cons <i>item</i> <i>list</i>))</td></tr></table>
<!--l. 2179--><p class="indent" >
</div>
</div>
<!--l. 2181--><p class="indent" >   Смотрите также <a 
href="clmse81.html#x101-203002r452">pushnew</a>.
</div>
<div class=defun>
<!--l. 2184--><p class="noindent" ><i>[Функция]</i><a 
 id="dx104-208011"></a><a 
 id="x104-208012r472"></a><b> union</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx104-208013"></a><a 
 id="x104-208014r473"></a><b> nunion</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2187--><p class="noindent" ><a 
href="#x104-208012r472">union</a> принимает два списка и возвращает новый список, содержащий всё,
что является элементами списков <i>list1</i> и <i>list2</i>. Если в списках есть
дубликаты, то в итоговом будет только один экземпляр. Например:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(union &#x2019;(a b c) &#x2019;(f a d))
</td></tr></table>
<!--l. 2193--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (a b c f d) или (b c f a d) или (d f a b c) или ...</td></tr></table>
<!--l. 2194--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2195--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(union &#x2019;((x 5) (y 6)) &#x2019;((z 2) (x 4)) :key #&#x2019;car)</td></tr></table>
<!--l. 2196--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> ((x 5) (y 6) (z 2)) или ((x 4) (y 6) (z 2)) или ...</td></tr></table>
<!--l. 2198--><p class="indent" >
</div>
</div>
<!--l. 2200--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списках. Итоговый список может
иметь общие ячейки с или быть равным <a 
href="clmse33.html#x44-78002r44">eq</a> переданным аргументам.
<!--l. 2205--><p class="indent" >   Функция :test может быть любым предикатом, и операция объединения
может быть описана следующим образом. Для всех возможных упорядоченных
                                                                          

                                                                          
пар, состоящих из одного элемента из списка <i>list1</i> и одного элемента из
списка <i>list2</i>, предикат устанавливает «равны» ли они. Для каждой пары
равных элементов, как минимум один из двух элементов будет помещён в
результат. Кроме того, любой элемент, которые не был равен ни одному
другому элементу, также будет помещён в результат. Это описание
может быть полезным при использовании хитрых функций проверки
равенства.
<!--l. 2214--><p class="indent" >   Аргумент :test-not может быть полезен, когда функция проверки
равенства является логическим отрицанием проверки равенства. Хороший
пример такой функции это <a 
href="clmse78.html#x97-198020r388">mismatch</a>, которая логически инвертирована так,
что если аргументы не равны, то может быть получена возможная полезная
информация. Эта дополнительная «полезная информация» отбрасывается в
следующем примере. <a 
href="clmse78.html#x97-198020r388">mismatch</a> используется только как предикат.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(union &#x2019;(#(a b) #(5 0 6) #(f 3))
</td></tr></table>
<!--l. 2221--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       &#x2019;(#(5 0 6) (a b) #(g h))</td></tr></table>
<!--l. 2222--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :test-not</td></tr></table>
<!--l. 2223--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       #&#x2019;mismatch)</td></tr></table>
<!--l. 2224--><p class="indent" >     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (#(a b) #(5 0 6) #(f 3) #(g h))     ;Возможный результат</td></tr></table>
<!--l. 2225--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> ((a b) #(f 3) #(5 0 6) #(g h))      ;Другой возможный результат</td></tr></table>
<!--l. 2227--><p class="indent" >
</div>
</div>
<!--l. 2228--><p class="noindent" >Использование :test-not #&#x2019;mismatch отличается от использования :test #&#x2019;equalp,
например, потому что <a 
href="clmse78.html#x97-198020r388">mismatch</a> определяет что #(a b) и (a b) одинаковы,
тогда как <a 
href="clmse33.html#x44-78008r47">equalp</a> определяет эти выражения разными.
<!--l. 2233--><p class="indent" >   <a 
href="#x104-208014r473">nunion</a> является деструктивной версией <a 
href="#x104-208012r472">union</a>. Она выполняет ту же
операцию, но может разрушить аргументы, возможно при использовании их
ячеек для построения результата.
</div>
<div class=defun>
<!--l. 2238--><p class="noindent" ><i>[Функция]</i><a 
 id="dx104-208015"></a><a 
 id="x104-208016r474"></a><b> intersection</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx104-208017"></a><a 
 id="x104-208018r475"></a><b> nintersection</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2241--><p class="noindent" ><a 
href="#x104-208016r474">intersection</a> принимает два списка и возвращает новый список содержащий
                                                                          

                                                                          
все элементы, которые есть и в первом и во втором списках одновременно.
Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(intersection &#x2019;(a b c) &#x2019;(f a d)) <span class="math"> ⇒</span> (a)
</td></tr></table>
<!--l. 2247--><p class="indent" >
</div>
</div>
<!--l. 2249--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списках. Итоговый список может
иметь общие ячейки с или быть равным <a 
href="clmse33.html#x44-78002r44">eq</a> переданным аргументам.
<!--l. 2254--><p class="indent" >   Функция :test может быть любым предикатом, и операция пересечения
может быть описана следующим образом. Для всех возможных упорядоченных
пар, состоящих из одного элемента из списка <i>list1</i> и одного элемента из
списка <i>list2</i>, предикат устанавливает «равны» ли они. Для каждой пары
равных элементов, только один из двух элементов будет помещён в
результат. Больше никаких элементов в итоговом списке не будет. Это
описание может быть полезным при использовании хитрых функций
проверки равенства.
<!--l. 2262--><p class="indent" >   <a 
href="#x104-208018r475">nintersection</a> является является деструктивной версией <a 
href="#x104-208016r474">intersection</a>. Она
выполняет ту же операцию, но может разрушить аргумент <i>list1</i>, возможно
при использовании их ячеек для построения результата. (Аргумент <i>list2</i> не
разрушается.)
</div>
<div class=defun>
<!--l. 2268--><p class="noindent" ><i>[Функция]</i><a 
 id="dx104-208019"></a><a 
 id="x104-208020r476"></a><b> set-diﬀerence</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx104-208021"></a><a 
 id="x104-208022r477"></a><b> nset-diﬀerence</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2271--><p class="noindent" ><a 
href="#x104-208020r476">set-diﬀerence</a> возвращает список элементов списка <i>list1</i>, которые не
встречаются в списке <i>list2</i>. Данная операция не разрушает аргументы.
<!--l. 2275--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списке <i>list1</i>. Итоговый список может
иметь общие ячейки, или быть равным <a 
href="clmse33.html#x44-78002r44">eq</a> аргументу <i>list1</i>.
<i>
<!--l. 2280--><p class="indent" >   :test</i> может быть любым предикатом, и операция разности множеств может
быть описана следующим образом. Для всех возможных упорядоченных пар,
состоящих из элементов первого и второго списков, используется предикат
для установки их «равенства». Элемент из списка <i>list1</i> помещается в
                                                                          

                                                                          
результат, тогда и только тогда, когда он не равен ни одному элементу
списка. Это позволяет делать очень интересные приложения. Например,
можно удалить из списка строк все строки, содержащие некоторый список
символов: <i>list2</i>. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;; Удалить все имена специй содержащие буквы &#x0022;c&#x0022; или &#x0022;w&#x0022;.
</td></tr></table>
<!--l. 2289--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-diﬀerence &#x2019;(&#x0022;strawberry&#x0022; &#x0022;chocolate&#x0022; &#x0022;banana&#x0022;</td></tr></table>
<!--l. 2290--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  &#x0022;lemon&#x0022; &#x0022;pistachio&#x0022; &#x0022;rhubarb&#x0022;)</td></tr></table>
<!--l. 2291--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                &#x2019;(#\c #\w)</td></tr></table>
<!--l. 2292--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                :test</td></tr></table>
<!--l. 2293--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                #&#x2019;(lambda (s c) (ﬁnd c s)))</td></tr></table>
<!--l. 2294--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (&#x0022;banana&#x0022; &#x0022;rhubarb&#x0022; &#x0022;lemon&#x0022;)     ;Возможен другой порядок элементов</td></tr></table>
<!--l. 2297--><p class="indent" >
</div>
</div>
<!--l. 2299--><p class="indent" >   <a 
href="#x104-208022r477">nset-diﬀerence</a> является деструктивной версией <a 
href="#x104-208020r476">set-diﬀerence</a>. Данная
операция может разрушить <i>list1</i>.
</div>
<div class=defun>
<!--l. 2303--><p class="noindent" ><i>[Функция]</i><a 
 id="dx104-208023"></a><a 
 id="x104-208024r478"></a><b> set-exclusive-or</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx104-208025"></a><a 
 id="x104-208026r479"></a><b> nset-exclusive-or</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2306--><p class="noindent" ><a 
href="#x104-208024r478">set-exclusive-or</a> возвращает список элементов, которые встречаются только в
списке <i>list1</i> и только в списке <i>list2</i>. Данная операция не разрушает
аргументы.
<!--l. 2311--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списке <i>list1</i>. Итоговый список может
иметь общие ячейки, или быть равным <a 
href="clmse33.html#x44-78002r44">eq</a> аргументу <i>list1</i>.
<!--l. 2316--><p class="indent" >   Функция проверки равенства элементов может быть любым предикатом,
и операцию <a 
href="#x104-208024r478">set-exclusive-or</a> можно описать следующим образом. Для всех
возможных упорядоченных пар, содержащих один элемент из списка <i>list1</i> и
один элемент из списка <i>list2</i>, функция используется для проверки
«равенства». Результат содержит точно те элементы списков <i>list1</i> и <i>list2</i>,
которые были только в различающихся парах.
<!--l. 2323--><p class="indent" >   <a 
href="#x104-208026r479">nset-exclusive-or</a> является деструктивной версией <a 
href="#x104-208024r478">set-exclusive-or</a>. Данная
операция может разрушить аргументы.
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 2327--><p class="noindent" ><i>[Функция]</i><a 
 id="dx104-208027"></a><a 
 id="x104-208028r480"></a><b> subsetp</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2329--><p class="noindent" ><a 
href="#x104-208028r480">subsetp</a> является предикатом, который истинен, если каждый элемент списка
<i>list1</i> встречается в («равен» некоторому элементу в) списке <i>list2</i>, иначе
ложен.
</div>
                                                                          

                                                                          
   <!--l. 2335--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse85.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse83.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse83.html#tailclmse83.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse84.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch15.html#clmse84.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 2335--><p class="indent" >   <a 
 id="tailclmse84.html"></a>  
</body></html> 
