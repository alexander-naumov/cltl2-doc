<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Precision, Contagion, and Coercion</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-19 00:40:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 74--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse62.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#tailclmch12.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse61.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse61.html" >Вверх</a><tt>&#x003E;</tt></p></div>
                                                                          

                                                                          
   <h3 class="sectionHead"><span class="titlemark">12.1   </span> <a 
 id="x78-17500012.1"></a>Precision, Contagion, and Coercion</h3>
<!--l. 77--><p class="noindent" >In general, computations with ﬂoating-point numbers are only approximate. The
<i>precision</i> of a ﬂoating-point number is not necessarily correlated at all with the
<i>accuracy</i> of that number. For instance, 3.142857142857142857 is a more precise
approximation to <span class="math">π</span> than 3.14159, but the latter is more accurate. The
precision refers to the number of bits retained in the representation. When an
operation combines a short ﬂoating-point number with a long one, the result
will be a long ﬂoating-point number. This rule is made to ensure that
as much accuracy as possible is preserved; however, it is by no means a
guarantee. Common Lisp numerical routines do assume, however, that the
accuracy of an argument does not exceed its precision. Therefore when two
small ﬂoating-point numbers are combined, the result will always be a
small ﬂoating-point number. This assumption can be overridden by ﬁrst
explicitly converting a small ﬂoating-point number to a larger representation.
(Common Lisp never converts automatically from a larger size to a smaller
one.)
<!--l. 96--><p class="indent" >   Rational computations cannot overﬂow in the usual sense (though of course
there may not be enough storage to represent one), as integers and ratios may in
principle be of any magnitude. Floating-point computations may get exponent
overﬂow or underﬂow; this is an error.
<div class=newer>
<!--l. 105--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx78-175001"></a>to address certain problems relating to
ﬂoating-point overﬂow and underﬂow, but certain parts of the proposed solution
were not adopted, namely to add the macro without-ﬂoating-underﬂow-traps to
the language and to require certain behavior of ﬂoating-point overﬂow and
underﬂow. The committee agreed that this area of the language requires more
discussion before a solution is standardized.
<!--l. 113--><p class="indent" >   For the record, the proposal that was considered and rejected (for the nonce)
introduced a macro without-ﬂoating-underﬂow-traps that would execute its body
in such a way that, within its dynamic extent, a ﬂoating-point underﬂow must not
signal an error but instead must produce either a denormalized number or zero as
the result. The rejected proposal also speciﬁed the following treatment of overﬂow
and underﬂow:
      <ul class="itemize1">
      <li class="itemize">A ﬂoating-point computation that overﬂows should signal an error of
      type <a 
href="clmse151.html#x185-472069r1012">ﬂoating-point-overﬂow</a>.
                                                                          

                                                                          
      </li>
      <li class="itemize">Unless the dynamic extent of a use of without-ﬂoating-underﬂow-traps,
      a ﬂoating-point computation that underﬂows should signal an error of
      type <a 
href="clmse151.html#x185-472071r1013">ﬂoating-point-underﬂow</a>. A result that can be represented only in
      denormalized form must be considered an underﬂow in implementations
      that support denormalized ﬂoating-point numbers.</li></ul>
<!--l. 131--><p class="noindent" >These points refer to conditions <a 
href="clmse151.html#x185-472069r1012">ﬂoating-point-overﬂow</a> and <a 
href="clmse151.html#x185-472071r1013">ﬂoating-point-underﬂow</a>
that were approved by X3J13 and are described in section <a 
href="clmse151.html#x185-47200029.5">29.5<!--tex4ht:ref: PREDEFINED-CONDITIONS-SECTION --></a>.
</div>
<!--l. 139--><p class="indent" >   When rational and ﬂoating-point numbers are compared or combined by a
numerical function, the rule of <i>ﬂoating-point contagion</i> is followed: when a
rational meets a ﬂoating-point number, the rational is ﬁrst converted to a
                                                                          

                                                                          
ﬂoating-point number of the same format. For functions such as <a 
href="clmse106.html#x131-239002r587">+</a> that take
more than two arguments, it may be that part of the operation is carried
out exactly using rationals and then the rest is done using ﬂoating-point
arithmetic.
<div class=new>
<!--l. 149--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx78-175002"></a>to apply the rule of ﬂoating-point contagion
stated above to the case of <i>combining</i> rational and ﬂoating-point numbers. For
<i>comparing</i>, the following rule is to be used instead: When a rational number and a
ﬂoating-point number are to be compared by a numerical function, in eﬀect the
ﬂoating-point number is ﬁrst converted to a rational number as if by the function
<a 
href="clmse66.html#x83-184004r215">rational</a>, and then an exact comparison of two rational numbers is performed. It is
of course valid to use a more eﬃcient implementation than actually calling the
function <a 
href="clmse66.html#x83-184004r215">rational</a>, as long as the result of the comparison is the same. In
the case of complex numbers, the real and imaginary parts are handled
separately.
<div class=rationale>
<!--l. 164--><p class="noindent" ><b>Rationale:</b> In general, accuracy cannot be preserved in combining operations, but it can
be preserved in comparisons, and preserving it makes that part of Common Lisp
algebraically a bit more tractable. In particular, this change prevents the breakdown of
transitivity. Let a be the result of (/ 10.0 single-ﬂoat-epsilon), and let j be the result of
(ﬂoor a). (Note that (= a (+ a 1.0)) is true, by the deﬁnition of <a 
href="clmse70.html#x87-188059r311">single-ﬂoat-epsilon</a>.)
Under the old rules, all of (&#x003C;= a j), (&#x003C; j (+ j 1)), and (&#x003C;= (+ j 1) a) would be
true; transitivity would then imply that (&#x003C; a a) ought to be true, but of course it is
false, and therefore transitivity fails. Under the new rule, however, (&#x003C;= (+ j 1) a) is
false.
</div>
</div>
<!--l. 181--><p class="indent" >   For functions that are mathematically associative (and possibly commutative),
a Common Lisp implementation may process the arguments in any manner
consistent with associative (and possibly commutative) rearrangement. This does
not aﬀect the order in which the argument forms are evaluated, of course; that
order is always left to right, as in all Common Lisp function calls. What is left
loose is the order in which the argument values are processed. The point of all this
is that implementations may diﬀer in which automatic coercions are applied
because of diﬀering orders of argument processing. As an example, consider this
expression: <div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(+ 1/3 2/3 1.0D0 1.0 1.0E-15)
</td></tr></table>
<!--l. 194--><p class="indent" >
</div>
</div>
<!--l. 195--><p class="noindent" >One implementation might process the arguments from left to right, ﬁrst adding 1/3
and 2/3 to get 1, then converting that to a double-precision ﬂoating-point number
for combination with 1.0D0, then successively converting and adding 1.0 and
1.0E-15. Another implementation might process the arguments from right to left,
ﬁrst performing a single-precision ﬂoating-point addition of 1.0 and 1.0E-15 (and
probably losing some accuracy in the process!), then converting the sum to
double precision and adding 1.0D0, then converting 2/3 to double-precision
ﬂoating-point and adding it, and then converting 1/3 and adding that. A third
implementation might ﬁrst scan all the arguments, process all the rationals ﬁrst to
keep that part of the computation exact, then ﬁnd an argument of the
largest ﬂoating-point format among all the arguments and add that, and
then add in all other arguments, converting each in turn (all in a perhaps
misguided attempt to make the computation as accurate as possible). In any
case, all three strategies are legitimate. The user can of course control
the order of processing explicitly by writing several calls; for example:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(+ (+ 1/3 2/3) (+ 1.0D0 1.0E-15) 1.0)
</td></tr></table>
<!--l. 215--><p class="indent" >
</div>
</div>
<!--l. 216--><p class="noindent" >The user can also control all coercions simply by writing calls to coercion functions
explicitly.
<!--l. 219--><p class="indent" >   In general, then, the type of the result of a numerical function is a
ﬂoating-point number of the largest format among all the ﬂoating-point
arguments to the function; but if the arguments are all rational, then the
result is rational (except for functions that can produce mathematically
irrational results, in which case a single-format ﬂoating-point number may
result).
<!--l. 226--><p class="indent" >   There is a separate rule of complex contagion. As a rule, complex numbers
never result from a numerical function unless one or more of the arguments is
                                                                          

                                                                          
complex. (Exceptions to this rule occur among the irrational and transcendental
functions, speciﬁcally <a 
href="clmse65.html#x82-181004r193">expt</a>, <a 
href="clmse65.html#x82-181008r194">log</a>, <a 
href="clmse65.html#x82-181011r195">sqrt</a>, <a 
href="clmse65.html#x82-182017r204">asin</a>, <a 
href="clmse65.html#x82-182019r205">acos</a>, <a 
href="clmse65.html#x82-182035r212">acosh</a>, and <a 
href="clmse65.html#x82-182037r213">atanh</a>; see
section <a 
href="clmse65.html#x82-18000012.5">12.5<!--tex4ht:ref: TRANSCENDENTAL-SECTION --></a>.) When a non-complex number meets a complex number, the
non-complex number is in eﬀect ﬁrst converted to a complex number by providing
an imaginary part of zero.
<!--l. 238--><p class="indent" >   If any computation produces a result that is a ratio of two integers such that
the denominator evenly divides the numerator, then the result is immediately
converted to the equivalent integer. This is called the rule of <i>rational
canonicalization</i>.
<!--l. 243--><p class="indent" >   If the result of any computation would be a complex rational with a zero
imaginary part, the result is immediately converted to a non-complex
rational number by taking the real part. This is called the rule of <i>complex
canonicalization</i>. Note that this rule does <i>not</i> apply to complex numbers whose
components are ﬂoating-point numbers. Whereas #C(5 0) and 5 are not distinct
values in Common Lisp (they are always <a 
href="clmse33.html#x44-78004r45">eql</a>), #C(5.0 0.0) and 5.0 are always
distinct values in Common Lisp (they are never <a 
href="clmse33.html#x44-78004r45">eql</a>, although they are
<a 
href="clmse33.html#x44-78008r47">equalp</a>).
                                                                          

                                                                          
   <!--l. 253--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse62.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#tailclmch12.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse61.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse61.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 253--><p class="indent" >   <a 
 id="tailclmse61.html"></a>  
</body></html> 
