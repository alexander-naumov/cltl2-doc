<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Dynamic Non-Local Exits Динамические нелокальные выходы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-10 00:01:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 6427--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch8.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse44.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse44.html#tailclmse44.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse45.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse45.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">7.11   </span> <a 
 id="x57-1520007.11"></a>Dynamic Non-Local Exits Динамические нелокальные выходы</h3>
<a 
 id="dx57-152001"></a>
<a 
 id="dx57-152002"></a>
<a 
 id="dx57-152003"></a>
<a 
 id="dx57-152004"></a>
<!--l. 6434--><p class="noindent" >Common Lisp provides a facility for exiting from a complex process in a non-local,
dynamically scoped manner. There are two classes of special forms for this
purpose, called <i>catch</i> forms and <i>throw</i> forms, or simply <i>catches</i> and <i>throws</i>. A
catch form evaluates some subforms in such a way that, if a throw form is
executed during such evaluation, the evaluation is aborted at that point and the
catch form immediately returns a value speciﬁed by the throw. Unlike <a 
href="clmse41.html#x53-124002r103">block</a>
and <a 
href="clmse142.html#x173-367002r883">return</a> (section <a 
href="clmse41.html#x53-1240007.7">7.7<!--tex4ht:ref: BLOCK-RETURN-SECTION --></a>), which allow for exiting a <a 
href="clmse41.html#x53-124002r103">block</a> form from any
point lexically within the body of the <a 
href="clmse41.html#x53-124002r103">block</a>, the catch/throw mechanism
works even if the throw form is not textually within the body of the catch
form. The throw need only occur within the extent (time span) of the
evaluation of the body of the catch. This is analogous to the distinction
between dynamically bound (special) variables and lexically bound (local)
variables.
<!--l. 6450--><p class="indent" >   Common Lisp предоставляет функциональноссть для выхода из сложного
процесса в нелокальном, динамических ограниченном стиле. Для этих целей
есть два вида специальных форм, называемых <i>catch</i> и <i>throw</i>. Форма catch
выполняет некоторые подформы так, что если форма throw выполняется в
ходе этих вычислений, в данной точке вычисления прерываются и форма
catch немедленно возвращает значение указанное в throw. В отличие от <a 
href="clmse41.html#x53-124002r103">block</a>
и <a 
href="clmse142.html#x173-367002r883">return</a> (раздел <a 
href="clmse41.html#x53-1240007.7">7.7<!--tex4ht:ref: BLOCK-RETURN-SECTION --></a>), которые позволяют выйти из тела <a 
href="clmse41.html#x53-124002r103">block</a> из любой точки
лексически, находящейся внутри тела, catch/throw механизм работает, даже
если форма throw по тексту не находится внутри тела формы catch.
Throw может использовать только в течение (продолжительности
времени) выполнения тела catch. Можно провести аналогию между ними,
как между динамически связываемыми переменными и лексически
связываемыми.
                                                                          

                                                                          
<div class=defspec>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> catch </b><a 
 id="dx57-152005"></a><a 
 id="x57-152006r132"></a> tag  { form}*
</td></tr></table>
<!--l. 6466--><p class="indent" >
</div>
<!--l. 6466--><p class="noindent" ><span class="paragraphHead"><a 
 id="x57-1530007.11"></a></span>
   The <a 
href="#x57-152006r132">catch</a> special form serves as a target for transfer of control by <a 
href="#x57-154003r134">throw</a>. The
form <i>tag</i> is evaluated ﬁrst to produce an object that names the catch; it may be
any Lisp object. A catcher is then established with the object as the tag. The
<i>form</i>s are evaluated as an implicit <a 
href="clmse38.html#x50-102002r80">progn</a>, and the results of the last form are
returned, except that if during the evaluation of the <i>form</i>s a throw should be
executed such that the tag of the throw matches (is <a 
href="clmse33.html#x44-81002r46">eq</a> to) the tag of the <a 
href="#x57-152006r132">catch</a>
and the catcher is the most recent outstanding catcher with that tag, then
the evaluation of the <i>form</i>s is aborted and the results speciﬁed by the
throw are immediately returned from the <a 
href="#x57-152006r132">catch</a> expression. The catcher
established by the <a 
href="#x57-152006r132">catch</a> expression is disestablished just before the results are
returned.
<!--l. 6484--><p class="indent" >   Специальная форма <a 
href="#x57-152006r132">catch</a> служит мишенью для передачи управления с
помощью <a 
href="#x57-154003r134">throw</a>. Первой выполняется форма <i>tag</i> для создания объекта
для имени catch. Он может быть любым Lisp&#x2019;овым объектом. Затем
устанавливается ловушка с тегом, в качестве которого используется этот
объект. Формы <i>form</i> выполняются как неявный <a 
href="clmse38.html#x50-102002r80">progn</a>, и возвращается
результат последней формы. Однако если во время вычислений будет
выполнена форма <a 
href="#x57-154003r134">throw</a> с тегом, который равен <a 
href="clmse33.html#x44-81002r46">eq</a> тегу catch, то управление
немедленно прерывается и возвращается результат указанный в форме throw.
Ловушка, устанавливаемая с помощью <a 
href="#x57-152006r132">catch</a>, упраздняется перед тем, как
будет возвращен результат.
<!--l. 6498--><p class="indent" >   The tag is used to match throws with catches. (catch &#x2019;foo <i>form</i>) will catch a
(throw &#x2019;foo <i>form</i>) but not a (throw &#x2019;bar <i>form</i>). It is an error if <a 
href="#x57-154003r134">throw</a> is done when
there is no suitable <a 
href="#x57-152006r132">catch</a> ready to catch it.
<!--l. 6503--><p class="indent" >   Тег используется для соотнесения throws и catches. (catch &#x2019;foo <i>form</i>) будет
                                                                          

                                                                          
перехватывать (throw &#x2019;foo <i>form</i>), но не будет (throw &#x2019;bar <i>form</i>). Если <a 
href="#x57-154003r134">throw</a>
выполнен без соотвествующего <a 
href="#x57-152006r132">catch</a>, готового его обработать, то это
является ошибкой.
<!--l. 6508--><p class="indent" >   Catch tags are compared using <a 
href="clmse33.html#x44-81002r46">eq</a>, not <a 
href="clmse33.html#x44-81005r47">eql</a>; therefore numbers and characters
should not be used as catch tags.
<!--l. 6512--><p class="indent" >   Теги catch сравниваются с использованием <a 
href="clmse33.html#x44-81002r46">eq</a>, а не <a 
href="clmse33.html#x44-81005r47">eql</a>. Таким
образом числа и строковые символы не могут использоваться в качестве
тегов.
<div class=incompatibility>
<!--l. 6517--><p class="noindent" ><b>Compatibility note:</b> The name <a 
href="#x57-152006r132">catch</a> comes from MacLisp, but the syntax of <a 
href="#x57-152006r132">catch</a> in
Common Lisp is diﬀerent. The MacLisp syntax was (catch <i>form</i> <i>tag</i>), where the <i>tag</i> was
not evaluated.
</div>
</div>
<a 
 id="dx57-153001"></a>
<a 
 id="dx57-153002"></a>
<div class=defspec>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> unwind-protect </b><a 
 id="dx57-153003"></a><a 
 id="x57-153004r133"></a> protected-form  {cleanup-form}*
</td></tr></table>
<!--l. 6530--><p class="indent" >
</div>
<!--l. 6530--><p class="noindent" ><span class="paragraphHead"><a 
 id="x57-1540007.11"></a></span>
   Sometimes it is necessary to evaluate a form and make sure that certain
side eﬀects take place after the form is evaluated; a typical example is <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (start-motor)
</td></tr></table>
<!--l. 6535--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (drill-hole)</td></tr></table>
<!--l. 6536--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (stop-motor))</td></tr></table>
<!--l. 6538--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 6539--><p class="noindent" >The non-local exit facility of Common Lisp creates a situation in which the above
code won&#x2019;t work, however: if drill-hole should do a throw to a catch that is outside
of the <a 
href="clmse38.html#x50-102002r80">progn</a> form (perhaps because the drill bit broke), then (stop-motor) will
never be evaluated (and the motor will presumably be left running). This is
particularly likely if drill-hole causes a Lisp error and the user tells the
error-handler to give up and abort the computation. (A possibly more practical
example might be <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(prog2 (open-a-ﬁle)
</td></tr></table>
<!--l. 6550--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (process-ﬁle)</td></tr></table>
<!--l. 6551--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (close-the-ﬁle))</td></tr></table>
<!--l. 6553--><p class="indent" >
</div>
</div>
<!--l. 6554--><p class="noindent" >where it is desired always to close the ﬁle when the computation is terminated for
whatever reason. This case is so important that Common Lisp provides the special
form <a 
href="clmse120.html#x148-302012r769">with-open-ﬁle</a> for this purpose.)
<!--l. 6559--><p class="indent" >   Иногда необходимо выполнить форму и быть уверенным, что некоторые
побочные эффекты выполняются после ее завершения. Например: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (start-motor)
</td></tr></table>
<!--l. 6563--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (drill-hole)</td></tr></table>
<!--l. 6564--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (stop-motor))</td></tr></table>
<!--l. 6566--><p class="indent" >
</div>
</div>
<!--l. 6567--><p class="noindent" >Функциональность нелокальных выходов в Common Lisp создает ситуацию, в
которой однако данный код может не сработать правильно. Если drill-hole
может бросить исключение в ловушку, находяющуюся выше данного <a 
href="clmse38.html#x50-102002r80">progn</a>,
то (stop-motor) никогда не выполниться. Более удобный пример с
открытием/закрытием файлов: <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(prog2 (open-a-ﬁle)
</td></tr></table>
<!--l. 6573--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (process-ﬁle)</td></tr></table>
<!--l. 6574--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (close-the-ﬁle))</td></tr></table>
<!--l. 6576--><p class="indent" >
</div>
</div>
<!--l. 6577--><p class="noindent" >где закрытие файла может не произойти, по причине ошибки в функции
process-ﬁle.
<!--l. 6580--><p class="indent" >   In order to allow the example hole-drilling program to work, it can be
rewritten using <a 
href="#x57-153004r133">unwind-protect</a> as follows: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;; Stop the motor no matter what (even if it failed to start).
</td></tr></table>
<!--l. 6583--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 6584--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(unwind-protect</td></tr></table>
<!--l. 6585--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (progn (start-motor)</td></tr></table>
<!--l. 6586--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (drill-hole))</td></tr></table>
<!--l. 6587--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (stop-motor))</td></tr></table>
<!--l. 6589--><p class="indent" >
</div>
</div>
<!--l. 6590--><p class="noindent" >If drill-hole does a throw that attempts to quit out of the <a 
href="#x57-153004r133">unwind-protect</a>, then
(stop-motor) will be executed.
<!--l. 6593--><p class="indent" >   Для того, чтобы вышеприведенный код работал корректно, можно
переписать его с использованием <a 
href="#x57-153004r133">unwind-protect</a>: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;; Stop the motor no matter what (even if it failed to start).
</td></tr></table>
<!--l. 6596--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 6597--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(unwind-protect</td></tr></table>
<!--l. 6598--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (progn (start-motor)</td></tr></table>
<!--l. 6599--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (drill-hole))</td></tr></table>
<!--l. 6600--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (stop-motor))</td></tr></table>
<!--l. 6602--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 6603--><p class="noindent" >Если drill-hole бросит исключение, которое попытается выйти из блока
<a 
href="#x57-153004r133">unwind-protect</a>, то (stop-motor) будет обязательно выполнена.
<!--l. 6606--><p class="indent" >   This example assumes that it is correct to call stop-motor even if the motor
has not yet been started. Remember that an error or interrupt may cause an
exit even before any initialization forms have been executed. Any state
restoration code should operate correctly no matter where in the protected
code an exit occurred. For example, the following code is not correct: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(unwind-protect
</td></tr></table>
<!--l. 6614--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (progn (incf *access-count*)</td></tr></table>
<!--l. 6615--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (perform-access))</td></tr></table>
<!--l. 6616--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (decf *access-count*))</td></tr></table>
<!--l. 6618--><p class="indent" >
</div>
</div>
<!--l. 6619--><p class="noindent" >If an exit occurs before completion of the <a 
href="clmse69.html#x86-200014r224">incf</a> operation the <a 
href="clmse69.html#x86-200016r225">decf</a> operation will be
executed anyway, resulting in an incorrect value for *access-count*. The correct
way to code this is as follows: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((old-count *access-count*))
</td></tr></table>
<!--l. 6624--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (unwind-protect</td></tr></table>
<!--l. 6625--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (progn (incf *access-count*)</td></tr></table>
<!--l. 6626--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (perform-access))</td></tr></table>
<!--l. 6627--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (setq *access-count* old-count)))</td></tr></table>
<!--l. 6629--><p class="indent" >
</div>
</div>
<!--l. 6631--><p class="indent" >   Этот пример допускает то, что вызов stop-motor корректен, даже если
мотор еще не был запущен. Помните, что ошибка или прерывание может
осуществить выход перед тем, как будет проведена инициализация. Любой
                                                                          

                                                                          
код по восстановлению состояния должен правильно работать вне
зависимости от того, где произошла ошибка. Например, следующий код
неправильный: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(unwind-protect
</td></tr></table>
<!--l. 6638--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (progn (incf *access-count*)</td></tr></table>
<!--l. 6639--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (perform-access))</td></tr></table>
<!--l. 6640--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (decf *access-count*))</td></tr></table>
<!--l. 6642--><p class="indent" >
</div>
</div>
<!--l. 6643--><p class="noindent" >Если выход случиться перед тем, как выполниться операция <a 
href="clmse69.html#x86-200014r224">incf</a>, то выполнение
<a 
href="clmse69.html#x86-200016r225">decf</a> приведет к некорректному значению в *access-count*. Правильно будет
записать этот код так: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((old-count *access-count*))
</td></tr></table>
<!--l. 6647--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (unwind-protect</td></tr></table>
<!--l. 6648--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (progn (incf *access-count*)</td></tr></table>
<!--l. 6649--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (perform-access))</td></tr></table>
<!--l. 6650--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (setq *access-count* old-count)))</td></tr></table>
<!--l. 6652--><p class="indent" >
</div>
</div>
<!--l. 6654--><p class="indent" >   As a general rule, <a 
href="#x57-153004r133">unwind-protect</a> guarantees to execute the <i>cleanup-form</i>s
before exiting, whether it terminates normally or is aborted by a throw of some
kind. (If, however, an exit occurs during execution of the <i>cleanup-form</i>s, no
special action is taken. The <i>cleanup-form</i>s of an <a 
href="#x57-153004r133">unwind-protect</a> are not protected
by that <a 
href="#x57-153004r133">unwind-protect</a>, though they may be protected if that <a 
href="#x57-153004r133">unwind-protect</a>
occurs within the protected form of another <a 
href="#x57-153004r133">unwind-protect</a>.) <a 
href="#x57-153004r133">unwind-protect</a>
returns whatever results from evaluation of the <i>protected-form</i> and discards all the
results from the <i>cleanup-form</i>s.
<!--l. 6666--><p class="indent" >   Как правило, <a 
href="#x57-153004r133">unwind-protect</a> гарантирует выполнение форм <i>cleanup-form</i>
перед выходом, как в случае нормального выхода, так и в случае генерации
                                                                          

                                                                          
исключения. (Если, однако, выход случился в ходе выполнения форм
<i>cleanup-form</i>, никакого специального действия не предпринимается. Формы
<i>cleanup-form</i> не защищаются. Для этого необходимо использовать
дополнительные конструкции <a 
href="#x57-153004r133">unwind-protect</a>.) <a 
href="#x57-153004r133">unwind-protect</a> возвращает
результат выполнения защищенной формы <i>protected-form</i> и игнорирует все
результаты выполнения форм чистки <i>cleanup-form</i>.
<!--l. 6677--><p class="indent" >   It should be emphasized that <a 
href="#x57-153004r133">unwind-protect</a> protects against <i>all</i> attempts to
exit from the protected form, including not only “dynamic exit” facilities such as
<a 
href="#x57-154003r134">throw</a> but also “lexical exit” facilities such as <a 
href="clmse42.html#x54-140002r122">go</a> and <a 
href="clmse41.html#x53-125002r104">return-from</a>. Consider this
situation: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(tagbody
</td></tr></table>
<!--l. 6683--><p class="indent" >                                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((x 3))</td></tr></table>
<!--l. 6684--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (unwind-protect</td></tr></table>
<!--l. 6685--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (if (numberp x) (go out))</td></tr></table>
<!--l. 6686--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (print x)))</td></tr></table>
<!--l. 6687--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> out</td></tr></table>
<!--l. 6688--><p class="indent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...)</td></tr></table>
<!--l. 6690--><p class="indent" >
</div>
</div>
<!--l. 6691--><p class="noindent" >When the <a 
href="clmse42.html#x54-140002r122">go</a> is executed, the call to <a 
href="clmse117.html#x144-284010r713">print</a> is executed ﬁrst, and then the transfer of
control to the tag out is completed.
<!--l. 6694--><p class="indent" >   Следует подчеркнуть, что <a 
href="#x57-153004r133">unwind-protect</a> защищает против <i>всех</i> попыток
выйти из защищенной формы, включая не только «динамический выход» с
помощью <a 
href="#x57-154003r134">throw</a>, но и также «лексический выход» с помощью <a 
href="clmse42.html#x54-140002r122">go</a> и
<a 
href="clmse41.html#x53-125002r104">return-from</a>. Рассмотрим следующую ситуацию: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(tagbody
</td></tr></table>
<!--l. 6699--><p class="indent" >                                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((x 3))</td></tr></table>
<!--l. 6700--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (unwind-protect</td></tr></table>
<!--l. 6701--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (if (numberp x) (go out))</td></tr></table>
<!--l. 6702--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (print x)))</td></tr></table>
<!--l. 6703--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> out</td></tr></table>
                                                                          

                                                                          
<!--l. 6704--><p class="indent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...)</td></tr></table>
<!--l. 6706--><p class="indent" >
</div>
</div>
<!--l. 6707--><p class="noindent" >Когда выполнится <a 
href="clmse42.html#x54-140002r122">go</a>, то сначала выполнится <a 
href="clmse117.html#x144-284010r713">print</a>, а затем перенос управления
на тег out будет завершен.
<div class=newer>
<!--l. 6711--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx57-154001"></a>to clarify the interaction of <a 
href="#x57-153004r133">unwind-protect</a> with
constructs that perform exits.
<!--l. 6714--><p class="indent" >   Let an <i>exit</i> be a point out of which control can be transferred. For a <a 
href="#x57-154003r134">throw</a> the
exit is the matching <a 
href="#x57-152006r132">catch</a>; for a <a 
href="clmse41.html#x53-125002r104">return-from</a> the exit is the corresponding <a 
href="clmse41.html#x53-124002r103">block</a>.
For a <a 
href="clmse42.html#x54-140002r122">go</a> the exit is the statement within the <a 
href="clmse42.html#x54-138002r119">tagbody</a> (the one to which
the target tag belongs) which is being executed at the time the <a 
href="clmse42.html#x54-140002r122">go</a> is
performed.
<!--l. 6720--><p class="indent" >   The extent of an exit is dynamic; it is not indeﬁnite. The extent of an exit
begins when the corresponding form (<a 
href="#x57-152006r132">catch</a>, <a 
href="clmse41.html#x53-124002r103">block</a>, or <a 
href="clmse42.html#x54-138002r119">tagbody</a> statement) is
entered. When the extent of an exit has ended, it is no longer legal to return from
it.
<!--l. 6725--><p class="indent" >   Note that the extent of an exit is not the same thing as the scope or
extent of the designator by which the exit is identiﬁed. For example, a
<a 
href="clmse41.html#x53-124002r103">block</a> name has lexical scope but the extent of its exit is dynamic. The
extent of a <a 
href="#x57-152006r132">catch</a> tag could diﬀer from the extent of the exit associated
with the <a 
href="#x57-152006r132">catch</a> (which is exactly what is at issue here). The diﬀerence
matters when there are transfers of control from the cleanup clauses of an
<a 
href="#x57-153004r133">unwind-protect</a>.
<!--l. 6733--><p class="indent" >   When a transfer of control out of an exit is initiated by <a 
href="#x57-154003r134">throw</a>, <a 
href="clmse41.html#x53-125002r104">return-from</a>, or
<a 
href="clmse42.html#x54-140002r122">go</a>, a variety of events occur before the transfer of control is complete:
      <ul class="itemize1">
      <li class="itemize">The  cleanup  clauses  of  any  intervening  <a 
href="#x57-153004r133">unwind-protect</a>  clauses  are
      evaluated.
      </li>
      <li class="itemize">Intervening dynamic bindings of special variables and catch tags are
      undone.
      </li>
      <li class="itemize">Intervening exits are <i>abandoned</i>, that is, their extent ends and it is no
      longer legal to attempt to transfer control from them.
                                                                          

                                                                          
      </li>
      <li class="itemize">The extent of the exit being invoked ends.
      </li>
      <li class="itemize">Control is ﬁnally passed to the target.</li></ul>
<!--l. 6746--><p class="noindent" >The ﬁrst edition left the order of these events in some doubt. The implementation
note for <a 
href="#x57-154003r134">throw</a> hinted that the ﬁrst two processes are interwoven, but it was
unclear whether it is permissible for an implementation to abandon all
intervening exits before processing any intervening <a 
href="#x57-153004r133">unwind-protect</a> cleanup
clauses.
<!--l. 6753--><p class="indent" >   The clariﬁcation adopted by X3J13 is as follows. Intervening exits are
abandoned as soon as the transfer of control is initiated; in the case of a <a 
href="#x57-154003r134">throw</a>,
this occurs at the beginning of the “second pass” mentioned in the implementation
note. It is an error to attempt a transfer of control to an exit whose dynamic
extent has ended.
<!--l. 6760--><p class="indent" >   Next the evaluation of <a 
href="#x57-153004r133">unwind-protect</a> cleanup clauses and the undoing of
dynamic bindings and <a 
href="#x57-152006r132">catch</a> tags are performed together, in the order
corresponding to the reverse of the order in which they were established. The
eﬀect of this is that the cleanup clauses of an <a 
href="#x57-153004r133">unwind-protect</a> will see the same
dynamic bindings of variables and <a 
href="#x57-152006r132">catch</a> tags as were visible when the
<a 
href="#x57-153004r133">unwind-protect</a> was entered. (However, some of those <a 
href="#x57-152006r132">catch</a> tags may not be
useable because they correspond to abandoned exit points.)
<!--l. 6770--><p class="indent" >   Finally control is transferred to the originally invoked exit and simultaneously
that exit is abandoned.
<!--l. 6773--><p class="indent" >   The eﬀect of this speciﬁcation is that once a program has attempted
to transfer control to a particular exit, an <a 
href="#x57-153004r133">unwind-protect</a> cleanup form
cannot step in and decide to transfer control to a more recent (nested) exit,
blithely forgetting the original exit request. However, a cleanup form may
restate the request to transfer to the same exit that started the cleanup
process.
<!--l. 6781--><p class="indent" >   Here is an example based on a nautical metaphor. The function gently moves
an oar in the water with low force, but if an oar gets stuck, the caller will catch a
crab. The function row takes a boat, an oar-stroking function, a stream, and a
count; an oar is constructed for the boat and stream and the oar-stroking function
is called :count times. The function life rows a particular boat. Merriment follows,
except that if the oarsman is winded he must stop to catch his breath. <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun gently (oar)
</td></tr></table>
<!--l. 6791--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (stroke oar :force 0.5)</td></tr></table>
<!--l. 6792--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (when (stuck oar)</td></tr></table>
<!--l. 6793--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (throw &#x2019;crab nil)))</td></tr></table>
<!--l. 6794--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 6795--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun row (boat stroke-fn stream &#x0026;key count)</td></tr></table>
<!--l. 6796--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((oar (make-oar boat stream)))</td></tr></table>
<!--l. 6797--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (loop repeat count do (funcall stroke-fn oar))))</td></tr></table>
<!--l. 6798--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 6799--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun life ()</td></tr></table>
<!--l. 6800--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (catch &#x2019;crab</td></tr></table>
<!--l. 6801--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (catch &#x2019;breath</td></tr></table>
<!--l. 6802--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (unwind-protect</td></tr></table>
<!--l. 6803--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (row *your-boat* #&#x2019;gently *query-io* :count 3))</td></tr></table>
<!--l. 6804--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (when (winded) (throw &#x2019;breath nil)))</td></tr></table>
<!--l. 6805--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (loop repeat 4 (set-mode :merry))</td></tr></table>
<!--l. 6806--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (dream))))</td></tr></table>
<!--l. 6808--><p class="indent" >
</div>
</div>
<!--l. 6809--><p class="noindent" >Suppose that the oar gets stuck, causing gently to call <a 
href="#x57-154003r134">throw</a> with the tag crab. The
program is then committed to exiting from the outer <a 
href="#x57-152006r132">catch</a> (the one with the tag
crab). As control breaks out of the <a 
href="#x57-153004r133">unwind-protect</a> form, the winded test is
executed. Suppose it is true; then another call to <a 
href="#x57-154003r134">throw</a> occurs, this time with the
tag breath. The inner <a 
href="#x57-152006r132">catch</a> (the one with the tag breath) has been abandoned as
a result of the ﬁrst <a 
href="#x57-154003r134">throw</a> operation (still in progress). The clariﬁcation voted by
X3J13 speciﬁes that the program is in error for attempting to transfer control to
an abandoned exit point. To put it in terms of the example: once you
have begun to catch a crab, you cannot rely on being able to catch your
breath.
<!--l. 6822--><p class="indent" >   Implementations may support longer extents for exits than is required by
this speciﬁcation, but portable programs may not rely on such extended
extents.
<!--l. 6826--><p class="indent" >   (This speciﬁcation is somewhat controversial. An alternative proposal was
that the abandoning of exits should be lumped in with the evaluation of
                                                                          

                                                                          
<a 
href="#x57-153004r133">unwind-protect</a> cleanup clauses and the undoing of dynamic bindings and <a 
href="#x57-152006r132">catch</a>
tags, performing all in reverse order of establishment. X3J13 agreed that this
approach is theoretically cleaner and more elegant but also more stringent and of
little additional practical use. There was some concern that a more stringent
speciﬁcation might be a great added burden to some implementors and would
achieve only a small gain for users.)
</div>
</div>
<div class=defspec>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> throw </b><a 
 id="dx57-154002"></a><a 
 id="x57-154003r134"></a> tag result
</td></tr></table>
<!--l. 6840--><p class="indent" >
</div>
<!--l. 6840--><p class="noindent" ><span class="paragraphHead"><a 
 id="x57-1550007.11"></a></span>
   The <a 
href="#x57-154003r134">throw</a> special form transfers control to a matching <a 
href="#x57-152006r132">catch</a> construct. The
<i>tag</i> is evaluated ﬁrst to produce an object called the throw tag; then the <i>result</i>
form is evaluated, and its results are saved (if the <i>result</i> form produces multiple
values, then <i>all</i> the values are saved). The most recent outstanding catch whose
tag matches the throw tag is exited; the saved results are returned as the value(s)
of the catch. A <a 
href="#x57-152006r132">catch</a> matches only if the catch tag is <a 
href="clmse33.html#x44-81002r46">eq</a> to the throw
tag.
<!--l. 6851--><p class="indent" >   In the process, dynamic variable bindings are undone back to the point of the
catch, and any intervening <a 
href="#x57-153004r133">unwind-protect</a> cleanup code is executed. The <i>result</i>
form is evaluated before the unwinding process commences, and whatever results
it produces are returned from the catch.
<!--l. 6857--><p class="indent" >   If there is no outstanding catcher whose tag matches the throw tag, no
unwinding of the stack is performed, and an error is signalled. When the error is
signalled, the outstanding catchers and the dynamic variable bindings are those in
force at the point of the throw.
<!--l. 6862--><p class="indent" >   Специальная форма <a 
href="#x57-154003r134">throw</a> переносит управление к соотвествующей
конструкции <a 
href="#x57-152006r132">catch</a>. Сначала выполняется <i>tag</i> для вычисления объекта,
                                                                          

                                                                          
называемого тег throw. Затем вычисляется форма результата <i>result</i>, и этот
результат сохраняется (если форма <i>result</i> возвращает несколько значений, то
<i>все</i> значения сохраняются). Управление выходит и самого последнего
установленного catch, тег которого совпадает с тегом throw. Сохраненные
результаты возвращаются, как значения конструкции <a 
href="#x57-152006r132">catch</a>. Теги catch и
throw совпадают, только если они равны <a 
href="clmse33.html#x44-81002r46">eq</a>.
<!--l. 6873--><p class="indent" >   В процессе, связывания динамических переменных упраздняются
до точки catch, и выполнятся все формы очистки в конструкциях
unwind-protect. Форма <i>result</i> вычисляется перед началом процесса
раскручивания, и ее значение возвращается из блока catch.
<!--l. 6878--><p class="indent" >   Если внешний блок catch с совпадающим тегом не найден, раскрутка стека
не происходит и сигнализируется ошибка. Когда ошибка сигнализируется,
ловушки и динамические связывания переменных являются теми, которые
были в точке throw.
<div class=implementation>
<!--l. 6884--><p class="noindent" ><b>Implementation note:</b> These requirements imply that throwing should typically
make two passes over the control stack. In the ﬁrst pass it simply searches for
a matching catch. In this search every <a 
href="#x57-152006r132">catch</a> must be considered, but every
<a 
href="#x57-153004r133">unwind-protect</a> should be ignored. On the second pass the stack is actually
unwound, one frame at a time, undoing dynamic bindings and outstanding
<a 
href="#x57-153004r133">unwind-protect</a> constructs in reverse order of creation until the matching catch is
reached.
</div>
<div class=incompatibility>
<!--l. 6897--><p class="noindent" ><b>Compatibility note:</b> The name <a 
href="#x57-154003r134">throw</a> comes from MacLisp, but the syntax of <a 
href="#x57-154003r134">throw</a> in
Common Lisp is diﬀerent. The MacLisp syntax was (throw <i>form</i> <i>tag</i>), where the <i>tag</i> was
not evaluated.
</div>
</div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
   <!--l. 6--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch8.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse44.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse44.html#tailclmse44.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse45.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse45.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 6--><p class="indent" >   <a 
 id="tailclmse45.html"></a>  
</body></html> 
