<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Определение макроса</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1218--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse46.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html#tailclmch8.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse45.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html#clmse45.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">8.1   </span> <a 
href="clm.html#QQ2-58-761" id="x58-7530008.1">Определение
макроса</a></h3>
<!--l. 1220--><p class="noindent" >Функция <tt><a 
href="#x58-753002r123">macro-function</a></tt> определяет, является ли данный символ именем
макроса. Конструкция <tt><a 
href="#x58-756002r124">defmacro</a></tt> предоставляет удобный способ определить
новый макрос.
<div class="defun">
<!--l. 1224--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx58-753001"></a><a 
 id="x58-753002r123"></a><b> macro-function</b>  <i>symbol</i> &#x0026;optional  <i>env</i>
</div>
<!--l. 1226--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7540008.1" id="x58-7540008.1"></a></span>
   Первый аргумент должен быть символом. Если символ содержит
определение функции, то есть определение макроса, локально созданное в
окружении <i>env</i> с помощью <tt><a 
href="clmse39.html#x51-601002r84">macrolet</a></tt> или глобально созданное с помощью
<tt><a 
href="#x58-756002r124">defmacro</a></tt>, тогда возвращается функция раскрытия (функция двух
аргументов, первый форма макровызова и второй — окружение). Если
символ не содержит определение функции, или это определение обычной
функции или это специальная форма, но не макрос, тогда возвращается <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>.
Наилучший способ вызвать функцию раскрытия использовать <tt><a 
href="clmse46.html#x59-798002r125">macroexpand</a></tt>
или <tt><a 
href="clmse46.html#x59-798004r126">macroexpand-1</a></tt>.
<!--l. 1237--><p class="indent" >   Возможно такое, что и <tt><a 
href="#x58-753002r123">macro-function</a></tt>, и <tt><a 
href="clmse35.html#x47-459002r58">special-operator-p</a></tt> обе
возвращают истину для одного заданного символа. Так происходит, потому
что реализация может для увеличения производительности реализовывать
                                                                          

                                                                          
любой макрос, как специальную форму. С другой стороны, определения
макросов должны быть доступны для использования программами, которые
понимают только стандартные специальные формы, перечисленные в
таблице <a 
href="clmse28.html#x38-2260011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>.
<tt>
<!--l. 1245--><p class="indent" >   <a 
href="clmse36.html#x48-474002r64">setf</a></tt> может быть использована с <tt><a 
href="#x58-753002r123">macro-function</a></tt> для установки в символ
глобального определения макроса: <div class="lisp"><div class="tabbing">
(setf (macro-function <i>symbol</i>) <i>fn</i>)
   <br>
<!--l. 1249--><p class="noindent" ></div>
<!--l. 1249--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7550008.1" id="x58-7550008.1"></a></span>
<!--l. 1249--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7560008.1" id="x58-7560008.1"></a></span>
</div>
<!--l. 1250--><p class="indent" >   Устанавливаемое значение должно быть функцией, которая принимает
два аргументы, список макровызова и окружение, и вычислять раскрытие
этого макровызова. Выполнение этой операции указывает на то, что символ
будет содержать <i>только</i> это определение макроса в качестве определения
глобальной функции. Предыдущее определение функции или макроса
утрачивается. С помощью <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> невозможно установить локальное
определение макроса. При использовании <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> указание второго параметра
(окружение) является ошибкой. Переопределение специальной формы также
является ошибкой.
<!--l. 1259--><p class="indent" >   Смотрите также <tt><a 
href="clmse48.html#x61-804003r130">compiler-macro-function</a></tt>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1263--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> defmacro </b><a 
 id="dx58-756001"></a><a 
 id="x58-756002r124"></a> name lambda-list [[{declaration}* | doc-string]] {form}*
   <br>
                                                                          

                                                                          
<!--l. 1264--><p class="noindent" ></div>
<!--l. 1264--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7570008.1" id="x58-7570008.1"></a></span>
</div>
<tt>
<!--l. 1265--><p class="indent" >   <a 
href="#x58-756002r124">defmacro</a></tt> является макросом определяющим макросы, которые
преобразуют формы макровызовов. <tt><a 
href="#x58-756002r124">defmacro</a></tt> имеет почти такой же
синтаксис, как и <tt><a 
href="clmse30.html#x40-261002r13">defun</a></tt>: <i>name</i> является символом, для которого создаётся
макрос, <i>lambda-list</i> похож на список параметров лямбда-выражения и <i>form</i>
содержит тело функции раскрытия. Конструкция <i>defmacro</i> устанавливает
функцию раскрытия, как глобальное определение макроса для символа
<i>name</i>. FIXME
<!--l. 1275--><p class="indent" >   Форма <tt><a 
href="#x58-756002r124">defmacro</a></tt> возвращает в качестве значение <i>name</i>.
<!--l. 1277--><p class="indent" >   Если мы рассмотрим макровызов, как список содержащий имя
функции и некоторые формы аргументов, то механизм заключается в
передаче в функцию <tt><a 
href="clmse37.html#x49-568002r73">apply</a></tt> этой функции и списка её (невычисленных)
аргументов. Спецификаторы параметров обрабатываются также, как и для
любого лямбда-выражения. В качестве параметров используются
формы аргументов макровызова. Затем вычисляются формы тела, как
неявный <tt><a 
href="clmse38.html#x50-580002r76">progn</a></tt>. Значение последней формы возвращается, как раскрытие
макровызова.
<!--l. 1285--><p class="indent" >   Если указана необязательная строка документации <i>doc-string</i>, тогда
она присоединяется к символу <i>name</i>, как строка документации типа
<tt><a 
href="clmse35.html#x47-433005r52">function</a></tt>. Смотрите <tt><a 
href="clmse143.html#x175-2635017r871">documentation</a></tt>. Если в определении макроса
представлена только строка документации, и после неё нет ни одной
формы, ни деклараций, ни просто для тела, то данная строка сама
становиться формой, и тело считается состоящим из одной формы — этой
строки.
<!--l. 1292--><p class="indent" >   Следующие три дополнительных маркера доступны в определении
лямбда-списка. <div class="indentdesc">
      <ul><li><b>
<tt>&#x0026;body</tt> </b></li>
      <!--l. 1296--><p class="noindent" >Данный  маркер  эквивалентен  <tt>&#x0026;rest</tt> маркеру,  но  дополнительно
      сообщает для функций вывода-форматирования и редактирования,
      что   оставшаяся   часть   формы   рассматривается   как   тело   и
      должна быть правильно отформатирована. (Можно использовать
      исключительно один маркер или <tt>&#x0026;body</tt>, или <tt>&#x0026;rest</tt>)
                                                                          

                                                                          
      <li><b>
<tt>&#x0026;whole</tt> </b></li>За  данным  маркером  указывается  одна  переменная,  которая
      будет связана со всей формой макровызова. Это значение, которое
      получает функция определения макроса в качестве своего первого
      аргумента. <tt>&#x0026;whole</tt> и следующая переменная должны указываться
      на первой позиции в лямбда-списке, перед другими параметрами
      или маркерами.
      <li><b>
<tt>&#x0026;environment</tt> </b></li>
      <!--l. 1310--><p class="noindent" >За данным маркером указывается одна переменная, которая будет
      связана с окружением, отображающим лексическое окружение, в
      котором произошёл макровызов. Это окружение может не быть
      полным  лексическим  окружением.  Оно  должно  использоваться
      только                 с                 функцией                 <tt><a 
href="clmse46.html#x59-798002r125">macroexpand</a></tt>
      ради  любых  локальных  определений  макросов,  которые  могли
      быть установлены с помощью <tt><a 
href="clmse39.html#x51-601002r84">macrolet</a></tt> конструкции внутри этого
      лексического окружения. Этот функционал полезен крайне редко,
      когда определение макроса должно явно раскрыть другие макросы
      в процессе своего раскрытия.</ul>
</div>
<!--l. 1320--><p class="indent" >   Смотрите <tt><a 
href="clmse29.html#x39-255002r11">lambda-list-keywords</a></tt>.
<tt>
<!--l. 1322--><p class="indent" >   <a 
href="#x58-756002r124">defmacro</a></tt>, в отличие от любых других конструкций Common Lisp&#x2019;а,
имеющих лямбда-списки в своём синтаксисе, предоставляет дополнительную
функциональность известную как <i>деструктуризация</i>.
<!--l. 1326--><p class="indent" >   Смотрите <tt><a 
href="clmse47.html#x60-801002r128">destructuring-bind</a></tt>, которая отдельно предоставляет эту
функциональность.
<!--l. 1328--><p class="indent" >   В любом месте, где могло бы стоять имя параметра, и где по синтаксису
не ожидается использование списка (как описано в разделе <a 
href="clmse29.html#x39-2310005.2.2">5.2.2<!--tex4ht:ref: LAMBDA-EXPRESSIONS-SECTION --></a>), можно
использовать ещё один встроенный лямбда-список. Когда использован такой
приём, при передаче форм аргументов для встроенного лямбда-списка,
необходимо обернуть эти формы в отдельный список. В качестве
примера, определение макроса для <tt><a 
href="clmse42.html#x54-668002r99">dolist</a></tt> можно записать в таком стиле:
<div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(defmacro dolist ((var listform <tt>&#x0026;optional</tt> resultform)
   <br>                                                                     &#x0026;rest body)<br>
  ...)<br>
<!--l. 1340--><p class="noindent" ></div>
<!--l. 1340--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7580008.1" id="x58-7580008.1"></a></span>
<!--l. 1340--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7590008.1" id="x58-7590008.1"></a></span>
</div>
<!--l. 1341--><p class="indent" >   Ниже будет больше примеров использования встраиваемых лямбда-списков в
<tt><a 
href="#x58-756002r124">defmacro</a></tt>.
<!--l. 1344--><p class="indent" >   Следующим правилом деструктуризации является то, что <tt><a 
href="#x58-756002r124">defmacro</a></tt>
позволяет любому лямбда-списку (верхнего уровня или встроенному) быть
dotted, заканчивающимся именем параметра. Такая ситуация обрабатывается
так, как будто имя параметра в конце списка, стоит после неявного маркера
<tt>&#x0026;rest</tt>. Например, уже показанное определение <tt><a 
href="clmse42.html#x54-668002r99">dolist</a></tt> может быть записано
так: <div class="lisp"><div class="tabbing">
(defmacro dolist ((var listform &#x0026;optional resultform)
   <br>                                                                           . body)<br>
  ...)<br>
<!--l. 1353--><p class="noindent" ></div>
<!--l. 1353--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7600008.1" id="x58-7600008.1"></a></span>
<!--l. 1353--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7610008.1" id="x58-7610008.1"></a></span>
</div>
<!--l. 1355--><p class="indent" >   Если компилятор встречает <tt><a 
href="#x58-756002r124">defmacro</a></tt>, он добавляет новый макрос в
окружение компиляции, и также функция раскрытия добавляется в
выходной файл. Таким образом новый макрос будет более быстрым во время
выполнения. Если необходимо избежать такого механизма, можно
использовать <tt><a 
href="#x58-756002r124">defmacro</a></tt> внутри конструкции <tt><a 
href="clmse30.html#x40-285002r17">eval-when</a></tt>.
                                                                          

                                                                          
<tt>
<!--l. 1361--><p class="indent" >   <a 
href="#x58-756002r124">defmacro</a></tt> может также использоваться для переопределения макроса
(например, для установки корректной версии определения вместо
некорректной), или для переопределения функции в макрос. Переопределение
специальной формы (смотрите таблицу <a 
href="clmse28.html#x38-2260011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>) не допускается. Смотрите
<tt><a 
href="clmse39.html#x51-601002r84">macrolet</a></tt>, которая устанавливает определение макроса в замкнутом
лексическом области видимости.
<!--l. 1369--><p class="indent" >   Допустим, для примера, что необходимо реализовать условную
конструкцию аналогичную Fortran&#x2019;овскому арифметическому выражению
IF. (Это конечно требует определённого расширения воображения
и приостановки неверия.) Конструкция должна принимать четыре
формы: <i>test-value</i>, <i>neg-form</i>, <i>zero-form</i> и <i>pos-form</i>. В зависимости от того,
является ли <i>test-form</i> отрицательным, нулём или положительным
числом, для выполнения будет выбрана одна из трёх последних форм. С
использованием <tt><a 
href="#x58-756002r124">defmacro</a></tt>, определение этой конструкции может выглядеть
так: <div class="lisp"><div class="tabbing">
(defmacro arithmetic-if (test neg-form zero-form pos-form)
   <br>                    (let ((var (gensym)))<br>                      ‘(let ((,var ,test))<br>
       (cond ((&#x003C; ,var 0) ,neg-form)<br>              ((= ,var 0) ,zero-form)<br>
             (t ,pos-form)))))<br>
<!--l. 1388--><p class="noindent" ></div>
<!--l. 1388--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7620008.1" id="x58-7620008.1"></a></span>
<!--l. 1388--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7630008.1" id="x58-7630008.1"></a></span>
</div>
<!--l. 1389--><p class="indent" >   Необходимо отметить, что в данном определении используется
функциональность обратной кавычки (смотрите раздел <a 
href="clmse111.html#x138-171800022.1.3">22.1.3<!--tex4ht:ref: MACRO-CHARACTERS-SECTION --></a>). Также
необходимо заметить, что используется <tt><a 
href="clmse55.html#x70-889002r153">gensym</a></tt> для создания нового имени
переменной. Это необходимо для избежания конфликтов с другими
переменными, которые могут использоваться в формах <i>neg-form</i>, <i>zero-form</i>
или <i>pos-form</i>.
                                                                          

                                                                          
<!--l. 1396--><p class="indent" >   Если форма выполняется интерпретатором, то определение функции для
символа <tt>arithmetic-if</tt> будет является макросом, с которым ассоциирована
функция двух аргументом эквивалентная данной <div class="lisp"><div class="tabbing">
(lambda (calling-form environment)
   <br>                                                      (declare (ignore environment))<br>
  (let ((var (gensym)))<br>                                           (list &#x2019;let<br>
          (list (list &#x2019;var (cadr calling-form)))<br>                 (list &#x2019;cond<br>
                (list (list &#x2019;&#x003C; var &#x2019;0) (caddr calling-form))<br>
                (list (list &#x2019;= var &#x2019;0) (cadddr calling-form))<br>
                (list &#x2019;t (ﬁfth calling-form))))))<br>
<!--l. 1409--><p class="noindent" ></div>
<!--l. 1409--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7640008.1" id="x58-7640008.1"></a></span>
<!--l. 1409--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7650008.1" id="x58-7650008.1"></a></span>
</div>
<!--l. 1410--><p class="indent" >   Лямбда-выражение является результатом выполнения декларации
<tt><a 
href="#x58-756002r124">defmacro</a></tt>. Вызов <tt><a 
href="clmse83.html#x103-1304002r458">list</a></tt> является (гипотетически) результатом макросимвола
обратной кавычки (<tt>‘</tt>) и связанной с ним запятой. Конкретная функция
раскрытия макроса может зависеть от реализации, например, она также
может содержать проверку на корректность входных аргументов в
макровызове.
<!--l. 1416--><p class="indent" >   Теперь, если <tt><a 
href="clmse106.html#x131-1633002r580">eval</a></tt> встретит <div class="lisp"><div class="tabbing">
(arithmetic-if (- x 4.0)
   <br>                     (- x)<br>                     (error &#x0022;Strange zero&#x0022;)<br>
               x)<br>
<!--l. 1422--><p class="noindent" ></div>
<!--l. 1422--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7660008.1" id="x58-7660008.1"></a></span>
                                                                          

                                                                          
<!--l. 1422--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7670008.1" id="x58-7670008.1"></a></span>
</div>
<!--l. 1423--><p class="indent" >   то раскроет эту форму в <div class="lisp"><div class="tabbing">
(let ((g407 (- x 4.0)))
   <br>   (cond ((&#x003C; g407 0) (- x))<br>         ((= g407 0) (error &#x0022;Strange zero&#x0022;))<br>
        (t x)))<br>
<!--l. 1429--><p class="noindent" ></div>
<!--l. 1429--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7680008.1" id="x58-7680008.1"></a></span>
<!--l. 1429--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7690008.1" id="x58-7690008.1"></a></span>
</div>
<!--l. 1430--><p class="indent" >   и <tt><a 
href="clmse106.html#x131-1633002r580">eval</a></tt> выполнит полученную форму. (Сейчас должно быть понятно, что
функциональность обратной кавычки очень полезна для написания
макросов. Она используется для построения шаблона, возвращаемой
формы, с константными частями и частями для выполнения. Шаблон
представляет собой «картину» кода, с местами для заполнения выделенными
запятыми.)
<!--l. 1436--><p class="indent" >   Для улучшения примера мы можем сделать так, чтобы <i>pos-form</i> и
<i>zero-form</i> могли быть заменены на <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> в результате раскрытия макроса.
Таким же образом действует и <tt><a 
href="clmse133.html#x163-2394002r817">if</a></tt> опуская ветку <i>else</i> в случае истинности
условия. <div class="lisp"><div class="tabbing">
(defmacro arithmetic-if (test neg-form
   <br>                                       <tt>&#x0026;optional</tt> zero-form pos-form)<br>
  (let ((var (gensym)))<br>                                  ‘(let ((,var ,test))<br>
       (cond ((&#x003C; ,var 0) ,neg-form)<br>              ((= ,var 0) ,zero-form)<br>
             (t ,pos-form)))))<br>
<!--l. 1448--><p class="noindent" ></div>
<!--l. 1448--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7700008.1" id="x58-7700008.1"></a></span>
                                                                          

                                                                          
<!--l. 1448--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7710008.1" id="x58-7710008.1"></a></span>
</div>
<!--l. 1449--><p class="indent" >   Тогда можно записать <div class="lisp"><div class="tabbing">
(arithmetic-if (- x 4.0) (print x))
   <br>
<!--l. 1452--><p class="noindent" ></div>
<!--l. 1452--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7720008.1" id="x58-7720008.1"></a></span>
<!--l. 1452--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7730008.1" id="x58-7730008.1"></a></span>
</div>
<!--l. 1453--><p class="indent" >   и это раскроется в что-то вроде <div class="lisp"><div class="tabbing">
(let ((g408 (- x 4.0)))
   <br>             (cond ((&#x003C; g408 0) (print x))<br>                   ((= g408 0) nil)<br>
        (t nil)))<br>
<!--l. 1459--><p class="noindent" ></div>
<!--l. 1459--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7740008.1" id="x58-7740008.1"></a></span>
<!--l. 1459--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7750008.1" id="x58-7750008.1"></a></span>
</div>
<!--l. 1460--><p class="indent" >   Результирующий код корректен, но некрасиво выглядит. Можно
переписать определение макроса для генерации лучшего кода, когда <i>pos-form</i>
и <i>zero-form</i> могут быть вообще опущены. Или же можно положиться на
реализацию Common Lisp&#x2019;а, которая возможно оптимизирует этот
код.
                                                                          

                                                                          
<!--l. 1466--><p class="indent" >   Деструктуризация является очень мощной функциональностью, которая
позволяет лямбда-списку в <tt><a 
href="#x58-756002r124">defmacro</a></tt> выразить сложную структуру
макровызова. Если не использовались ключевые символы лямбда-списка, то
он представляет собой просто список с некоторой степенью вложенности и
параметрами в качестве листьев. Структура макровызова должна иметь
такую же структуру списка. Например, рассмотрим следующее определение
макроса: <div class="lisp"><div class="tabbing">
(defmacro halibut ((mouth eye1 eye2)
   <br>                                             ((ﬁn1 length1) (ﬁn2 length2))<br>
                   tail)<br>                                             ...)<br>
<!--l. 1477--><p class="noindent" ></div>
<!--l. 1477--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7760008.1" id="x58-7760008.1"></a></span>
<!--l. 1477--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7770008.1" id="x58-7770008.1"></a></span>
</div>
<!--l. 1478--><p class="indent" >   Теперь давайте рассмотрим макровызов: <div class="lisp"><div class="tabbing">
(halibut (m (car eyes) (cdr eyes))
   <br>                                ((f1 (count-scales f1)) (f2 (count-scales f2)))<br>
         my-favorite-tail)<br>
<!--l. 1483--><p class="noindent" ></div>
<!--l. 1483--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7780008.1" id="x58-7780008.1"></a></span>
<!--l. 1483--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7790008.1" id="x58-7790008.1"></a></span>
</div>
<!--l. 1484--><p class="indent" >   Все это приведёт к тому, что функция раскрытия получит следующие
значения для её параметров:
                                                                          

                                                                          
<div class="flushleft" 
>
<!--l. 1486--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Параметр</td><td align="left" >Значение         </td>
</tr><tr><td align="left" >mouth     </td><td align="left" >m                   </td>
</tr><tr><td align="left" >eye1        </td><td align="left" >(car eyes)         </td>
</tr><tr><td align="left" >eye2        </td><td align="left" >(cdr eyes)         </td>
</tr><tr><td align="left" >ﬁn1         </td><td align="left" >f1                   </td>
</tr><tr><td align="left" >length1    </td><td align="left" >(count-scales f1)</td>
</tr><tr><td align="left" >ﬁn2         </td><td align="left" >f2                   </td>
</tr><tr><td align="left" >length2    </td><td align="left" >(count-scales f2)</td>
</tr><tr><td align="left" >tail         </td><td align="left" >my-favorite-tail </td></tr><tr><td align="left" > </td></tr></table></div></div>
<!--l. 1499--><p class="noindent" >Следующий макровызов ошибочный, так как аргумента для параметра <tt>length1</tt>
не представлено: <div class="lisp"><div class="tabbing">
(halibut (m (car eyes) (cdr eyes))
   <br>                                                       ((f1) (f2 (count-scales f2)))<br>
         my-favorite-tail)<br>
<!--l. 1505--><p class="noindent" ></div>
<!--l. 1505--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7800008.1" id="x58-7800008.1"></a></span>
<!--l. 1505--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7810008.1" id="x58-7810008.1"></a></span>
</div>
<!--l. 1506--><p class="indent" >   Следующий макровызов также ошибочный, так как на месте
предполагаемого списка указан символ. <div class="lisp"><div class="tabbing">
(halibut my-favorite-head
   <br>                                ((f1 (count-scales f1)) (f2 (count-scales f2)))<br>
         my-favorite-tail)<br>
<!--l. 1512--><p class="noindent" ></div>
<!--l. 1512--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7820008.1" id="x58-7820008.1"></a></span>
                                                                          

                                                                          
<!--l. 1512--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7830008.1" id="x58-7830008.1"></a></span>
</div>
<!--l. 1513--><p class="indent" >   Тот факт, что значение переменной <tt>my-favorite-head</tt> может быть
списком, не имеет здесь значения. В макровызове структура должна
совпадать с лямбда-списком в определении.
<!--l. 1517--><p class="indent" >   Использование ключевых символов лямбда-списка предоставляет ещё
большую гибкость. Например, предположим, что удобно будет в функции
раскрытия обращаться к элементам списка, называемым cdmouth, <tt>eye1</tt>, and
<tt>eye2</tt>, как к <tt>head</tt>. Можно записать так: <div class="lisp"><div class="tabbing">
(defmacro halibut ((<tt>&#x0026;whole</tt> head mouth eye1 eye2)
   <br>                                             ((ﬁn1 length1) (ﬁn2 length2))<br>
                   tail)<br>
<!--l. 1527--><p class="noindent" ></div>
<!--l. 1527--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7840008.1" id="x58-7840008.1"></a></span>
<!--l. 1527--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7850008.1" id="x58-7850008.1"></a></span>
</div>
<!--l. 1528--><p class="indent" >   Теперь рассмотрим такой же, как раньше, корректный макровызов:
<div class="lisp"><div class="tabbing">
(halibut (m (car eyes) (cdr eyes))
   <br>                                ((f1 (count-scales f1)) (f2 (count-scales f2)))<br>
         my-favorite-tail)<br>
<!--l. 1533--><p class="noindent" ></div>
<!--l. 1533--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7860008.1" id="x58-7860008.1"></a></span>
                                                                          

                                                                          
<!--l. 1533--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7870008.1" id="x58-7870008.1"></a></span>
</div>
<!--l. 1534--><p class="indent" >   Это приведёт к тому, что функции раскрытия получит те же значения
для своих параметров, а также значение для параметра <tt>head</tt>:
<div class="flushleft" 
>
<!--l. 1536--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Parameter</td><td align="left" >Value                         </td></tr><tr><td align="left" >head </td> <td align="left" >(m (car eyes) (cdr eyes))</td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
<!--l. 1546--><p class="indent" >   Существует условие для деструктуризации, встроенный лямбда-список
разрешён только на позиции, где синтаксис лямбда-списка предусматривает
имя параметра, но не список. Это защищает от двусмысленности. Например,
нельзя записать <div class="lisp"><div class="tabbing">
(defmacro loser (x <tt>&#x0026;optional</tt> (a b <tt>&#x0026;rest</tt> c) <tt>&#x0026;rest</tt> z)
   <br>                                                                                          ...)<br>
<!--l. 1552--><p class="noindent" ></div>
<!--l. 1552--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7880008.1" id="x58-7880008.1"></a></span>
<!--l. 1552--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7890008.1" id="x58-7890008.1"></a></span>
</div>
<!--l. 1553--><p class="indent" >   потому что синтаксис лямбда-списка не позволяет использовать списки
после <tt>&#x0026;optional</tt>. Список <tt>(a b <tt>&#x0026;rest</tt> c)</tt> был бы интерпретирован как
необязательный параметр <tt>a</tt>, у которого значение по умолчанию <tt>b</tt>, и
supplied-p параметр с некорректным именем <tt>&#x0026;rest</tt>, и дополнительным
символом <tt>c</tt>, также некорректным. Было бы правильнее выразить это так:
<div class="lisp"><div class="tabbing">
(defmacro loser (x <tt>&#x0026;optional</tt> ((a b <tt>&#x0026;rest</tt> c)) <tt>&#x0026;rest</tt> z)
   <br>                                                                                          ...)<br>
<!--l. 1561--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1561--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7900008.1" id="x58-7900008.1"></a></span>
<!--l. 1561--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7910008.1" id="x58-7910008.1"></a></span>
</div>
<!--l. 1562--><p class="indent" >   Дополнительные круглые скобки устраняют двусмысленность. Однако,
такой макровызов, как <tt>(loser (car pool))</tt> не предоставляет никакой
формы аргумента для лямбда-списка <tt>(a b <tt>&#x0026;rest</tt> c)</tt>, значит значение по
умолчанию для него будет <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. А так как <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> является пустым списком, то
этот макровызов ошибочен. Полностью корректное определение выглядит
так: <div class="lisp"><div class="tabbing">
(defmacro loser (x <tt>&#x0026;optional</tt> ((a b <tt>&#x0026;rest</tt> c) &#x2019;(nil nil)) <tt>&#x0026;rest</tt> z)
   <br>                                                                                          ...)<br>
<!--l. 1570--><p class="noindent" ></div>
<!--l. 1570--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7920008.1" id="x58-7920008.1"></a></span>
<!--l. 1570--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7930008.1" id="x58-7930008.1"></a></span>
</div>
<!--l. 1571--><p class="indent" >   или так <div class="lisp"><div class="tabbing">
(defmacro loser (x <tt>&#x0026;optional</tt> ((<tt>&#x0026;optional</tt> a b <tt>&#x0026;rest</tt> c)) <tt>&#x0026;rest</tt> z)
   <br>                                                                                          ...)<br>
<!--l. 1575--><p class="noindent" ></div>
<!--l. 1575--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7940008.1" id="x58-7940008.1"></a></span>
                                                                          

                                                                          
<!--l. 1575--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7950008.1" id="x58-7950008.1"></a></span>
</div>
<!--l. 1576--><p class="indent" >   Они слегка отличаются: первое определение требует, что если
макровызов явно указывает <tt>a</tt>, тогда он должен указать явно и <tt>b</tt>, тогда
как второе определение не содержит такого требования. Например,
<div class="lisp"><div class="tabbing">
(loser (car pool) ((+ x 1)))
   <br>
<!--l. 1581--><p class="noindent" ></div>
<!--l. 1581--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7960008.1" id="x58-7960008.1"></a></span>
<!--l. 1581--><p class="noindent" ><span class="paragraphHead"><a 
href="#x58-7970008.1" id="x58-7970008.1"></a></span>
</div>
<!--l. 1582--><p class="indent" >   будет корректным макровызовом для второго определения, но не для
первого.
</div>
                                                                          

                                                                          
<!--l. 1585--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse46.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html#tailclmch8.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse45.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html#clmse45.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse45.html"></a>  </div> </div> 
</body></html> 
