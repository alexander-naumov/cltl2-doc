<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Функции для манипуляции с байтами</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 23:44:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 6814--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse72.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse70.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse70.html#tailclmse70.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse71.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse71.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">12.8   </span> <a 
href="clm.html#QQ2-88-1275" id="x88-124600012.8">Функции для
манипуляции с байтами</a></h3>
<!--l. 6816--><p class="noindent" >Common Lisp содержит несколько функций для работы с полями смежных
битов произвольной длины, находящимися где-нибудь в целом числе. Такое
множество смежных битов называется <i>байт</i>. В Common Lisp&#x2019;е термин <i>байт</i>
не означает некоторое определённое количество бит (как например
восемь), а обозначает поле произвольной, определяемой пользователем
длины.
<!--l. 6823--><p class="indent" >   Функции обработки байтом используют объекты, называющиеся
<i>спецификаторы байта</i> для определения заданной позиции байта в целом
числе. Представление спецификатора байта зависит от реализации. В
частности оно может быть или не быть числом. Достаточно знать, что
функция <tt><a 
href="clmli7.html#x196-3479158r158">byte</a></tt> будет создавать такой спецификатор, и что функция для
обработки байта будет принимать его. Функция <tt><a 
href="clmli7.html#x196-3479158r158">byte</a></tt> принимает два
целых числа указывающих на <i>позицию</i> и <i>размер</i> байта и возвращает
его спецификатор. Такой спецификатор определяет байт, у которого
ширина равна <i>размеру</i>, и биты которого имеют веса с <span class="math">2<sup>position+size−1</sup></span> по
<span class="math">2<sup>position</sup></span>.
<div class="defun">
<!--l. 6835--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx88-1246001"></a><a 
 id="x88-1246002r291"></a><b> byte</b>  <i>size</i> <i>position</i>
</div>
<!--l. 6837--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-124700012.8" id="x88-124700012.8"></a></span>
<tt>
   <a 
href="clmli7.html#x196-3479158r158">byte</a></tt> принимает два целых числа, указывающих на размер и позицию
байта и возвращает спецификатор, который может использоваться в
функциях работы с байтами.
</div>
<div class="defun">
<!--l. 6843--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx88-1247001"></a><a 
 id="x88-1247002r292"></a><b> byte-size</b>  <i>bytespec</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx88-1247003"></a><a 
 id="x88-1247004r293"></a><b> byte-position</b>  <i>bytespec</i>
</div>
                                                                          

                                                                          
<!--l. 6846--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-124800012.8" id="x88-124800012.8"></a></span>
   Принимая спецификатор байта, <tt><a 
href="clmli7.html#x196-3479160r160">byte-size</a></tt> возвращает размер
указанного байта, а <tt><a 
href="clmli7.html#x196-3479159r159">byte-position</a></tt> — позицию этого байта. Например:
<div class="lisp"><div class="tabbing">
(byte-size (byte <i>j</i> <i>k</i>)) <span class="math"> ≡</span> <i>j</i>
   <br>                                                  (byte-position (byte <i>j</i> <i>k</i>)) <span class="math"> ≡</span> <i>k</i><br>
<!--l. 6853--><p class="noindent" ></div>
<!--l. 6853--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-124900012.8" id="x88-124900012.8"></a></span>
<!--l. 6853--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-125000012.8" id="x88-125000012.8"></a></span>
</div>
</div>
<div class="defun">
<!--l. 6856--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx88-1250001"></a><a 
 id="x88-1250002r294"></a><b> ldb</b>  <i>bytespec</i> <i>integer</i>
</div>
<!--l. 6858--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-125100012.8" id="x88-125100012.8"></a></span>
   Спецификатор байта <i>bytespec</i> указывает на байт, который будет извлечён
из целого числа <i>integer</i>. Результат возвращается в качестве неотрицательного
целого числа. Например: <div class="lisp"><div class="tabbing">
(logbitp <i>j</i> (ldb (byte <i>s</i> <i>p</i>) <i>n</i>)) <span class="math"> ≡</span> (and (&#x003C; <i>j</i> <i>s</i>) (logbitp (+ <i>j</i> <i>p</i>) <i>n</i>))
   <br>
<!--l. 6865--><p class="noindent" ></div>
<!--l. 6865--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-125200012.8" id="x88-125200012.8"></a></span>
                                                                          

                                                                          
<!--l. 6865--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-125300012.8" id="x88-125300012.8"></a></span>
</div>
<!--l. 6866--><p class="indent" >   Имя функции <tt><a 
href="clmli7.html#x196-3479504r504">ldb</a></tt> означает «load byte (загрузить байт)».
<!--l. 6868--><p class="indent" >   Если аргумент <i>integer</i> задан формой, которая может использоваться в
<tt><a 
href="clmli7.html#x196-3479840r840">setf</a></tt>, тогда <tt><a 
href="clmli7.html#x196-3479840r840">setf</a></tt> может использоваться вместе с <tt><a 
href="clmli7.html#x196-3479504r504">ldb</a></tt> для изменения байта в
целом числе указанном в форме <i>integer</i>. Это действие выполняется с
помощью операции <tt><a 
href="clmli7.html#x196-3479350r350">dpb</a></tt>.
</div>
<div class="defun">
<!--l. 6874--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx88-1253001"></a><a 
 id="x88-1253002r295"></a><b> ldb-test</b>  <i>bytespec</i> <i>integer</i>
</div>
<!--l. 6876--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-125400012.8" id="x88-125400012.8"></a></span>
<tt>
   <a 
href="clmli7.html#x196-3479505r505">ldb-test</a></tt> является предикатом, который истинен, если любой из битов,
указанных в спецификаторе байта <i>bytespec</i>, в целом числе <i>integer</i> имеет
значение 1. Другими словами, предикат истинен, если указанное поле не
равно нулю. <div class="lisp"><div class="tabbing">
(ldb-test <i>bytespec</i> <i>n</i>) <span class="math"> ≡</span> (not (zerop (ldb <i>bytespec</i> <i>n</i>)))
   <br>
<!--l. 6883--><p class="noindent" ></div>
<!--l. 6883--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-125500012.8" id="x88-125500012.8"></a></span>
<!--l. 6883--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-125600012.8" id="x88-125600012.8"></a></span>
</div>
</div>
<div class="defun">
<!--l. 6886--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx88-1256001"></a><a 
 id="x88-1256002r296"></a><b> mask-ﬁeld</b>  <i>bytespec</i> <i>integer</i>
</div>
                                                                          

                                                                          
<!--l. 6888--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-125700012.8" id="x88-125700012.8"></a></span>
   Функция похожа а <tt><a 
href="clmli7.html#x196-3479504r504">ldb</a></tt>. Однако результат содержит указанный байт
целого числа <i>integer</i> в той же позиции, что указана в спецификаторе <i>bytespec</i>,
а не в нулевой позиции, как делает <tt><a 
href="clmli7.html#x196-3479504r504">ldb</a></tt>. Таким образом результат в
указанном байте совпадает с целым числом <i>integer</i> , но в остальных местах
имеет нулевые биты. Например: <div class="lisp"><div class="tabbing">
(ldb <i>bs</i> (mask-ﬁeld <i>bs</i> <i>n</i>)) <span class="math"> ≡</span> (ldb <i>bs</i> <i>n</i>)
   <br>                        <br>                        (logbitp <i>j</i> (mask-ﬁeld (byte <i>s</i> <i>p</i>) <i>n</i>))<br>
   <span class="math"> ≡</span> (and (&#x003E;= <i>j</i> <i>p</i>) (&#x003C; <i>j</i> (+ <i>p</i> <i>s</i>)) (logbitp <i>j</i> <i>n</i>))<br>                         <br>
(mask-ﬁeld <i>bs</i> <i>n</i>) <span class="math"> ≡</span> (logand <i>n</i> (dpb -1 <i>bs</i> 0))<br>
<!--l. 6902--><p class="noindent" ></div>
<!--l. 6902--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-125800012.8" id="x88-125800012.8"></a></span>
<!--l. 6902--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-125900012.8" id="x88-125900012.8"></a></span>
</div>
<!--l. 6904--><p class="indent" >   Если аргумент <i>integer</i> задан формой, которая может использоваться в
<tt><a 
href="clmli7.html#x196-3479840r840">setf</a></tt>, тогда <tt><a 
href="clmli7.html#x196-3479840r840">setf</a></tt> может использоваться вместе с <tt><a 
href="clmli7.html#x196-3479604r604">mask-field</a></tt> для изменения
байта в целом числе указанном в форме <i>integer</i>. Это действие выполняется с
помощью операции <tt><a 
href="clmli7.html#x196-3479329r329">deposit-field</a></tt>.
</div>
<div class="defun">
<!--l. 6910--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx88-1259001"></a><a 
 id="x88-1259002r297"></a><b> dpb</b>  <i>newbyte</i> <i>bytespec</i> <i>integer</i>
</div>
<!--l. 6912--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-126000012.8" id="x88-126000012.8"></a></span>
   Данная функция возвращает число, которое похоже на <i>integer</i> за
исключением битов, указанных спецификатором <i>bytespec.</i>. Пусть <i>s</i> будет
размером, указанным в спецификаторе <i>bytespec</i>. Тогда целое число <i>newbyte</i>
будет интерпретировано, будучи выровненным вправо, как если бы было
результатом <tt><a 
href="clmli7.html#x196-3479504r504">ldb</a></tt>. Например: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(logbitp <i>j</i> (dpb <i>m</i> (byte <i>s</i> <i>p</i>) <i>n</i>))
   <br>      <span class="math"> ≡</span> (if (and (&#x003E;= <i>j</i> <i>p</i>) (&#x003C; <i>j</i> (+ <i>p</i> <i>s</i>)))<br>                (logbitp (- <i>j</i> <i>p</i>) <i>m</i>)<br>
         (logbitp <i>j</i> <i>n</i>))<br>
<!--l. 6924--><p class="noindent" ></div>
<!--l. 6924--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-126100012.8" id="x88-126100012.8"></a></span>
<!--l. 6924--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-126200012.8" id="x88-126200012.8"></a></span>
</div>
<!--l. 6925--><p class="indent" >   Имя функции <tt><a 
href="clmli7.html#x196-3479350r350">dpb</a></tt> означает «deposit byte (сохранить байт)».
</div>
<div class="defun">
<!--l. 6928--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx88-1262001"></a><a 
 id="x88-1262002r298"></a><b> deposit-ﬁeld</b>  <i>newbyte</i> <i>bytespec</i> <i>integer</i>
</div>
<!--l. 6930--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-126300012.8" id="x88-126300012.8"></a></span>
   Данная функция относится к <tt><a 
href="clmli7.html#x196-3479604r604">mask-field</a></tt> так же, как <tt><a 
href="clmli7.html#x196-3479350r350">dpb</a></tt> относится к
<tt><a 
href="clmli7.html#x196-3479504r504">ldb</a></tt>. Результатом является целое число, которое содержит биты <i>newbyte</i> в
том месте, куда указывает спецификатор <i>bytespec</i>, и биты числа <i>integer</i> во
всех остальных местах. <div class="lisp"><div class="tabbing">
(logbitp <i>j</i> (deposit-ﬁeld <i>m</i> (byte <i>s</i> <i>p</i>) <i>n</i>))
   <br>         <span class="math"> ≡</span> (if (and (&#x003E;= <i>j</i> <i>p</i>) (&#x003C; <i>j</i> (+ <i>p</i> <i>s</i>)))<br>                   (logbitp <i>j</i> <i>m</i>)<br>
          (logbitp <i>j</i> <i>n</i>))<br>
<!--l. 6941--><p class="noindent" ></div>
<!--l. 6941--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-126400012.8" id="x88-126400012.8"></a></span>
<!--l. 6941--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-126500012.8" id="x88-126500012.8"></a></span>
</div>
<div class="implementation">
                                                                          

                                                                          
<!--l. 6944--><p class="noindent" ><b>Заметка для реализации:</b> If the <i>bytespec</i> is a constant, one may of course
construct, at compile time, an equivalent mask <i>m</i>, for example by computing
<tt>(deposit-field -1 <i>bytespec</i> 0)</tt>. Given this mask <i>m</i>, one may then compute
<div class="lisp"><div class="tabbing">
(deposit-ﬁeld <i>newbyte</i> <i>bytespec</i> <i>integer</i>)
   <br>
<!--l. 6951--><p class="noindent" ></div>
<!--l. 6951--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-126600012.8" id="x88-126600012.8"></a></span>
<!--l. 6951--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-126700012.8" id="x88-126700012.8"></a></span>
</div>
<!--l. 6952--><p class="indent" >   by computing <div class="lisp"><div class="tabbing">
(logior (logand <i>newbyte</i> <i>m</i>) (logand <i>integer</i> (lognot <i>m</i>)))
   <br>
<!--l. 6955--><p class="noindent" ></div>
<!--l. 6955--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-126800012.8" id="x88-126800012.8"></a></span>
<!--l. 6955--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-126900012.8" id="x88-126900012.8"></a></span>
</div>
<!--l. 6956--><p class="indent" >   where the result of <tt>(lognot <i>m</i>)</tt> can of course also be computed at compile time.
However, the following expression may also be used and may require fewer temporary
registers in some situations: <div class="lisp"><div class="tabbing">
(logxor <i>integer</i> (logand <i>m</i> (logxor <i>integer</i> <i>newbyte</i>)))
   <br>
<!--l. 6962--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 6962--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-127000012.8" id="x88-127000012.8"></a></span>
<!--l. 6962--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-127100012.8" id="x88-127100012.8"></a></span>
</div>
<!--l. 6963--><p class="indent" >   A related, though possibly less useful, trick is that <div class="lisp"><div class="tabbing">
(let ((z (logand (logxor x y) m)))
   <br>                                                                           (setq x (logxor z x))<br>
  (setq y (logxor z y)))<br>
<!--l. 6968--><p class="noindent" ></div>
<!--l. 6968--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-127200012.8" id="x88-127200012.8"></a></span>
<!--l. 6968--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-127300012.8" id="x88-127300012.8"></a></span>
</div>
<!--l. 6969--><p class="indent" >   interchanges those bits of <tt>x</tt> and <tt>y</tt> for which the mask <tt>m</tt> is <tt>1</tt>, and leaves alone those
bits of <tt>x</tt> and <tt>y</tt> for which <tt>m</tt> is <tt>0</tt>.
</div>
</div>
                                                                          

                                                                          
<!--l. 6976--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse72.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse70.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse70.html#tailclmse70.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse71.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse71.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse71.html"></a>   </div> </div> 
</body></html> 
