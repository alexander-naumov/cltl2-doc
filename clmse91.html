<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Array Information</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-18 01:47:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 424--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse92.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse90.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse90.html#tailclmse90.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse91.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch17.html#clmse91.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">17.3   </span> <a 
 id="x113-21700017.3"></a>Array Information</h3>
<!--l. 426--><p class="noindent" >The following functions extract from an array interesting information other than
the elements.
<div class=defun>
<!--l. 429--><p class="noindent" ><i>[Function]</i><a 
 id="dx113-217001"></a><a 
 id="x113-217002r527"></a><b> array-element-type</b>  <i>array</i>
<!--l. 431--><p class="noindent" ><a 
href="#x113-217002r527">array-element-type</a> returns a type speciﬁer for the set of objects that can be
stored in the <i>array</i>. This set may be larger than the set requested when the array
was created; for example, the result of <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(array-element-type (make-array 5 :element-type &#x2019;(mod 5)))
</td></tr></table>
<!--l. 438--><p class="indent" >
</div>
</div>
<!--l. 439--><p class="noindent" >could be (mod 5), (mod 8), ﬁxnum, <a 
href="clmse31.html#x42-74004r19">t</a>, or any other type of which (mod 5) is a
subtype. See <a 
href="clmse32.html#x43-76004r21">subtypep</a>.
</div>
<div class=defun>
<!--l. 443--><p class="noindent" ><i>[Function]</i><a 
 id="dx113-217003"></a><a 
 id="x113-217004r528"></a><b> array-rank</b>  <i>array</i>
<!--l. 445--><p class="noindent" >This returns the number of dimensions (axes) of <i>array</i>. This will be a
non-negative integer. See <a 
href="clmse89.html#x111-215007r521">array-rank-limit</a>.
<div class=incompatibility>
<!--l. 451--><p class="noindent" ><b>Compatibility note:</b> In Lisp Machine Lisp, this is called array-#-dims. This name
causes problems in other Lisp dialects because of the # character.
</div>
</div>
<div class=defun>
<!--l. 459--><p class="noindent" ><i>[Function]</i><a 
 id="dx113-217005"></a><a 
 id="x113-217006r529"></a><b> array-dimension</b>  <i>array</i> <i>axis-number</i>
<!--l. 461--><p class="noindent" >The length of dimension number <i>axis-number</i> of the <i>array</i> is returned. <i>array</i> may
be any kind of array, and <i>axis-number</i> should be a non-negative integer less than
                                                                          

                                                                          
the rank of <i>array</i>. If the <i>array</i> is a vector with a ﬁll pointer, <a 
href="#x113-217006r529">array-dimension</a>
returns the total size of the vector, including inactive elements, not the size
indicated by the ﬁll pointer. (The function <a 
href="clmse76.html#x95-196008r365">length</a> will return the size indicated by
the ﬁll pointer.)
<div class=incompatibility>
<!--l. 473--><p class="noindent" ><b>Compatibility note:</b> This is similar to the Lisp Machine Lisp function array-dimension-n,
but takes its arguments in the other order, and is zero-origin for consistency instead of
one-origin. In Lisp Machine Lisp (array-dimension-n 0) returns the length of the array
leader.
</div>
</div>
<div class=defun>
<!--l. 483--><p class="noindent" ><i>[Function]</i><a 
 id="dx113-217007"></a><a 
 id="x113-217008r530"></a><b> array-dimensions</b>  <i>array</i>
<!--l. 485--><p class="noindent" ><a 
href="#x113-217008r530">array-dimensions</a> returns a list whose elements are the dimensions of <i>array</i>.
</div>
<div class=defun>
<!--l. 490--><p class="noindent" ><i>[Function]</i><a 
 id="dx113-217009"></a><a 
 id="x113-217010r531"></a><b> array-total-size</b>  <i>array</i>
<!--l. 492--><p class="noindent" ><a 
href="#x113-217010r531">array-total-size</a> returns the total number of elements in the <i>array</i>, calculated as
the product of all the dimensions. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(array-total-size <i>x</i>)
</td></tr></table>
<!--l. 496--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ≡</span> (apply #&#x2019;* (array-dimensions <i>x</i>))</td></tr></table>
<!--l. 497--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ≡</span> (reduce #&#x2019;* (array-dimensions <i>x</i>))</td></tr></table>
<!--l. 499--><p class="indent" >
</div>
</div>
<!--l. 500--><p class="noindent" >Note that the total size of a zero-dimensional array is 1. The total size of a
one-dimensional array is calculated without regard for any ﬁll pointer.
</div>
<div class=defun>
<!--l. 505--><p class="noindent" ><i>[Function]</i><a 
 id="dx113-217011"></a><a 
 id="x113-217012r532"></a><b> array-in-bounds-p</b>  <i>array</i> &#x0026;rest  <i>subscripts</i>
<!--l. 507--><p class="noindent" >This predicate checks whether the <i>subscripts</i> are all legal subscripts for <i>array</i>. The
predicate is true if they are all legal; otherwise it is false. The <i>subscripts</i> must be
integers. The number of <i>subscripts</i> supplied must equal the rank of the array. Like
<a 
href="clmse90.html#x112-216002r525">aref</a>, <a 
href="#x113-217012r532">array-in-bounds-p</a> ignores ﬁll pointers.
</div>
                                                                          

                                                                          
<div class=defun>
<!--l. 515--><p class="noindent" ><i>[Function]</i><a 
 id="dx113-217013"></a><a 
 id="x113-217014r533"></a><b> array-row-major-index</b>  <i>array</i> &#x0026;rest  <i>subscripts</i>
<!--l. 517--><p class="noindent" >This function takes an array and valid subscripts for the array and returns a
single non-negative integer less than the total size of the array that identiﬁes the
accessed element in the row-major ordering of the elements. The number of
<i>subscripts</i> supplied must equal the rank of the array. Each subscript must be a
non-negative integer less than the corresponding array dimension. Like <a 
href="clmse90.html#x112-216002r525">aref</a>,
<a 
href="#x113-217014r533">array-row-major-index</a> ignores ﬁll pointers.
<!--l. 527--><p class="indent" >   A possible deﬁnition of <a 
href="#x113-217014r533">array-row-major-index</a>, with no error checking, would
be <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun array-row-major-index (a &#x0026;rest subscripts)
</td></tr></table>
<!--l. 530--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (apply #&#x2019;+ (maplist #&#x2019;(lambda (x y)</td></tr></table>
<!--l. 531--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                          (* (car x) (apply #&#x2019;* (cdr y))))</td></tr></table>
<!--l. 532--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      subscripts</td></tr></table>
<!--l. 533--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      (array-dimensions a))))</td></tr></table>
<!--l. 535--><p class="indent" >
</div>
</div>
<!--l. 536--><p class="noindent" >For a one-dimensional array, the result of <a 
href="#x113-217014r533">array-row-major-index</a> always equals the
supplied subscript.
</div>
<div class=new>
<div class=defun>
<!--l. 541--><p class="noindent" ><i>[Function]</i><a 
 id="dx113-217015"></a><a 
 id="x113-217016r534"></a><b> row-major-aref</b>  <i>array</i> <i>index</i>
<!--l. 543--><p class="noindent" >X3J13 voted in March 1988 <a 
 id="dx113-217017"></a>to add the function <a 
href="#x113-217016r534">row-major-aref</a>. This allows any
array element to be accessed as if the containing array were one-dimensional. The
<i>index</i> must be a non-negative integer less than the total size of the <i>array</i>. It
indexes into the array as if its elements were arranged one-dimensionally
in row-major order. It may be understood in terms of <a 
href="clmse90.html#x112-216002r525">aref</a> as follows:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(row-major-aref <i>array</i> <i>index</i>) <span class="math"> ≡</span>
</td></tr></table>
<!--l. 553--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (aref (make-array (array-total-size array))</td></tr></table>
                                                                          

                                                                          
<!--l. 554--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    :displaced-to array</td></tr></table>
<!--l. 555--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    :element-type (array-element-type array))</td></tr></table>
<!--l. 556--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        index)</td></tr></table>
<!--l. 558--><p class="indent" >
</div>
</div>
<!--l. 559--><p class="noindent" >In other words, one may treat an array as one-dimensional by creating a new
one-dimensional array that is displaced to the old one and then accessing the new
array. Alternatively, <a 
href="clmse90.html#x112-216002r525">aref</a> may be understood in terms of <a 
href="#x113-217016r534">row-major-aref</a>:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(aref <i>array</i> <span class="math"><i>i</i><sub>0</sub></span> <span class="math"><i>i</i><sub>1</sub></span> ... <span class="math"><i>i</i><sub>n−1</sub></span>) <span class="math"> ≡</span>
</td></tr></table>
<!--l. 564--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (row-major-aref array</td></tr></table>
<!--l. 565--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  (array-row-major-index array <span class="math"><i>i</i><sub>0</sub></span> <span class="math"><i>i</i><sub>1</sub></span> ... <span class="math"><i>i</i><sub>n−1</sub></span>)</td></tr></table>
<!--l. 567--><p class="indent" >
</div>
</div>
<!--l. 568--><p class="noindent" >That is, a multidimensional array access is equivalent to a row-major access using an
equivalent row-major index.
<!--l. 571--><p class="indent" >   Like <a 
href="clmse90.html#x112-216002r525">aref</a>, <a 
href="#x113-217016r534">row-major-aref</a> completely ignores ﬁll pointers. A call to
row-major-setf is suitable for use as a <i>place</i> for <a 
href="clmse36.html#x48-90002r64">setf</a>.
<!--l. 574--><p class="indent" >   This operation makes it easier to write code that eﬃciently processes arrays of
any rank. Suppose, for example, that one wishes to set every element of an array
tennis-scores to zero. One might write <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬁll (make-array (array-total-size tennis-scores)
</td></tr></table>
<!--l. 578--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  :element-type (array-element-type tennis-scores)</td></tr></table>
<!--l. 579--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  :displaced-to tennis-scores)</td></tr></table>
<!--l. 580--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      0)</td></tr></table>
<!--l. 582--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 583--><p class="noindent" >Unfortunately, this incurs the overhead of creating a displaced array, and <a 
href="clmse78.html#x97-198002r377">ﬁll</a> cannot
be applied to multidimensional arrays. Another approach would be to handle each
possible rank separately: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ecase (array-rank tennis-scores)
</td></tr></table>
<!--l. 587--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (0 (setf (aref tennis-scores) 0))</td></tr></table>
<!--l. 588--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (1 (dotimes (i0 (array-dimension tennis-scores 0))</td></tr></table>
<!--l. 589--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (setf (aref tennis-scores i0) 0)))</td></tr></table>
<!--l. 590--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (2 (dotimes (i0 (array-dimension tennis-scores 0))</td></tr></table>
<!--l. 591--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (dotimes (i1 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 592--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (setf (aref tennis-scores i0 i1) 0))))</td></tr></table>
<!--l. 593--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 594--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (7 (dotimes (i0 (array-dimension tennis-scores 0))</td></tr></table>
<!--l. 595--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (dotimes (i1 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 596--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (dotimes (i2 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 597--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (dotimes (i3 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 598--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (dotimes (i4 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 599--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               (dotimes (i5 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 600--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 (dotimes (i6 (array-dimension tennis-scores 1))</td></tr></table>
<!--l. 601--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (setf (aref tennis-scores i0 i1 i2 i3 i4 i5 i6)</td></tr></table>
<!--l. 602--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                         0)))))))))</td></tr></table>
<!--l. 603--><p class="indent" >                                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  )</td></tr></table>
<!--l. 605--><p class="indent" >
</div>
</div>
<!--l. 606--><p class="noindent" >It is easy to get tired of writing such code. Furthermore, this approach is undesirable
because some implementations of Common Lisp will in fact correctly support
arrays of rank greater than 7 (though no implementation is required to do
so). A recursively nested loop does the job, but it is still pretty hairy:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(labels
</td></tr></table>
<!--l. 612--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ((grok-any-rank (&#x0026;rest indices)</td></tr></table>
<!--l. 613--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">     (let ((d (- (array-rank tennis-scores) (length indices)))</td></tr></table>
                                                                          

                                                                          
<!--l. 614--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (if (= d 0)</td></tr></table>
<!--l. 615--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (setf (apply #&#x2019;row-major-aref indices) 0)</td></tr></table>
<!--l. 616--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (dotimes (i (array-dimension tennis-scores (- d 1)))</td></tr></table>
<!--l. 617--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (apply #&#x2019;grok-any-rank i indices))))))</td></tr></table>
<!--l. 618--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (grok-any-rank))</td></tr></table>
<!--l. 620--><p class="indent" >
</div>
</div>
<!--l. 621--><p class="noindent" >Whether this code is particularly eﬃcient depends on many implementation
parameters, such as how &#x0026;rest arguments are handled and how cleverly
calls to <a 
href="clmse37.html#x49-95002r68">apply</a> are compiled. How much easier it is to use <a 
href="#x113-217016r534">row-major-aref</a>!
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(dotimes (i (array-total-size tennis-scores))
</td></tr></table>
<!--l. 626--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf (row-major-aref tennis-scores i) 0))</td></tr></table>
<!--l. 628--><p class="indent" >
</div>
</div>
<!--l. 629--><p class="noindent" >Surely this code is sweeter than the honeycomb.
</div>
</div>
<div class=defun>
<!--l. 633--><p class="noindent" ><i>[Function]</i><a 
 id="dx113-217018"></a><a 
 id="x113-217019r535"></a><b> adjustable-array-p</b>  <i>array</i>
<!--l. 635--><p class="noindent" >This predicate is true if the argument (which must be an array) is adjustable, and
otherwise is false.
<div class=newer>
<!--l. 640--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx113-217020"></a>to clarify that <a 
href="#x113-217019r535">adjustable-array-p</a> is true
of an array if and only if <a 
href="clmse94.html#x116-220002r554">adjust-array</a>, when applied to that array, will
return the same array, that is, an array <a 
href="clmse33.html#x44-78002r44">eq</a> to the original array. If the
:adjustable argument to <a 
href="clmse89.html#x111-215002r520">make-array</a> is non-<a 
href="clmse31.html#x42-74002r18">nil</a> when an array is created,
then <a 
href="#x113-217019r535">adjustable-array-p</a> must be true of that array. If an array is created
with the :adjustable argument <a 
href="clmse31.html#x42-74002r18">nil</a> (or omitted), then <a 
href="#x113-217019r535">adjustable-array-p</a>
may be true or false of that array, depending on the implementation.
X3J13 further voted to <i>deﬁne</i> the terminology “adjustable array” to mean
precisely “an array of which <a 
href="#x113-217019r535">adjustable-array-p</a> is true.” See <a 
href="clmse89.html#x111-215002r520">make-array</a> and
                                                                          

                                                                          
<a 
href="clmse94.html#x116-220002r554">adjust-array</a>.
</div>
</div>
                                                                          

                                                                          
   <!--l. 658--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse92.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse90.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse90.html#tailclmse90.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse91.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch17.html#clmse91.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 658--><p class="indent" >   <a 
 id="tailclmse91.html"></a>  
</body></html> 
