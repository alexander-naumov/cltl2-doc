<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Операторы условных переходов</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 6679--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse41.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse39.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse39.html#tailclmse39.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse40.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse40.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">7.6   </span> <a 
href="clm.html#QQ2-52-623" id="x52-6150007.6">Операторы
условных переходов</a></h3>
<!--l. 6681--><p class="noindent" >Традиционная условная конструкция в Lisp&#x2019;е это <tt><a 
href="#x52-624002r90">cond</a></tt>. Однако, <tt><a 
href="clmse133.html#x163-2394002r817">if</a></tt>
гораздо проще и очень похожа на условные конструкции в других
языках программирования. Она сделана примитивом в Common Lisp&#x2019;е.
Common Lisp также предоставляет конструкции диспетчеризации
(распределения) <tt><a 
href="#x52-631002r91">case</a></tt> и <tt><a 
href="#x52-634002r92">typecase</a></tt>, которые часто более удобны, чем
<tt><a 
href="#x52-624002r90">cond</a></tt>.
<div class="defspec">
<div class="defmacheader">
<!--l. 6688--><p class="indent" >   <div class="tabbing">
 <i>[Специальный оператор]</i><b> if </b><a 
 id="dx52-615001"></a><a 
 id="x52-615002r87"></a> test then [else]
   <br>
<!--l. 6689--><p class="noindent" ></div>
<!--l. 6689--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6160007.6" id="x52-6160007.6"></a></span>
</div>
<!--l. 6690--><p class="indent" >   Специальная формы <tt><a 
href="clmse133.html#x163-2394002r817">if</a></tt> обозначает то же, что и конструкция <b>if</b>-<b>then</b>-<b>else</b>
в большинстве других языках программирования. Сначала выполняется
форма <i>test</i>. Если результат не равен <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, тогда выбирается форма <i>then</i>.
Иначе выбирается форма <i>else</i>. Выбранная ранее форма выполняется, и <tt><a 
href="clmse133.html#x163-2394002r817">if</a></tt>
возвращает то, что вернула это форма. <div class="lisp"><div class="tabbing">
(if <i>test</i> <i>then</i> <i>else</i>) <span class="math"> ≡</span> (cond (<i>test</i> <i>then</i>) (<tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> <i>else</i>))
   <br>
<!--l. 6699--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 6699--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6170007.6" id="x52-6170007.6"></a></span>
<!--l. 6699--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6180007.6" id="x52-6180007.6"></a></span>
</div>
<!--l. 6700--><p class="indent" >   Но в некоторых ситуациях <tt><a 
href="clmse133.html#x163-2394002r817">if</a></tt> оказывается более читабельным.
<!--l. 6702--><p class="indent" >   Форма <i>else</i> может быть опущена. В таком случае, если значение формы
<i>test</i> является <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, тогда ничего не будет выполнено и возвращаемое значение
формы <tt><a 
href="clmse133.html#x163-2394002r817">if</a></tt> будет <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. Если в этой ситуации значение формы <tt><a 
href="clmse133.html#x163-2394002r817">if</a></tt> важно, тогда
в зависимости от контекста стилистически удобнее использовать форму <tt><a 
href="clmse34.html#x45-413002r49">and</a></tt>.
Если значение не важно, тогда удобнее использовать конструкцию
<tt><a 
href="clmse133.html#x163-2395002r818">when</a></tt>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6711--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> when </b><a 
 id="dx52-618001"></a><a 
 id="x52-618002r88"></a> test {form}*
   <br>
<!--l. 6712--><p class="noindent" ></div>
<!--l. 6712--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6190007.6" id="x52-6190007.6"></a></span>
</div>
<tt>
<!--l. 6713--><p class="indent" >   (when <i>test</i> <i>form1</i> <i>form2</i> ... )</tt> сначала выполняет <i>test</i>. Если
результат <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, тогда ничего не выполняется и возвращается <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. Иначе,
последовательно выполняются формы <i>form</i> слева направо (как неявный
<tt><a 
href="clmse38.html#x50-580002r76">progn</a></tt>), и возвращается значение последней формы. <div class="lisp"><div class="tabbing">
(when <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (and <i>p</i> (progn <i>a</i> <i>b</i> <i>c</i>))
   <br>                                                (when <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (cond (<i>p</i> <i>a</i> <i>b</i> <i>c</i>))<br>
(when <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (if <i>p</i> (progn <i>a</i> <i>b</i> <i>c</i>) <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>)<br>
(when <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (unless (not <i>p</i>) <i>a</i> <i>b</i> <i>c</i>)<br>
<!--l. 6724--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 6724--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6200007.6" id="x52-6200007.6"></a></span>
<!--l. 6724--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6210007.6" id="x52-6210007.6"></a></span>
</div>
<!--l. 6725--><p class="indent" >   В целях хорошего стиля, <tt><a 
href="clmse133.html#x163-2395002r818">when</a></tt> обычно используется для выполнения
побочных эффектов при некоторых условиях, и значение <tt><a 
href="clmse133.html#x163-2395002r818">when</a></tt> не используется.
Если значение все-таки важно, тогда, может быть, стилистически функции
<tt><a 
href="clmse34.html#x45-413002r49">and</a></tt> или <tt><a 
href="clmse133.html#x163-2394002r817">if</a></tt> более подходят.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6732--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> unless </b><a 
 id="dx52-621001"></a><a 
 id="x52-621002r89"></a> test {form}*
   <br>
<!--l. 6733--><p class="noindent" ></div>
<!--l. 6733--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6220007.6" id="x52-6220007.6"></a></span>
</div>
<tt>
<!--l. 6734--><p class="indent" >   (unless <i>test</i> <i>form1</i> <i>form2</i> ... )</tt> сначала выполняет <i>test</i>. Если
результат <i>не</i> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, тогда ничего не выполняется и возвращается <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>.
Иначе, последовательно выполняются формы <i>form</i> слева направо
(как неявный <tt><a 
href="clmse38.html#x50-580002r76">progn</a></tt>), и возвращается значение последней формы.
<div class="lisp"><div class="tabbing">
(unless <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (cond ((not <i>p</i>) <i>a</i> <i>b</i> <i>c</i>))
   <br>                                     (unless <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (if <i>p</i> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> (progn <i>a</i> <i>b</i> <i>c</i>))<br>
(unless <i>p</i> <i>a</i> <i>b</i> <i>c</i>) <span class="math"> ≡</span> (when (not <i>p</i>) <i>a</i> <i>b</i> <i>c</i>)<br>
<!--l. 6744--><p class="noindent" ></div>
<!--l. 6744--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6230007.6" id="x52-6230007.6"></a></span>
                                                                          

                                                                          
<!--l. 6744--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6240007.6" id="x52-6240007.6"></a></span>
</div>
<!--l. 6745--><p class="indent" >   В целях хорошего стиля, <tt><a 
href="clmse133.html#x163-2396002r819">unless</a></tt> обычно используется для выполнения
побочных эффектов при некоторых условиях, и значение <tt><a 
href="clmse133.html#x163-2396002r819">unless</a></tt> не
используется. Если значение все-таки важно, тогда может быть стилистически
более подходящая функция <tt><a 
href="clmse133.html#x163-2394002r817">if</a></tt>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6752--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> cond </b><a 
 id="dx52-624001"></a><a 
 id="x52-624002r90"></a> {(test {form}*)}*
   <br>
<!--l. 6753--><p class="noindent" ></div>
<!--l. 6753--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6250007.6" id="x52-6250007.6"></a></span>
</div>
<!--l. 6754--><p class="indent" >   Форма <tt><a 
href="#x52-624002r90">cond</a></tt> содержит некоторое (возможно нулевое) количество
подвыражений, которые является списками форм. Каждое подвыражение
содержит форму условия и ноль и более форм для выполнения. Например:
<div class="lisp"><div class="tabbing">
(cond (<i>test-1</i> <i>consequent-1-1</i> <i>consequent-1-2</i> ...)
   <br>                      (<i>test-2</i>)<br>                      (<i>test-3</i> <i>consequent-3-1</i> ...)<br>
      ... )<br>
<!--l. 6763--><p class="noindent" ></div>
<!--l. 6763--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6260007.6" id="x52-6260007.6"></a></span>
                                                                          

                                                                          
<!--l. 6763--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6270007.6" id="x52-6270007.6"></a></span>
</div>
<!--l. 6765--><p class="indent" >   Отбирается первое подвыражение, чья форма условия вычисляется в
не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. Все остальные подвыражения игнорируются. Формы отобранного
подвыражения последовательно выполняются (как неявный <tt><a 
href="clmse38.html#x50-580002r76">progn</a></tt>).
<!--l. 6769--><p class="indent" >   Если быть точнее, <tt><a 
href="#x52-624002r90">cond</a></tt> обрабатывает свои подвыражения слева направо.
Для каждого подвыражения, вычисляется форма условия. Если результат
<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, <tt><a 
href="#x52-624002r90">cond</a></tt> переходит к следующему подвыражению. Если результат <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt>, <i>cdr</i>
подвыражения обрабатывается, как список форм. Этот список выполняется
слева направо, как неявный <tt><a 
href="clmse38.html#x50-580002r76">progn</a></tt>. После выполнения списка форм, <tt><a 
href="#x52-624002r90">cond</a></tt>
возвращает управление без обработки оставшихся подвыражений.
Специальная форма <tt><a 
href="#x52-624002r90">cond</a></tt> возвращает результат выполнения последней
формы из списка. Если этот список пустой, тогда возвращается значение
формы условия. Если <tt><a 
href="#x52-624002r90">cond</a></tt> вернула управление без вычисления какой-либо
ветки (все условные формы вычислялись в <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>), возвращается значение
<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>.
<!--l. 6781--><p class="indent" >   Для того, чтобы выполнить последнее подвыражение, в случае если
раньше ничего не выполнилось, можно использовать <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> для формы условия. В
целях стиля, если значение <tt><a 
href="#x52-624002r90">cond</a></tt> будет для чего-то использоваться,
желательно записывать последнее выражение так: <tt>(<tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>)</tt>. Также вопросом
вкуса является запись последнего подвыражения <tt><a 
href="#x52-624002r90">cond</a></tt> как «синглтон», в
таком случае, используется неявный <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt>. (Следует отметить, если <i>x</i> может
возвращать несколько значений, то <tt>(cond ... (<i>x</i>))</tt> может вести себя
отлично от <tt>(cond ... (<tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> <i>x</i>))</tt>. Первое выражение всегда возвращает одно
выражение, тогда как второе возвращает все то же, что и <i>x</i>. В зависимости
от стиля, можно указывать поведение явно <tt>(cond ... (t (values <i>x</i>)))</tt>,
используя функцию <tt><a 
href="clmse43.html#x55-707002r111">values</a></tt> для явного указания возврата одного значения.)
Например: <div class="lisp"><div class="tabbing">
(setq z (cond (a &#x2019;foo) (b &#x2019;bar)))                                ;Возможна неопределённость
   <br>      (setq z (cond (a &#x2019;foo) (b &#x2019;bar) (<tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>)))                     ;Уже лучше<br>
(cond (a b) (c d) (e))                                             ;Возможна неопределённость<br>
(cond (a b) (c d) (<tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> e))                                          ;Уже лучше<br>
(cond (a b) (c d) (<tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> (values e)))                               ;Неплохо (если необходимо<br>
                                                      ; одно значение)<br>
(cond (a b) (c))                                                    ;Возможна неопределённость<br>
                                                                          

                                                                          
(cond (a b) (t c))                                                  ;Уже лучше<br>
(if a b c)                                                             ;Тоже неплохо<br>
<!--l. 6805--><p class="noindent" ></div>
<!--l. 6805--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6280007.6" id="x52-6280007.6"></a></span>
<!--l. 6805--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6290007.6" id="x52-6290007.6"></a></span>
</div>
<!--l. 6806--><p class="indent" >   Lisp&#x2019;овая форма <tt><a 
href="#x52-624002r90">cond</a></tt> сравнима с последовательностью <b>if</b>-<b>then</b>-<b>else</b>,
используемой в большинстве алгебраических языках программирования:
<div class="lisp"><div class="tabbing">
(cond (<i>p</i> ...)                                                 <b>if</b> <i>p</i> <b>тогда</b> ...
<br>        (<i>q</i> ...)               roughly                       <b>иначе</b> <b>если</b> <i>q</i> <b>тогда</b> ...<br>
      (<i>r</i> ...)               corresponds                  <b>иначе</b> <b>если</b> <i>r</i> <b>тогда</b> ...<br>
      ...                    to                               ...<br>
      (<tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> ...))                                               <b>иначе</b> ...<br>
<!--l. 6816--><p class="noindent" ></div>
<!--l. 6816--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6300007.6" id="x52-6300007.6"></a></span>
<!--l. 6816--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6310007.6" id="x52-6310007.6"></a></span>
</div>
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6820--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> case </b><a 
 id="dx52-631001"></a><a 
 id="x52-631002r91"></a> keyform {({({key}*) | key}{form}*)}*
   <br>
<!--l. 6821--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 6821--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6320007.6" id="x52-6320007.6"></a></span>
</div>
<tt>
<!--l. 6822--><p class="indent" >   <a 
href="#x52-631002r91">case</a></tt> условный оператор, который выбирает ветку для выполнения, в
зависимости от равенства некоторой переменной некоторой константе.
Константа обычно представляет собой ключевой символ, целое число или
строковый символ (но может быть и любой другой объект). Вот развёрнутая
форма: <div class="lisp"><div class="tabbing">
(case <i>keyform</i>
   <br>                                  (<i>keylist-1</i> <i>consequent-1-1</i> <i>consequent-1-2</i> ...)<br>
  (<i>keylist-2</i> <i>consequent-2-1</i> ...)<br>                (<i>keylist-3</i> <i>consequent-3-1</i> ...)<br>
  ...)<br>
<!--l. 6832--><p class="noindent" ></div>
<!--l. 6832--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6330007.6" id="x52-6330007.6"></a></span>
<!--l. 6832--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6340007.6" id="x52-6340007.6"></a></span>
</div>
<!--l. 6833--><p class="indent" >   Структурно <tt><a 
href="#x52-631002r91">case</a></tt> очень похож на <tt><a 
href="#x52-624002r90">cond</a></tt>, и поведение такое же: выбрать
список форм и выполнить их. Однако <tt><a 
href="#x52-631002r91">case</a></tt> отличается механизмом выбора
подвыражения.
<!--l. 6837--><p class="indent" >   Сперва <tt><a 
href="#x52-631002r91">case</a></tt> вычисляет форму <i>keyform</i> для получения объекта, который
называется <i>ключевой объект</i>. Затем <tt><a 
href="#x52-631002r91">case</a></tt> рассматривает все подвыражения.
Если <i>ключевой объект</i> присутствует в списке <i>keylist</i> (то есть, если <i>ключевой
объект</i> равен <tt><a 
href="clmse33.html#x44-402003r45">eql</a></tt> хотя бы одному элементу из списка <i>keylist</i>), то список форм
выбранного подвыражения вычисляется, как неявный <tt><a 
href="clmse38.html#x50-580002r76">progn</a></tt>. <tt><a 
href="#x52-631002r91">case</a></tt>
возвращает то же, что и последняя форма списка (или <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> если список форм
был пустой). Если ни одно подвыражение не удовлетворило условию, то <tt><a 
href="#x52-631002r91">case</a></tt>
возвращает <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>.
<!--l. 6848--><p class="indent" >   Ключи в списке ключей <i>keylist</i> <i>не</i> выполняются. В данном списке должны
быть указаны литеральные ключи. Если один ключ попадается более чем в
одном подвыражении, это считается ошибкой. Следствием является то, что
порядок этих подвыражений не влияет на поведение конструкции
<tt><a 
href="#x52-631002r91">case</a></tt>.
                                                                          

                                                                          
<!--l. 6855--><p class="indent" >   Вместо <i>keylist</i> можно записать один из символов: <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> или <tt>otherwise</tt>.
Подвыражение с одним из таких символов всегда удовлетворяет условию
выбора. Такое подвыражение должно быть последним (это исключение из
правила о произвольности положения подвыражений). Смотрите также
<tt><a 
href="clmse147.html#x180-2819002r937">ecase</a></tt> и <tt><a 
href="clmse147.html#x180-2822002r938">ccase</a></tt>, каждая из которых предоставляет неявное <tt>otherwise</tt>
подвыражение для сигнализирования об ошибке, если ни одно подвыражение
не удовлетворило условию.
<!--l. 6863--><p class="indent" >   Если в подвыражении только один ключ, тогда этот ключ может быть
записан вместо списка. Такой «синглтоновый ключ» не может быть <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> (так
как возникают конфликты с (), который означает список без ключей), <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt>,
<tt>otherwise</tt> или cons-ячейкой.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 6871--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> typecase </b><a 
 id="dx52-634001"></a><a 
 id="x52-634002r92"></a> keyform {(type {form}*)}*
   <br>
<!--l. 6872--><p class="noindent" ></div>
<!--l. 6872--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6350007.6" id="x52-6350007.6"></a></span>
</div>
<tt>
<!--l. 6873--><p class="indent" >   <a 
href="#x52-634002r92">typecase</a></tt> условный оператор, который выбирает подвыражение на основе
типа объекта. Развёрнутая форма: <div class="lisp"><div class="tabbing">
(typecase <i>keyform</i>
   <br>                                    (<i>type-1</i> <i>consequent-1-1</i> <i>consequent-1-2</i> ...)<br>
  (<i>type-2</i> <i>consequent-2-1</i> ...)<br>                    (<i>type-3</i> <i>consequent-3-1</i> ...)<br>
  ...)<br>
<!--l. 6882--><p class="noindent" ></div>
<!--l. 6882--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6360007.6" id="x52-6360007.6"></a></span>
                                                                          

                                                                          
<!--l. 6882--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6370007.6" id="x52-6370007.6"></a></span>
</div>
<!--l. 6883--><p class="indent" >   Структура <tt><a 
href="#x52-634002r92">typecase</a></tt> похожа на <tt><a 
href="#x52-624002r90">cond</a></tt> или <tt><a 
href="#x52-631002r91">case</a></tt>. Поведение также схоже в
том, что выбирается подвыражение в зависимости от условия. Различие
заключается в механизме выбора подвыражения.
<!--l. 6887--><p class="indent" >   Сперва <tt><a 
href="#x52-634002r92">typecase</a></tt> вычисляет форму <i>keyform</i> для создания объекта,
называемого ключевым объектом. Далее <tt><a 
href="#x52-634002r92">typecase</a></tt> друг за другом
рассматривает каждое подвыражение. Форма <i>type</i>, которая встречается
в каждом подвыражении, является спецификатором типа. Данный
спецификатор не вычисляется, поэтому должен быть литеральным. Когда
ключевой объект принадлежит некоторый типу, то выделенный список форм
<i>consequent</i> выполняется последовательно (как неявный <tt><a 
href="clmse38.html#x50-580002r76">progn</a></tt>). <tt><a 
href="#x52-634002r92">typecase</a></tt>
возвращает то, что вернула последняя форма из списка (или <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> если список
был пуст). Если не одно подвыражение не было выбрано, <tt><a 
href="#x52-634002r92">typecase</a></tt>
возвращает <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>.
<!--l. 6898--><p class="indent" >   Как и для <tt><a 
href="#x52-631002r91">case</a></tt> можно использовать <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> или <tt>otherwise</tt> на позиции <i>типа</i>
для задания подвыражений, которые будут выполняться, только если не
было выполнено других подвыражений. Смотрите также <tt><a 
href="clmse147.html#x180-2813002r935">etypecase</a></tt> и
<tt><a 
href="clmse147.html#x180-2816002r936">ctypecase</a></tt>, каждая из которых предоставляет неявную ветку <tt>otherwise</tt> для
сигнализирования об ошибке, что ни одно подвыражение не удовлетворило
условию.
<!--l. 6905--><p class="indent" >   Допустимо указывать более одного подвыражение, тип условия которого
уже является подтипом условия другого подвыражения. В таком случае
будет выбрано первое встретившееся подвыражение. Таким образом в
<tt><a 
href="#x52-634002r92">typecase</a></tt>, в отличие от <tt><a 
href="#x52-631002r91">case</a></tt>, порядок следования подвыражений влияет на
поведение всей конструкции. <div class="lisp"><div class="tabbing">
(typecase an-object
   <br>   (string ...)                             ;Подвыражение обрабатывает строки<br>
   ((array t) ...)                          ;Подвыражение обрабатывает общие массивы<br>
   ((array bit) ...)                       ;Подвыражение обрабатывает битовые массивы<br>
   (array ...)                              ;Обрабатывает все остальные массивы<br>
   ((or list number) ...)                ;Подвыражение обрабатывает списки и числа<br>
   (t ...))                                   ;Подвыражение обрабатывает все остальные объекты<br>
<!--l. 6919--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 6919--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6380007.6" id="x52-6380007.6"></a></span>
<!--l. 6919--><p class="noindent" ><span class="paragraphHead"><a 
href="#x52-6390007.6" id="x52-6390007.6"></a></span>
</div>
</div>
                                                                          

                                                                          
<!--l. 6922--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse41.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse39.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse39.html#tailclmse39.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse40.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse40.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse40.html"></a>   </div> </div> 
</body></html> 
