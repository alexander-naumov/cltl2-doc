<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Printed Representation of Lisp Objects</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 27--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse116.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch22.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch22.html#tailclmch22.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse115.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch22.html#clmse115.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">22.1   </span> <a 
 id="x142-18700022.1"></a>Printed Representation of Lisp Objects</h3>
                                                                          

                                                                          
<!--l. 29--><p class="noindent" >Lisp objects in general are not text strings but complex data structures. They
have very diﬀerent properties from text strings as a consequence of their internal
representation. However, to make it possible to get at and talk about Lisp objects,
Lisp provides a representation of most objects in the form of printed text; this is
called the printed representation, which is used for input/output purposes and in
the examples throughout this book. Functions such as <i>print</i> take a Lisp
object and send the characters of its printed representation to a stream.
The collection of routines that does this is known as the (Lisp) printer.
The <i>read</i> function takes characters from a stream, interprets them as a
printed representation of a Lisp object, builds that object, and returns
it; the collection of routines that does this is called the (Lisp) reader. <a 
 id="dx142-187001"></a><a 
 id="dx142-187002"></a>
<a 
 id="dx142-187003"></a>
<!--l. 46--><p class="indent" >   Ideally, one could print a Lisp object and then read the printed representation
back in, and so obtain the same identical object. In practice this is diﬃcult and
for some purposes not even desirable. Instead, reading a printed representation
produces an object that is (with obscure technical exceptions) <i>equal</i> to the
originally printed object.
<!--l. 53--><p class="indent" >   Most Lisp objects have more than one possible printed representation. For
example, the integer twenty-seven can be written in any of these ways: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">27    27.    #o33    #x1B    #b11011    #.(* 3 3 3)    81/3
</td></tr></table>
<!--l. 57--><p class="indent" >
</div>
</div>
<!--l. 58--><p class="noindent" >A list of two symbols <i>A</i> and <i>B</i> can be printed in many ways: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (A B)    (a b)    (  a  b )    (<tt>\</tt>A |B|)
</td></tr></table>
<!--l. 60--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (|<tt>\</tt>A|</td></tr></table>
<!--l. 61--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  B</td></tr></table>
<!--l. 62--><p class="indent" >                                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">)</td></tr></table>
<!--l. 64--><p class="indent" >
</div>
                                                                          

                                                                          
</div>
<!--l. 65--><p class="noindent" >The last example, which is spread over three lines, may be ugly, but it is legitimate.
In general, wherever whitespace is permissible in a printed representation, any
number of spaces and newlines may appear.
<!--l. 69--><p class="indent" >   When <i>print</i> produces a printed representation, it must choose arbitrarily
from among many possible printed representations. It attempts to choose
one that is readable. There are a number of global variables that can be
used to control the actions of <i>print</i>, and a number of diﬀerent printing
functions.
<!--l. 75--><p class="indent" >   This section describes in detail what is the standard printed representation for
any Lisp object and also describes how <i>read</i> operates.
<!--l. 78--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">22.1.1   </span> <a 
 id="x142-18800022.1.1"></a>What the Read Function Accepts</h4>
<a 
 id="dx142-188001"></a>
<!--l. 81--><p class="noindent" >The purpose of the Lisp reader is to accept characters, interpret them as the
printed representation of a Lisp object, and construct and return such an object.
The reader cannot accept everything that the printer produces; for example, the
printed representations of compiled code objects cannot be read in. However, the
reader has many features that are not used by the output of the printer at all,
such as comments, alternative representations, and convenient abbreviations for
frequently used but unwieldy constructs. The reader is also parameterized in such
a way that it can be used as a lexical analyzer for a more general user-written
parser.
<!--l. 92--><p class="indent" >   The reader is organized as a recursive-descent parser. Broadly speaking, the
reader operates by reading a character from the input stream and treating it
in one of three ways. Whitespace characters serve as separators but are
otherwise ignored. Constituent and escape characters are accumulated to
make a token, which is then interpreted as a number or symbol. Macro
characters trigger the invocation of functions (possibly user-supplied) that can
perform arbitrary parsing actions, including recursive invocation of the
reader.
<!--l. 103--><p class="indent" >   More precisely, when the reader is invoked, it reads a single character from the
input stream and dispatches according to the syntactic type of that character.
Every character that can appear in the input stream must be of exactly one of the
following kinds: illegal, whitespace, constituent, single escape, multiple escape, or
                                                                          

                                                                          
macro. Macro characters are further divided into the types terminating and
non-terminating (of tokens). (Note that macro characters have nothing whatever
to do with macros in their operation. There is a superﬁcial similarity in that
macros allow the user to extend the syntax of Common Lisp at the level of forms,
while macro characters allow the user to extend the syntax at the level of
characters.) Constituents additionally have one or more attributes, the most
important of which is alphabetic; these attributes are discussed further in
section <a 
href="#x142-18900022.1.2">22.1.2<!--tex4ht:ref: PARSE-TOKENS-SECTION --></a>.
<!--l. 125--><p class="indent" >   The parsing of Common Lisp expressions is discussed in terms of these
syntactic character types because the types of individual characters are
not ﬁxed but may be altered by the user (see <i>set-syntax-from-char</i> and
<i>set-macro-character</i>). The characters of the standard character set initially have
the syntactic types shown in table <a 
href="#x142-1880021">22.1<!--tex4ht:ref: Standard-Character-Syntax-Table --></a>. Note that the brackets, braces, question
mark, and exclamation point (that is, <i><tt>[</tt></i>, <i><tt>]</tt></i>, <i><tt>{</tt></i>, <i><tt>}</tt></i>, <i>?</i>, and <i>!</i>) are normally deﬁned to
be constituents, but they are not used for any purpose in standard Common Lisp
syntax and do not occur in the names of built-in Common Lisp functions or
variables. These characters are explicitly reserved to the user. The primary intent
is that they be used as macro characters; but a user might choose, for
example, to make <i>!</i> be a single escape character (as it is in Portable Standard
Lisp).
   <div class="table">
                                                                          

                                                                          
<!--l. 146--><p class="indent" >   <a 
 id="x142-1880021"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 22.1: </span><span  
class="content">Standard Character Syntax Types</span></div><!--tex4ht:label?: x142-1880021 -->
Table unavailable
<!--l. 198--><p class="noindent" >The characters marked with an asterisk are initially constituents but are reserved to the
user for use as macro characters or for any other desired purpose.
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<!--l. 205--><p class="indent" >   The algorithm performed by the Common Lisp reader is roughly as
follows:
   <ol  class="enumerate1" >
   <li 
  class="enumerate" id="x142-188004x1">If at end of ﬁle, perform end-of-ﬁle processing (as speciﬁed by the caller of
   the <i>read</i> function). Otherwise, read one character from the input stream,
   call it x, and dispatch according to the syntactic type of x to one of steps <a 
href="#x142-1880052">2<!--tex4ht:ref: READER-ILLEGAL --></a>
   to <a 
href="#x142-1880157">7<!--tex4ht:ref: READER-CONSTITUENT --></a>. <a 
 id="x142-1880031"></a>
   </li>
   <li 
  class="enumerate" id="x142-188006x2">If x is an illegal character, signal an error. <a 
 id="x142-1880052"></a>
   </li>
   <li 
  class="enumerate" id="x142-188008x3">If x is a whitespace character, then discard it and go back to step <a 
href="#x142-1880031">1<!--tex4ht:ref: READER-START --></a>. <a 
 id="x142-1880073"></a>
   </li>
   <li 
  class="enumerate" id="x142-188010x4">If x is a macro character (at this point the distinction between terminating
   and non-terminating macro characters does not matter), then execute the
   function associated with that character. The function may return zero
   values or one value (see <i>values</i>).
   <!--l. 233--><p class="noindent" >The macro-character function may of course read characters from the
   input stream; if it does, it will see those characters following the macro
   character.  The  function  may  even  invoke  the  reader  recursively.  This
   is how the macro character <i>(</i> constructs a list: by invoking the reader
   recursively to read the elements of the list.
   <!--l. 239--><p class="noindent" >If one value is returned, then return that value as the result of the read
   operation; the algorithm is done. If zero values are returned, then go back
   to step <a 
href="#x142-1880031">1<!--tex4ht:ref: READER-START --></a>.
   </li>
   <li 
  class="enumerate" id="x142-188012x5">If x is a single escape character (normally <i><tt>\</tt></i>), then read the next character and
   call it y (but if at end of ﬁle, signal an error instead). Ignore the usual syntax
   of y and pretend it is a constituent whose only attribute is alphabetic. <div class=obsolete> (If y is a
   lowercase character, leave it alone; do not replace it with the corresponding
   uppercase character.)
   </div> <div class=newer> For the purposes of <i>readtable-case</i>, y is not replaceable.
   </div> Use y to begin a token, and go to step <a 
href="#x142-1880178">8<!--tex4ht:ref: READER-PLAIN-TOKEN --></a>.
                                                                          

                                                                          
   </li>
   <li 
  class="enumerate" id="x142-188014x6">If x is a multiple escape character (normally <i>|</i>), then begin a token (initially
   containing no characters) and go to step <a 
href="#x142-1880199">9<!--tex4ht:ref: READER-MULTI-TOKEN --></a>.
   </li>
   <li 
  class="enumerate" id="x142-188016x7">If x is a constituent character, then it begins an extended token. <a 
 id="x142-1880157"></a>After the
   entire token is read in, it will be interpreted either as representing a Lisp
   object such as a symbol or number (in which case that object is returned as
   the result of the read operation), or as being of illegal syntax (in which case an
   error is signaled). <div class=obsolete> If x is a lowercase character, replace it with the
   corresponding uppercase character.
   </div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to introduce <i>readtable-case</i>. Consequently, the
   preceding sentence should be ignored. The case of x should not be altered;
   instead, x should be regarded as replaceable.
   </div> Use x to begin a token, and go on to step <a 
href="#x142-1880178">8<!--tex4ht:ref: READER-PLAIN-TOKEN --></a>.
   </li>
   <li 
  class="enumerate" id="x142-188018x8">(At this point a token is being accumulated, and an even number of multiple
   escape characters have been encountered.) If at end of ﬁle, go to step <a 
href="#x142-18802110">10<!--tex4ht:ref: READER-TOKEN-END --></a>.
   Otherwise, read a character (call it y), and perform one of the following
   actions according to its syntactic type: <a 
 id="x142-1880178"></a>
        <ul class="itemize1">
        <li class="itemize">If y is a constituent or non-terminating macro, then do the following. <div class=obsolete> If y
        is a lowercase character, replace it with the corresponding uppercase
        character.
        </div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to introduce <i>readtable-case</i>. Consequently,
        the preceding sentence should be ignored. The case of y should not be
        altered; instead, y should be regarded as replaceable.
        </div> Append y to the token being built, and repeat step <a 
href="#x142-1880178">8<!--tex4ht:ref: READER-PLAIN-TOKEN --></a>.
        </li>
        <li class="itemize">If y is a single escape character, then read the next character and call it z
        (but if at end of ﬁle, signal an error instead). Ignore the usual syntax of z
        and pretend it is a constituent whose only attribute is alphabetic. <div class=obsolete> (If z is
        a lowercase character, leave it alone; do not replace it with the
        corresponding uppercase character.)
        </div> <div class=newer> For the purposes of <i>readtable-case</i>, z is not replaceable.
        </div> Append z to the token being built, and repeat step <a 
href="#x142-1880178">8<!--tex4ht:ref: READER-PLAIN-TOKEN --></a>.
                                                                          

                                                                          
        </li>
        <li class="itemize">If y is a multiple escape character, then go to step <a 
href="#x142-1880199">9<!--tex4ht:ref: READER-MULTI-TOKEN --></a>.
        </li>
        <li class="itemize">If y is an illegal character, signal an error.
        </li>
        <li class="itemize">If y is a terminating macro character, it terminates the token. First
        “unread” the character y (see <i>unread-char</i>), then go to step <a 
href="#x142-18802110">10<!--tex4ht:ref: READER-TOKEN-END --></a>.
        </li>
        <li class="itemize">If y is a whitespace character, it terminates the token. First “unread” y if
        appropriate (see <i>read-preserving-whitespace</i>), then go to step <a 
href="#x142-18802110">10<!--tex4ht:ref: READER-TOKEN-END --></a>.</li></ul>
   </li>
   <li 
  class="enumerate" id="x142-188020x9">(At this point a token is being accumulated, and an odd number of multiple
   escape characters have been encountered.) If at end of ﬁle, signal an error.
   Otherwise, read a character (call it y), and perform one of the following
   actions according to its syntactic type: <a 
 id="x142-1880199"></a>
        <ul class="itemize1">
        <li class="itemize">If y is a constituent, macro, or whitespace character, then ignore the
        usual syntax of that character and pretend it is a constituent
        whose only attribute is alphabetic. <div class=obsolete> (If y is a lowercase character,
        leave it alone; do not replace it with the corresponding uppercase
        character.)
        </div> <div class=newer> For the purposes of <i>readtable-case</i>, y is not replaceable.
        </div> Append y to the token being built, and repeat step <a 
href="#x142-1880199">9<!--tex4ht:ref: READER-MULTI-TOKEN --></a>.
        </li>
        <li class="itemize">If y is a single escape character, then read the next character and call it z
        (but if at end of ﬁle, signal an error instead). Ignore the usual syntax of z
        and pretend it is a constituent whose only attribute is alphabetic. <div class=obsolete> (If z is
        a lowercase character, leave it alone; do not replace it with the
        corresponding uppercase character.)
        </div> <div class=newer> For the purposes of <i>readtable-case</i>, z is not replaceable.
        </div> Append z to the token being built, and repeat step <a 
href="#x142-1880199">9<!--tex4ht:ref: READER-MULTI-TOKEN --></a>.
        </li>
        <li class="itemize">If y is a multiple escape character, then go to step <a 
href="#x142-1880178">8<!--tex4ht:ref: READER-PLAIN-TOKEN --></a>.
        </li>
        <li class="itemize">If y is an illegal character, signal an error.</li></ul>
                                                                          

                                                                          
   </li>
   <li 
  class="enumerate" id="x142-188022x10">An entire token has been accumulated. <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to
   introduce <i>readtable-case</i>. If the accumulated token is to be interpreted as a
   symbol, any case conversion of replaceable characters should be performed at
   this point according to the value of the <i>readtable-case</i> slot of the current
   readtable (the value of <i>*readtable*</i>).
   </div> Interpret the token as representing a Lisp object and return that object as the
   result of the read operation, or signal an error if the token is not of legal syntax. <div class=newer>
   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to specify that implementation-deﬁned
   attributes may be removed from the characters of a symbol token when
   constructing the print name. It is implementation-dependent which attributes
   are removed.
   </div> <a 
 id="x142-18802110"></a></li></ol>
<!--l. 416--><p class="indent" >   As a rule, a single escape character never stands for itself but always serves to
cause the following character to be treated as a simple alphabetic character. A
single escape character can be included in a token only if preceded by another
single escape character.
<!--l. 421--><p class="indent" >   A multiple escape character also never stands for itself. The characters between
a pair of multiple escape characters are all treated as simple alphabetic characters,
except that single escape and multiple escape characters must nevertheless be
preceded by a single escape character to be included.
<div class=incompatibility>
<!--l. 428--><p class="noindent" ><b>Compatibility note:</b> In MacLisp, the <i>|</i> character is implemented as a macro character
that reads characters up to the next unescaped <i>|</i> and then makes a token; no characters
are ever read beyond the second <i>|</i> of a matching pair. In Common Lisp, the second <i>|</i>
does not terminate the token being read but merely reverts to the ordinary (rather than
multiple-escape) mode of token accumulation. This results in some diﬀerences in the way
certain character sequences are interpreted. For example, the sequence <i>|foo||bar|</i>
would be read in MacLisp as two distinct tokens, <i>|foo|</i> and <i>|bar|</i>, whereas in
Common Lisp it would be treated as a single token equivalent to <i>|foobar|</i>. The
sequence <i>|foo|bar|baz|</i> would be read in MacLisp as three distinct tokens, <i>|foo|</i>,
<i>bar</i>, and <i>|baz|</i>, whereas in Common Lisp it would be treated as a single token
equivalent to <i>|fooBARbaz|</i>; note that the middle three lowercase letters are
converted to uppercase letters as they do not fall within a matching pair of vertical
bars.
<!--l. 447--><p class="indent" >   One reason for the diﬀerent treatment of <i>|</i> in Common Lisp lies in the syntax for
package-qualiﬁed symbol names. A sequence such as <i>|foo:bar|</i> ought to be interpreted as
a symbol whose name is <i>foo:bar</i>; the colon should be treated as a simple alphabetic
                                                                          

                                                                          
character because it lies within a pair of vertical bars. The symbol <i>|bar|</i> within the
package <i>|foo|</i> can be notated not as <i>|foo:bar|</i> but as <i>|foo|:|bar|</i>; the colon can
serve as a package marker because it falls outside the vertical bars, and yet the
notation is treated as a single token thanks to the new rules adopted in Common
Lisp.
<!--l. 459--><p class="indent" >   In MacLisp, the parentheses are treated as additional character types. In Common
Lisp they are simply macro characters, as described in section <a 
href="#x142-19000022.1.3">22.1.3<!--tex4ht:ref: MACRO-CHARACTERS-SECTION --></a>.
<!--l. 463--><p class="indent" >   What MacLisp calls “single character objects” (tokens of type single) are not
provided for explicitly in Common Lisp. They can be viewed as simply a kind of macro
character. That is, the eﬀect of <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setsyntax &#x2019;$ &#x2019;single <i>nil</i>)
</td></tr></table>
<!--l. 468--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setsyntax &#x2019;% &#x2019;single <i>nil</i>)</td></tr></table>
<!--l. 470--><p class="indent" >
</div>
</div>
<!--l. 471--><p class="noindent" >in MacLisp can be achieved in Common Lisp by <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun single-macro-character (stream char)
</td></tr></table>
<!--l. 473--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (ignore stream))</td></tr></table>
<!--l. 474--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (intern (string char)))</td></tr></table>
<!--l. 475--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-macro-character &#x2019;$ #&#x2019;single-macro-character)</td></tr></table>
<!--l. 476--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-macro-character &#x2019;% #&#x2019;single-macro-character)</td></tr></table>
<!--l. 478--><p class="indent" >
</div>
</div>
</div>
   <h4 class="subsectionHead"><span class="titlemark">22.1.2   </span> <a 
 id="x142-18900022.1.2"></a>Parsing of Numbers and Symbols</h4>
<!--l. 486--><p class="noindent" >When an extended token is read, it is interpreted as a number or symbol. In
general, the token is interpreted as a number if it satisﬁes the syntax for numbers
speciﬁed in table <a 
href="#x142-1890012">22.2<!--tex4ht:ref: NUMBER-SYNTAX-TABLE --></a>; this is discussed in more detail below.
                                                                          

                                                                          
<!--l. 491--><p class="indent" >   The characters of the extended token may serve various syntactic functions as
shown in table <a 
href="#x142-1890023">22.3<!--tex4ht:ref: Standard-Readtable-Attributes-Table --></a>, but it must be remembered that any character included in a
token under the control of an escape character is treated as alphabetic rather than
according to the attributes shown in the table. One consequence of this rule is
that a whitespace, macro, or escape character will always be treated as
alphabetic within an extended token because such a character cannot
be included in an extended token except under the control of an escape
character.
<!--l. 502--><p class="indent" >   To allow for extensions to the syntax of numbers, a syntax for potential
numbers is deﬁned in Common Lisp that is more general than the actual syntax
for numbers. Any token that is not a potential number and does not consist
entirely of dots will always be taken to be a symbol, now and in the future;
programs may rely on this fact. Any token that is a potential number but does
not ﬁt the actual number syntax deﬁned below is a reserved token and has an
implementation-dependent interpretation; an implementation may signal an error,
quietly treat the token as a symbol, or take some other action. Programmers
should avoid the use of such reserved tokens. (A symbol whose name looks
like a reserved token can always be written using one or more escape
characters.)
<div class=new>
<!--l. 517--><p class="indent" >   Just as bignum is the standard term used by Lisp implementors for very large
integers, and ﬂonum (rhymes with “low hum”) refers to a ﬂoating-point number,
the term potnum has been used widely as an abbreviation for “potential number.”
“Potnum” rhymes with “hot rum.”
</div>
<!--l. 525--><p class="indent" >   A token is a potential number if it satisﬁes the following requirements:
   <div class="table">
                                                                          

                                                                          
<!--l. 529--><p class="indent" >   <a 
 id="x142-1890012"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 22.2: </span><span  
class="content">Actual Syntax of Numbers</span></div><!--tex4ht:label?: x142-1890012 -->
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">number ::= integer | ratio | ﬂoating-point-number
</td></tr></table>
<!--l. 535--><p class="noindent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">integer ::=  [<i>sign</i>]   {<i>digit</i>}+   [<i>decimal-point</i>] </td></tr></table>
<!--l. 536--><p class="noindent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">ratio ::=  [<i>sign</i>]   {<i>digit</i>}+  <i>/</i> {<i>digit</i>}+ </td></tr></table>
<!--l. 537--><p class="noindent" ><table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:193;" 
class="tabbing">ﬂoating-point-number ::=</td><td  
class="tabbing"> [<i>sign</i>]   {<i>digit</i>}∗ decimal-point {<i>digit</i>}+   [<i>exponent</i>] </td></tr></table>
<!--l. 538--><p class="noindent" ><table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:193;" 
class="tabbing">                       </td><td  
class="tabbing">| [<i>sign</i>]   {<i>digit</i>}+   [<i>decimal-point {<i>digit</i>}∗</i>]  exponent</td></tr></table>
<!--l. 540--><p class="noindent" >                                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">sign ::= <i>+</i> |<i>-</i></td></tr></table>
<!--l. 540--><p class="noindent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">decimal-point ::= <i>.</i></td></tr></table>
<!--l. 541--><p class="noindent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">digit ::= <i>0</i> |<i>1</i> |<i>2</i> |<i>3</i> |<i>4</i> |<i>5</i> |<i>6</i> |<i>7</i> |<i>8</i> |<i>9</i></td></tr></table>
<!--l. 543--><p class="noindent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">exponent ::= exponent-marker  [<i>sign</i>]   {<i>digit</i>}+ </td></tr></table>
<!--l. 544--><p class="noindent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">exponent-marker ::= <i>e</i> |<i>s</i> |<i>f </i> |<i>d</i> |<i>l</i> |<i>E</i> |<i>S</i> |<i>F</i> |<i>D</i> |<i>L</i></td></tr></table>
<!--l. 547--><p class="noindent" >
</div>
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
      <ul class="itemize1">
      <li class="itemize">It consists entirely of digits, signs (<i>+</i> or <i>-</i>), ratio markers (<i>/</i>), decimal
      points  (<i>.</i>),  extension  characters  (<i><tt>^</tt></i> or  <i><tt>_</tt></i>),  and  number  markers.  (A
      number marker is a letter. Whether a letter may be treated as a number
      marker depends on context, but no letter that is adjacent to another
      letter may ever be treated as a number marker. Floating-point exponent
      markers are instances of number markers.)
      </li>
      <li class="itemize">It contains at least one digit. (Letters may be considered to be digits,
      depending on the value of <i>*read-base*</i>, but only in tokens containing
      no decimal points.)
      </li>
      <li class="itemize">It begins with a digit, sign, decimal point, or extension character.
      </li>
      <li class="itemize">It does not end with a sign.</li></ul>
<!--l. 572--><p class="noindent" >As examples, the following tokens are potential numbers, but they are not actually
numbers as deﬁned below, and so are reserved tokens. (They do indicate some
interesting possibilities for future extensions.)
   <div class="table">
                                                                          

                                                                          
<!--l. 578--><p class="indent" >   <a 
 id="x142-1890023"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 22.3: </span><span  
class="content">Standard Constituent Character Attributes</span></div><!--tex4ht:label?: x142-1890023 -->
Table unavailable
<!--l. 632--><p class="noindent" >These interpretations apply only to characters whose syntactic type is constituent. Entries
marked with an asterisk are normally shadowed because the characters are of syntactic type
whitespace, macro, single escape, or multiple escape. An alphadigit character is interpreted as a
digit if it is a valid digit in the radix speciﬁed by <i>*read-base*</i>; otherwise it is alphabetic.
Characters with an illegal attribute can never appear in a token except under the control of an
escape character.
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:116;" 
class="tabbing">1b5000           </td><td style="width:116;" 
class="tabbing">777777q         </td><td style="width:116;" 
class="tabbing">1.7J               </td><td style="width:116;" 
class="tabbing">-3/4+6.7J       </td><td  
class="tabbing">12/25/83
</td></tr></table>
<!--l. 648--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:116;" 
class="tabbing">27<tt>̂</tt>19            </td><td style="width:116;" 
class="tabbing">3<tt>̂</tt>4/5            </td><td style="width:116;" 
class="tabbing">6//7              </td><td style="width:116;" 
class="tabbing">3.1.2.6           </td><td  
class="tabbing"><tt>̂</tt>-43<tt>̂</tt></td></tr></table>
<!--l. 649--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:116;" 
class="tabbing">3.141<tt>_</tt>592<tt>_</tt>653<tt>_</tt>589<tt>_</tt>793<tt>_</tt>238<tt>_</tt>4</td><td style="width:116;" 
class="tabbing"> </td><td style="width:116;" 
class="tabbing">                   </td><td  
class="tabbing">-3.7+2.6i-6.17j+19.6k</td></tr></table>
<!--l. 651--><p class="indent" >
</div>
</div>
<!--l. 652--><p class="noindent" >The following tokens are not potential numbers but are always treated as symbols: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:116;" 
class="tabbing">/                  </td><td style="width:116;" 
class="tabbing">/5                 </td><td style="width:116;" 
class="tabbing">+                  </td><td style="width:116;" 
class="tabbing">1+                </td><td  
class="tabbing">1-
</td></tr></table>
<!--l. 656--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:116;" 
class="tabbing">foo+              </td><td style="width:116;" 
class="tabbing">ab.cd             </td><td style="width:116;" 
class="tabbing"><tt>_</tt>            </td><td style="width:116;" 
class="tabbing"><tt>̂</tt>            </td><td  
class="tabbing"><tt>̂</tt>/-</td></tr></table>
<!--l. 658--><p class="indent" >
</div>
</div>
<!--l. 659--><p class="noindent" >The following tokens are potential numbers if the value of <i>*read-base*</i> is <i>16</i> (an
abnormal situation), but they are always treated as symbols if the value of
<i>*read-base*</i> is <i>10</i> (the usual value): <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:116;" 
class="tabbing">bad-face         </td><td style="width:116;" 
class="tabbing">25-dec-83        </td><td style="width:116;" 
class="tabbing">a/b               </td><td style="width:116;" 
class="tabbing">fad<tt>_</tt>cafe         </td><td  
class="tabbing">f<tt>̂</tt>
</td></tr></table>
<!--l. 666--><p class="indent" >
</div>
</div>
<!--l. 667--><p class="noindent" >It is possible for there to be an ambiguity as to whether a letter should be treated as
a digit or as a number marker. In such a case, the letter is always treated as a
digit rather than as a number marker.
                                                                          

                                                                          
<!--l. 672--><p class="indent" >   Note that the printed representation for a potential number may not
contain any escape characters. An escape character robs the following
character of all syntactic qualities, forcing it to be strictly alphabetic and
therefore unsuitable for use in a potential number. For example, all of
the following representations are interpreted as symbols, not numbers: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><tt>\</tt>256   25<tt>\</tt>64   1.0<tt>\</tt>E6   |100|   3<tt>\</tt>.14159   |3/4|   3<tt>\</tt>/4   5||
</td></tr></table>
<!--l. 680--><p class="indent" >
</div>
</div>
<!--l. 681--><p class="noindent" >In each case, removing the escape character(s) would allow the token to be treated as
a number.
<!--l. 684--><p class="indent" >   If a potential number can in fact be interpreted as a number according to the
BNF syntax in table <a 
href="#x142-1890012">22.2<!--tex4ht:ref: NUMBER-SYNTAX-TABLE --></a>, then a number object of the appropriate type is
constructed and returned. It should be noted that in a given implementation it
may be that not all tokens conforming to the actual syntax for numbers can
actually be converted into number objects. For example, specifying too large or
too small an exponent for a ﬂoating-point number may make the number
impossible to represent in the implementation. Similarly, a ratio with denominator
zero (such as <i>-35/000</i>) cannot be represented in any implementation. In any such
circumstance where a token with the syntax of a number cannot be converted to
an internal number object, an error is signaled. (On the other hand, an
error must not be signaled for specifying too many signiﬁcant digits for a
ﬂoating-point number; an appropriately truncated or rounded value should be
produced.)
<!--l. 701--><p class="indent" >   There is an omission in the syntax of numbers as described in table <a 
href="#x142-1890012">22.2<!--tex4ht:ref: NUMBER-SYNTAX-TABLE --></a>, in
that the syntax does not account for the possible use of letters as digits. The radix
used for reading integers and ratios is normally decimal. However, this radix is
actually determined by the value of the variable <i>*read-base*</i>, whose initial value is
<i>10</i>. <i>*read-base*</i> may take on any integral value between <i>2</i> and <i>36</i>; let this value
be n. Then a token x is interpreted as an integer or ratio in base n if it could be
properly so interpreted in the syntax <i>#nRx</i> (see section <a 
href="#x142-19100022.1.4">22.1.4<!--tex4ht:ref: SHARP-SIGN-MACRO-CHARACTER-SECTION --></a>). So, for
example, if the value of <i>*read-base*</i> is <i>16</i>, then the printed representation <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(a small face in a bad place)
</td></tr></table>
<!--l. 717--><p class="indent" >
</div>
</div>
<!--l. 718--><p class="noindent" >would be interpreted as if the following representation had been read with
<i>*read-base*</i> set to <i>10</i>: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(10 small 64206 in 10 2989 place)
</td></tr></table>
<!--l. 722--><p class="indent" >
</div>
</div>
<!--l. 723--><p class="noindent" >because four of the seven tokens in the list can be interpreted as hexadecimal
numbers. This facility is intended to be used in reading ﬁles of data that for some
reason contain numbers not in decimal radix; it may also be used for reading
programs written in Lisp dialects (such as MacLisp) whose default number radix
is not decimal. Non-decimal constants in Common Lisp programs or portable
Common Lisp data ﬁles should be written using <i>#O</i>, <i>#X</i>, <i>#B</i>, or <i>#nR</i>
syntax.
<!--l. 732--><p class="indent" >   When <i>*read-base*</i> has a value greater than <i>10</i>, an ambiguity is introduced
into the actual syntax for numbers because a letter can serve as either a digit or
an exponent marker; a simple example is <i>1E0</i> when the value of <i>*read-base*</i> is
<i>16</i>. The ambiguity is resolved in accordance with the general principle
that interpretation as a digit is preferred to interpretation as a number
marker. The consequence in this case is that if a token can be interpreted as
either an integer or a ﬂoating-point number, then it is taken to be an
integer.
<!--l. 742--><p class="indent" >   If a token consists solely of dots (with no escape characters), then an error is
signaled, except in one circumstance: if the token is a single dot and occurs in a
situation appropriate to “dotted list” syntax, then it is accepted as a part
of such syntax. Signaling an error catches not only misplaced dots in
dotted list syntax but also lists that were truncated by <i>*print-length*</i>
cutoﬀ, because such lists end with a three-dot sequence (<i>...</i>). Examples: <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a . b)                 </td><td  
class="tabbing">;A dotted pair of <i>a</i> and <i>b</i>
</td></tr></table>
<!--l. 752--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a.b)                   </td><td  
class="tabbing">;A list of one element, the symbol named <i>a.b</i></td></tr></table>
<!--l. 753--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a. b)                  </td><td  
class="tabbing">;A list of two elements <i>a.</i> and <i>b</i></td></tr></table>
<!--l. 754--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a .b)                  </td><td  
class="tabbing">;A list of two elements <i>a</i> and <i>.b</i></td></tr></table>
<!--l. 755--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a <tt>\</tt>. b)               </td><td  
class="tabbing">;A list of three elements <i>a</i>, <i>.</i>, and <i>b</i></td></tr></table>
<!--l. 756--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a |.| b)               </td><td  
class="tabbing">;A list of three elements <i>a</i>, <i>.</i>, and <i>b</i></td></tr></table>
<!--l. 757--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a <tt>\</tt>... b)              </td><td  
class="tabbing">;A list of three elements <i>a</i>, <i>...</i>, and <i>b</i></td></tr></table>
<!--l. 758--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a |...| b)              </td><td  
class="tabbing">;A list of three elements <i>a</i>, <i>...</i>, and <i>b</i></td></tr></table>
<!--l. 759--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a b . c)               </td><td  
class="tabbing">;A dotted list of <i>a</i> and <i>b</i> with <i>c</i> at the end</td></tr></table>
<!--l. 760--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">.iot                     </td><td  
class="tabbing">;The symbol whose name is <i>.iot</i></td></tr></table>
<!--l. 761--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(. b)                   </td><td  
class="tabbing">;Illegal; an error is signaled</td></tr></table>
<!--l. 762--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a .)                    </td><td  
class="tabbing">;Illegal; an error is signaled</td></tr></table>
<!--l. 763--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a .. b)                </td><td  
class="tabbing">;Illegal; an error is signaled</td></tr></table>
<!--l. 764--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a . . b)               </td><td  
class="tabbing">;Illegal; an error is signaled</td></tr></table>
<!--l. 765--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:148;" 
class="tabbing">(a b c ...)             </td><td  
class="tabbing">;Illegal; an error is signaled</td></tr></table>
<!--l. 767--><p class="indent" >
</div>
</div>
<!--l. 769--><p class="indent" >   In all other cases, the token is construed to be the name of a symbol. If there
are any package markers (colons) in the token, they divide the token into pieces
used to control the lookup and creation of the symbol.
<div class=obsolete>
<!--l. 775--><p class="indent" >   If there is a single package marker, and it occurs at the beginning of the token,
then the token is interpreted as a keyword, that is, a symbol in the <i>keyword</i>
package. The part of the token after the package marker must not have the syntax
of a number.
<!--l. 780--><p class="indent" >   If there is a single package marker not at the beginning or end of the token,
then it divides the token into two parts. The ﬁrst part speciﬁes a package; the
second part is the name of an external symbol available in that package. Neither
of the two parts may have the syntax of a number.
<!--l. 786--><p class="indent" >   If there are two adjacent package markers not at the beginning or end of the
token, then they divide the token into two parts. The ﬁrst part speciﬁes a
package; the second part is the name of a symbol within that package (possibly
an internal symbol). Neither of the two parts may have the syntax of a
number.
                                                                          

                                                                          
</div>
<div class=new>
<!--l. 794--><p class="indent" >   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to clarify that, in the situations described in
the preceding three paragraphs, the restriction on the syntax of the parts should
be strengthened: none of the parts may have the syntax of even a potential
number. Tokens such as <i>:3600</i>, <i>:1/2</i>, and <i>editor:3.14159</i> were already ruled out;
this clariﬁcation further declares that such tokens as <i>:2<tt>^</tt>3</i>, <i>compiler:1.7J</i>, and
<i>Christmas:12/25/83</i> are also in error and therefore should not be used in portable
programs. Implementations may diﬀer in their treatment of such package-marked
potential numbers.
</div>
<!--l. 807--><p class="indent" >   If a symbol token contains no package markers, then the entire token is the
name of the symbol. The symbol is looked up in the default package, which is the
value of the variable <i>*package*</i>.
<!--l. 812--><p class="indent" >   All other patterns of package markers, including the cases where there are
more than two package markers or where a package marker appears at the end of
the token, at present do not mean anything in Common Lisp (see chapter <a 
href="clmch11.html#x72-11100011">11<!--tex4ht:ref: XPACK --></a>). It
is therefore currently an error to use such patterns in a Common Lisp
program. The valid patterns for tokens may be summarized as follows:
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:144;" 
class="tabbing">nnnnn               </td><td  
class="tabbing">a number
</td></tr></table>
<!--l. 820--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:144;" 
class="tabbing">xxxxx                </td><td  
class="tabbing">a symbol in the current package</td></tr></table>
<!--l. 821--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:144;" 
class="tabbing"><i>:xxxxx</i>               </td><td  
class="tabbing">a symbol in the keyword package</td></tr></table>
<!--l. 822--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:144;" 
class="tabbing"><i>ppppp:xxxxx</i>        </td><td  
class="tabbing">an external symbol in the ppppp package</td></tr></table>
<!--l. 823--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:144;" 
class="tabbing"><i>ppppp::xxxxx</i>       </td><td  
class="tabbing">a (possibly internal) symbol in the ppppp package</td></tr></table>
<!--l. 825--><p class="indent" >
</div>
<!--l. 826--><p class="noindent" >where nnnnn has the syntax of a number, and xxxxx and ppppp do not have the
syntax of a number.
<div class=new>
<!--l. 830--><p class="indent" >   In accordance with the X3J13 decision noted above ⟨<b>?</b>⟩, xxxxx and ppppp may
not have the syntax of even a potential number.
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 835--><p class="noindent" > <i>[Variable]</i>   <b>*read-base*</b> <a 
 id="dx142-189003"></a><a 
 id="x142-189004r670"></a>
<!--l. 837--><p class="noindent" >The value of <i>*read-base*</i> controls the interpretation of tokens by <i>read</i> as being
integers or ratios. Its value is the radix in which integers and ratios are to be read;
the value may be any integer from <i>2</i> to <i>36</i> (inclusive) and is normally <i>10</i> (decimal
radix). Its value aﬀects only the reading of integers and ratios. In particular,
ﬂoating-point numbers are always read in decimal radix. The value of
<i>*read-base*</i> does not aﬀect the radix for rational numbers whose radix is
explicitly indicated by <i>#O</i>, <i>#X</i>, <i>#B</i>, or <i>#nR</i> syntax or by a trailing decimal
point.
<!--l. 849--><p class="indent" >   Care should be taken when setting <i>*read-base*</i> to a value larger than <i>10</i>,
because tokens that would normally be interpreted as symbols may be
interpreted as numbers instead. For example, with <i>*read-base*</i> set to <i>16</i>
(hexadecimal radix), variables with names such as <i>a</i>, <i>b</i>, <i>f </i>, <i>bad</i>, and <i>face</i> will
be treated by the reader as numbers (with decimal values 10, 11, 15,
2989, and 64206, respectively). The ability to alter the input radix is
provided in Common Lisp primarily for the purpose of reading data ﬁles
in special formats, rather than for the purpose of altering the default
radix in which to read programs. The user is strongly encouraged to use
<i>#O</i>, <i>#X</i>, <i>#B</i>, or <i>#nR</i> syntax when notating non-decimal constants in
programs.
<div class=incompatibility>
<!--l. 863--><p class="noindent" ><b>Compatibility note:</b> This variable corresponds to the variable called <i>ibase</i> in MacLisp
and to the function called <i>radix</i> in Interlisp.
</div>
</div>
<div class=defun>
<!--l. 871--><p class="noindent" > <i>[Variable]</i>   <b>*read-suppress*</b> <a 
 id="dx142-189005"></a><a 
 id="x142-189006r671"></a>
<!--l. 873--><p class="noindent" >When the value of <i>*read-suppress*</i> is <i>nil</i>, the Lisp reader operates normally.
When it is not <i>nil</i>, then most of the interesting operations of the reader are
suppressed; input characters are parsed, but much of what is read is not
interpreted.
<!--l. 879--><p class="indent" >   The primary purpose of <i>*read-suppress*</i> is to support the operation of the
read-time conditional constructs <i>#+</i> and <i>#-</i> (see section <a 
href="#x142-19100022.1.4">22.1.4<!--tex4ht:ref: SHARP-SIGN-MACRO-CHARACTER-SECTION --></a>). It is important
for these constructs to be able to skip over the printed representation of a Lisp
expression despite the possibility that the syntax of the skipped expression may
not be entirely legal for the current implementation; this is because a primary
application of <i>#+</i> and <i>#-</i> is to allow the same program to be shared
among several Lisp implementations despite small incompatibilities of
                                                                          

                                                                          
syntax.
<!--l. 889--><p class="indent" >   A non-<i>nil</i> value of <i>*read-suppress*</i> has the following speciﬁc eﬀects on the
Common Lisp reader:
      <ul class="itemize1">
      <li class="itemize">All  extended  tokens  are  completely  uninterpreted.  It  matters  not
      whether the token looks like a number, much less like a valid number;
      the pattern of package markers also does not matter. An extended
      token is simply discarded and treated as if it were <i>nil</i>; that is, reading
      an  extended  token  when  <i>*read-suppress*</i> is  non-<i>nil</i> simply  returns
      <i>nil</i>. (One consequence of this is that the error concerning improper
      dotted-list syntax will not be signaled.)
      </li>
      <li class="itemize">Any standard <i>#</i> macro-character construction that requires, permits,
      or disallows an inﬁx numerical argument, such as <i>#nR</i>, will not enforce
      any constraint on the presence, absence, or value of such an argument.
      </li>
      <li class="itemize">The <i>#<tt>\</tt></i> construction always produces the value <i>nil</i>. It will not signal
      an error even if an unknown character name is seen.
      </li>
      <li class="itemize">Each of the <i>#B</i>, <i>#O</i>, <i>#X</i>, and <i>#R</i> constructions always scans over a
      following token and produces the value <i>nil</i>. It will not signal an error
      even if the token does not have the syntax of a rational number.
      </li>
      <li class="itemize">The <i>#*</i> construction always scans over a following token and produces
      the value <i>nil</i>. It will not signal an error even if the token does not
      consist solely of the characters <i>0</i> and <i>1</i>.</li></ul>
<div class=obsolete>
      <ul class="itemize1">
      <li class="itemize">Each  of  the  <i>#.</i> and  <i>#,</i> constructions  reads  the  following  form  (in
      suppressed  mode,  of  course)  but  does  not  evaluate  it.  The  form  is
      discarded and <i>nil</i> is produced.</li></ul>
                                                                          

                                                                          
</div>
<div class=newer>
<!--l. 934--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to remove <i>#,</i> from the language.
</div>
      <ul class="itemize1">
      <li class="itemize">Each of the <i>#A</i>, <i>#S</i>, and <i>#:</i> constructions reads the following form
      (in suppressed mode, of course) but does not interpret it in any way;
      it need not even be a list in the case of <i>#S</i>, or a symbol in the case of
      <i>#:</i>. The form is discarded and <i>nil</i> is produced.
      </li>
      <li class="itemize">The <i>#=</i> construction is totally ignored. It does not read a following
      form. It produces no object, but is treated as whitespace.
      </li>
      <li class="itemize">The <i>##</i> construction always produces <i>nil</i>.</li></ul>
<!--l. 953--><p class="noindent" >Note that, no matter what the value of <i>*read-suppress*</i>, parentheses still continue to
delimit (and construct) lists; the <i>#(</i> construction continues to delimit vectors;
and comments, strings, and the quote and backquote constructions continue to be
interpreted properly. Furthermore, such situations as <i>&#x2019;)</i>, <i>#&#x003C;</i>, <i>#)</i>, and <i>#⟨space⟩</i>
continue to signal errors.
<!--l. 961--><p class="indent" >   In some cases, it may be appropriate for a user-written macro-character
deﬁnition to check the value of <i>*read-suppress*</i> and to avoid certain computations
or side eﬀects if its value is not <i>nil</i>.
</div>
<div class=newer>
<div class=defun>
<!--l. 967--><p class="noindent" > <i>[Variable]</i>   <b>*read-eval*</b> <a 
 id="dx142-189007"></a><a 
 id="x142-189008r672"></a>
<!--l. 969--><p class="noindent" >X3J13 voted in June 1989 ⟨<b>?</b>⟩ to add a new reader control variable, <i>*read-eval*</i>,
whose default value is <i>t</i>. If <i>*read-eval*</i> is false, the <i>#.</i> reader macro signals an
error.
<!--l. 974--><p class="indent" >   Printing is also aﬀected. If <i>*read-eval*</i> is false and <i>*print-readably*</i> is
true, any <i>print-object</i> method that would otherwise output a <i>#.</i> reader
macro must either output something diﬀerent or signal an error of type
<i>print-not-readable</i>.
<!--l. 979--><p class="indent" >   Binding <i>*read-eval*</i> to <i>nil</i> is useful when reading data that came from an
untrusted source, such as a network or a user-supplied data ﬁle; it prevents the <i>#.</i>
                                                                          

                                                                          
reader macro from being exploited as a “Trojan horse” to cause arbitrary forms to
be evaluated.
</div>
</div>
   <h4 class="subsectionHead"><span class="titlemark">22.1.3   </span> <a 
 id="x142-19000022.1.3"></a>Macro Characters</h4>
<a 
 id="dx142-190001"></a>
<a 
 id="dx142-190002"></a>
<!--l. 990--><p class="noindent" >If the reader encounters a macro character, then the function associated
with that macro character is invoked and may produce an object to be
returned. This function may read following characters in the stream in
whatever syntax it likes (it may even call <i>read</i> recursively) and return the
object represented by that syntax. Macro characters may or may not be
recognized, of course, when read as part of other special syntaxes (such as for
strings).
<!--l. 998--><p class="indent" >   The reader is therefore organized into two parts: the basic dispatch loop, which
also distinguishes symbols and numbers, and the collection of macro characters.
Any character can be reprogrammed as a macro character; this is a means by
which the reader can be extended. The macro characters normally deﬁned are as
follows: <div class=flushdesc>
  <div><br /><b>
<i>(</i>                                                                         </b>The
left-parenthesis character initiates reading of a pair or list. The function <i>read</i> is
called recursively to read successive objects until a right parenthesis is found to be
next in the input stream. A list of the objects read is returned. Thus the input
sequence <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(a b c)
</td></tr></table>
<!--l. 1011--><p class="indent" >
</div>
</div>
<!--l. 1012--><p class="noindent" >is read as a list of three objects (the symbols <i>a</i>, <i>b</i>, and <i>c</i>). The right parenthesis
need not immediately follow the printed representation of the last object;
                                                                          

                                                                          
whitespace characters and comments may precede it. This can be useful for
putting one object on each line and making it easy to add new objects: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun traﬃc-light (color)
</td></tr></table>
<!--l. 1019--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (case color</td></tr></table>
<!--l. 1020--><p class="indent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (green)</td></tr></table>
<!--l. 1021--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (red (stop))</td></tr></table>
<!--l. 1022--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (amber (accelerate))     ;Insert more colors after this line</td></tr></table>
<!--l. 1023--><p class="indent" >                                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ))</td></tr></table>
<!--l. 1025--><p class="indent" >
</div>
</div>
<!--l. 1027--><p class="indent" >  It may be that no objects precede the right parenthesis, as in <i>()</i> or <i>( )</i>; this
reads as a list of zero objects (the empty list).
<!--l. 1030--><p class="indent" >  If a token that is just a dot, not preceded by an escape character, is
read after some object, then exactly one more object must follow the
dot, possibly followed by whitespace, followed by the right parenthesis: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(a b c . d)
</td></tr></table>
<!--l. 1038--><p class="indent" >
</div>
</div>
<!--l. 1039--><p class="noindent" >This means that the cdr of the last pair in the list is not <i>nil</i>, but rather the object
whose representation followed the dot. The above example might have been the
result of evaluating <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(cons &#x2019;a (cons &#x2019;b (cons &#x2019;c &#x2019;d)))  ⇒ (a b c . d)
</td></tr></table>
<!--l. 1044--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1045--><p class="noindent" >Similarly, we have <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(cons &#x2019;znets &#x2019;wolq-zorbitan)  ⇒ (znets . wolq-zorbitan)
</td></tr></table>
<!--l. 1048--><p class="indent" >
</div>
</div>
<!--l. 1049--><p class="noindent" >It is permissible for the object following the dot to be a list: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(a b c d . (e f . (g)))
</td></tr></table>
<!--l. 1052--><p class="indent" >
</div>
</div>
<!--l. 1053--><p class="noindent" >is the same as <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(a b c d e f g)
</td></tr></table>
<!--l. 1056--><p class="indent" >
</div>
</div>
<!--l. 1057--><p class="noindent" >but a list following a dot is a non-standard form that <i>print</i> will never produce.
  <br /><b>
<i>)</i>                                                                         </b>The
right-parenthesis character is part of various constructs (such as the syntax for
lists) using the left-parenthesis character and is invalid except when used in such a
construct. <a 
 id="dx142-190003"></a>
<!--l. 1066--><p class="indent" >
                                                                          

                                                                          
  <br /><b>
<i><tt>'</tt></i>                                                                         </b>The
single-quote (accent acute) character provides an abbreviation to make it easier to
put constants in programs. The form <i>&#x2019;foo</i> reads the same as <i>(quote foo)</i>: a list of
the symbol <i>quote</i> and foo.
  <br /><b>
<i>;</i>                                                                         </b>
Semicolon is used to write comments. <a 
 id="dx142-190004"></a><a 
 id="dx142-190005"></a> The semicolon and all characters up to and
including the next newline are ignored. Thus a comment can be put at the end of
any line without aﬀecting the reader. (A comment will terminate a token, but a
newline would terminate the token anyway.) <div class=newer> There is no functional diﬀerence
between using one semicolon and using more than one, but the conventions shown
here are in common use.
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;;; COMMENT-EXAMPLE function.
</td></tr></table>
<!--l. 1091--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; This function is useless except to demonstrate comments.</td></tr></table>
<!--l. 1092--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; (Actually, this example is much too cluttered with them.)</td></tr></table>
<!--l. 1093--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1094--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun comment-example (x y)      ;X is anything; Y is an a-list.</td></tr></table>
<!--l. 1095--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (cond ((listp x) x)             ;If X is a list, use that.</td></tr></table>
<!--l. 1096--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        ;; X is now not a list. There are two other cases.</td></tr></table>
<!--l. 1097--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        ((symbolp x)</td></tr></table>
<!--l. 1098--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         ;; Look up a symbol in the a-list.</td></tr></table>
<!--l. 1099--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (cdr (assoc x y)))       ;Remember, (cdr <i>nil</i>) is <i>nil</i>.</td></tr></table>
<!--l. 1100--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        ;; Do this when all else fails:</td></tr></table>
<!--l. 1101--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (t (cons x                ;Add x to a default list.</td></tr></table>
<!--l. 1102--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 &#x2019;((lisp t)       ;LISP is okay.</td></tr></table>
<!--l. 1103--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (fortran nil)  ;FORTRAN is not.</td></tr></table>
<!--l. 1104--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (pl/i -500)    ;Note that you can put comments in</td></tr></table>
<!--l. 1105--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (ada .001)     ; &#x0022;data&#x0022; as well as in &#x0022;programs&#x0022;.</td></tr></table>
<!--l. 1106--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   ;; COBOL??</td></tr></table>
                                                                          

                                                                          
<!--l. 1107--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (teco -1.0e9))))))</td></tr></table>
<!--l. 1109--><p class="indent" >
</div>
</div>
<!--l. 1110--><p class="noindent" >In this example, comments may begin with one to four semicolons.
     <ul class="itemize1">
     <li class="itemize">Single-semicolon comments are all aligned to the same column at the
     right;  usually  each  comment  concerns  only  the  code  it  is  next  to.
     Occasionally a comment is long enough to occupy two or three lines; in
     this case, it is conventional to indent the continued lines of the comment
     one space (after the semicolon).
     </li>
     <li class="itemize">Double-semicolon comments are aligned to the level of indentation of the
     code. A space conventionally follows the two semicolons. Such comments
     usually describe the state of the program at that point or the code
     section that follows the comment.
     </li>
     <li class="itemize">Triple-semicolon comments are aligned to the left margin. They usually
     document whole programs or large code blocks.
     </li>
     <li class="itemize">Quadruple-semicolon   comments   usually   indicate   titles   of   whole
     programs or large code blocks.</li></ul>
<div class=incompatibility>
<!--l. 1135--><p class="noindent" ><b>Compatibility note:</b> These conventions arose among users of MacLisp and have been
found to be very useful. The conventions are conveniently exploited by certain software
tools, such as the EMACS editor and the ATSIGN listing program developed at MIT. <div class=new>
The ATSIGN listing program, alas, is no longer in use, but EMACS is widely available,
especially the GNU EMACS implementation, which is available from the Free Software
Foundation, 675 Massachusetts Avenue, Cambridge, Massachusetts   02139. Remember,
GNU&#x2019;s Not UNIX.
</div>
</div>
  <br /><b>
<i>&#x0022;</i>                                                                         </b>
The double quote character begins the printed representation of a string.
                                                                          

                                                                          
Successive characters are read from the input stream and accumulated
until another double quote is encountered. An exception to this occurs
if a single escape character is seen; the escape character is discarded,
the next character is accumulated, and accumulation continues. When a
matching double quote is seen, all the accumulated characters up to but not
including the matching double quote are made into a simple string and
returned.
  <br /><b>
<i><tt>`</tt></i>                                                                         </b>The
backquote (accent grave) character makes it easier to write programs to construct
complex data structures by using a template.  <div class=new>Notice of correction. In the ﬁrst
edition, the backquote character ⟨<i><tt>`</tt></i>⟩ appearing at the left margin above was
inadvertently omitted.
</div> As an example, writing <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><tt>‘</tt>(cond ((numberp ,x) ,<tt>@</tt>y) (t (print ,x) ,<tt>@</tt>y))
</td></tr></table>
<!--l. 1176--><p class="indent" >
</div>
</div>
<!--l. 1177--><p class="noindent" >is roughly equivalent to writing <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list &#x2019;cond
</td></tr></table>
<!--l. 1179--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (cons (list &#x2019;numberp x) y)</td></tr></table>
<!--l. 1180--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (list* &#x2019;t (list &#x2019;print x) y))</td></tr></table>
<!--l. 1182--><p class="indent" >
</div>
</div>
<!--l. 1183--><p class="noindent" >The general idea is that the backquote is followed by a template, a picture of a data
structure to be built. This template is copied, except that within the template
commas can appear. Where a comma occurs, the form following the comma is to
be evaluated to produce an object to be inserted at that point. Assume <i>b</i> has the
value <i>3</i>; then evaluating the form denoted by <i><tt>`</tt>(a b ,b ,(+ b 1) b)</i> produces the
                                                                          

                                                                          
result <i>(a b 3 4 b)</i>.
<!--l. 1191--><p class="indent" >  If a comma is immediately followed by an at-sign (<i><tt>@</tt></i>), then the form following
the at-sign is evaluated to produce a list of objects. These objects are then
“spliced” into place in the template. For example, if <i>x</i> has the value <i>(a b c)</i>, then <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><tt>‘</tt>(x ,x ,<tt>@</tt>x foo ,(cadr x) bar ,(cdr x) baz ,<tt>@</tt>(cdr x))
</td></tr></table>
<!--l. 1196--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (x (a b c) a b c foo b bar (b c) baz b c)</td></tr></table>
<!--l. 1198--><p class="indent" >
</div>
</div>
<!--l. 1200--><p class="indent" >  The backquote syntax can be summarized formally as follows. For each of
several situations in which backquote can be used, a possible interpretation of
that situation as an equivalent form is given. Note that the form is equivalent only
in the sense that when it is evaluated it will calculate the correct result. An
implementation is quite free to interpret backquote in any way such that a
backquoted form, when evaluated, will produce a result <i>equal</i> to that produced by
the interpretation shown here.
     <ul class="itemize1">
     <li class="itemize"><i><tt>`</tt>basic</i> is the same as <i>&#x2019;basic</i>, that is, <i>(quote basic)</i>, for any form basic
     that is not a list or a general vector.
     </li>
     <li class="itemize"><i><tt>`</tt>,form</i>  is  the  same  as  form,  for  any  form,  provided  that  the
     representation of form does not begin with “<i><tt>@</tt></i>” or “<i>.</i>”. (A similar caveat
     holds for all occurrences of a form after a comma.)
     </li>
     <li class="itemize"><i><tt>`</tt>,<tt>@</tt>form</i> is an error.
     </li>
     <li class="itemize"><i><tt>`</tt>(x1 x2 x3 ... xn . atom)</i> may be interpreted to mean <div class=lisp> <div class=tabbing>
     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:38;" 
class="tabbing"></td><td  
class="tabbing">(append [x1] [x2] [x3] ... [xn] (quote atom))
</td></tr></table>
     <!--l. 1229--><p class="noindent" >
                                                                          

                                                                          
</div>
</div>
     <!--l. 1230--><p class="noindent" >where the brackets are used to indicate a transformation of an xj as
     follows:
         <ul class="itemize2">
         <li class="itemize">[form] is interpreted as <i>(list <tt>`</tt>form)</i>, which contains a backquoted
         form that must then be further interpreted.
         </li>
         <li class="itemize">[<i>,form</i>] is interpreted as <i>(list form)</i>.
         </li>
         <li class="itemize">[<i>,<tt>@</tt>form</i>] is interpreted simply as form.</li></ul>
     </li>
     <li class="itemize"><i><tt>`</tt>(x1 x2 x3 ... xn)</i> may be interpreted to mean the same as the backquoted
     form <i><tt>`</tt>(x1 x2 x3 ... xn . <i>nil</i>)</i>, thereby reducing it to the previous
     case.
     </li>
     <li class="itemize"><i><tt>`</tt>(x1 x2 x3 ... xn . ,form)</i> may be interpreted to mean <div class=lisp> <div class=tabbing>
     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:38;" 
class="tabbing"></td><td  
class="tabbing">(append [x1] [x2] [x3] ... [xn] form)
</td></tr></table>
     <!--l. 1255--><p class="noindent" >
</div>
</div>
     <!--l. 1256--><p class="noindent" >where the brackets indicate a transformation of an xj as described
     above.
     </li>
     <li class="itemize"><i><tt>`</tt>(x1 x2 x3 ... xn . ,<tt>@</tt>form)</i> is an error.
     </li>
     <li class="itemize"><i><tt>`</tt>#(x1 x2 x3 ... xn)</i> may be interpreted to mean <div class=lisp> <div class=tabbing>
     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:38;" 
class="tabbing"></td><td  
class="tabbing">(apply #&#x2019;vector <tt>‘</tt>(x1 x2 x3 ... xn))
</td></tr></table>
     <!--l. 1265--><p class="noindent" >
                                                                          

                                                                          
</div>
</div>
     </li></ul>
<!--l. 1268--><p class="indent" >  No other uses of comma are permitted; in particular, it may not appear within
the <i>#A</i> or <i>#S</i> syntax.
<!--l. 1271--><p class="indent" >  Anywhere “<i>,<tt>@</tt></i>” may be used, the syntax “<i>,.</i>” may be used instead to indicate
that it is permissible to destroy the list produced by the form following the “<i>,.</i>”;
this may permit more eﬃcient code, using <i>nconc</i> instead of <i>append</i>, for
example.
<!--l. 1276--><p class="indent" >  If the backquote syntax is nested, the innermost backquoted form should be
expanded ﬁrst. This means that if several commas occur in a row, the leftmost
one belongs to the innermost backquote.
<!--l. 1280--><p class="indent" >  Once again, it is emphasized that an implementation is free to interpret a
backquoted form as any form that, when evaluated, will produce a result that is
<i>equal</i> to the result implied by the above deﬁnition. In particular, no guarantees
are made as to whether the constructed copy of the template will or will not share
list structure with the template itself. As an example, the above deﬁnition implies
that <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><tt>‘</tt>((,a b) ,c ,<tt>@</tt>d)
</td></tr></table>
<!--l. 1288--><p class="indent" >
</div>
</div>
<!--l. 1289--><p class="noindent" >will be interpreted as if it were <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(append (list (append (list a) (list &#x2019;b) &#x2019;<i>nil</i>)) (list c) d &#x2019;<i>nil</i>)
</td></tr></table>
<!--l. 1292--><p class="indent" >
</div>
</div>
<!--l. 1293--><p class="noindent" >but it could also be legitimately interpreted to mean any of the following. <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(append (list (append (list a) (list &#x2019;b))) (list c) d)
</td></tr></table>
<!--l. 1295--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(append (list (append (list a) &#x2019;(b))) (list c) d)</td></tr></table>
<!--l. 1296--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(append (list (cons a &#x2019;(b))) (list c) d)</td></tr></table>
<!--l. 1297--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list* (cons a &#x2019;(b)) c d)</td></tr></table>
<!--l. 1298--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list* (cons a (list &#x2019;b)) c d)</td></tr></table>
<!--l. 1299--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list* (cons a &#x2019;(b)) c (copy-list d))</td></tr></table>
<!--l. 1301--><p class="indent" >
</div>
</div>
<!--l. 1302--><p class="noindent" >(There is no good reason why <i>copy-list</i> should be performed, but it is not
prohibited.)
                                                                          

                                                                          
<div class=new>
<!--l. 1308--><p class="indent" >  Some users complain that backquote syntax is diﬃcult to read, especially when
it is nested. I agree that it can get complicated, but in some situations (such as
writing macros that expand into deﬁnitions for other macros) such complexity is
to be expected, and the alternative is much worse.
<!--l. 1314--><p class="indent" >  After I gained some experience in writing nested backquote forms, I found that
I was not stopping to analyze the various patterns of nested backquotes and
interleaved commas and quotes; instead, I was recognizing standard idioms
wholesale, in the same manner that I recognize <i>cadar</i> as the primitive for “extract
the lambda-list from the form <i>((lambda ...) ...)</i>)” without stopping to analyze it
into “<i>car</i> of <i>cdr</i> of <i>car</i>.” For example, <i>,x</i> within a doubly-nested backquote form
means “the value of <i>x</i> available during the second evaluation will appear here once
the form has been twice evaluated,” whereas <i>,&#x2019;,x</i> means “the value of <i>x</i>
available during the ﬁrst evaluation will appear here once the form has been
twice evaluated” and <i>„x</i> means “the value of the value of <i>x</i> will appear
here.”
<!--l. 1328--><p class="indent" >  See appendix <a 
href="clmap3.html#x201-367000C">C<!--tex4ht:ref: BACKQUOTE-SIMULATOR --></a> for a systematic set of examples of the use of nested
backquotes.
</div>
  <br /><b>
<i>,</i>                                                                          </b>The
comma character is part of the backquote syntax and is invalid if used other
than inside the body of a backquote construction as described above.
<a 
 id="dx142-190006"></a>
  <br /><b>
<i>#</i>                                                                        </b>This
is a dispatching macro character. It reads an optional digit string and then one
more character, and uses that character to select a function to run as a
macro-character function.
<!--l. 1344--><p class="indent" >  The <i>#</i> character also happens to be a non-terminating macro character.
This is completely independent of the fact that it is a dispatching macro
character; it is a coincidence that the only standard dispatching macro
character in Common Lisp is also the only standard non-terminating macro
character.
<!--l. 1350--><p class="indent" >  See the next section for predeﬁned <i>#</i> macro-character constructions.</div>
                                                                          

                                                                          
</div>
   <h4 class="subsectionHead"><span class="titlemark">22.1.4   </span> <a 
 id="x142-19100022.1.4"></a>Standard Dispatching Macro Character Syntax</h4>
<a 
 id="dx142-191001"></a>
<!--l. 1357--><p class="noindent" >The standard syntax includes forms introduced by the <i>#</i> character. These take
the general form of a <i>#</i>, a second character that identiﬁes the syntax, and
following arguments in some form. If the second character is a letter, then
case is not important; <i>#O</i> and <i>#o</i> are considered to be equivalent, for
example.
<!--l. 1364--><p class="indent" >   Certain <i>#</i> forms allow an unsigned decimal number to appear between the <i>#</i>
and the second character; some other forms even require it. Those forms that do
not explicitly permit such a number to appear forbid it.
   <div class="table">
                                                                          

                                                                          
<!--l. 1370--><p class="indent" >   <a 
 id="x142-1910024"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 22.4: </span><span  
class="content">Standard # Macro Character Syntax</span></div><!--tex4ht:label?: x142-1910024 -->
Table unavailable
<!--l. 1426--><p class="noindent" >The combinations marked by an asterisk are explicitly reserved to the user and will
never be deﬁned by Common Lisp.
<div class=new>
<!--l. 1431--><p class="noindent" >X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify <i>#P</i> and <i>#p</i> (undeﬁned in the ﬁrst
edition).
</div>
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<!--l. 1438--><p class="indent" >   The currently deﬁned <i>#</i> constructs are described below and summarized in
table <a 
href="#x142-1910024">22.4<!--tex4ht:ref: Standard-Sharp-Macro-Definitions-Table --></a>; more are likely to be added in the future. However, the constructs <i>#!</i>,
<i>#?</i>, <i>#<tt>[</tt></i>, <i>#<tt>]</tt></i>, <i>#<tt>{</tt></i>, and <i>#<tt>}</tt></i> are explicitly reserved for the user and will never be
deﬁned by the Common Lisp standard. <div class=flushdesc>
  <div><br /><b>
<i>#<tt>\</tt></i>                                                                       </b>
<i>#<tt>\</tt>x</i> reads in as a character object that represents the character x. Also,
<i>#<tt>\</tt>name</i> reads in as the character object whose name is name. <a 
 id="dx142-191003"></a>Note that the
backslash <i><tt>\</tt></i> allows this construct to be parsed easily by EMACS-like editors.
<!--l. 1454--><p class="indent" >  In  the  single-character  case,  the  character  x  must  be  followed  by  a
non-constituent character, lest a name appear to follow the <i>#<tt>\</tt></i>. A good model
of what happens is that after <i>#<tt>\</tt></i> is read, the reader backs up over the <i><tt>\</tt></i> and
then reads an extended token, treating the initial <i><tt>\</tt></i> as an escape character
(whether it really is or not in the current readtable).
<!--l. 1461--><p class="indent" >  Uppercase  and  lowercase  letters  are  distinguished  after  <i>#<tt>\</tt></i>;  <i>#<tt>\</tt>A</i>  and
<i>#<tt>\</tt>a</i> denote diﬀerent character objects. Any character works after <i>#<tt>\</tt></i>, even
those that are normally special to <i>read</i>, such as parentheses. Non-printing
characters may be used after <i>#<tt>\</tt></i>, although for them names are generally
preferred.
<i>
<!--l. 1467--><p class="indent" >  #<tt>\</tt>name</i> reads in as a character object whose name is name (actually, whose
name is <i>(string-upcase name)</i>; therefore the syntax is case-insensitive). The name
should have the syntax of a symbol. The following names are standard across all
implementations: <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:126;" 
class="tabbing"><i>newline</i>           </td><td  
class="tabbing">The character that represents the division between lines
</td></tr></table>
<!--l. 1474--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:126;" 
class="tabbing"><i>space</i>              </td><td  
class="tabbing">The space or blank character</td></tr></table>
<!--l. 1476--><p class="indent" >
</div>
<!--l. 1477--><p class="noindent" >The following names are semi-standard; if an implementation supports them, they
should be used for the described characters and no others. <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:126;" 
class="tabbing"><i>rubout</i>            </td><td  
class="tabbing">The rubout or delete character.
</td></tr></table>
<!--l. 1481--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:126;" 
class="tabbing"><i>page</i>               </td><td  
class="tabbing">The form-feed or page-separator character</td></tr></table>
<!--l. 1482--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:126;" 
class="tabbing"><i>tab</i>                </td><td  
class="tabbing">The tabulate character</td></tr></table>
<!--l. 1483--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:126;" 
class="tabbing"><i>backspace</i>        </td><td  
class="tabbing">The backspace character</td></tr></table>
<!--l. 1484--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:126;" 
class="tabbing"><i>return</i>            </td><td  
class="tabbing">The carriage return character</td></tr></table>
<!--l. 1485--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:126;" 
class="tabbing"><i>linefeed</i>           </td><td  
class="tabbing">The line-feed character</td></tr></table>
<!--l. 1487--><p class="indent" >
</div>
<!--l. 1488--><p class="noindent" >In some implementations, one or more of these characters might be a synonym for a
standard character; the <i>#<tt>\</tt>Linefeed</i> character might be the same as <i>#<tt>\</tt>Newline</i>,
for example.
<!--l. 1492--><p class="indent" >  When the Lisp printer types out the name of a special character, it uses the
same table as the <i>#<tt>\</tt></i> reader; therefore any character name you see typed out is
acceptable as input (in that implementation). Standard names are always
preferred over non-standard names for printing.
<!--l. 1497--><p class="indent" >  The following convention is used in implementations that support non-zero
bits attributes for character objects. If a name after <i>#<tt>\</tt></i> is longer than
one character and has a hyphen in it, then it may be split into the two
parts preceding and following the ﬁrst hyphen; the ﬁrst part (actually,
<i>string-upcase</i> of the ﬁrst part) may then be interpreted as the name or initial of a
bit, and the second part as the name of the character (which may in
turn contain a hyphen and be subject to further splitting). For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:180;" 
class="tabbing">#<tt>\</tt>Control-Space        </td><td  
class="tabbing">#<tt>\</tt>Control-Meta-Tab
</td></tr></table>
<!--l. 1509--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:180;" 
class="tabbing">#<tt>\</tt>C-M-Return          </td><td  
class="tabbing">#<tt>\</tt>H-S-M-C-Rubout</td></tr></table>
<!--l. 1511--><p class="indent" >
</div>
</div>
<!--l. 1512--><p class="noindent" >If the character name consists of a single character, then that character is used.
Another <i><tt>\</tt></i> may be necessary to quote the character. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:180;" 
class="tabbing">#<tt>\</tt>Control-%             </td><td  
class="tabbing">#<tt>\</tt>Control-Meta-<tt>\</tt>&#x0022;
</td></tr></table>
<!--l. 1516--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:180;" 
class="tabbing">#<tt>\</tt>Control-<tt>\</tt>a             </td><td  
class="tabbing">#<tt>\</tt>Meta-&#x003E;</td></tr></table>
<!--l. 1518--><p class="indent" >
</div>
</div>
<div class=obsolete>
<!--l. 1521--><p class="indent" >  If an unsigned decimal integer appears between the <i>#</i> and <i><tt>\</tt></i>, it is interpreted as
a font number, to become the font attribute of the character object (see
<i>char-font</i>).
</div>
<div class=newer>
<!--l. 1527--><p class="indent" >  X3J13 voted in March 1989 ⟨<b>?</b>⟩ to replace the notion of bits and font attributes
with that of implementation-deﬁned attributes. Presumably this eliminates the
portable use of this syntax for font information, although the vote did not address
this question directly.
</div>
  <br /><b>
<i>#&#x2019;</i>                                                                       </b><i>#&#x2019;foo</i>
is an abbreviation for <i>(function foo)</i>. foo may be the printed representation of any
Lisp object. This abbreviation may be remembered by analogy with the <i>&#x2019;</i>
macro character, since the <i>function</i> and <i>quote</i> special forms are similar in
form.
  <br /><b>
<i>#(</i>                                                                       </b>
A series of representations of objects enclosed by <i>#(</i> and <i>)</i> is read as
a simple vector of those objects. This is analogous to the notation for
lists.
<!--l. 1546--><p class="indent" >  If an unsigned decimal integer appears between the <i>#</i> and <i>(</i>, it speciﬁes
explicitly the length of the vector. In that case, it is an error if too many objects
are speciﬁed before the closing <i>)</i>, and if too few are speciﬁed, the last object (it is
an error if there are none in this case) is used to ﬁll all remaining elements of the
vector. For example, <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#(a b c c c c)     #6(a b c c c c)     #6(a b c)     #6(a b c c)
</td></tr></table>
<!--l. 1556--><p class="indent" >
</div>
</div>
<!--l. 1557--><p class="noindent" >all mean the same thing: a vector of length 6 with elements <i>a</i>, <i>b</i>, and four
instances of <i>c</i>. The notation <i>#()</i> denotes an empty vector, as does <i>#0()</i>
(which is legitimate because it is not the case that too few elements are
speciﬁed).
  <br /><b>
<i>#*</i>                                                                       </b>A
series of binary digits (<i>0</i> and <i>1</i>) preceded by <i>#*</i> is read as a simple bit-vector
containing those bits, the leftmost bit in the series being bit 0 of the
bit-vector.
<!--l. 1568--><p class="indent" >  If an unsigned decimal integer appears between the <i>#</i> and <i>*</i>, it speciﬁes
explicitly the length of the vector. In that case, it is an error if too many bits are
speciﬁed, and if too few are speciﬁed the last one (it is an error if there are none
in this case) is used to ﬁll all remaining elements of the bit-vector. For example, <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#*101111     #6*101111     #6*101     #6*1011
</td></tr></table>
<!--l. 1577--><p class="indent" >
</div>
</div>
<!--l. 1578--><p class="noindent" >all mean the same thing: a vector of length 6 with elements <i>1</i>, <i>0</i>, <i>1</i>, <i>1</i>,
<i>1</i>, and <i>1</i>. The notation <i>#*</i> denotes an empty bit-vector, as does <i>#0*</i>
(which is legitimate because it is not the case that too few elements are
speciﬁed). <div class=new> Compare this to <i>#B</i>, used for expressing integers in binary
notation.
</div>
  <br /><b>
<i>#:</i>                                                                        </b><i>#:foo</i>
requires foo to have the syntax of an unqualiﬁed symbol name (no embedded
                                                                          

                                                                          
colons). It denotes an uninterned symbol whose name is foo. Every time this
syntax is encountered, a diﬀerent uninterned symbol is created. If it is necessary
to refer to the same uninterned symbol more than once in the same expression,
the <i>#=</i> syntax may be useful.
  <br /><b>
<i>#.</i>                                                                        </b>
<i>#.foo</i> is read as the object resulting from the evaluation of the Lisp object
represented by foo, which may be the printed representation of any Lisp object.
The evaluation is done during the <i>read</i> process, when the <i>#.</i> construct is
encountered.
<div class=newer>
<!--l. 1603--><p class="indent" >  X3J13 voted in June 1989 ⟨<b>?</b>⟩ to add a new reader control variable, <i>*read-eval*</i>.
If it is true, the <i>#.</i> reader macro behaves as described above; if it is false, the <i>#.</i>
reader macro signals an error.
</div>
<!--l. 1609--><p class="indent" >  The <i>#.</i> syntax therefore performs a read-time evaluation of foo. By contrast, <i>#,</i>
(see below) performs a load-time evaluation.
<!--l. 1612--><p class="indent" >  Both <i>#.</i> and <i>#,</i> allow you to include, in an expression being read, an object
that does not have a convenient printed representation; instead of writing a
representation for the object, you write an expression that will compute the
object.</div>
</div>
<div class=obsolete>
<div class=flushdesc>
  <div><br /><b>
<i>#,</i>                                                                        </b>
<i>#,foo</i> is read as the object resulting from the evaluation of the Lisp object
represented by foo, which may be the printed representation of any Lisp
object. The evaluation is done during the <i>read</i> process, unless the compiler
is doing the reading, in which case it is arranged that foo will be evaluated
when the ﬁle of compiled code is loaded. The <i>#,</i> syntax therefore performs a
load-time evaluation of foo. By contrast, <i>#.</i> (see above) performs a read-time
evaluation. In a sense, <i>#,</i> is like specifying <i>(eval load)</i> to <i>eval-when</i>, whereas
<i>#.</i>  is  more  like  specifying  <i>(eval  compile)</i>.  It  makes  no  diﬀerence  when
loading interpreted code; when code is to be compiled, however, <i>#.</i> speciﬁes
                                                                          

                                                                          
compile-time evaluation and <i>#,</i> speciﬁes load-time evaluation.</div>
</div>
</div>
<div class=new>
<!--l. 1638--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to remove <i>#,</i> from the language. X3J13
noted that the ﬁrst edition failed to make it clear that <i>#,</i> can be meaningful only
within quoted forms. All sorts of anomalies can arise, including inconsistencies
between the interpreter and compiler, if <i>#,</i> is not properly restricted. See
<i>load-time-eval</i>.
</div>
<div class=flushdesc>
  <div><br /><b>
<i>#B</i>                                                                       </b>
<i>#brational</i> reads rational in binary (radix 2). For example, <i>#B1101</i>  ≡ <i>13</i>, and
<i>#b101/11</i>  ≡ <i>5/3</i>. <div class=new> Compare this to <i>#*</i>, used for expressing bit-vectors in binary
notation.
</div>
  <br /><b>
<i>#O</i>                                                                       </b>
<i>#orational</i> reads rational in octal (radix 8). For example, <i>#o37/15</i>  ≡ <i>31/13</i>,
and <i>#o777</i>  ≡ <i>511</i>.
  <br /><b>
<i>#X</i>                                                                      </b>
<i>#xrational</i> reads rational in hexadecimal (radix 16). The digits above <i>9</i> are the
letters <i>A</i> through <i>F</i> (the lowercase letters <i>a</i> through <i>f </i> are also acceptable). For
example, <i>#xF00</i>  ≡ <i>3840</i>.
  <br /><b>
<i>#nR</i>                                                                     </b>
<i>#radixrrational</i> reads rational in radix radix. radix must consist of only digits, and
it is read in decimal; its value must be between 2 and 36 (inclusive).
                                                                          

                                                                          
<!--l. 1672--><p class="indent" >  For example, <i>#3r102</i> is another way of writing <i>11</i>, and <i>#11R32</i> is another way
of writing <i>35</i>. For radices larger than 10, letters of the alphabet are used in order
for the digits after <i>9</i>.
  <br /><b>
<i>#nA</i>                                                                      </b>The
syntax <i>#nAobject</i> constructs an n-dimensional array, using object as the value of
the <i>:initial-contents</i> argument to <i>make-array</i>.
<!--l. 1681--><p class="indent" >  The value of n makes a diﬀerence: <i>#2A((0 1 5) (foo 2 (hot dog)))</i>, for example,
represents a 2-by-3 matrix: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">0       1       5
</td></tr></table>
<!--l. 1684--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">foo     2       (hot dog)</td></tr></table>
<!--l. 1686--><p class="indent" >
</div>
</div>
<!--l. 1687--><p class="noindent" >In contrast, <i>#1A((0 1 5) (foo 2 (hot dog)))</i> represents a length-2 array whose
elements are lists: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(0 1 5)    (foo 2 (hot dog))
</td></tr></table>
<!--l. 1691--><p class="indent" >
</div>
</div>
<!--l. 1692--><p class="noindent" >Furthermore, <i>#0A((0 1 5) (foo 2 (hot dog)))</i> represents a zero-dimensional array
whose sole element is a list: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">((0 1 5) (foo 2 (hot dog)))
</td></tr></table>
<!--l. 1696--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 1697--><p class="noindent" >Similarly, <i>#0Afoo</i> (or, more readably, <i>#0A foo</i>) represents a zero-dimensional array
whose sole element is the symbol <i>foo</i>. The expression <i>#1Afoo</i> would not be legal
because <i>foo</i> is not a sequence.
  <br /><b>
<i>#S</i>                                                                       </b>The
syntax <i>#s(name slot1 value1 slot2 value2 ...)</i> denotes a structure. This is legal
only if name is the name of a structure already deﬁned by <i>defstruct</i> and if the
structure has a standard constructor macro, which it normally will. Let cm stand
for the name of this constructor macro; then this syntax is equivalent to <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#.(cm keyword1 &#x2019;value1 keyword2 &#x2019;value2 ...)
</td></tr></table>
<!--l. 1711--><p class="indent" >
</div>
</div>
<!--l. 1712--><p class="noindent" >where each keywordj is the result of computing <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(intern (string slotj) &#x2019;keyword)
</td></tr></table>
<!--l. 1715--><p class="indent" >
</div>
</div>
<!--l. 1716--><p class="noindent" >(This computation is made so that one need not write a colon in front of every slot
name.) The net eﬀect is that the constructor macro is called with the speciﬁed
slots having the speciﬁed values (note that one does not write quote marks in the
<i>#S</i> syntax). Whatever object the constructor macro returns is returned by the
<i>#S</i> syntax.</div>
</div>
<div class=newer>
<div class=flushdesc>
  <div><br /><b>
                                                                          

                                                                          
<i>#P</i>                                                                       </b>
X3J13 voted in June 1989 ⟨<b>?</b>⟩ to deﬁne the reader syntax <i>#p&#x0022;...&#x0022;</i> to be
equivalent to <i>#.(parse-namestring &#x0022;...&#x0022;)</i>. Presumably this was meant to be
taken descriptively and not literally. I would think, for example, that the
committee  did  not  wish  to  quibble  over  the  package  in  which  the  name
<i>parse-namestring</i> was to be read. Similarly, I would presume that the <i>#p</i>
syntax operates normally rather than signaling an error when <i>*read-eval*</i>
is false. I interpret the intent of the vote to be that <i>#p</i> reads a following
form, which should be a string, that is then converted to a pathname as if
by application of the standard function <i>parse-namestring</i>.</div>
</div>
</div>
<div class=flushdesc>
  <div><br /><b>
<i>#n<tt>=</tt></i>                                                                      </b>
The syntax <i>#n=object</i> reads as whatever Lisp object has object as its printed
representation. However, that object is labelled by n, a required unsigned
decimal integer, for possible reference by the syntax <i>#n#</i> (below). The scope
of the label is the expression being read by the outermost call to <i>read</i>. Within
this expression the same label may not appear twice.
  <br /><b>
<i>#n#</i>                                                                     </b>The
syntax <i>#n#</i>, where n is a required unsigned decimal integer, serves as a reference
to some object labelled by <i>#n=</i>; that is, <i>#n#</i> represents a pointer to the same
identical (<i>eq</i>) object labelled by <i>#n=</i>. This permits notation of structures with
shared or circular substructure. For example, a structure created in the variable <i>y</i>
by this code: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x (list &#x2019;p &#x2019;q))
</td></tr></table>
<!--l. 1760--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq y (list (list &#x2019;a &#x2019;b) x &#x2019;foo x))</td></tr></table>
<!--l. 1761--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(rplacd (last y) (cdr y))</td></tr></table>
<!--l. 1763--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1764--><p class="noindent" >could be represented in this way: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">((a b) . #1=(#2=(p q) foo #2# . #1#))
</td></tr></table>
<!--l. 1767--><p class="indent" >
</div>
</div>
<!--l. 1768--><p class="noindent" >Without this notation, but with <i>*print-length*</i> set to <i>10</i>, the structure would print
in this way: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">((a b) (p q) foo (p q) (p q) foo (p q) (p q) foo (p q) ...)
</td></tr></table>
<!--l. 1772--><p class="indent" >
</div>
</div>
<!--l. 1773--><p class="noindent" >A reference <i>#n#</i> may occur only after a label <i>#n=</i>; forward references are not
permitted. In addition, the reference may not appear as the labelled object itself
(that is, one may not write <i>#n= #n#</i>), because the object labelled by <i>#n=</i> is
not well deﬁned in this case.
  <br /><b>
<i>#+</i>                                                                       </b> The
<i>#+</i> syntax provides a read-time conditionalization facility; the syntax is <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#+feature form
</td></tr></table>
<!--l. 1785--><p class="indent" >
</div>
</div>
<!--l. 1786--><p class="noindent" >If feature is “true,” then this syntax represents a Lisp object whose printed
                                                                          

                                                                          
representation is form. If feature is “false,” then this syntax is eﬀectively
whitespace; it is as if it did not appear.
<!--l. 1790--><p class="indent" >  The feature should be the printed representation of a symbol or list. If feature is
a symbol, then it is true if and only if it is a member of the list that is the value of
the global variable <i>*features*</i>.
<div class=incompatibility>
<!--l. 1796--><p class="noindent" ><b>Compatibility note:</b> MacLisp uses the <i>status</i> special form for this purpose, and Lisp
Machine Lisp duplicates <i>status</i> essentially only for the sake of <i>(status features)</i>.
The use of a variable allows one to bind the features list, when compiling, for
example.
</div>
<!--l. 1804--><p class="indent" >  Otherwise, feature should be a Boolean expression composed of <i>and</i>, <i>or</i>, and
<i>not</i> operators on (recursive) feature expressions.
<!--l. 1808--><p class="indent" >  For example, suppose that in implementation A the features <i>spice</i> and <i>perq</i> are
true, and in implementation B the feature <i>lispm</i> is true. Then the expressions on
the left below are read the same as those on the right in implementation A: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(cons #+spice &#x0022;Spice&#x0022; #+lispm &#x0022;Lispm&#x0022; x)      (cons &#x0022;Spice&#x0022; x)
</td></tr></table>
<!--l. 1813--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a &#x2019;(1 2 #+perq 43 #+(not perq) 27))     (setq a &#x2019;(1 2 43))</td></tr></table>
<!--l. 1814--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((a 3) #+(or spice lispm) (b 3))         (let ((a 3) (b 3))</td></tr></table>
<!--l. 1815--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (foo a))                                      (foo a))</td></tr></table>
<!--l. 1816--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(cons a #+perq #-perq b c)                    (cons a c)</td></tr></table>
<!--l. 1818--><p class="indent" >
</div>
</div>
<!--l. 1819--><p class="noindent" >In implementation B, however, they are read in this way: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(cons #+spice &#x0022;Spice&#x0022; #+lispm &#x0022;Lispm&#x0022; x)      (cons &#x0022;Lispm&#x0022; x)
</td></tr></table>
<!--l. 1821--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq a &#x2019;(1 2 #+perq 43 #+(not perq) 27))     (setq a &#x2019;(1 2 27))</td></tr></table>
<!--l. 1822--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((a 3) #+(or spice lispm) (b 3))         (let ((a 3) (b 3))</td></tr></table>
<!--l. 1823--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (foo a))                                      (foo a))</td></tr></table>
<!--l. 1824--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(cons a #+perq #-perq b c)                    (cons a c)</td></tr></table>
<!--l. 1826--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1828--><p class="indent" >
                                                                          

                                                                          
<!--l. 1830--><p class="indent" >  The <i>#+</i> construction must be used judiciously if unreadable code is not to
result. The user should make a careful choice between read-time conditionalization
and run-time conditionalization.
<div class=obsolete>
<!--l. 1835--><p class="indent" >  The <i>#+</i> syntax operates by ﬁrst reading the feature speciﬁcation and then
skipping over the form if the feature is “false.” This skipping of a form is a bit
tricky because of the possibility of user-deﬁned macro characters and side eﬀects
caused by the <i>#.</i> and <i>#,</i> constructions. It is accomplished by binding the
variable <i>*read-suppress*</i> to a non-<i>nil</i> value and then calling the <i>read</i>
function. See the description of <i>*read-suppress*</i> for the details of this
operation.
</div> <div class=new> X3J13 voted in January 1989 ⟨<b>?</b>⟩ to remove <i>#,</i> from the language.
</div> <div class=newer> X3J13 voted in March 1988 ⟨<b>?</b>⟩ to specify that the <i>keyword</i> package is the
default package during the reading of a feature speciﬁcation. Thus <i>#+spice</i> means
the same thing as <i>#+:spice</i>, and <i>#+(or spice lispm)</i> means the same
thing as <i>#+(or :spice :lispm)</i>. Symbols in other packages may be used as
feature names, but one must use an explicit package preﬁx to cite one after
<i>#+</i>.
</div>
  <br /><b>
<i>#-</i>                                                                        </b>
<i>#-feature form</i> is equivalent to <i>#+(not feature) form</i>.
  <br /><b>
<i>#|</i>                                                                        </b>
<i>#|...|#</i> is treated as a comment by the reader, just as everything from a
semicolon to the next newline is treated as a comment. Anything may appear in
the comment, except that it must be balanced with respect to other occurrences
of <i>#|</i> and <i>|#</i>. Except for this nesting rule, the comment may contain any
characters whatsoever.
<!--l. 1871--><p class="indent" >  The main purpose of this construct is to allow “commenting out” of
blocks of code or data. The balancing rule allows such blocks to contain
pieces already so commented out. In this respect the <i>#|...|#</i> syntax of
Common Lisp diﬀers from the <i>/*...*/</i> comment syntax used by PL/I and
C.
  <br /><b>
                                                                          

                                                                          
<i>#&#x003C;</i>                                                                       </b>This
is not legal reader syntax. It is conventionally used in the printed representation
of objects that cannot be read back in. Attempting to read a <i>#&#x003C;</i> will cause an
error. (More precisely, it is legal syntax, but the macro-character function for <i>#&#x003C;</i>
signals an error.)
<div class=newer>
<!--l. 1885--><p class="indent" >  The usual convention for printing unreadable data objects is to print some
identifying information (the internal machine address of the object, if nothing
else) preceded by <i>#&#x003C;</i> and followed by <i>&#x003E;</i>.
<!--l. 1889--><p class="indent" >  X3J13 voted in June 1989 ⟨<b>?</b>⟩ to add <i>print-unreadable-object</i>, a macro that
prints an object using <i>#&#x003C;...&#x003E;</i> syntax and also takes care of checking the variable
<i>*print-readably*</i>.
</div>
  <br /><b>
<i>#</i>⟨space⟩, <i> #</i>⟨tab⟩, <i> #</i>⟨newline⟩, <i> #</i>⟨page⟩, <i> #</i>⟨return⟩                    </b>A <i>#</i>
followed by a whitespace character is not legal reader syntax. This prevents
abbreviated forms produced via <i>*print-level*</i> cutoﬀ from reading in again, as a
safeguard against losing information. (More precisely, this is legal syntax, but the
macro-character function for it signals an error.)
  <br /><b>
<i>#)</i>                                                                       </b>This
is not legal reader syntax. This prevents abbreviated forms produced via
<i>*print-level*</i> cutoﬀ from reading in again, as a safeguard against losing
information. (More precisely, this is legal syntax, but the macro-character
function for it signals an error.)</div>
</div>
   <h4 class="subsectionHead"><span class="titlemark">22.1.5   </span> <a 
 id="x142-19200022.1.5"></a>The Readtable</h4>
<a 
 id="dx142-192001"></a>
<!--l. 1916--><p class="noindent" >Previous sections describe the standard syntax accepted by the <i>read</i> function.
This section discusses the advanced topic of altering the standard syntax either to
provide extended syntax for Lisp objects or to aid the writing of other
parsers.
                                                                          

                                                                          
<!--l. 1921--><p class="indent" >   There is a data structure called the readtable that is used to control
the reader. It contains information about the syntax of each character
equivalent to that in table <a 
href="#x142-1880021">22.1<!--tex4ht:ref: Standard-Character-Syntax-Table --></a>. It is set up exactly as in table <a 
href="#x142-1880021">22.1<!--tex4ht:ref: Standard-Character-Syntax-Table --></a> to
give the standard Common Lisp meanings to all the characters, but the
user can change the meanings of characters to alter and customize the
syntax of characters. It is also possible to have several readtables describing
diﬀerent syntaxes and to switch from one to another by binding the variable
<i>*readtable*</i>.
<div class=obsolete>
<!--l. 1932--><p class="indent" >   Even if an implementation supports characters with non-zero bits and font
attributes, it need not (but may) allow for such characters to have syntax
descriptions in the readtable. However, every character of type <i>string-char</i> must
be represented in the readtable.
</div>
<div class=newer>
<!--l. 1939--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to remove the type <i>string-char</i> and to replace
the bits and font attributes with the notion of implementation-deﬁned
attributes. If any implementation-deﬁned attributes are supported, an
implementation may (but need not) allow for such characters to have syntax
descriptions in the readtable. Characters that do not have non-standard
values for any implementation-deﬁned attribute must be represented in the
readtable.
</div>
<div class=defun>
<!--l. 1948--><p class="noindent" > <i>[Variable]</i>   <b>*readtable*</b> <a 
 id="dx142-192002"></a><a 
 id="x142-192003r673"></a>
<!--l. 1950--><p class="noindent" >The value of <i>*readtable*</i> is the current readtable. The initial value of this is a
readtable set up for standard Common Lisp syntax. You can bind this variable to
temporarily change the readtable being used.
</div>
<!--l. 1956--><p class="indent" >   To program the reader for a diﬀerent syntax, a set of functions are provided
for manipulating readtables. Normally, you should begin with a copy of the
standard Common Lisp readtable and then customize the individual characters
within that copy.
<div class=defun>
<!--l. 1961--><p class="noindent" > <i>[Function]</i>   <b>copy-readtable</b> <a 
 id="dx142-192004"></a><a 
 id="x142-192005r674"></a>   <b>&#x0026;optional</b>  <i>from-readtable</i> <i>to-readtable</i>
<!--l. 1963--><p class="noindent" >A copy is made of from-readtable, which defaults to the current readtable (the
value of the global variable <i>*readtable*</i>). If from-readtable is <i>nil</i>, then
a copy of a standard Common Lisp readtable is made. For example, <div class=lisp>
                                                                          

                                                                          
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq *readtable* (copy-readtable nil))
</td></tr></table>
<!--l. 1970--><p class="indent" >
</div>
</div>
<!--l. 1971--><p class="noindent" >will restore the input syntax to standard Common Lisp syntax, even if the original
readtable has been clobbered (assuming it is not so badly clobbered that you
cannot type in the above expression!). On the other hand, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq *readtable* (copy-readtable))
</td></tr></table>
<!--l. 1977--><p class="indent" >
</div>
</div>
<!--l. 1978--><p class="noindent" >will merely replace the current readtable with a copy of itself.
<!--l. 1980--><p class="indent" >   If to-readtable is unsupplied or <i>nil</i>, a fresh copy is made. Otherwise,
to-readtable must be a readtable, which is destructively copied into.
</div>
<div class=defun>
<!--l. 1984--><p class="noindent" > <i>[Function]</i>   <b>readtablep</b> <a 
 id="dx142-192006"></a><a 
 id="x142-192007r675"></a>   <i>object</i>
<!--l. 1986--><p class="noindent" ><i>readtablep</i> is true if its argument is a readtable, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(readtablep x)  ≡ (typep x &#x2019;readtable)
</td></tr></table>
<!--l. 1991--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 1994--><p class="noindent" > <i>[Function]</i>   <b>set-syntax-from-char</b> <a 
 id="dx142-192008"></a><a 
 id="x142-192009r676"></a>   <i>to-char</i>  <i>from-char</i>  <b>&#x0026;optional</b>
<i>to-readtable</i> <i>from-readtable</i>
<!--l. 1996--><p class="noindent" >This makes the syntax of to-char in to-readtable be the same as the syntax of
from-char in from-readtable. The to-readtable defaults to the current readtable
(the value of the global variable <i>*readtable*</i>), and from-readtable defaults to <i>nil</i>,
meaning to use the syntaxes from the standard Lisp readtable. <div class=new> X3J13 voted in
January 1989 ⟨<b>?</b>⟩ to clarify that the to-char and from-char must each be a
character.
</div>
<!--l. 2009--><p class="indent" >   Only attributes as shown in table <a 
href="#x142-1880021">22.1<!--tex4ht:ref: Standard-Character-Syntax-Table --></a> are copied; moreover, if a macro
character is copied, the macro deﬁnition function is copied also. However,
attributes as shown in table <a 
href="#x142-1890023">22.3<!--tex4ht:ref: Standard-Readtable-Attributes-Table --></a> are not copied; they are “hard-wired” into
the extended-token parser. For example, if the deﬁnition of <i>S</i> is copied
to <i>*</i>, then <i>*</i> will become a constituent that is alphabetic but cannot be
used as an exponent indicator for short-format ﬂoating-point number
syntax.
<!--l. 2021--><p class="indent" >   It works to copy a macro deﬁnition from a character such as <i>&#x0022;</i> to another
character; the standard deﬁnition for <i>&#x0022;</i> looks for another character that is the
same as the character that invoked it. It doesn&#x2019;t work to copy the deﬁnition of <i>(</i>
to <i><tt>{</tt></i>, for example; it can be done, but it lets one write lists in the form <i><tt>{</tt>a b c)</i>,
not <i><tt>{</tt>a b c<tt>}</tt></i>, because the deﬁnition always looks for a closing parenthesis, not a
closing brace. See the function <i>read-delimited-list</i>, which is useful in this
connection.
<div class=new>
<!--l. 2032--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to specify that the <i>set-syntax-from-char</i>
function returns <i>t</i>.
</div>
</div>
<div class=defun>
<!--l. 2038--><p class="noindent" > <i>[Function]</i>   <b>set-macro-character</b> <a 
 id="dx142-192010"></a><a 
 id="x142-192011r677"></a>   <i>char</i>  <i>function</i>  <b>&#x0026;optional</b>
<i>non-terminating-p</i> <i>readtable</i><br 
class="newline" /><i>[Function]</i>   <b>get-macro-character</b> <a 
 id="dx142-192012"></a><a 
 id="x142-192013r678"></a>   <i>char</i>  <b>&#x0026;optional</b>  <i>readtable</i>
<!--l. 2041--><p class="noindent" ><i>set-macro-character</i> causes char to be a macro character that when seen
by <i>read</i> causes function to be called. If non-terminating-p is not <i>nil</i> (it
defaults to <i>nil</i>), then it will be a non-terminating macro character: it
may be embedded within extended tokens. <i>set-macro-character</i> returns
<i>t</i>.
<i>
                                                                          

                                                                          
<!--l. 2049--><p class="indent" >   get-macro-character</i> returns the function associated with char and, as a second
value, returns the non-terminating-p ﬂag; it returns <i>nil</i> if char does not have
macro-character syntax. In each case, readtable defaults to the current
readtable.
<div class=new>
<!--l. 2055--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to specify that if <i>nil</i> is explicitly passed as
the second argument to <i>get-macro-character</i>, then the standard readtable is used.
This is consistent with the behavior of <i>copy-readtable</i>.
</div>
<!--l. 2062--><p class="indent" >   The function is called with two arguments, stream and char. The stream is the
input stream, and char is the macro character itself. In the simplest case, function
may return a Lisp object. This object is taken to be that whose printed
representation was the macro character and any following characters read by the
function. As an example, a plausible deﬁnition of the standard single quote
character is: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun single-quote-reader (stream char)
</td></tr></table>
<!--l. 2072--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (ignore char))</td></tr></table>
<!--l. 2073--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (list &#x2019;quote (read stream t nil t)))</td></tr></table>
<!--l. 2074--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2075--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-macro-character #<tt>\</tt>&#x2019; #&#x2019;single-quote-reader)</td></tr></table>
<!--l. 2077--><p class="indent" >
</div>
</div>
<!--l. 2078--><p class="noindent" >(Note that <i>t</i> is speciﬁed for the recursive-p argument to <i>read</i>; see section <a 
href="clmse116.html#x143-19500022.2.1">22.2.1<!--tex4ht:ref: CHARACTER-INPUT-SECTION --></a>.) The
function reads an object following the single-quote and returns a list of the symbol
<i>quote</i> and that object. The char argument is ignored.
                                                                          

                                                                          
<!--l. 2086--><p class="indent" >   The function may choose instead to return zero values (for example, by using
<i>(values)</i> as the return expression). In this case, the macro character and whatever
it may have read contribute nothing to the object being read. As an example, here
is a plausible deﬁnition for the standard semicolon (comment) character: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun semicolon-reader (stream char)
</td></tr></table>
<!--l. 2093--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (ignore char))</td></tr></table>
<!--l. 2094--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ;; First swallow the rest of the current input line.</td></tr></table>
<!--l. 2095--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ;; End-of-ﬁle is acceptable for terminating the comment.</td></tr></table>
<!--l. 2096--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (do () ((char= (read-char stream nil #<tt>\</tt>Newline t) #<tt>\</tt>Newline)))</td></tr></table>
<!--l. 2097--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ;; Return zero values.</td></tr></table>
<!--l. 2098--><p class="indent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (values))</td></tr></table>
<!--l. 2099--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2100--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-macro-character #<tt>\</tt>; #&#x2019;semicolon-reader)</td></tr></table>
<!--l. 2102--><p class="indent" >
</div>
</div>
<!--l. 2103--><p class="noindent" >(Note that <i>t</i> is speciﬁed for the recursive-p argument to <i>read-char</i>; see
section <a 
href="clmse116.html#x143-19500022.2.1">22.2.1<!--tex4ht:ref: CHARACTER-INPUT-SECTION --></a>.)
<!--l. 2106--><p class="indent" >   The function should not have any side eﬀects other than on the stream.
Because of backtracking and restarting of the <i>read</i> operation, front ends (such as
editors and rubout handlers) to the reader may cause function to be called
repeatedly during the reading of a single expression in which the macro character
only appears once.
<div class=incompatibility>
<!--l. 2116--><p class="noindent" ><b>Compatibility note:</b> The ability to return either zero or one value is the closest
Common Lisp macro characters come to the splicing macro characters of MacLisp or the
<i>splice</i> macro characters of Interlisp. The Common Lisp deﬁnition does not allow the
splicing of arbitrarily many values, but it does allow a macro-character function to
decide after it is invoked whether or not to yield a value, an option not possible in
MacLisp or Interlisp.
<!--l. 2125--><p class="indent" >   MacLisp has nothing equivalent to non-terminating macro characters. The Interlisp
equivalents of terminating and non-terminating macro characters are macro characters
with the <i>ALWAYS</i> or <i>FIRST</i> option, respectively. Common Lisp has nothing equivalent
to the Interlisp <i>ALONE</i> macro-character option.
                                                                          

                                                                          
</div>
<div class=new>
<!--l. 2134--><p class="indent" >   Here is an example of a more elaborate set of read-macro characters that I
used in the implementation of the original simulator for Connection Machine Lisp
<span class="cite">[<a 
href="clmli5.html#XCONNECTION-MACHINE-LISP">44</a>, <a 
href="clmli5.html#XCMLISP-IMPLEMENTATION">57</a>]</span>, a parallel dialect of Common Lisp. This simulator was used to
gain experience with the language before freezing its design for full-scale
implementation on a Connection Machine computer system. This example
illustrates the typical manner in which a language designer can embed a new
language within the syntactic and semantic framework of Lisp, saving the eﬀort of
designing an implementation from scratch.
<!--l. 2145--><p class="indent" >   Connection Machine Lisp introduces a new data type called a xapping,
which is simply an unordered set of ordered pairs of Lisp objects. The
ﬁrst element of each pair is called the index and the second element the
value. We say that the xapping maps each index to its corresponding
value. No two pairs of the same xapping may have the same (that is, <i>eql</i>)
index. Xappings may be ﬁnite or inﬁnite sets of pairs; only certain kinds of
inﬁnite xappings are required, and special representations are used for
them.
<!--l. 2153--><p class="indent" >   A ﬁnite xapping is notated by writing the pairs between braces, separated by
whitespace. A pair is notated by writing the index and the value, separated by a
right arrow (or an exclamation point if the host Common Lisp has no right-arrow
character).
<!--l. 2158--><p class="noindent" ><b>Remark:</b> The original language design used the right arrow; the exclamation point was
chosen to replace it on ASCII-only terminals because it is one of the six characters <i>[ ]
{ } ! ?</i> reserved by Common Lisp to the user.
<!--l. 2163--><p class="indent" >   While preparing the <span class="TEX">T<span 
class="E">E</span>X</span> manuscript for this book I made a mistake in font
selection and discovered that by an absolutely incredible coincidence the right
arrow has the same numerical code (octal 41) within <span class="TEX">T<span 
class="E">E</span>X</span> fonts as the ASCII
exclamation point. The result was that although the manuscript called for
right arrows, exclamation points came out in the printed copy. Imagine my
astonishment!
<!--l. 2172--><p class="indent" >   Here is an example of a xapping that maps three symbols to strings: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">{moe ⇒ &#x0022;Oh, a wise guy, eh?&#x0022; larry ⇒ &#x0022;Hey, what&#x2019;s the idea?&#x0022;
</td></tr></table>
<!--l. 2175--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> curly ⇒ &#x0022;Nyuk, nyuk, nyuk!&#x0022;}</td></tr></table>
<!--l. 2177--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 2178--><p class="noindent" >For convenience there are certain abbreviated notations. If the index and
value for a pair are the same object x, then instead of having to write
“x ⇒
x” (or, worse yet, “<i>#43=x ⇒
#43#</i>”) we may write simply x for the pair. If all pairs of a xapping are of this
form, we call the xapping a xet. For example, the notation <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">{baseball chess cricket curling bocce 43-man-squamish}
</td></tr></table>
<!--l. 2187--><p class="indent" >
</div>
</div>
<!--l. 2188--><p class="noindent" >is entirely equivalent in meaning to <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">{baseball ⇒ baseball curling ⇒ curling cricket ⇒ cricket
</td></tr></table>
<!--l. 2190--><p class="indent" >     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> chess ⇒ chess bocce ⇒ bocce 43-man-squamish ⇒ 43-man-squamish}</td></tr></table>
<!--l. 2192--><p class="indent" >
</div>
</div>
<!--l. 2193--><p class="noindent" >namely a xet of symbols naming six sports.
<!--l. 2195--><p class="indent" >   Another useful abbreviation covers the situation where the n pairs of a ﬁnite
xapping are integers, collectively covering a range from zero to n − 1.
This kind of xapping is called a xector and may be notated by writing
the values between brackets in ascending order of their indices. Thus <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">[tinker evers chance]
</td></tr></table>
<!--l. 2202--><p class="indent" >
</div>
</div>
<!--l. 2203--><p class="noindent" >is merely an abbreviation for <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">{tinker ⇒ 0 evers ⇒ 1 chance ⇒ 2}
</td></tr></table>
<!--l. 2206--><p class="indent" >
</div>
</div>
<!--l. 2208--><p class="indent" >   There are two kinds of inﬁnite xapping: constant and universal. A constant
xapping <i>{ ⇒
z}</i> maps every object to the same value z. The universal xapping <i>{ ⇒
}</i> maps every object to itself and is therefore the xet of all Lisp objects, sometimes
called simply the universe. Both kinds of inﬁnite xet may be modiﬁed by explicitly
writing exceptions. One kind of exception is simply a pair, which speciﬁes
the value for a particular index; the other kind of exception is simply
k ⇒
indicating that the xapping does not have a pair with index k after all. Thus the
notation <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">{sky ⇒ blue grass ⇒ green idea ⇒ glass ⇒ ⇒ red}
</td></tr></table>
<!--l. 2218--><p class="indent" >
</div>
</div>
<!--l. 2219--><p class="noindent" >indicates a xapping that maps <i>sky</i> to <i>blue</i>, <i>grass</i> to <i>green</i>, and every other object
except <i>idea</i> and <i>glass</i> to <i>red</i>. Note well that the presence or absence of whitespace
on either side of an arrow is crucial to the correct interpretation of the
notation.
<!--l. 2225--><p class="indent" >   Here is the representation of a xapping as a structure: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defstruct
</td></tr></table>
<!--l. 2227--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (xapping (:print-function print-xapping)</td></tr></table>
<!--l. 2228--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (:constructor xap</td></tr></table>
<!--l. 2229--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (domain range &#x0026;optional</td></tr></table>
<!--l. 2230--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (default &#x2019;:unknown defaultp)</td></tr></table>
<!--l. 2231--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (inﬁnite (and defaultp :constant))</td></tr></table>
                                                                          

                                                                          
<!--l. 2232--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (exceptions &#x2019;()))))</td></tr></table>
<!--l. 2233--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  domain</td></tr></table>
<!--l. 2234--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  range</td></tr></table>
<!--l. 2235--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  default</td></tr></table>
<!--l. 2236--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (inﬁnite nil :type (member nil :constant :universal)</td></tr></table>
<!--l. 2237--><p class="indent" >                                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  exceptions)</td></tr></table>
<!--l. 2239--><p class="indent" >
</div>
</div>
<!--l. 2240--><p class="noindent" >The explicit pairs are represented as two parallel lists, one of indexes (<i>domain</i>) and
one of values (<i>range</i>). The <i>default</i> slot is the default value, relevant only if the
<i>inﬁnite</i> slot is <i>:constant</i>. The <i>exceptions</i> slot is a list of indices for which
there are no values. (See the end of section <a 
href="clmse117.html#x144-20000022.3.3">22.3.3<!--tex4ht:ref: FORMAT-SECTION --></a> for the deﬁnition of
<i>print-xapping</i>.)
<!--l. 2246--><p class="indent" >   Here, then, is the code for reading xectors in bracket notation: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun open-bracket-macro-char (stream macro-char)
</td></tr></table>
<!--l. 2248--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (ignore macro-char))</td></tr></table>
<!--l. 2249--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((range (read-delimited-list #<tt>\</tt>] stream t)))</td></tr></table>
<!--l. 2250--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (xap (iota-list (length range)) range)))</td></tr></table>
<!--l. 2251--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2252--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-macro-character #<tt>\</tt>[ #&#x2019;open-bracket-macro-char)</td></tr></table>
<!--l. 2253--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-macro-character #<tt>\</tt>] (get-macro-character #<tt>\</tt>) ))</td></tr></table>
<!--l. 2254--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2255--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun iota-list (n)     ;Return list of integers from 0 to n − 1</td></tr></table>
<!--l. 2256--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (do ((j (- n 1) (- j 1))</td></tr></table>
<!--l. 2257--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (z &#x2019;() (cons j z)))</td></tr></table>
<!--l. 2258--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ((&#x003C; j 0) z)))</td></tr></table>
<!--l. 2260--><p class="indent" >
</div>
</div>
<!--l. 2261--><p class="noindent" >The code for reading xappings in the more general brace notation, with all the
possibilities for xets (or individual xet pairs), inﬁnite xappings, and exceptions, is
a bit more complicated; it is shown in table <a 
href="#x142-1920145">22.5<!--tex4ht:ref: XAPPING-MACRO-CHAR-TABLE --></a>. That code is used in
conjunction with the initializations <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-macro-character #<tt>\</tt><tt>{</tt> #&#x2019;open-brace-macro-char)
</td></tr></table>
<!--l. 2266--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-macro-character #<tt>\</tt><tt>}</tt> (get-macro-character #<tt>\</tt>) ))</td></tr></table>
<!--l. 2268--><p class="indent" >
</div>
</div>
</div>
</div>
   <div class="table">
                                                                          

                                                                          
<!--l. 2274--><p class="indent" >   <a 
 id="x142-1920145"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
<div class=new>
 <div class="caption" 
><span class="id">Table 22.5: </span><span  
class="content">Macro Character Deﬁnition for Xapping Syntax</span></div><!--tex4ht:label?: x142-1920145 -->
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun open-brace-macro-char (s macro-char)
</td></tr></table>
<!--l. 2278--><p class="noindent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (ignore macro-char))</td></tr></table>
<!--l. 2279--><p class="noindent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (do ((ch (peek-char t s t nil t) (peek-char t s t nil t))</td></tr></table>
<!--l. 2280--><p class="noindent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (domain &#x2019;())  (range &#x2019;())  (exceptions &#x2019;()))</td></tr></table>
<!--l. 2281--><p class="noindent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ((char= ch #<tt>\</tt><tt>}</tt>)</td></tr></table>
<!--l. 2282--><p class="noindent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (read-char s t nil t)</td></tr></table>
<!--l. 2283--><p class="noindent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (construct-xapping (reverse domain) (reverse range)))</td></tr></table>
<!--l. 2284--><p class="noindent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (cond ((char= ch #<tt>\</tt> ⇒ )</td></tr></table>
<!--l. 2285--><p class="noindent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (read-char s t nil t)</td></tr></table>
<!--l. 2286--><p class="noindent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (let ((nextch (peek-char nil s t nil t)))</td></tr></table>
<!--l. 2287--><p class="noindent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (cond ((char= nextch #<tt>\</tt><tt>}</tt>)</td></tr></table>
<!--l. 2288--><p class="noindent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    (read-char s t nil t)</td></tr></table>
<!--l. 2289--><p class="noindent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    (return (xap (reverse domain)</td></tr></table>
<!--l. 2290--><p class="noindent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                 (reverse range)</td></tr></table>
<!--l. 2291--><p class="noindent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                 nil :universal exceptions)))</td></tr></table>
<!--l. 2292--><p class="noindent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (t (let ((item (read s t nil t)))</td></tr></table>
<!--l. 2293--><p class="noindent" >     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                        (cond ((char= (peek-char t s t nil t) #<tt>\</tt><tt>}</tt>)</td></tr></table>
<!--l. 2294--><p class="noindent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                               (read-char s t nil t)</td></tr></table>
<!--l. 2295--><p class="noindent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                               (return (xap (reverse domain)</td></tr></table>
<!--l. 2296--><p class="noindent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                            (reverse range)</td></tr></table>
<!--l. 2297--><p class="noindent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                            item :constant</td></tr></table>
<!--l. 2298--><p class="noindent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                            exceptions)))</td></tr></table>
<!--l. 2299--><p class="noindent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                              (t (reader-error s</td></tr></table>
<!--l. 2300--><p class="noindent" ><table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                   &#x0022;Default  ⇒ item must be last&#x0022;))))))))</td></tr></table>
<!--l. 2301--><p class="noindent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (t (let ((item (read-preserving-whitespace s t nil t))</td></tr></table>
<!--l. 2302--><p class="noindent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (nextch (peek-char nil s t nil t)))</td></tr></table>
<!--l. 2303--><p class="noindent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               (cond ((char= nextch #<tt>\</tt> ⇒ )</td></tr></table>
<!--l. 2304--><p class="noindent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      (read-char s t nil t)</td></tr></table>
<!--l. 2305--><p class="noindent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      (cond ((member (peek-char nil s t nil t)</td></tr></table>
<!--l. 2306--><p class="noindent" ><table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                                     &#x2019;(#<tt>\</tt>Space #<tt>\</tt>Tab #<tt>\</tt>Newline))</td></tr></table>
<!--l. 2307--><p class="noindent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                             (push item exceptions))</td></tr></table>
                                                                          

                                                                          
<!--l. 2308--><p class="noindent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                            (t (push item domain)</td></tr></table>
<!--l. 2309--><p class="noindent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                               (push (read s t nil t) range))))</td></tr></table>
<!--l. 2310--><p class="noindent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                     ((char= nch #<tt>\</tt><tt>}</tt>)</td></tr></table>
<!--l. 2311--><p class="noindent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      (read-char s t nil t)</td></tr></table>
<!--l. 2312--><p class="noindent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      (push item domain)</td></tr></table>
<!--l. 2313--><p class="noindent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      (push item range)</td></tr></table>
<!--l. 2314--><p class="noindent" > <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      (return (xap (reverse domain) (reverse range))))</td></tr></table>
<!--l. 2315--><p class="noindent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                     (t (push item domain)</td></tr></table>
<!--l. 2316--><p class="noindent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                        (push item range))))))))</td></tr></table>
<!--l. 2318--><p class="noindent" >
</div>
</div>
</div>
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<div class=defun>
<!--l. 2322--><p class="noindent" > <i>[Function]</i>   <b>make-dispatch-macro-character</b> <a 
 id="dx142-192015"></a><a 
 id="x142-192016r679"></a>   <i>char</i>  <i>                   </i>
<b>&#x0026;optional</b>  <i>non-terminating-p</i> <i>readtable</i>
<!--l. 2324--><p class="noindent" >This causes the character char to be a dispatching macro character in readtable
(which defaults to the current readtable). If non-terminating-p is not <i>nil</i> (it
defaults to <i>nil</i>), then it will be a non-terminating macro character: it may be
embedded within extended tokens. <i>make-dispatch-macro-character</i> returns
<i>t</i>.
<!--l. 2332--><p class="indent" >   Initially every character in the dispatch table has a character-macro function
that signals an error. Use <i>set-dispatch-macro-character</i> to deﬁne entries in the
dispatch table. <div class=new> X3J13 voted in January 1989 ⟨<b>?</b>⟩ to clarify that char must be a
character.
</div>
</div>
<div class=defun>
<!--l. 2343--><p class="noindent" > <i>[Function]</i>   <b>set-dispatch-macro-character</b> <a 
 id="dx142-192017"></a><a 
 id="x142-192018r680"></a>   <i>disp-char</i>  <i>sub-char</i>  <i>function</i>
<b>&#x0026;optional</b>  <i>readtable</i><br 
class="newline" /><i>[Function]</i>   <b>get-dispatch-macro-character</b> <a 
 id="dx142-192019"></a><a 
 id="x142-192020r681"></a>   <i>disp-char</i>  <i>sub-char</i>  <i>    </i>
<b>&#x0026;optional</b>  <i>readtable</i>
<!--l. 2346--><p class="noindent" ><i>set-dispatch-macro-character</i> causes function to be called when the disp-char
followed by sub-char is read. The readtable defaults to the current readtable. The
arguments and return values for function are the same as for normal macro
characters except that function gets sub-char, not disp-char, as its second
argument and also receives a third argument that is the non-negative integer
whose decimal representation appeared between disp-char and sub-char, or <i>nil</i> if
no decimal integer appeared there.
<!--l. 2359--><p class="indent" >   The sub-char may not be one of the ten decimal digits; they are always
reserved for specifying an inﬁx integer argument. Moreover, if sub-char is a
lowercase character (see <i>lower-case-p</i>), its uppercase equivalent is used instead.
(This is how the rule is enforced that the case of a dispatch sub-character doesn&#x2019;t
matter.)
<i>
<!--l. 2366--><p class="indent" >   set-dispatch-macro-character</i> returns <i>t</i>.
<i>
<!--l. 2368--><p class="indent" >   get-dispatch-macro-character</i> returns the macro-character function for
sub-char under disp-char, or <i>nil</i> if there is no function associated with
                                                                          

                                                                          
sub-char.
<!--l. 2372--><p class="indent" >   If the sub-char is one of the ten decimal digits <i>0 1 2 3 4 5 6 7 8 9</i>,
<i>get-dispatch-macro-character</i> always returns <i>nil</i>. If sub-char is a lowercase
character, its uppercase equivalent is used instead.
<div class=new>
<!--l. 2378--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to specify that if <i>nil</i> is explicitly
passed as the second argument to <i>get-dispatch-macro-character</i>, then
the standard readtable is used. This is consistent with the behavior of
<i>copy-readtable</i>.
</div>
<!--l. 2385--><p class="indent" >   For either function, an error is signaled if the speciﬁed disp-char is not in
fact a dispatch character in the speciﬁed readtable. It is necessary to use
<i>make-dispatch-macro-character</i> to set up the dispatch character before specifying
its sub-characters.
<!--l. 2391--><p class="indent" >   As an example, suppose one would like <i>#$foo</i> to be read as if it were <i>(dollars
foo)</i>. One might say: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun |#$-reader| (stream subchar arg)
</td></tr></table>
<!--l. 2394--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (ignore subchar arg))</td></tr></table>
<!--l. 2395--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (list &#x2019;dollars (read stream t nil t)))</td></tr></table>
<!--l. 2396--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2397--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-dispatch-macro-character #<tt>\</tt># #<tt>\</tt>$ #&#x2019;|#$-reader|)</td></tr></table>
<!--l. 2399--><p class="indent" >
</div>
</div>
</div>
<div class=incompatibility>
<!--l. 2403--><p class="noindent" ><b>Compatibility note:</b> This macro-character mechanism is diﬀerent from those in
MacLisp, Interlisp, and Lisp Machine Lisp. Recently Lisp systems have implemented
very general readers, even readers so programmable that they can parse arbitrary
compiled BNF grammars. Unfortunately, these readers can be complicated to
use. This design is an attempt to make the reader as simple as possible to
understand, use, and implement. Splicing macros have been eliminated; a recent
informal poll indicates that no one uses them to produce other than zero or one
value. The ability to access parts of the object preceding the macro character
has been eliminated. The MacLisp single-character-object feature has been
                                                                          

                                                                          
eliminated because it is seldom used and trivially obtainable by deﬁning a
macro.
<!--l. 2417--><p class="indent" >   The user is encouraged to turn oﬀ most macro characters, turn others into
single-character-object macros, and then use <i>read</i> purely as a lexical analyzer on top of
which to build a parser. It is unnecessary, however, to cater to more complex lexical
analysis or parsing than that needed for Common Lisp.
</div>
<div class=newer>
<div class=defun>
<!--l. 2426--><p class="noindent" > <i>[Function]</i>   <b>readtable-case</b> <a 
 id="dx142-192021"></a><a 
 id="x142-192022r682"></a>   <i>readtable</i>
<!--l. 2428--><p class="noindent" >X3J13 voted in June 1989 ⟨<b>?</b>⟩ to introduce the function <i>readtable-case</i> to
control the reader&#x2019;s interpretation of case. It provides access to a slot in a
readtable, and may be used with <i>setf </i> to alter the state of that slot. The
possible values for the slot are <i>:upcase</i>, <i>:downcase</i>, <i>:preserve</i>, and <i>:invert</i>; the
<i>readtable-case</i> for the standard readtable is <i>:upcase</i>. Note that <i>copy-readtable</i> is
required to copy the <i>readtable-case</i> slot along with all other readtable
information.
<!--l. 2440--><p class="indent" >   Once the reader has accumulated a token as described in section <a 
href="#x142-18800022.1.1">22.1.1<!--tex4ht:ref: READER --></a>, if the
token is a symbol, “replaceable” characters (unescaped uppercase or lowercase
constituent characters) may be modiﬁed under the control of the <i>readtable-case</i> of
the current readtable:
      <ul class="itemize1">
      <li class="itemize">For <i>:upcase</i>, replaceable characters are converted to uppercase. (This
      was the behavior speciﬁed by the ﬁrst edition.)
      </li>
      <li class="itemize">For <i>:downcase</i>, replaceable characters are converted to lowercase.
      </li>
      <li class="itemize">For <i>:preserve</i>, the cases of all characters remain unchanged.
      </li>
      <li class="itemize">For <i>:invert</i>, if all of the replaceable letters in the extended token are
      of the same case, they are all converted to the opposite case; otherwise
      the cases of all characters in that token remain unchanged.</li></ul>
<!--l. 2456--><p class="noindent" >As an illustration, consider the following code. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((*readtable* (copy-readtable nil)))
</td></tr></table>
<!--l. 2458--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (format t &#x0022;READTABLE-CASE  Input   Symbol-name<tt>~</tt></td></tr></table>
<!--l. 2459--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           <tt>~</tt>%——————                  —————–<tt>~</tt></td></tr></table>
<!--l. 2460--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           <tt>~</tt>%&#x0022;)</td></tr></table>
<!--l. 2461--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dolist (readtable-case &#x2019;(:upcase :downcase :preserve :invert))</td></tr></table>
<!--l. 2462--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (setf (readtable-case *readtable*) readtable-case)</td></tr></table>
<!--l. 2463--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (dolist (input &#x2019;(&#x0022;ZEBRA&#x0022; &#x0022;Zebra&#x0022; &#x0022;zebra&#x0022;))</td></tr></table>
<!--l. 2464--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (format t &#x0022;:<tt>~</tt>A<tt>~</tt>16T<tt>~</tt>A<tt>~</tt>24T<tt>~</tt>A<tt>~</tt>%&#x0022;</td></tr></table>
<!--l. 2465--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                (string-upcase readtable-case)</td></tr></table>
<!--l. 2466--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                input</td></tr></table>
<!--l. 2467--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                (symbol-name (read-from-string input)))))))</td></tr></table>
<!--l. 2469--><p class="indent" >
</div>
</div>
<!--l. 2470--><p class="noindent" >The output from this test code should be <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">READTABLE-CASE  Input   Symbol-name
</td></tr></table>
<!--l. 2472--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">———————————–</td></tr></table>
<!--l. 2473--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE         ZEBRA   ZEBRA</td></tr></table>
<!--l. 2474--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE         Zebra   ZEBRA</td></tr></table>
<!--l. 2475--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE         zebra   ZEBRA</td></tr></table>
<!--l. 2476--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE       ZEBRA   zebra</td></tr></table>
<!--l. 2477--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE       Zebra   zebra</td></tr></table>
<!--l. 2478--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE       zebra   zebra</td></tr></table>
<!--l. 2479--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE       ZEBRA   ZEBRA</td></tr></table>
<!--l. 2480--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE       Zebra   Zebra</td></tr></table>
<!--l. 2481--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE       zebra   zebra</td></tr></table>
<!--l. 2482--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT         ZEBRA   zebra</td></tr></table>
<!--l. 2483--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT         Zebra   Zebra</td></tr></table>
<!--l. 2484--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT         zebra   ZEBRA</td></tr></table>
<!--l. 2486--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
<!--l. 2488--><p class="indent" >   The <i>readtable-case</i> of the current readtable also aﬀects the printing of symbols
(see <i>*print-case*</i> and <i>*print-escape*</i>).
</div>
   <h4 class="subsectionHead"><span class="titlemark">22.1.6   </span> <a 
 id="x142-19300022.1.6"></a>What the Print Function Produces</h4>
<!--l. 2495--><p class="noindent" >The Common Lisp printer is controlled by a number of special variables. These
are referred to in the following discussion and are fully documented at the end of
this section.
<!--l. 2499--><p class="indent" >   How an expression is printed depends on its data type, as described in the
following paragraphs.
<div class=flushdesc>
<!--l. 2503--><p class="indent" >
  <div><br /><b>
Integers                                                                   </b>
If appropriate, a radix speciﬁer may be printed; see the variable <i>*print-radix*</i>.
If an integer is negative, a minus sign is printed and then the absolute value
of the integer is printed. Integers are printed in the radix speciﬁed by the
variable <i>*print-base*</i> in the usual positional notation, most signiﬁcant digit
ﬁrst. The number zero is represented by the single digit <i>0</i> and never has
a sign. A decimal point may then be printed, depending on the value of
<i>*print-radix*</i>.
  <br /><b>
Ratios                                                                    </b>
If appropriate, a radix speciﬁer may be printed; see the variable <i>*print-radix*</i>.
If the ratio is negative, a minus sign is printed. Then the absolute value of
the numerator is printed, as for an integer; then a <i>/</i>; then the denominator.
The numerator and denominator are both printed in the radix speciﬁed by
the variable <i>*print-base*</i>; they are obtained as if by the <i>numerator</i> and
<i>denominator</i> functions, and so ratios are always printed in reduced form
(lowest terms).
  <br /><b>
Floating-point numbers                                                    </b>
If  the  sign  of  the  number  (as  determined  by  the  function  <i>ﬂoat-sign</i>)  is
                                                                          

                                                                          
negative, then a minus sign is printed. Then the magnitude is printed in one
of two ways. If the magnitude of the ﬂoating-point number is either zero
or between 10<sup>−3</sup>  (inclusive) and 10<sup>7</sup>  (exclusive), it may be printed as the
integer part of the number, then a decimal point, followed by the fractional
part of the number; there is always at least one digit on each side of the
decimal point. If the format of the number does not match that speciﬁed
by the variable <i>*read-default-ﬂoat-format*</i>, then the exponent marker for
that format and the digit <i>0</i> are also printed. For example, the base of the
natural logarithms as a short-format ﬂoating-point number might be printed
as <i>2.71828S0</i>.
<!--l. 2542--><p class="indent" >  For non-zero magnitudes outside of the range 10<sup>−3</sup> to 10<sup>7</sup>, a ﬂoating-point
number   will   be   printed   in   “computerized   scientiﬁc   notation.”   The
representation of the number is scaled to be between 1 (inclusive) and 10
(exclusive) and then printed, with one digit before the decimal point and
at least one digit after the decimal point. Next the exponent marker for
the  format  is  printed,  except  that  if  the  format  of  the  number  matches
that speciﬁed by the variable <i>*read-default-ﬂoat-format*</i>, then the exponent
marker <i>E</i> is used. Finally, the power of 10 by which the fraction must be
multiplied to equal the original number is printed as a decimal integer. For
example, Avogadro&#x2019;s number as a short-format ﬂoating-point number might
be printed as <i>6.02S23</i>.
  <br /><b>
Complex numbers                                                         </b>
A  complex  number  is  printed  as  <i>#C</i>,  an  open  parenthesis,  the  printed
representation  of  its  real  part,  a  space,  the  printed  representation  of  its
imaginary part, and ﬁnally a close parenthesis.
<div class=obsolete>
Characters                                                                When
<i>*print-escape*</i> is <i>nil</i>, a character prints as itself; it is sent directly to the output
stream. When <i>*print-escape*</i> is not <i>nil</i>, then <i>#<tt>\</tt></i> syntax is used. For example, the
printed representation of the character <i>#<tt>\</tt>A</i> with control and meta bits on would
be <i>#<tt>\</tt>CONTROL-META-A</i>, and that of <i>#<tt>\</tt>a</i> with control and meta bits on would
be <i>#<tt>\</tt>CONTROL-META-<tt>\</tt>a</i>.
</div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-readably*</i> is not <i>nil</i> then
every object must be printed in a readable form, regardless of other printer
                                                                          

                                                                          
control variables. For characters, the simplest approach is always to use
<i>#<tt>\</tt></i> syntax when <i>*print-readably*</i> is not <i>nil</i>, regardless of the value of
<i>*print-escape*</i>.
</div>
<div class=obsolete>
Symbols
<!--l. 2592--><p class="indent" >  When <i>*print-escape*</i> is <i>nil</i>, only the characters of the print name of the symbol
are output (but the case in which to print any uppercase characters in the print
name is controlled by the variable <i>*print-case*</i>).
</div>
<div class=newer>
<!--l. 2599--><p class="indent" >  X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that the new <i>readtable-case</i> slot of the
current readtable also controls the case in which letters (whether uppercase or
lowercase) in the print name of a symbol are output, no matter what the value of
<i>*print-escape*</i>.
</div>
<div class=obsolete>
<!--l. 2606--><p class="indent" >  The remaining paragraphs describing the printing of symbols cover the
situation when <i>*print-escape*</i> is not <i>nil</i>.
</div>
<div class=newer>
<!--l. 2611--><p class="indent" >  X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-readably*</i> is not <i>nil</i> then
every object must be printed in a readable form, regardless of other printer
control variables. For symbols, the simplest approach is to print them, when
<i>*print-readably*</i> is not <i>nil</i>, as if <i>*print-escape*</i> were not <i>nil</i>, regardless of the
actual value of <i>*print-escape*</i>.
</div>
<!--l. 2619--><p class="indent" >  Backslashes <i><tt>\</tt></i> and vertical bars <i>|</i> are included as required. In particular,
backslash or vertical-bar syntax is used when the name of the symbol would be
otherwise treated by the reader as a potential number (see section <a 
href="#x142-18900022.1.2">22.1.2<!--tex4ht:ref: PARSE-TOKENS-SECTION --></a>). In
making this decision, it is assumed that the value of <i>*print-base*</i> being used for
printing would be used as the value of <i>*read-base*</i> used for reading; the value of
<i>*read-base*</i> at the time of printing is irrelevant. For example, if the value of
<i>*print-base*</i> were <i>16</i> when printing the symbol <i>face</i>, it would have to be
printed as <i><tt>\</tt>FACE</i> or <i><tt>\</tt>Face</i> or <i>|FACE|</i>, because the token <i>face</i> would be
read as a hexadecimal number (decimal value 64206) if <i>*read-base*</i> were
                                                                          

                                                                          
<i>16</i>.
<div class=obsolete>
<!--l. 2634--><p class="indent" >  The case in which to print any uppercase characters in the print name is
controlled by the variable <i>*print-case*</i>.
</div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to clarify the interaction of <i>*print-case*</i> with
<i>*print-escape*</i>; see <i>*print-case*</i>.
</div> As a special case [no pun intended], <i>nil</i> may sometimes be printed as <i>()</i> instead,
when <i>*print-escape*</i> and <i>*print-pretty*</i> are both not <i>nil</i>.
<!--l. 2646--><p class="indent" >  Package preﬁxes may be printed (using colon syntax) if necessary. The rules for
package qualiﬁers are as follows. When the symbol is printed, if it is in the
keyword package, then it is printed with a preceding colon; otherwise, if it is
accessible in the current package, it is printed without any qualiﬁcation;
otherwise, it is printed with qualiﬁcation. See chapter <a 
href="clmch11.html#x72-11100011">11<!--tex4ht:ref: XPACK --></a>.
<div class=obsolete>
<!--l. 2656--><p class="indent" >  A symbol that is uninterned (has no home package) is printed preceded by <i>#:</i> if
the variables <i>*print-gensym*</i> and <i>*print-escape*</i> are both non-<i>nil</i>; if either is <i>nil</i>,
then the symbol is printed without a preﬁx, as if it were in the current
package.
</div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-readably*</i> is not <i>nil</i> then
every object must be printed in a readable form, regardless of other printer
control variables. For uninterned symbols, the simplest approach is to print them,
when <i>*print-readably*</i> is not <i>nil</i>, as if <i>*print-escape*</i> and <i>*print-gensym*</i> were
not <i>nil</i>, regardless of their actual values.
</div>
<div class=implementation>
<!--l. 2672--><p class="noindent" ><b>Implementation note:</b> Because the <i>#:</i> syntax does not intern the following symbol, it
is necessary to use circular-list syntax if <i>*print-circle*</i> is not <i>nil</i> and the same
uninterned symbol appears several times in an expression to be printed. For example,
the result of <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((x (make-symbol &#x0022;FOO&#x0022;))) (list x x))
</td></tr></table>
<!--l. 2680--><p class="indent" >
</div>
</div>
<!--l. 2681--><p class="noindent" >would be printed as <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><i>(#:foo #:foo)</i>
</td></tr></table>
<!--l. 2684--><p class="indent" >
</div>
</div>
<!--l. 2685--><p class="noindent" >if <i> *print-circle*</i> were <i>nil</i>, but as <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><i>(#1<tt>=</tt>#:foo #1#)</i>
</td></tr></table>
<!--l. 2689--><p class="indent" >
</div>
</div>
<!--l. 2690--><p class="noindent" >if <i> *print-circle*</i> were not <i>nil</i>.
</div>
<div class=obsolete>
<!--l. 2696--><p class="indent" >  The case in which symbols are to be printed is controlled by the variable
<i>*print-case*</i>.
</div> <div class=newer> It is also controlled by <i>*print-escape*</i> and the <i>readtable-case</i> slot of the current
readtable (the value of <i>*readtable*</i>).
</div> <div class=obsolete>
Strings                                                                   The
characters of the string are output in order. If <i>*print-escape*</i> is not <i>nil</i>, a double
quote is output before and after, and all double quotes and single escape
characters are preceded by backslash. The printing of strings is not aﬀected by
<i>*print-array*</i>. If the string has a ﬁll pointer, then only those characters below the
ﬁll pointer are printed.
</div>
<div class=newer>
<!--l. 2715--><p class="indent" >  X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-readably*</i> is not <i>nil</i> then
every object must be printed in a readable form, regardless of other printer
control variables. For strings, the simplest approach is to print them, when
<i>*print-readably*</i> is not <i>nil</i>, as if <i>*print-escape*</i> were not <i>nil</i>, regardless of the
actual value of <i>*print-escape*</i>.
                                                                          

                                                                          
</div>
  <br /><b>
Conses                                                                   </b>
Wherever possible, list notation is preferred over dot notation. Therefore the
following algorithm is used:
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x142-193002x1">Print an open parenthesis, <i>(</i>.
     </li>
     <li 
  class="enumerate" id="x142-193004x2">Print the car of the cons.
     </li>
     <li 
  class="enumerate" id="x142-193006x3">If the cdr is a cons, make it the current cons, print a space, and go to
     step 2.
     </li>
     <li 
  class="enumerate" id="x142-193008x4">If the cdr is not null, print a space, a dot, a space, and the cdr.
     </li>
     <li 
  class="enumerate" id="x142-193010x5">Print a close parenthesis, <i>)</i>.</li></ol>
<!--l. 2733--><p class="indent" >  This form of printing is clearer than showing each individual cons cell. Although
the two expressions below are equivalent, and the reader will accept either one
and produce the same data structure, the printer will always print such a data
structure in the second form. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(a . (b . ((c . (d . <i>nil</i>)) . (e . <i>nil</i>))))
</td></tr></table>
<!--l. 2739--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2740--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(a b (c d) e)</td></tr></table>
<!--l. 2742--><p class="indent" >
</div>
</div>
<div class=obsolete>
<!--l. 2744--><p class="noindent" >The printing of conses is aﬀected by the variables <i>*print-level*</i> and <i>*print-length*</i>.
</div>
<div class=newer>
<!--l. 2749--><p class="indent" >  X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-readably*</i> is not <i>nil</i> then
                                                                          

                                                                          
every object must be printed in a readable form, regardless of other printer
control variables. For conses, the simplest approach is to print them, when
<i>*print-readably*</i> is not <i>nil</i>, as if <i>*print-level*</i> and <i>*print-length*</i> were <i>nil</i>,
regardless of their actual values.
</div>
<div class=obsolete>
Bit-vectors                                                                A
bit-vector is printed as <i>#*</i> followed by the bits of the bit-vector in order. If
<i>*print-array*</i> is <i>nil</i>, however, then the bit-vector is printed in a format (using
<i>#&#x003C;</i>) that is concise but not readable. If the bit-vector has a ﬁll pointer, then only
those bits below the ﬁll pointer are printed.
</div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-readably*</i> is not <i>nil</i> then
every object must be printed in a readable form, regardless of other printer
control variables. For bit-vectors, the simplest approach is to print them, when
<i>*print-readably*</i> is not <i>nil</i>, as if <i>*print-array*</i> were not <i>nil</i>, regardless of the
actual value of <i>*print-array*</i>.
</div>
  <br /><b>
Vectors                                                                   </b>Any
vector other than a string or bit-vector is printed using general-vector syntax; this
means that information about specialized vector representations will be lost. The
printed representation of a zero-length vector is <i>#()</i>. The printed representation
of a non-zero-length vector begins with <i>#(</i>. Following that, the ﬁrst element of
the vector is printed. If there are any other elements, they are printed in turn,
with a space printed before each additional element. A close parenthesis after the
last element terminates the printed representation of the vector. <div class=obsolete> The printing of
vectors is aﬀected by the variables <i>*print-level*</i> and <i>*print-length*</i>. If the
vector has a ﬁll pointer, then only those elements below the ﬁll pointer are
printed.
<!--l. 2790--><p class="indent" >  If <i>*print-array*</i> is <i>nil</i>, however, then the vector is not printed as described
above, but in a format (using <i>#&#x003C;</i>) that is concise but not readable.
</div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-readably*</i> is not <i>nil</i> then
every object must be printed in a readable form, regardless of other printer
control variables. For vectors, the simplest approach is to print them, when
<i>*print-readably*</i> is not <i>nil</i>, as if <i>*print-level*</i> and <i>*print-length*</i> were <i>nil</i> and
                                                                          

                                                                          
<i>*print-array*</i> were not <i>nil</i>, regardless of their actual values.
</div>
  <br /><b>
Arrays                                                                    </b>
Normally any array other than a vector is printed using <i>#nA</i> format.
Let n be the rank of the array. Then <i>#</i> is printed, then n as a decimal
integer, then <i>A</i>, then n open parentheses. Next the elements are scanned in
row-major order. Imagine the array indices being enumerated in odometer
fashion, recalling that the dimensions are numbered from 0 to n − 1. Every
time the index for dimension j is incremented, the following actions are
taken:
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x142-193012x1">If j &#x003C; n − 1, then print a close parenthesis.
     </li>
     <li 
  class="enumerate" id="x142-193014x2">If incrementing the index for dimension j caused it to equal dimension
     j,  reset  that  index  to  zero  and  increment  dimension  j − 1  (thereby
     performing these three steps recursively), unless j = 0, in which case
     simply terminate the entire algorithm. If incrementing the index for
     dimension j did not cause it to equal dimension j, then print a space.
     </li>
     <li 
  class="enumerate" id="x142-193016x3">If j &#x003C; n − 1, then print an open parenthesis.</li></ol>
<!--l. 2827--><p class="noindent" >This causes the contents to be printed in a format suitable for use as the
<i>:initial-contents</i> argument to <i>make-array</i>. <div class=obsolete> The lists eﬀectively printed by this
procedure are subject to truncation by <i>*print-level*</i> and <i>*print-length*</i>.
</div>
<!--l. 2834--><p class="indent" >  If the array is of a specialized type, containing bits or string-characters, then
the innermost lists generated by the algorithm given above may instead be
printed using bit-vector or string syntax, provided that these innermost lists
would not be subject to truncation by <i>*print-length*</i>. For example, a
3-by-2-by-4 array of string-characters that would ordinarily be printed as <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#3A(((#<tt>\</tt>s #<tt>\</tt>t #<tt>\</tt>o #<tt>\</tt>p) (#<tt>\</tt>s #<tt>\</tt>p #<tt>\</tt>o #<tt>\</tt>t))
</td></tr></table>
<!--l. 2840--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ((#<tt>\</tt>p #<tt>\</tt>o #<tt>\</tt>s #<tt>\</tt>t) (#<tt>\</tt>p #<tt>\</tt>o #<tt>\</tt>t #<tt>\</tt>s))</td></tr></table>
                                                                          

                                                                          
<!--l. 2841--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ((#<tt>\</tt>t #<tt>\</tt>o #<tt>\</tt>p #<tt>\</tt>s) (#<tt>\</tt>o #<tt>\</tt>p #<tt>\</tt>t #<tt>\</tt>s)))</td></tr></table>
<!--l. 2843--><p class="indent" >
</div>
</div>
<!--l. 2844--><p class="noindent" >may instead be printed more concisely as <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#3A((&#x0022;stop&#x0022; &#x0022;spot&#x0022;) (&#x0022;post&#x0022; &#x0022;pots&#x0022;) (&#x0022;tops&#x0022; &#x0022;opts&#x0022;))
</td></tr></table>
<!--l. 2847--><p class="indent" >
</div>
</div>
<div class=obsolete>
<!--l. 2850--><p class="indent" >  If <i>*print-array*</i> is <i>nil</i>, then the array is printed in a format (using <i>#&#x003C;</i>) that is
concise but not readable.
</div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-readably*</i> is not <i>nil</i> then
every object must be printed in a readable form, regardless of other printer
control variables. For arrays, the simplest approach is to print them, when
<i>*print-readably*</i> is not <i>nil</i>, as if <i>*print-level*</i> and <i>*print-length*</i> were <i>nil</i> and
<i>*print-array*</i> were not <i>nil</i>, regardless of their actual values.
</div>
  <br /><b>
Random-states                                                            </b>
Common Lisp does not specify a speciﬁc syntax for printing objects of type
<i>random-state</i>. However, every implementation must arrange to print a
random-state object in such a way that, within the same implementation of
Common Lisp, the function <i>read</i> can construct from the printed representation a
copy of the random-state object as if the copy had been made by
<i>make-random-state</i>.
<div class=obsolete>
Pathnames
Common Lisp does not specify a speciﬁc syntax for printing objects of type
<i>pathname</i>. However, every implementation must arrange to print a pathname in
                                                                          

                                                                          
such a way that, within the same implementation of Common Lisp, the function
<i>read</i> can construct from the printed representation an equivalent instance of the
pathname object.
</div>
<div class=newer>
<!--l. 2881--><p class="indent" >  X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-escape*</i> is true, a
pathname should be printed by <i>write</i> as <i>#P&#x0022;...&#x0022;</i> where <i>&#x0022;...&#x0022;</i> is the namestring
representation of the pathname. If <i>*print-escape*</i> is false, <i>write</i> prints a pathname
by printing its namestring (presumably without escape characters or surrounding
double quotes).
</div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-readably*</i> is not <i>nil</i> then
every object must be printed in a readable form, regardless of other printer
control variables. For pathnames, the simplest approach is to print them, when
<i>*print-readably*</i> is not <i>nil</i>, as if <i>*print-escape*</i> were <i>nil</i>, regardless of its actual
value.
</div></div>
</div>
<!--l. 2898--><p class="indent" >   Structures deﬁned by <i>defstruct</i> are printed under the control of the
user-speciﬁed <i>:print-function</i> option to <i>defstruct</i>. If the user does not provide a
printing function explicitly, then a default printing function is supplied that prints
the structure using <i>#S</i> syntax (see section <a 
href="#x142-19100022.1.4">22.1.4<!--tex4ht:ref: SHARP-SIGN-MACRO-CHARACTER-SECTION --></a>).
<div class=obsolete>
<!--l. 2905--><p class="indent" >   Any other types are printed in an implementation-dependent manner. It is
recommended that printed representations of all such objects begin with the
characters <i>#&#x003C;</i> and end with <i>&#x003E;</i> so that the reader will catch such objects and not
permit them to be read under normal circumstances. It is speciﬁcally and
purposely not required that a Common Lisp implementation be able to print an
object of type <i>hash-table</i>, <i>readtable</i>, <i>package</i>, <i>stream</i>, or <i>function</i> in a way that
can be read back in successfully by <i>read</i>; the use of <i>#&#x003C;</i> syntax is especially
recommended for the printing of such objects.
</div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-readably*</i> is not <i>nil</i> then
every object must be printed in a readable form, regardless of the values of
other printer control variables; if this is not possible, then an error of type
<i>print-not-readable</i> must be signaled to avoid printing an unreadable syntax such
as <i>#&#x003C;...&#x003E;</i>.
<!--l. 2923--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to add <i>print-unreadable-object</i>, a macro that
prints an object using <i>#&#x003C;...&#x003E;</i> syntax and also takes care of checking the variable
                                                                          

                                                                          
<i>*print-readably*</i>.
</div>
<!--l. 2928--><p class="indent" >   When debugging or when frequently dealing with large or deep objects at
top level, the user may wish to restrict the printer from printing large
amounts of information. The variables <i>*print-level*</i> and <i>*print-length*</i>
allow the user to control how deep the printer will print and how many
elements at a given level the printer will print. Thus the user can see enough
of the object to identify it without having to wade through the entire
expression.
<div class=newer>
<div class=defun>
<!--l. 2937--><p class="noindent" > <i>[Variable]</i>   <b>*print-readably*</b> <a 
 id="dx142-193017"></a><a 
 id="x142-193018r683"></a>
<!--l. 2939--><p class="noindent" >The default value of <i>*print-readably*</i> is <i>nil</i>. If <i>*print-readably*</i> is true,
then printing any object must either produce a printed representation
that the reader will accept or signal an error. If printing is successful,
the reader will, on reading the printed representation, produce an object
that is “similar as a constant” (see section <a 
href="clmse127.html#x157-22800025.1.4">25.1.4<!--tex4ht:ref: SIMILAR-AS-A-CONSTANT-SECTION --></a>) to the object that was
printed.
<!--l. 2948--><p class="indent" >   If <i>*print-readably*</i> is true and printing a readable printed representation is not
possible, the printer signals an error of type <i>print-not-readable</i> rather than using
an unreadable syntax such as <i>#&#x003C;</i>. The printed representation produced when
<i>*print-readably*</i> is true might or might not be the same as the printed
representation produced when <i>*print-readably*</i> is false.
<!--l. 2955--><p class="indent" >   If <i>*print-readably*</i> is true and another printer control variable (such as
<i>*print-length*</i>, <i>*print-level*</i>, <i>*print-escape*</i>, <i>*print-gensym*</i>, <i>*print-array*</i>,
or an implementation-deﬁned printer control variable) would cause the
preceding requirements to be violated, that other printer control variable is
ignored.
<!--l. 2961--><p class="indent" >   The printing of interned symbols is not aﬀected by <i>*print-readably*</i>.
<!--l. 2963--><p class="indent" >   Note that the “similar as a constant” rule for readable printing implies
that <i>#A</i> or <i>#(</i> syntax cannot be used for arrays of element-type other
than <i>t</i>. An implementation will have to use another syntax or signal a
<i>print-not-readable</i> error. A <i>print-not-readable</i> error will not be signaled for strings
or bit-vectors.
<!--l. 2969--><p class="indent" >   All methods for <i>print-object</i> must obey <i>*print-readably*</i>. This rule applies to
both user-deﬁned methods and implementation-deﬁned methods.
<!--l. 2972--><p class="indent" >   The reader control variable <i>*read-eval*</i> also aﬀects printing. If <i>*read-eval*</i> is
false and <i>*print-readably*</i> is true, any <i>print-object</i> method that would otherwise
                                                                          

                                                                          
output a <i>#.</i> reader macro must either output something diﬀerent or signal an
error of type <i>print-not-readable</i>.
<!--l. 2977--><p class="indent" >   Readable printing of structures and objects of type <i>standard-object</i> is
controlled by their <i>print-object</i> methods, not by their <i>make-load-form</i> methods.
“Similarity as a constant” for these objects is application-dependent and hence is
deﬁned to be whatever these methods do.
<i>
<!--l. 2983--><p class="indent" >   *print-readably*</i> allows errors involving data with no readable printed
representation to be detected when writing the ﬁle rather than later on when the
ﬁle is read.
<i>
<!--l. 2987--><p class="indent" >   *print-readably*</i> is more rigorous than <i>*print-escape*</i>; output printed with
escapes must be merely generally recognizable by humans, with a good chance of
being recognizable by computers, whereas output printed readably must be
reliably recognizable by computers.
</div>
</div>
<div class=defun>
<!--l. 2994--><p class="noindent" > <i>[Variable]</i>   <b>*print-escape*</b> <a 
 id="dx142-193019"></a><a 
 id="x142-193020r684"></a>
<!--l. 2996--><p class="noindent" >When this ﬂag is <i>nil</i>, then escape characters are not output when an expression is
printed. In particular, a symbol is printed by simply printing the characters of
its print name. The function <i>princ</i> eﬀectively binds <i>*print-escape*</i> to
<i>nil</i>.
<!--l. 3002--><p class="indent" >   When this ﬂag is not <i>nil</i>, then an attempt is made to print an expression in
such a way that it can be read again to produce an <i>equal</i> structure. The function
<i>prin1</i> eﬀectively binds <i>*print-escape*</i> to <i>t</i>. The initial value of this variable is
<i>t</i>.
<div class=incompatibility>
<!--l. 3009--><p class="noindent" ><b>Compatibility note:</b> <i>*print-escape*</i> controls what was called slashiﬁcation in
MacLisp.
</div>
</div>
<div class=defun>
<!--l. 3016--><p class="noindent" > <i>[Variable]</i>   <b>*print-pretty*</b> <a 
 id="dx142-193021"></a><a 
 id="x142-193022r685"></a>
<!--l. 3018--><p class="noindent" >When this ﬂag is <i>nil</i>, then only a small amount of whitespace is output when
printing an expression.
<!--l. 3022--><p class="indent" >   When this ﬂag is not <i>nil</i>, then the printer will endeavor to insert extra
whitespace where appropriate to make the expression more readable. A few
                                                                          

                                                                          
other simple changes may be made, such as printing <i>&#x2019;foo</i> instead of <i>(quote
foo)</i>.
<!--l. 3027--><p class="indent" >   The initial value of <i>*print-pretty*</i> is implementation-dependent.
<div class=new>
<!--l. 3030--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to adopt a facility for user-controlled pretty
printing in Common Lisp (see chapter <a 
href="clmch27.html#x175-25300027">27<!--tex4ht:ref: PPRINT --></a>).
</div>
</div>
<div class=defun>
<!--l. 3038--><p class="noindent" > <i>[Variable]</i>   <b>*print-circle*</b> <a 
 id="dx142-193023"></a><a 
 id="x142-193024r686"></a>
<!--l. 3040--><p class="noindent" >When this ﬂag is <i>nil</i> (the default), then the printing process proceeds by recursive
descent; an attempt to print a circular structure may lead to looping behavior and
failure to terminate.
<div class=obsolete>
<!--l. 3046--><p class="indent" >   When this ﬂag is not <i>nil</i>, then the printer will endeavor to detect cycles in the
structure to be printed, and to use <i>#n=</i> and <i>#n#</i> syntax to indicate the
circularities.
</div>
<div class=newer>
<!--l. 3052--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that if <i>*print-circle*</i> is true, the
printer is required to detect not only cycles but shared substructure, indicating
both through the use of <i>#n=</i> and <i>#n#</i> syntax. As an example, under the
speciﬁcation of the ﬁrst edition <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(print &#x2019;(#1=(a #1#) #1#))
</td></tr></table>
<!--l. 3059--><p class="indent" >
</div>
</div>
<!--l. 3060--><p class="noindent" >might legitimately print <i>(#1=(A #1#) #1#)</i> or <i>(#1=(A #1#) #2=(A #2#))</i>; the
vote speciﬁes that the ﬁrst form is required.
</div>
<div class=new>
<!--l. 3066--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to specify that user-deﬁned printing
functions for the <i>defstruct</i> <i>:print-function</i> option, as well as user-deﬁned methods
for the CLOS generic function <i>print-object</i>, may print objects to the supplied
                                                                          

                                                                          
stream using <i>write</i>, <i>print1</i>, <i>princ</i>, <i>format</i>, or <i>print-object</i> and expect circularities
to be detected and printed using <i>#n#</i> syntax (when <i>*print-circle*</i> is non-<i>nil</i>, of
course).
<!--l. 3075--><p class="indent" >   It seems to me that the same ought to apply to abbreviation as controlled
by <i>*print-level*</i> and <i>*print-length*</i>, but that was not addressed by this
vote.
</div>
</div>
<div class=defun>
<!--l. 3081--><p class="noindent" > <i>[Variable]</i>   <b>*print-base*</b> <a 
 id="dx142-193025"></a><a 
 id="x142-193026r687"></a>
<!--l. 3083--><p class="noindent" >The value of <i>*print-base*</i> determines in what radix the printer will print
rationals. This may be any integer from <i>2</i> to <i>36</i>, inclusive; the default value is <i>10</i>
(decimal radix). For radices above <i>10</i>, letters of the alphabet are used to represent
digits above <i>9</i>.
<div class=incompatibility>
<!--l. 3091--><p class="noindent" ><b>Compatibility note:</b> MacLisp calls this variable <i>base</i>, and its default value is <i>8</i>, not
<i>10</i>.
<!--l. 3094--><p class="indent" >   In both MacLisp and Common Lisp, ﬂoating-point numbers are always printed in
decimal, no matter what the value of <i>*print-base*</i>.
</div>
</div>
<div class=defun>
<!--l. 3101--><p class="noindent" > <i>[Variable]</i>   <b>*print-radix*</b> <a 
 id="dx142-193027"></a><a 
 id="x142-193028r688"></a>
<!--l. 3103--><p class="noindent" >If the variable <i>*print-radix*</i> is non-<i>nil</i>, the printer will print a radix speciﬁer to
indicate the radix in which it is printing a rational number. To prevent confusion
of the letter <i>O</i> with the digit <i>0</i>, and of the letter <i>B</i> with the digit <i>8</i>, the radix
speciﬁer is always printed using lowercase letters. For example, if the current base
is twenty-four (decimal), the decimal integer twenty-three would print as <i>#24rN</i>.
If <i>*print-base*</i> is <i>2</i>, <i>8</i>, or <i>16</i>, then the radix speciﬁer used is <i>#b</i>, <i>#o</i>, or <i>#x</i>. For
integers, base ten is indicated by a trailing decimal point instead of a leading
radix speciﬁer; for ratios, however, <i>#10r</i> is used. The default value of
<i>*print-radix*</i> is <i>nil</i>.
</div>
<div class=defun>
<!--l. 3117--><p class="noindent" > <i>[Variable]</i>   <b>*print-case*</b> <a 
 id="dx142-193029"></a><a 
 id="x142-193030r689"></a>
<!--l. 3119--><p class="noindent" >The <i>read</i> function normally converts lowercase characters appearing in symbols to
corresponding uppercase characters, so that internally print names normally
contain only uppercase characters. However, users may prefer to see output using
                                                                          

                                                                          
lowercase letters or letters of mixed case. This variable controls the case (upper,
lower, or mixed) in which to print any uppercase characters in the names of
symbols when vertical-bar syntax is not used. The value of <i>*print-case*</i> should be
one of the keywords <i>:upcase</i>, <i>:downcase</i>, or <i>:capitalize</i>; the initial value is
<i>:upcase</i>.
<!--l. 3133--><p class="indent" >   Lowercase characters in the internal print name are always printed in
lowercase, and are preceded by a single escape character or enclosed by multiple
escape characters. Uppercase characters in the internal print name are printed in
uppercase, in lowercase, or in mixed case so as to capitalize words, according to
the value of <i>*print-case*</i>. The convention for what constitutes a “word” is the
same as for the function <i>string-capitalize</i>.
<div class=newer>
<!--l. 3144--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to clarify the interaction of <i>*print-case*</i> with
<i>*print-escape*</i>. When <i>*print-escape*</i> is <i>nil</i>, <i>*print-case*</i> determines the
case in which to print all uppercase characters in the print name of the
symbol. When <i>*print-escape*</i> is not <i>nil</i>, the implementation has some
freedom as to which characters will be printed so as to appear in an “escape
context” (after an escape character, typically <i><tt>\</tt></i>, or between multiple escape
characters, typically <i>|</i>); <i>*print-case*</i> determines the case in which to print
all uppercase characters that will not appear in an escape context. For
example, when the value of <i>*print-case*</i> is <i>:upcase</i>, an implementation might
choose to print the symbol whose print name is <i>&#x0022;(S)HE&#x0022;</i> as <i><tt>\</tt>(S<tt>\</tt>)HE</i> or
as <i>|(S)HE|</i>, among other possibilities. When the value of <i>*print-case*</i>
is <i>:downcase</i>, the corresponding output should be <i><tt>\</tt>(s<tt>\</tt>)he</i> or <i>|(S)HE|</i>,
respectively.
<!--l. 3159--><p class="indent" >   Consider the following test code. (For the sake of this example assume that
<i>readtable-case</i> is <i>:upcase</i> in the current readtable; this is discussed further below.) <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((tabwidth 11))
</td></tr></table>
<!--l. 3163--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dolist (sym &#x2019;(|x| |FoObAr| |fOo|))</td></tr></table>
<!--l. 3164--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((tabstop -1))</td></tr></table>
<!--l. 3165--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (format t &#x0022;<tt>~</tt>&#x0026;&#x0022;)</td></tr></table>
<!--l. 3166--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (dolist (escape &#x2019;(t nil))</td></tr></table>
<!--l. 3167--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (dolist (case &#x2019;(:upcase :downcase :capitalize))</td></tr></table>
<!--l. 3168--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (format t &#x0022;<tt>~</tt>VT&#x0022; (* (incf tabstop) tabwidth))</td></tr></table>
                                                                          

                                                                          
<!--l. 3169--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (write sym :escape escape :case case)))))</td></tr></table>
<!--l. 3170--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (format t &#x0022; %&#x0022;))</td></tr></table>
<!--l. 3172--><p class="indent" >
</div>
</div>
<!--l. 3173--><p class="noindent" >An implementation that leans heavily on multiple-escape characters (vertical bars)
might produce the following output: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">|x|        |x|        |x|        x          x          x
</td></tr></table>
<!--l. 3176--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">|FoObAr|   |FoObAr|   |FoObAr|   FoObAr     foobar     Foobar</td></tr></table>
<!--l. 3177--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">|fOo|      |fOo|      |fOo|      fOo        foo        foo</td></tr></table>
<!--l. 3179--><p class="indent" >
</div>
</div>
<!--l. 3180--><p class="noindent" >An implementation that leans heavily on single-escape characters (backslashes) might
produce the following output: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><tt>\</tt>x         <tt>\</tt>x         <tt>\</tt>x         x          x          x
</td></tr></table>
<!--l. 3183--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">F<tt>\</tt>oO<tt>\</tt>bA<tt>\</tt>r  f<tt>\</tt>oo<tt>\</tt>ba<tt>\</tt>r  F<tt>\</tt>oo<tt>\</tt>ba<tt>\</tt>r  FoObAr     foobar     Foobar</td></tr></table>
<!--l. 3184--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><tt>\</tt>fO<tt>\</tt>o      <tt>\</tt>fo<tt>\</tt>o      <tt>\</tt>fo<tt>\</tt>o      fOo        foo        foo</td></tr></table>
<!--l. 3186--><p class="indent" >
</div>
</div>
<!--l. 3187--><p class="noindent" >These examples are not exhaustive; output using both kinds of escape characters (for
example, <i>|FoO|<tt>\</tt>bA<tt>\</tt>r</i>) is permissible (though ugly).
<!--l. 3190--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to add a new <i>readtable-case</i> slot to readtables to
control automatic case conversion during the reading of symbols. The value of
<i>readtable-case</i> in the current readtable also aﬀects the printing of unescaped
letters (letters appearing in an escape context are always printed in their own
case).
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">If <i>readtable-case</i> is <i>:upcase</i>, unescaped uppercase letters are printed in
      the case speciﬁed by <i>*print-case*</i> and unescaped lowercase letters are
      printed in their own case. (If <i>*print-escape*</i> is non-<i>nil</i>, all lowercase
      letters will necessarily be escaped.)
      </li>
      <li class="itemize">If <i>readtable-case</i> is <i>:downcase</i>, unescaped lowercase letters are printed
      in the case speciﬁed by <i>*print-case*</i> and unescaped uppercase letters
      are printed in their own case. (If <i>*print-escape*</i> is non-<i>nil</i>, all uppercase
      letters will necessarily be escaped.)
      </li>
      <li class="itemize">If <i>readtable-case</i> is <i>:preserve</i>, all unescaped letters are printed in their
      own case, regardless of the value of <i>*print-case*</i>. There is no need to
      escape any letters, even if <i>*print-escape*</i> is non-<i>nil</i>, though the X3J13
      vote did not prohibit escaping letters in this situation.
      </li>
      <li class="itemize">If <i>readtable-case</i> is <i>:invert</i>, and if all unescaped letters are of the same
      case, then the case of all the unescaped letters is inverted; but if the
      unescaped letters are not all of the same case then each is printed
      in its own case. (Thus <i>:invert</i> does not always invert the case; the
      inversion is conditional.) There is no need to escape any letters, even
      if <i>*print-escape*</i> is non-<i>nil</i>, though the X3J13 vote did not prohibit
      escaping letters in this situation.</li></ul>
<!--l. 3222--><p class="noindent" >Consider the following code. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Generate a table illustrating READTABLE-CASE and *PRINT-CASE*.
</td></tr></table>
<!--l. 3224--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 3225--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((*readtable* (copy-readtable nil))</td></tr></table>
<!--l. 3226--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (*print-case* *print-case*))</td></tr></table>
<!--l. 3227--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (format t &#x0022;READTABLE-CASE *PRINT-CASE*  Symbol-name  Output<tt>~</tt></td></tr></table>
<!--l. 3228--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           <tt>~</tt>%————————-                         ————————-<tt>~</tt></td></tr></table>
<!--l. 3229--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           <tt>~</tt>%&#x0022;)</td></tr></table>
<!--l. 3230--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dolist (readtable-case &#x2019;(:upcase :downcase :preserve :invert))</td></tr></table>
                                                                          

                                                                          
<!--l. 3231--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (setf (readtable-case *readtable*) readtable-case)</td></tr></table>
<!--l. 3232--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (dolist (print-case &#x2019;(:upcase :downcase :capitalize))</td></tr></table>
<!--l. 3233--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (dolist (sym &#x2019;(|ZEBRA| |Zebra| |zebra|))</td></tr></table>
<!--l. 3234--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (setq *print-case* print-case)</td></tr></table>
<!--l. 3235--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (format t &#x0022;:<tt>~</tt>A<tt>~</tt>15T:<tt>~</tt>A<tt>~</tt>29T<tt>~</tt>A<tt>~</tt>42T<tt>~</tt>A<tt>~</tt>%&#x0022;</td></tr></table>
<!--l. 3236--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  (string-upcase readtable-case)</td></tr></table>
<!--l. 3237--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  (string-upcase print-case)</td></tr></table>
<!--l. 3238--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  (symbol-name sym)</td></tr></table>
<!--l. 3239--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  (prin1-to-string sym)))))))</td></tr></table>
<!--l. 3241--><p class="indent" >
</div>
</div>
<!--l. 3244--><p class="noindent" >Note that the call to <i>prin1-to-string</i> (the last argument in the call to
<i>format</i> that is within the nested loops) eﬀectively uses a non-<i>nil</i> value for
<i>*print-escape*</i>.
<!--l. 3249--><p class="indent" >   Assuming an implementation that uses vertical bars around a symbol name if
any characters need escaping, the output from this test code should be  <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">READTABLE-CASE *PRINT-CASE*  Symbol-name  Output
</td></tr></table>
<!--l. 3254--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">————————————————–</td></tr></table>
<!--l. 3255--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE        :UPCASE       ZEBRA        ZEBRA</td></tr></table>
<!--l. 3256--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE        :UPCASE       Zebra        |Zebra|</td></tr></table>
<!--l. 3257--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE        :UPCASE       zebra        |zebra|</td></tr></table>
<!--l. 3258--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE        :DOWNCASE     ZEBRA        zebra</td></tr></table>
<!--l. 3259--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE        :DOWNCASE     Zebra        |Zebra|</td></tr></table>
<!--l. 3260--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE        :DOWNCASE     zebra        |zebra|</td></tr></table>
<!--l. 3261--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE        :CAPITALIZE   ZEBRA        Zebra</td></tr></table>
<!--l. 3262--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE        :CAPITALIZE   Zebra        |Zebra|</td></tr></table>
<!--l. 3263--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:UPCASE        :CAPITALIZE   zebra        |zebra|</td></tr></table>
<!--l. 3264--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE      :UPCASE       ZEBRA        |ZEBRA|</td></tr></table>
<!--l. 3265--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE      :UPCASE       Zebra        |Zebra|</td></tr></table>
<!--l. 3266--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE      :UPCASE       zebra        ZEBRA</td></tr></table>
<!--l. 3267--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE      :DOWNCASE     ZEBRA        |ZEBRA|</td></tr></table>
<!--l. 3268--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE      :DOWNCASE     Zebra        |Zebra|</td></tr></table>
                                                                          

                                                                          
<!--l. 3269--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE      :DOWNCASE     zebra        zebra</td></tr></table>
<!--l. 3270--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE      :CAPITALIZE   ZEBRA        |ZEBRA|</td></tr></table>
<!--l. 3271--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE      :CAPITALIZE   Zebra        |Zebra|</td></tr></table>
<!--l. 3272--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:DOWNCASE      :CAPITALIZE   zebra        Zebra</td></tr></table>
<!--l. 3273--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE      :UPCASE       ZEBRA        ZEBRA</td></tr></table>
<!--l. 3274--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE      :UPCASE       Zebra        Zebra</td></tr></table>
<!--l. 3275--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE      :UPCASE       zebra        zebra</td></tr></table>
<!--l. 3276--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE      :DOWNCASE     ZEBRA        ZEBRA</td></tr></table>
<!--l. 3277--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE      :DOWNCASE     Zebra        Zebra</td></tr></table>
<!--l. 3278--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE      :DOWNCASE     zebra        zebra</td></tr></table>
<!--l. 3279--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE      :CAPITALIZE   ZEBRA        ZEBRA</td></tr></table>
<!--l. 3280--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE      :CAPITALIZE   Zebra        Zebra</td></tr></table>
<!--l. 3281--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:PRESERVE      :CAPITALIZE   zebra        zebra</td></tr></table>
<!--l. 3282--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT        :UPCASE       ZEBRA        zebra</td></tr></table>
<!--l. 3283--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT        :UPCASE       Zebra        Zebra</td></tr></table>
<!--l. 3284--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT        :UPCASE       zebra        ZEBRA</td></tr></table>
<!--l. 3285--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT        :DOWNCASE     ZEBRA        zebra</td></tr></table>
<!--l. 3286--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT        :DOWNCASE     Zebra        Zebra</td></tr></table>
<!--l. 3287--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT        :DOWNCASE     zebra        ZEBRA</td></tr></table>
<!--l. 3288--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT        :CAPITALIZE   ZEBRA        zebra</td></tr></table>
<!--l. 3289--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT        :CAPITALIZE   Zebra        Zebra</td></tr></table>
<!--l. 3290--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">:INVERT        :CAPITALIZE   zebra        ZEBRA</td></tr></table>
<!--l. 3291--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">
</td></tr></table>
<!--l. 3292--><p class="indent" >
</div>
</div>
<!--l. 3294--><p class="indent" >   This illustrates all combinations for <i>readtable-case</i> and <i>*print-case*</i>.
</div>
</div>
                                                                          

                                                                          
<div class=defun>
<!--l. 3301--><p class="noindent" > <i>[Variable]</i>   <b>*print-gensym*</b> <a 
 id="dx142-193031"></a><a 
 id="x142-193032r690"></a>
<!--l. 3303--><p class="noindent" >The <i>*print-gensym*</i> variable controls whether the preﬁx <i>#:</i> is printed before
symbols that have no home package. The preﬁx is printed if the variable is not
<i>nil</i>. The initial value of <i>*print-gensym*</i> is <i>t</i>.
</div>
   <div class="table">
                                                                          

                                                                          
<!--l. 3310--><p class="indent" >   <a 
 id="x142-1930336"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 22.6: </span><span  
class="content">Examples of Print Level and Print Length Abbreviation</span></div><!--tex4ht:label?: x142-1930336 -->
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >v </td><td align="left" >n</td><td align="left" >Output                                                                 </td>
</tr><tr><td align="left" >0 </td><td align="left" >1</td><td align="left" >#                                                                         </td>
</tr><tr><td align="left" >1 </td><td align="left" >1</td><td align="left" >(if ...)                                                                    </td>
</tr><tr><td align="left" >1 </td><td align="left" >2</td><td align="left" >(if # ...)                                                                </td>
</tr><tr><td align="left" >1 </td><td align="left" >3</td><td align="left" >(if # # ...)                                                             </td>
</tr><tr><td align="left" >1 </td><td align="left" >4</td><td align="left" >(if # # #)                                                             </td>
</tr><tr><td align="left" >2 </td><td align="left" >1</td><td align="left" >(if ...)                                                                    </td>
</tr><tr><td align="left" >2 </td><td align="left" >2</td><td align="left" >(if (member x ...) ...)                                                </td>
</tr><tr><td align="left" >2 </td><td align="left" >3</td><td align="left" >(if (member x y) (+ # 3) ...)                                     </td>
</tr><tr><td align="left" >3 </td><td align="left" >2</td><td align="left" >(if (member x ...) ...)                                                </td>
</tr><tr><td align="left" >3 </td><td align="left" >3</td><td align="left" >(if (member x y) (+ (car x) 3) ...)                              </td>
</tr><tr><td align="left" >3 </td><td align="left" >4</td><td align="left" >(if (member x y) (+ (car x) 3) &#x2019;(foo . #(a b c d ...)))     </td>
</tr><tr><td align="left" >3 </td><td align="left" >5</td><td align="left" >(if (member x y) (+ (car x) 3) &#x2019;(foo . #(a b c d &#x0022;Baz&#x0022;)))</td></tr></table>               </div>
</td></tr></table><!--l. 3330--><p class="noindent" >
</div>
</div>
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<div class=defun>
<!--l. 3333--><p class="noindent" > <i>[Variable]</i>   <b>*print-level*</b> <a 
 id="dx142-193034"></a><a 
 id="x142-193035r691"></a>  <br 
class="newline" /><i>[Variable]</i>   <b>*print-length*</b> <a 
 id="dx142-193036"></a><a 
 id="x142-193037r692"></a>
<!--l. 3336--><p class="noindent" >The <i>*print-level*</i> variable controls how many levels deep a nested data
object will print. If <i>*print-level*</i> is <i>nil</i> (the initial value), then no control
is exercised. Otherwise, the value should be an integer, indicating the
maximum level to be printed. An object to be printed is at level <i>0</i>; its
components (as of a list or vector) are at level <i>1</i>; and so on. If an object
to be recursively printed has components and is at a level equal to or
greater than the value of <i>*print-level*</i>, then the object is printed as simply
<i>#</i>.
<!--l. 3347--><p class="indent" >   The <i>*print-length*</i> variable controls how many elements at a given level are
printed. A value of <i>nil</i> (the initial value) indicates that there be no limit to the
number of components printed. Otherwise, the value of <i>*print-length*</i> should
be an integer. Should the number of elements of a data object exceed
the value <i>*print-length*</i>, the printer will print three dots, <i>...</i>, in place
of those elements beyond the number speciﬁed by <i>*print-length*</i>. (In
the case of a dotted list, if the list contains exactly as many elements
as the value of <i>*print-length*</i>, and in addition has the non-null atom
terminating it, that terminating atom is printed rather than the three
dots.)
<i>
<!--l. 3358--><p class="indent" >   *print-level*</i> and <i>*print-length*</i> aﬀect the printing not only of lists but also of
vectors, arrays, and any other object printed with a list-like syntax. They do not
aﬀect the printing of symbols, strings, and bit-vectors.
<!--l. 3363--><p class="indent" >   The Lisp reader will normally signal an error when reading an expression that
has been abbreviated because of level or length limits. This signal is given because
the <i>#</i> dispatch character normally signals an error when followed by
whitespace or <i>)</i>, and because <i>...</i> is deﬁned to be an illegal token, as are all
tokens consisting entirely of periods (other than the single dot used in dot
notation).
<!--l. 3370--><p class="indent" >   As an example, table <a 
href="#x142-1930336">22.6<!--tex4ht:ref: LEVEL-LENGTH-TABLE --></a> shows the ways the object <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(if (member x y) (+ (car x) 3) &#x2019;(foo . #(a b c d &#x0022;Baz&#x0022;)))
</td></tr></table>
                                                                          

                                                                          
<!--l. 3373--><p class="indent" >
</div>
</div>
<!--l. 3374--><p class="noindent" >would be printed for various values of <i>*print-level*</i> (in the column labeled v) and
<i>*print-length*</i> (in the column labeled n).
</div>
<div class=defun>
<!--l. 3378--><p class="noindent" > <i>[Variable]</i>   <b>*print-array*</b> <a 
 id="dx142-193038"></a><a 
 id="x142-193039r693"></a>
<!--l. 3380--><p class="noindent" >If <i>*print-array*</i> is <i>nil</i>, then the contents of arrays other than strings are never
printed. Instead, arrays are printed in a concise form (using <i>#&#x003C;</i>) that gives
enough information for the user to be able to identify the array but does not
include the entire array contents. If <i>*print-array*</i> is not <i>nil</i>, non-string arrays are
printed using <i>#(</i>, <i>#*</i>, or <i>#nA</i> syntax. <div class=new>Notice of correction. In the ﬁrst edition,
the preceding paragraph mentioned the nonexistent variable <i>print-array</i> instead of
<i>*print-array*</i>.
</div> The initial value of <i>*print-array*</i> is implementation-dependent.
</div>
<div class=newer>
<!--l. 3397--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to add the macro <i>with-standard-io-syntax</i>.
</div> <div class=defmac>
<!--l. 3400--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> with-standard-io-syntax </b> <a 
 id="dx142-193040"></a><a 
 id="x142-193041r694"></a>   {<i>declaration</i>}∗  {<i>form</i>}∗
</td></tr></table>
<!--l. 3401--><p class="indent" >
</div>
   Within the dynamic extent of the body, all reader/printer control variables,
including any implementation-deﬁned ones not speciﬁed by Common
Lisp, are bound to values that produce standard read/print behavior.
Table <a 
href="#x142-1930427">22.7<!--tex4ht:ref: WITH-STANDARD-IO-SYNTAX-TABLE --></a> shows the values to which standard Common Lisp variables are
bound.
   <div class="table">
                                                                          

                                                                          
   <a 
 id="x142-1930427"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 22.7: </span><span  
class="content">Standard Bindings for I/O Control Variables</span></div><!--tex4ht:label?: x142-1930427 -->
<div class="flushleft" 
>
<!--l. 3411--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Variable                         </td><td align="left" >Value                                </td>
</tr><tr><td align="left" >*package*                      </td><td align="left" >the <i>common-lisp-user</i> package</td>
</tr><tr><td align="left" >*print-array*                  </td><td align="left" >t                                      </td>
</tr><tr><td align="left" >*print-base*                   </td><td align="left" >10                                     </td>
</tr><tr><td align="left" >*print-case*                    </td><td align="left" >:upcase                              </td>
</tr><tr><td align="left" >*print-circle*                  </td><td align="left" >nil                                    </td>
</tr><tr><td align="left" >*print-escape*                </td><td align="left" >t                                      </td>
</tr><tr><td align="left" >*print-gensym*               </td><td align="left" >t                                      </td>
</tr><tr><td align="left" >*print-length*                 </td><td align="left" >nil                                    </td>
</tr><tr><td align="left" >*print-level*                   </td><td align="left" >nil                                    </td>
</tr><tr><td align="left" >*print-lines*                   </td><td align="left" >nil *                                  </td>
</tr><tr><td align="left" >*print-miser-width*         </td><td align="left" >nil *                                  </td>
</tr><tr><td align="left" >*print-pprint-dispatch*     </td><td align="left" >nil *                                  </td>
</tr><tr><td align="left" >*print-pretty*                 </td><td align="left" >nil                                    </td>
</tr><tr><td align="left" >*print-radix*                  </td><td align="left" >nil                                    </td>
</tr><tr><td align="left" >*print-readably*              </td><td align="left" >t                                      </td>
</tr><tr><td align="left" >*print-right-margin*         </td><td align="left" >nil *                                  </td>
</tr><tr><td align="left" >*read-base*                    </td><td align="left" >10                                     </td>
</tr><tr><td align="left" >*read-default-ﬂoat-format*</td><td align="left" >single-ﬂoat                         </td>
</tr><tr><td align="left" >*read-eval*                     </td><td align="left" >t                                      </td>
</tr><tr><td align="left" >*read-suppress*               </td><td align="left" >nil                                    </td>
</tr><tr><td align="left" >*readtable*                    </td><td align="left" >the standard readtable          </td></tr></table></div></div>
<!--l. 3439--><p class="noindent" >* X3J13 voted in June 1989 ⟨<b>?</b>⟩ to introduce the printer control variables
<i>*print-right-margin*</i>, <i>*print-miser-width*</i>, <i>*print-lines*</i>, and <i>*print-pprint-dispatch*</i>
(see section <a 
href="clmse145.html#x177-25500027.2">27.2<!--tex4ht:ref: PPRINT-VARIABLES-SECTION --></a>) but did not specify the values to which <i>with-standard-io-syntax</i>
should bind them. I recommend that all four should be bound to <i>nil</i>.
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
   The values returned by <i>with-standard-io-syntax</i> are the values of the last body
form, or <i>nil</i> if there are no body forms.
   The intent is that a pair of executions, as shown in the following example,
should provide reasonable reliable communication of data from one Lisp process
to another: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Write DATA to a ﬁle.
</td></tr></table>
<!--l. 3456--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(with-open-ﬁle (ﬁle pathname :direction :output)</td></tr></table>
<!--l. 3457--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (with-standard-io-syntax</td></tr></table>
<!--l. 3458--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (print data ﬁle)))</td></tr></table>
<!--l. 3459--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 3460--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; ...  Later, in another Lisp:</td></tr></table>
<!--l. 3461--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(with-open-ﬁle (ﬁle pathname :direction :input)</td></tr></table>
<!--l. 3462--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (with-standard-io-syntax</td></tr></table>
<!--l. 3463--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (setq data (read ﬁle))))</td></tr></table>
<!--l. 3465--><p class="indent" >
</div>
</div>
<!--l. 3467--><p class="noindent" >Using <i>with-standard-io-syntax</i> to bind all the variables, instead of using <i>let</i> and
explicit bindings, ensures that nothing is overlooked and avoids problems with
implementation-deﬁned reader/printer control variables. If the user wishes to use
a non-standard value for some variable, such as <i>*package*</i> or <i>*read-eval*</i>, it can
be bound by <i>let</i> inside the body of <i>with-standard-io-syntax</i>. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Write DATA to a ﬁle. Forbid use of #. syntax.
</td></tr></table>
<!--l. 3475--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(with-open-ﬁle (ﬁle pathname :direction :output)</td></tr></table>
<!--l. 3476--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((*read-eval* nil))</td></tr></table>
<!--l. 3477--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (with-standard-io-syntax</td></tr></table>
<!--l. 3478--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (print data ﬁle))))</td></tr></table>
<!--l. 3479--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 3480--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Read DATA from a ﬁle. Forbid use of #. syntax.</td></tr></table>
                                                                          

                                                                          
<!--l. 3481--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(with-open-ﬁle (ﬁle pathname :direction :input)</td></tr></table>
<!--l. 3482--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((*read-eval* nil))</td></tr></table>
<!--l. 3483--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (with-standard-io-syntax</td></tr></table>
<!--l. 3484--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (setq data (read ﬁle)))))</td></tr></table>
<!--l. 3486--><p class="indent" >
</div>
</div>
<!--l. 3487--><p class="noindent" >Similarly, a user who dislikes the arbitrary choice of values for <i>*print-circle*</i>
and <i>*print-pretty*</i> can bind these variables to other values inside the
body.
<!--l. 3491--><p class="indent" >   The X3J13 vote left it unclear whether <i>with-standard-io-syntax</i> permits
declarations to appear before the body of the macro call. I believe that was the
intent, and this is reﬂected in the syntax shown above; but this is only my
interpretation.
</div>
                                                                          

                                                                          
   <!--l. 3497--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse116.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch22.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch22.html#tailclmch22.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse115.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch22.html#clmse115.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 3497--><p class="indent" >   <a 
 id="tailclmse115.html"></a>  
</body></html> 
