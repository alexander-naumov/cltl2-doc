%Part{Intro, Root = "CLM.MSS"}
% Chapter of Common Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.


\addtocontents{toc}{Preface (Second Edition)\hskip 1em\relax xi\vskip4pt}
\addtocontents{toc}{Acknowledgments (Second Edition)\hskip 1em\relax xiii\vskip4pt}
\addtocontents{toc}{Acknowledgments (First Edition)\hskip 1em\relax xvii\vskip4pt}

\clearpage\def\pagestatus{FINAL PROOF}
\chapter{Introduction Вступление}

Common Lisp is a new dialect of Lisp, a
successor to MacLisp \cite{MOONUAL,PITMANUAL}, influenced strongly by
Zetalisp \cite{BLUE-LISPM,GREEN-LISPM} and to some extent by Scheme
\cite{SCHEME-REVISED-REPORT} and Interlisp \cite{INTERLISP}.

Common Lisp это новый диалект Lisp'а, наследник
MacLisp'а \cite{MOONUAL,PITMANUAL}, под влиянием
ZetaLisp \cite{BLUE-LISPM,GREEN-LISPM} и в некоторой мере
Schem'ой \cite{SCHEME-REVISED-REPORT} и Interlisp'ом \cite{INTERLISP}.

\section{Purpose}

Common Lisp is intended to meet these goals:

Common Lisp предназначен для достижения следующих целей:


\begin{flushdesc}
\item[{\it Commonality}]
Common Lisp originated in an attempt to focus the
work of several implementation groups, each of which was constructing successor
implementations of MacLisp for different computers.  These
implementations had begun to diverge because of the differences in the
implementation environments: microcoded personal computers (Zetalisp,
Spice Lisp), commercial timeshared computers (NIL---the ``New Implementation of
Lisp''), and supercomputers (S-1 Lisp).  While the differences among the several
implementation environments of necessity will continue to force
certain incompatibilities among the
implementations, Common Lisp serves as a common dialect to
which each implementation makes any necessary extensions.

\item[{\it Объединение}]
Common Lisp создан в попытке сфокусировать работу несколько групп
разработчиков, каждая из которых создавала потомка MacLisp для
различных компьютеров. Это реализации начинали разниться по
причине различий в платформах: персональные компьютеры (Zetalisp,
Spice Lisp), коммерческие компьютеры с разделяемым временем
(NIL--- ``Новая реализация Lisp'а'') и суперкомпьютеры (S-1
Lisp). Тогда как различия платформ будут порождать несовместимости
между реализациями, Common Lisp предоставляет общий диалект,
который каждая реализация будет расширять для своих потребностей.

\item[{\it Portability}]

\begingroup\looseness=1
Common Lisp intentionally excludes features
that cannot be implemented easily on a broad class of machines.
On the one hand, features that are difficult or expensive
to implement on hardware without special microcode are avoided
or provided in a more abstract and efficiently implementable form.
(Examples of this are the invisible forwarding pointers
and locatives of Zetalisp.  Some of the problems that they solve
are addressed in different ways in Common Lisp.)
On the other hand, features that are useful only on certain ``ordinary''
or ``commercial'' processors are avoided or made optional.  (An example of
this is the type declaration facility, which is useful in some
implementations and completely ignored in others.  Type declarations are
completely optional and for correct programs
affect only efficiency, not semantics.)
Common Lisp is designed to make it easy to write programs
that depend as little as possible on machine-specific
characteristics, such as word length, while allowing some variety of
implementation \hbox{techniques}.
\par\endgroup

\item[{\it Переносимость}]

\begingroup\looseness=1
Common Lisp умышленно исключает возможности, которые не могут быть
реализованы простым способом на широком классе машин. С одной
стороны, возможности которые сложны или дороги в реализации на
аппаратной части без специальных микрокодов исключаются или
представляются в более абстрактной и реализуемой форме.
(Examples of this are the invisible forwarding pointers
and locatives of Zetalisp.  Some of the problems that they solve
are addressed in different ways in Common Lisp.)
С другой стороны, возможности, которые полезны только на
``обычных'' или ``коммерческих'' процессорах исключаются или
делаются опциональными. (Примером тому является функция декларации
типы, которая полеза на некоторыз реализациях и полностью
игнорируется на других. Декларации типов полностью опциональны и
для корректных программ применяются для эффективности, а не для семантики.)
Common Lisp спроектирован для упрощения написания программ,
которые зависят как можно меньше от машинноспецифичных
характеристик, например, таких как длина слова, тогда как
допускают различие в механизмах реализаций.
\par\endgroup

\item[{\it Consistency}]
Most Lisp implementations are internally inconsistent
in that by default the interpreter and compiler may assign different
semantics to correct programs.
This semantic difference stems primarily from the fact
that the interpreter assumes all variables to be dynamically scoped,
whereas the compiler assumes all variables to be local unless explicitly
directed otherwise.  This difference has been the usual practice in Lisp
for the sake of convenience
and efficiency but can lead to very subtle bugs.  The definition of
Common Lisp avoids such anomalies by explicitly requiring the interpreter
and compiler to impose identical semantics on correct programs
so far as possible.

\item[{\it Согласованность}]
Многие реализации Lisp'а несогласованы внутри в том, что по
умолчанию интерпретатор и компилятор могут приписывать различиные
семантики для корректных программ.
Most Lisp implementations are internally inconsistent
in that by default the interpreter and compiler may assign different
semantics to correct programs.
Эти семантические различия преимущественно вытекают из факта, того
что интерпретатор делает все переменные динамическими, тогда как
компилятор делает все переменные лексическими, если не указано
иное. Такое различие было обычной практикой в Lisp'е для
достижения удобства и эффективност, но могло быть причиной скрытых
ошибок. Определение Common Lisp'а исключает такие аномалии явным
требованием к интерпретатору и компилятору реализовывать
идентичные семантики для корректных программ настолько, насколько
это возможно.

\item[{\it Expressiveness}]
Common Lisp culls what
experience has shown to be the most useful and understandable constructs
from not only MacLisp but also
Interlisp, other Lisp dialects, and other programming languages.
Constructs judged to be awkward or less useful have been
excluded.   (An example is the \cd{store} construct of MacLisp.)

\item[{\it Выразительность}]
Common Lisp culls what
experience has shown to be the most useful and understandable constructs
from not only MacLisp but also
Interlisp, other Lisp dialects, and other programming languages.
Constructs judged to be awkward or less useful have been
excluded.   (An example is the \cd{store} construct of MacLisp.)
Common Lisp собрал опыт, который показывает наиболее удобные и
понятные конструкции не только из MacLisp'а, а также из других
диалектов, и языков программирования. Конструкции оцененные как
неуклюжие или бесполезные были исключены. (Например, \cd{store}
конструкция MacLisp'а).

\item[{\it Compatibility}]
Unless there is a good reason to the contrary,
Common Lisp strives to be compatible with Lisp Machine Lisp, MacLisp, and
Interlisp, roughly in that order.

\item[{\it Совместимость}]
Common Lisp старается быть совместимым с Lisp Machine Lisp,
MacLisp и Interlisp, примерно в таком порядке.

\item[{\it Efficiency}]
Common Lisp has a number of features designed to
facilitate the production of high-quality compiled code in those
implementations whose developers
care to invest effort in an optimizing compiler.
One implementation of Common Lisp, namely S-1 Lisp, already has a compiler
that produces code for numerical computations that is competitive
in execution speed to that produced by a Fortran compiler \cite{S1-COMPILER}.
The S-1 Lisp compiler
extends the work done in MacLisp to produce extremely efficient
numerical code \cite{MACLISP-BEATS-FORTRAN}.

\item[{\it Эффективность}]
Common Lisp содержит набор возможностей, созданных для облегчения
производства высококачественного скомпилированного коды в тех
реализациях, разработчики которых заинтересованы в создании
эффективного компилятора. Одна реализация Common Lisp'а называемая
S-1 Lisp, уже содержит компилятор, которые производит код для
численных вычислений, который конкурирует в скорости выполнения
с кодом от компилятора Fortran'а \cite{S1-COMPILER}. S-1 Lisp
компилятор расширяет работу проделанную в MacLisp'е для создания
наиболее эффективных численных вычислений \cite{MACLISP-BEATS-FORTRAN}.

\item[{\it Power}]
Common Lisp is a descendant of MacLisp, which has
traditionally placed emphasis on providing system-building tools.
Such tools may in turn be used to build the user-level packages
such as Interlisp provides; these packages are not, however, part
of the Common Lisp core specification.  It is expected such packages will
be built on top of the Common Lisp core.

\item[{\it Мощность}]
Common Lisp является потомком MacLisp'а, который традиционно делал
акцент на предоставлении системных инструментов. Такие интструменты
могли быть использованы для создания пользовательских
инструментов, какие предоставлял Interlisp; эти пакеты, однако, не
являются частью Common Lisp спецификации. Ожидается, что
такие пакеты будут построены на основе Common Lisp ядра.

\item[{\it Stability}]
It is intended that Common Lisp
will change only slowly and with due deliberation.  The various dialects
that are supersets of Common Lisp may serve as laboratories within which to
test language extensions, but such extensions will be added to
Common Lisp only after careful examination and experimentation.

\item[{\it Стабильность}]
Предполагается, что Common Lisp будет изменяться медленно с
должным обдумыванием. Различные диалекты, которые могут содержать
лаборатории, которые будут проверять расширения для языка, но
такие расширения будут добавляться в Common Lisp с осторожностью.
\end{flushdesc}

\vskip 0pt plus 2pt%manual

The goals of Common Lisp are thus very close to those of Standard Lisp
\cite{STANDARD-LISP-REPORT} and Portable Standard Lisp \cite{PSL-MANUAL}.
Common Lisp differs from Standard Lisp
primarily in incorporating more features, including a
richer and more complicated set of data types and more complex
control structures.

This book is intended to be a language specification
rather than an implementation specification
(although implementation notes are scattered throughout the text).
It defines a set of
standard language concepts and constructs that may be used
for communication of data structures and algorithms in the Common Lisp
dialect.  This set of concepts
and constructs is sometimes referred to as the ``core Common Lisp language''
because it contains conceptually necessary or important features.
It is not necessarily implementationally minimal.
While many features could be defined in terms of others
by writing Lisp code, and indeed may be implemented that way,
it was felt that these features should be conceptually primitive
so that there might be agreement among all users as to their usage.
(For example, bignums and rational numbers could be implemented as
Lisp code given operations on fixnums.  However, it is important
to the conceptual integrity of the language that they be regarded
by the user as primitive, and they are useful enough to warrant
a standard definition.)

For the most part, this book defines a programming language, not a
programming environment.  A few interfaces are defined for
invoking such standard programming tools as a compiler, an editor,
a program trace facility, and a debugger, but very little is said
about their nature or operation.  It is expected that one or more
extensive programming environments will be built using Common Lisp as a
foundation, and will be documented separately.

\begin{newer}
There are now many implementations of Common Lisp,
some programmed by research groups in universities
and some by companies that sell them commercially,
and a number of useful
programming environments have indeed grown up around
these implementations.
What is more, all the goals stated above have been achieved,
most notably that of portability.  Moving large bodies
of Lisp code from one computer to another is now routine.
\end{newer}

\section{Notational Conventions}

A number of special notational conventions are used throughout this book
for the sake of conciseness.

\subsection{Decimal Numbers}

All numbers in this book are in decimal notation unless
there is an explicit indication to the contrary.
(Decimal notation is normally taken for granted, of course.
Unfortunately, for certain other dialects of Lisp, MacLisp in particular,
the default notation for numbers is octal (base 8) rather than decimal,
and so the use of decimal notation for describing Common Lisp is,
taken in its historical context, a bit unusual!)

\subsection{Nil, False, and the Empty List}

In Common Lisp, as in most Lisp dialects, the symbol \cd{nil}
is used to represent both the empty list and the ``false'' value
for Boolean tests.  An empty list may, of course, also be written
\cd{()}; this normally denotes the same object as \cd{nil}.
(It is possible, by extremely perverse manipulation of the package system,
to cause the sequence of letters \cd{nil} to be recognized
not as the symbol that represents the empty list but as another
symbol with the same name.  This obscure possibility will be ignored
in this book.)
These two notations may be used interchangeably as far as the Lisp
system is concerned.  However, as a matter of style,
this book
uses the notation {\empty} when it is desirable to emphasize
the use of an empty list, and uses the notation {\false}
when it is desirable to emphasize the use of the Boolean ``false''.
The notation \cd{'nil} (note the explicit quotation mark) is used to emphasize
the use of a symbol.
For example:
\begin{lisp}
~~~~~~~~~~~~~~~~~~~~~~~~~~~\=\kill
(defun three () 3)\>;{\rm Emphasize empty parameter list} \\
(append '{\empty} '{\empty}) \EV\ {\empty}\>;{\rm Emphasize use of empty lists} \\
(not {\false}) \EV\ {\true}\>;{\rm Emphasize use as Boolean ``false''} \\
(get '{\nil} 'color)\>;{\rm Emphasize use as a symbol}
\end{lisp}

Any data object other than {\false} is construed to be Boolean
``not false'', that is, ``true''.  The symbol {\true} is conventionally
used to mean ``true'' when no other value is more appropriate.
When a function is said to ``return {\it false}'' or to ``be {\it false}''
in some circumstance, this means that it returns {\false}.
However, when a function is said to ``return {\it true}'' or to ``be {\it true}''
in some circumstance, this means that it returns some value other
than {\false}, but not necessarily {\true}.

\subsection{Evaluation, Expansion, and Equivalence}

Execution of code in Lisp is called {\it evaluation} because executing a
piece of code normally results in a data object called the {\it value}
produced by the code.  The symbol \EV\ is used in examples to
indicate evaluation.
For example,
\begin{lisp}
(+ 4 5) \EV\ 9
\end{lisp}
means ``the result of evaluating the code \cd{(+ 4 5)} is (or would be,
or would have been) \cd{9}.'' 

The symbol \EX\ is used in examples to indicate macro expansion.
For example,
\begin{lisp}
(push x v) \EX\ (setf v (cons x v))
\end{lisp}
means ``the result of expanding the macro-call form \cd{(push x v)}
is \cd{(setf v (cons x v))}.''  This implies that the two pieces
of code do the same thing; the second piece of code is
the definition of what the first does.

The symbol \EQ\ is used in examples to indicate code equivalence.
For example,
\begin{lisp}
(gcd x (gcd y z)) \EQ\ (gcd (gcd x y) z)
\end{lisp}
means ``the value and effects of evaluating the form
\cd{(gcd x (gcd y z))} are always the same as the value
and effects of
\cd{(gcd (gcd x y) z)} for any values of the
variables \cd{x}, \cd{y}, and \cd{z}.''
This implies that the two pieces
of code do the same thing; however, neither directly defines
the other in the way macro expansion does.

\subsection{Errors}
\label{INTRO-ERRORS}

When this book specifies that it ``is an error'' for some situation
to occur, this means that:
\begin{itemize}
\item No valid Common Lisp program should cause this situation to occur.

\item If this situation occurs, the effects and results are completely
undefined as far as adherence to the Common Lisp specification is concerned.

\item No Common Lisp implementation is required to detect such an error.
Of course, implementors are encouraged to provide for detection
of such errors wherever reasonable.
\end{itemize}
This is not to say that some particular implementation might not define
the effects and results for such a situation; the point is that no program
conforming to the Common Lisp specification may correctly depend on such
effects or results.

On the other hand, if it is specified in this book that in some situation
``an error is {\it signaled},'' this means that:
\begin{itemize}
\item If this situation occurs, an error will be signaled
(see \cd{error} and \cd{cerror}).

\item Valid Common Lisp programs may rely on the fact that an error will be signaled.

\item Every Common Lisp implementation is required to detect such an error.
\end{itemize}

In places where it is stated that so-and-so ``must'' or ``must not''
or ``may not''  be the case, then it ``is an error'' if the stated requirement
is not met.  For example, if an argument ``must be a symbol,'' then it
``is an error'' if the argument is not a symbol.  In all cases where
an error is to be {\it signaled}, the word ``signaled'' is always used
explicitly in this book.

\begin{newer}
X3J13 has adopted a more elaborate terminology for errors,
and has made some effort to specify the type of error to be signaled
in situations where signaling is appropriate.  This effort
was not complete as of September 1989, and I have made little
attempt to incorporate the new error terminology or
error type specifications in this book.  However, the new terminology
is described and used in the specification of the
Common Lisp Object System appearing in chapter~\ref{CLOS}; this gives
the flavor of how erroneous situations will be described,
and appropriate actions prescribed, in the forthcoming ANSI Common
Lisp standard.
\end{newer}

\begin{table}[t]
\caption{Sample Function Description}
\label{Sample-Function-Description}
\begingroup\normalsize
\begin{defun}*[Function]
sample-function arg1 arg2 &optional arg3 arg4

The function \cd{sample-function} adds together {\it arg1} and {\it arg2}, and
then multiplies the result by {\it arg3}.  If {\it arg3} is not provided or
is {\nil}, the multiplication isn't done.  \cd{sample-function} then returns
a list whose first element is this result and whose second element is
{\it arg4} (which defaults to the symbol \cd{foo}).
For example:
\begin{lisp}
(sample-function 3 4) \EV\ (7 foo) \\
(sample-function 1 2 2 'bar) \EV\ (6 bar)
\end{lisp}
In general,
\cd{(sample-function {\it x} {\it y})} \EQ\ \cd{(list (+ {\it x} {\it y}) 'foo)}.
\end{defun}
\endgroup
\vskip\ruletonoteskip
\hrule
\vskip\ruletonoteskip\null
\caption{Sample Variable Description}
\label{Sample-Variable-Description}
\begingroup\normalsize
\begin{defun}*[Variable]
*sample-variable*

The variable \cd{*sample-variable*} specifies how many times
the special form \cd{sample-special-form} should iterate.
The value should always be a non-negative integer or {\nil}
(which means iterate indefinitely many times).  The initial value is \cd{0}
(meaning no iterations).
\end{defun}
\endgroup
\vskip\ruletonoteskip
\hrule
\vskip\ruletonoteskip\null
\caption{Sample Constant Description}
\label{Sample-Constant-Description}
\begingroup\normalsize
\begin{defun}*[Constant]
sample-constant

The named constant \cd{sample-constant} has as its value
the height of the terminal screen in furlongs times
the base-2 logarithm of the implementation's total disk capacity in bytes,
as a floating-point number.
\end{defun}
\endgroup
\end{table}

\begin{table}[t]
\caption{Sample Special Form Description}
\label{Sample-Special-Form-Description}
\begingroup\normalsize
\begin{defspec}*
sample-special-form [name] ({var}*) {\,form}+

This evaluates each form in sequence as an implicit \cd{progn}, and does this
as many times as specified by
the global variable \cd{*sample-variable*}.  Each variable {\it var} is bound
and initialized to \cd{43} before the first iteration, and unbound after
the last iteration.
The name {\it name}, if supplied, may be used in a \cd{return-from} form
to exit from the loop prematurely.  If the loop ends normally,
\cd{sample-special-form} returns {\nil}.
For example:
\begin{lisp}
(setq *sample-variable* 3) \\
(sample-special-form {\empty} {\it form1} {\it form2})
\end{lisp}
This evaluates {\it form1}, {\it form2}, {\it form1}, {\it form2}, {\it form1}, {\it form2}
in that order.
\end{defspec}
\endgroup
\vskip\ruletonoteskip
\hrule
\vskip\ruletonoteskip\null
\caption{Sample Macro Description}
\label{Sample-Macro-Description}
\begingroup\normalsize
\begin{defmac}*
sample-macro var <declaration* | doc-string> {tag | statement}*

This evaluates the statements as a \cd{prog} body,
with the variable {\it var} bound to \cd{43}.
\begin{lisp}
(sample-macro x (return (+ x x))) \EV\ 86 \\
(sample-macro {\it var} . {\it body}) \EX\ (prog (({\it var} 43)) . {\it body})
\end{lisp}
\end{defmac}
\endgroup
\end{table}

\subsection{Descriptions of Functions and Other Entities}
\label{FUNCTION-HEADER-NOTATION-SECTION}

Functions, variables, named constants, special forms, and macros are described
using a distinctive typographical format.
Table~\ref{Sample-Function-Description} illustrates the manner
in which Common Lisp functions are documented.
The first line specifies the name of the function,
the manner in which it accepts arguments,
and the fact that it is a function.
If the function takes many arguments, then the names of the arguments
may spill across two or three lines.
The paragraphs following this standard header
explain the definition and uses of the function and often
present examples or related functions.

Sometimes two or more related functions are explained in a single
combined description.  In this situation the headers for all the
functions appear together, followed by the combined description.

In general, actual code (including actual names of functions)
appears in this typeface: \cd{(cons a b)}.
Names that stand for pieces of code (metavariables) are written in
{\it italics}.  In a function description, the names of the parameters appear
in italics for expository purposes.  The word \cd{\&optional} in the
list of parameters indicates that all arguments past that point are
optional; the default values for the parameters are described in the
text.  Parameter lists may also contain \cd{\&rest}, indicating that an
indefinite number of arguments may appear, or \cd{\&key}, indicating
that keyword arguments are accepted.
(The \cd{\&optional}/\cd{\&rest}/\cd{\&key}
syntax is actually used in Common Lisp function definitions for these purposes.)

Table~\ref{Sample-Variable-Description} illustrates the manner in
which a global variable is documented.  The first line specifies the
name of the variable and the fact that it is a variable.
Purely as a matter of convention, all global variables used
by Common Lisp have names beginning and ending with an asterisk.

Table~\ref{Sample-Constant-Description} illustrates the manner in
which a named constant is documented.  The first line specifies the
name of the constant and the fact that it is a constant.
(A constant is just like a global variable, except that it is
an error ever to alter its value or to bind it to a new value.)

Tables~\ref{Sample-Special-Form-Description}
and~\ref{Sample-Macro-Description} illustrate the documentation
of special forms and macros, which are closely related in purpose.
These are very different from functions.
Functions are called according to a single, specific, consistent syntax;
the \cd{\&optional}/\cd{\&rest}/\cd{\&key} syntax specifies how the function uses its arguments
internally but does not affect the syntax of a call.
In contrast, each special form or macro can have its own idiosyncratic syntax.
It is by special forms and macros that the syntax of Common Lisp is defined
and extended.

In the description of a special form or macro, an italicized word names a
corresponding part of the form that invokes the special form or macro.
Parentheses stand for themselves and should be
written as such when invoking the special form or macro.
Brackets, braces, stars, plus signs, and vertical bars are metasyntactic
marks.
Brackets,
$\lbrack$ and $\rbrack$, indicate that what they enclose is optional
(may appear zero times or one time in that place); the square
brackets should not be written in code.
Braces, $\lbrace$ and $\rbrace$, simply parenthesize what they enclose
but may be followed by a star, ${}^*$, or a plus sign, ${}^+$;
a star indicates that what the braces enclose may appear any number of times
(including zero, that is, not at all), whereas a plus sign indicates
that what the braces enclose may appear any non-zero number of times
(that is, must appear at least once).  Within braces or brackets,
a vertical bar, $|$, separates mutually exclusive choices.
In summary, the notation \Mstar{\it x} means zero or more occurrences
of {\it x}, the notation \Mplus{\it x} means one or more occurrences
of {\it x}, and the notation \Mopt{\it x} means zero or one occurrence
of {\it x}.  These notations are also used for syntactic
descriptions expressed as BNF-like productions, as
in table~\ref{NUMBER-SYNTAX-TABLE}.

\begin{newer}
Double brackets, $\dlbrack$ and $\drbrack$, indicate that any number of the
alternatives enclosed may be used, and those used
may occur in any order, but each
alternative may be used at most once unless followed by a star.
For example,
\begin{tabbing}
{\it p} \Mchoice{x {\Mor} \Mstar{y} {\Mor} z} {\it q}
\end{tabbing}
means that
at most one {\it x}, any number of {\it y}'s, and at most one {\it z}
may appear between the mandatory occurrences of {\it p}
and {\it q}, and those that appear may be in any order.

A downward arrow, \Mind{}, indicates a form of syntactic indirection
that helps to make \Mchoice{~} notation more readable.  If {\it X} is
some non-terminal symbol occurring on the left-hand side of some BNF
production, then the right-hand
side of that production is to be textually substituted for any occurrence
of \Mind{X}.  Thus the two fragments
\begin{tabbing}
{\it p} \Mchoice{\Mind{xyz-mixture}} {\it q} \\
{\it xyz-mixture} ::= {\it x\/} {\Mor} \Mstar{y} {\Mor} {\it z\/}
\end{tabbing}
are together equivalent to the previous example.
\end{newer}

In the last example in table~\ref{Sample-Macro-Description}, notice the
use of dot notation.  The dot appearing in the expression
\cd{(sample-macro {\it var} . {\it body})} means that the name {\it body} stands
for a list of forms, not just a single form, at the end of a list.  This
notation is often used in examples.

\begin{newer}
In the heading line in table~\ref{Sample-Macro-Description}, notice the
use of \Mchoice{~} notation to indicate that any number of declarations
may appear but at most one documentation string (which may appear before,
after, or somewhere in the middle of any declarations).
\end{newer}


\subsection{The Lisp Reader}

The term ``Lisp reader'' refers not to you, the reader of this book,
nor to some person reading Lisp code, but specifically
to a Lisp procedure, namely the function \cd{read},
which reads characters from an input stream and interprets them by parsing
as representations of Lisp objects.

\subsection{Overview of Syntax}

Certain characters are used in special ways in the syntax of Common Lisp.
The complete syntax is explained in detail in chapter~\ref{IO},
but a quick summary here may be useful:
\begin{indentdesc}{1.2pc}
\item[\cd{(}]
A left parenthesis begins a list of items.  The list may
contain any number of items, including zero.  Lists may be nested.
For example, \cd{(cons (car x) (cdr y))} is a list of three things,
of which the last two are themselves lists.

\item[\cd{)}] A right parenthesis ends a list of items.

\item[\cd{\Xquote}] An acute accent (also called single
quote or apostrophe) followed by an expression {\it form}
is an abbreviation for \cd{(quote {\it form})}.  Thus \cd{'foo} means
\cd{(quote foo)} and \cd{'(cons 'a 'b)} means \cd{(quote (cons (quote a) (quote b)))}.

\item[\cd{;}] Semicolon is the comment character.  It and all
characters up to the end of the line are discarded.

\item[\cd{"}] Double quotes surround character strings: \\
\cd{"This is a thirty-nine-character string."}

\item[\cd{{\Xbackslash}}] Backslash is an escape character. 
It causes the next character to be treated as a letter rather than for its usual
syntactic purpose.  For example, \cd{A{\Xbackslash}(B} denotes a symbol whose
name consists of the three characters \cd{A}, \cd{(}, and \cd{B}. Similarly,
\cd{"{\Xbackslash}""} denotes a character string containing one character, a
double quote, because the first and third double quotes serve to delimit the
string, and the second double quote serves as the contents of the string.  The
backslash causes the second double quote to be taken literally and prevents it
from being interpreted as the terminating delimiter of the string.

\item[\cd{|}] Vertical bars are used in pairs
to surround the name (or part of the name) of a symbol that has
many special characters in it.  It is roughly equivalent to putting a
backslash in front of every character so surrounded.  For example,
\cd{|A(B)|}, \cd{A|(|B|)|}, and \cd{A{\Xbackslash}(B{\Xbackslash})} all mean the symbol whose name
consists of the four characters \cd{A}, \cd{(}, \cd{B}, and \cd{)}.

\item[\cd{\#}] The number sign signals the beginning of a
complicated syntactic structure.
The next character designates the precise syntax to follow.
For example, \cd{\#o105} means $105_{8}$ (105 in octal notation);
\cd{\#x105} means $105_{16}$ (105 in hexadecimal notation);
\cd{\#b1011} means $1011_{2}$ (1011 in binary notation);
\cd{\#{\Xbackslash}L} denotes a character object for the character \cd{L}; and
\cd{\#(a b c)} denotes a vector of three elements \cd{a}, \cd{b}, and \cd{c}.
A particularly important case is that \cd{\#'{\it fn}} means \cd{(function {\it fn})},
in a manner analogous to \cd{'{\it form}} meaning \cd{(quote {\it form})}.

\item[\cd{{\Xbq}}] Grave accent (``backquote'') signals that
the next expression is a template that may contain commas.  The backquote syntax
represents a program that will construct a data structure
according to the template.

\item[\cd{,}] Commas are used within the backquote syntax.

\item[\cd{:}] Colon is used to indicate which package a
symbol belongs to. For example, \cd{network:reset} denotes the symbol named
\cd{reset} in the package named \cd{network}.  A leading colon indicates a {\it
keyword}, a symbol that always evaluates to itself.
The colon character is not actually part of the print name
of the symbol.
This is all explained in chapter~\ref{XPACK}; until you read
that, just keep in mind that a symbol notated with a leading colon
is in effect a constant that evaluates to itself.
\end{indentdesc}

\vskip 0pt plus 2pt%manual

\begin{new}%CORR
{\it Notice of correction.}
In the first edition, the characters ``\cd{,}'' and ``\cd{:}'' at the
left margin above were inadvertently omitted.
\end{new}

Brackets, braces, question mark, and exclamation point
(that is, \cd{{\Xlbracket}}, \cd{{\Xrbracket}}, \cd{{\Xlbrace}}, \cd{{\Xrbrace}},
\cd{?}, and \cd{!}) are not used for any purpose in standard Common Lisp syntax.
These characters are explicitly reserved to the user, primarily
for use as {\it macro characters} for user-defined lexical syntax extensions
(see section~\ref{MACRO-CHARACTERS-SECTION}).

\begin{obsolete}
All code in this book is written using lowercase letters.
Common Lisp is generally insensitive to the case in which code
is written.  Internally, names of symbols are ordinarily
converted to and stored in uppercase form.
There are ways to force case conversion on output if desired;
see \cd{*print-case*}.
In this book, wherever an interactive exchange between a user
and the Lisp system is shown, the input is exhibited with lowercase
letters and the output with uppercase letters.
\end{obsolete}

\begin{newer}
X3J13 voted in June 1989 \issue{READ-CASE-SENSITIVITY} to introduce
\cd{readtable-case}.  Certain settings allow the names of symbols
to be case-sensitive.  The default behavior, however, is as described
in the previous paragraph.  In any event, only uppercase letters
appear in the internal print names of symbols naming the
standard Common Lisp facilities described in this book.
\end{newer}
