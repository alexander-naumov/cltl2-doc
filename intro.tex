%Part{Intro, Root = "CLM.MSS"}
% Chapter of Common Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.


\addtocontents{toc}{Preface (Second Edition)\hskip 1em\relax xi\vskip4pt}
\addtocontents{toc}{Acknowledgments (Second Edition)\hskip 1em\relax xiii\vskip4pt}
\addtocontents{toc}{Acknowledgments (First Edition)\hskip 1em\relax xvii\vskip4pt}

\clearpage\def\pagestatus{FINAL PROOF}
\chapter{Introduction Вступление}

Common Lisp is a new dialect of Lisp, a
successor to MacLisp \cite{MOONUAL,PITMANUAL}, influenced strongly by
Zetalisp \cite{BLUE-LISPM,GREEN-LISPM} and to some extent by Scheme
\cite{SCHEME-REVISED-REPORT} and Interlisp \cite{INTERLISP}.

Common Lisp это новый диалект Lisp'а, наследник
MacLisp'а \cite{MOONUAL,PITMANUAL}, под влиянием
ZetaLisp \cite{BLUE-LISPM,GREEN-LISPM} и в некоторой мере
Schem'ой \cite{SCHEME-REVISED-REPORT} и Interlisp'ом \cite{INTERLISP}.

\section{Purpose Цель}

Common Lisp is intended to meet these goals:

Common Lisp предназначен для достижения следующих целей: 

\begin{flushdesc}
\item[\textit{Commonality}]
Common Lisp originated in an attempt to focus the
work of several implementation groups, each of which was constructing successor
implementations of MacLisp for different computers.  These
implementations had begun to diverge because of the differences in the
implementation environments: microcoded personal computers (Zetalisp,
Spice Lisp), commercial timeshared computers (NIL---the ``New Implementation of
Lisp''), and supercomputers (S-1 Lisp).  While the differences among the several
implementation environments of necessity will continue to force
certain incompatibilities among the
implementations, Common Lisp serves as a common dialect to
which each implementation makes any necessary extensions.

\item[\textit{Объединение}]
Common Lisp создан в попытке сфокусировать работу несколько групп
разработчиков, каждая из которых создавала потомка MacLisp для
различных компьютеров. Это реализации начинали разниться по
причине различий в платформах: персональные компьютеры (Zetalisp,
Spice Lisp), коммерческие компьютеры с разделяемым временем
(NIL--- <<Новая реализация Lisp'а>>) и суперкомпьютеры (S-1
Lisp). Тогда как различия платформ будут порождать несовместимости
между реализациями, Common Lisp предоставляет общий диалект,
который каждая реализация будет расширять для своих потребностей.

\item[\textit{Portability}]

\begingroup\looseness=1
Common Lisp intentionally excludes features
that cannot be implemented easily on a broad class of machines.
On the one hand, features that are difficult or expensive
to implement on hardware without special microcode are avoided
or provided in a more abstract and efficiently implementable form.
(Examples of this are the invisible forwarding pointers
and locatives of Zetalisp.  Some of the problems that they solve
are addressed in different ways in Common Lisp.)
On the other hand, features that are useful only on certain ``ordinary''
or ``commercial'' processors are avoided or made optional.  (An example of
this is the type declaration facility, which is useful in some
implementations and completely ignored in others.  Type declarations are
completely optional and for correct programs
affect only efficiency, not semantics.)
Common Lisp is designed to make it easy to write programs
that depend as little as possible on machine-specific
characteristics, such as word length, while allowing some variety of
implementation \hbox{techniques}.
\par\endgroup

\item[\textit{Переносимость}]

\begingroup\looseness=1
Common Lisp умышленно исключает возможности, которые не могут быть
реализованы простым способом на широком классе машин. С одной
стороны, возможности которые сложны или дороги в реализации на
аппаратной части без специальных микрокодов исключаются или
представляются в более абстрактной и реализуемой форме.
(Examples of this are the invisible forwarding pointers
and locatives of Zetalisp.  Some of the problems that they solve
are addressed in different ways in Common Lisp.)
С другой стороны, возможности, которые полезны только на
<<обычных>> или <<коммерческих>> процессорах исключаются или
делаются опциональными. (Примером тому является функция декларации
типы, которая полеза на некоторыз реализациях и полностью
игнорируется на других. Декларации типов полностью опциональны и
для корректных программ применяются для эффективности, а не для семантики.)
Common Lisp спроектирован для упрощения написания программ,
которые зависят как можно меньше от машинноспецифичных
характеристик, например, таких как длина слова, тогда как
допускают различие в механизмах реализаций.
\par\endgroup

\item[\textit{Consistency}]
Most Lisp implementations are internally inconsistent
in that by default the interpreter and compiler may assign different
semantics to correct programs.
This semantic difference stems primarily from the fact
that the interpreter assumes all variables to be dynamically scoped,
whereas the compiler assumes all variables to be local unless explicitly
directed otherwise.  This difference has been the usual practice in Lisp
for the sake of convenience
and efficiency but can lead to very subtle bugs.  The definition of
Common Lisp avoids such anomalies by explicitly requiring the interpreter
and compiler to impose identical semantics on correct programs
so far as possible.

\item[\textit{Согласованность}]
Многие реализации Lisp'а несогласованы внутри в том, что по
умолчанию интерпретатор и компилятор могут приписывать различиные
семантики для корректных программ.
Most Lisp implementations are internally inconsistent
in that by default the interpreter and compiler may assign different
semantics to correct programs.
Эти семантические различия преимущественно вытекают из факта, того
что интерпретатор делает все переменные динамическими, тогда как
компилятор делает все переменные лексическими, если не указано
иное. Такое различие было обычной практикой в Lisp'е для
достижения удобства и эффективност, но могло быть причиной скрытых
ошибок. Определение Common Lisp'а исключает такие аномалии явным
требованием к интерпретатору и компилятору реализовывать
идентичные семантики для корректных программ настолько, насколько
это возможно.

\item[\textit{Expressiveness}]
Common Lisp culls what
experience has shown to be the most useful and understandable constructs
from not only MacLisp but also
Interlisp, other Lisp dialects, and other programming languages.
Constructs judged to be awkward or less useful have been
excluded.   (An example is the \cdf{store} construct of MacLisp.)

\item[\textit{Выразительность}]
Common Lisp culls what
experience has shown to be the most useful and understandable constructs
from not only MacLisp but also
Interlisp, other Lisp dialects, and other programming languages.
Constructs judged to be awkward or less useful have been
excluded.   (An example is the \cdf{store} construct of MacLisp.)
Common Lisp собрал опыт, который показывает наиболее удобные и
понятные конструкции не только из MacLisp'а, а также из других
диалектов, и языков программирования. Конструкции оцененные как
неуклюжие или бесполезные были исключены. (Например, \cdf{store}
конструкция MacLisp'а).

\item[\textit{Compatibility}]
Unless there is a good reason to the contrary,
Common Lisp strives to be compatible with Lisp Machine Lisp, MacLisp, and
Interlisp, roughly in that order.

\item[\textit{Совместимость}]
Common Lisp старается быть совместимым с Lisp Machine Lisp,
MacLisp и Interlisp, примерно в таком порядке.

\item[\textit{Efficiency}]
Common Lisp has a number of features designed to
facilitate the production of high-quality compiled code in those
implementations whose developers
care to invest effort in an optimizing compiler.
One implementation of Common Lisp, namely S-1 Lisp, already has a compiler
that produces code for numerical computations that is competitive
in execution speed to that produced by a Fortran compiler \cite{S1-COMPILER}.
The S-1 Lisp compiler
extends the work done in MacLisp to produce extremely efficient
numerical code \cite{MACLISP-BEATS-FORTRAN}.

\item[\textit{Эффективность}]
Common Lisp содержит набор возможностей, созданных для облегчения
производства высококачественного скомпилированного коды в тех
реализациях, разработчики которых заинтересованы в создании
эффективного компилятора. Одна реализация Common Lisp'а называемая
S-1 Lisp, уже содержит компилятор, которые производит код для
численных вычислений, который конкурирует в скорости выполнения
с кодом от компилятора Fortran'а \cite{S1-COMPILER}. S-1 Lisp
компилятор расширяет работу проделанную в MacLisp'е для создания
наиболее эффективных численных вычислений \cite{MACLISP-BEATS-FORTRAN}.

\item[\textit{Power}]
Common Lisp is a descendant of MacLisp, which has
traditionally placed emphasis on providing system-building tools.
Such tools may in turn be used to build the user-level packages
such as Interlisp provides; these packages are not, however, part
of the Common Lisp core specification.  It is expected such packages will
be built on top of the Common Lisp core.

\item[\textit{Мощность}]
Common Lisp является потомком MacLisp'а, который традиционно делал
акцент на предоставлении системных инструментов. Такие интструменты
могли быть использованы для создания пользовательских
инструментов, какие предоставлял Interlisp; эти пакеты, однако, не
являются частью Common Lisp спецификации. Ожидается, что
такие пакеты будут построены на основе Common Lisp ядра.

\item[\textit{Stability}]
It is intended that Common Lisp
will change only slowly and with due deliberation.  The various dialects
that are supersets of Common Lisp may serve as laboratories within which to
test language extensions, but such extensions will be added to
Common Lisp only after careful examination and experimentation.

\item[\textit{Стабильность}]
Предполагается, что Common Lisp будет изменяться медленно с
должным обдумыванием. Различные диалекты, которые могут содержать
лаборатории, которые будут проверять расширения для языка, но
такие расширения будут добавляться в Common Lisp с осторожностью.
\end{flushdesc}

\vskip 0pt plus 2pt%manual

The goals of Common Lisp are thus very close to those of Standard Lisp
\cite{STANDARD-LISP-REPORT} and Portable Standard Lisp \cite{PSL-MANUAL}.
Common Lisp differs from Standard Lisp
primarily in incorporating more features, including a
richer and more complicated set of data types and more complex
control structures.

В целях Common Lisp'а быть близким к Standard Lisp'у \cite{STANDARD-LISP-REPORT}
и Portable Standard Lisp'у \cite{PSL-MANUAL}. Common Lisp отличается от Standard
Lisp'а преимущественно тем, что содержит больше возможностей, включая более
богатую и более сложную систему типов и более сложные управляющие конструкции. 

This book is intended to be a language specification
rather than an implementation specification
(although implementation notes are scattered throughout the text).
It defines a set of
standard language concepts and constructs that may be used
for communication of data structures and algorithms in the Common Lisp
dialect.  This set of concepts
and constructs is sometimes referred to as the ``core Common Lisp language''
because it contains conceptually necessary or important features.
It is not necessarily implementationally minimal.
While many features could be defined in terms of others
by writing Lisp code, and indeed may be implemented that way,
it was felt that these features should be conceptually primitive
so that there might be agreement among all users as to their usage.
(For example, bignums and rational numbers could be implemented as
Lisp code given operations on fixnums.  However, it is important
to the conceptual integrity of the language that they be regarded
by the user as primitive, and they are useful enough to warrant
a standard definition.)

Эта книга преимущественно презназначена быть спецификацией языка, а не
реализации (однако, примечания для реализаций встречаются в тексте).
Книга определяет множества стандартных языковых концепций и конструкций, которые
могут использоваться для связи данных и алгоритмов в диалекте Common Lisp. Это
множество концепций и конструкций иногда называется <<ядро языка Common
Lisp>>, потому что они содержит концептуально необходимые или важные вещи. Но
это не является необходимым концептуальным минимумом. Так как многие возможности
могут быть определены с помощью других написанием Lisp кода, и фактически могут
так и быть реализованы. Поэтому такие возможности не обязательно должны быть
концептуальными примитивами. Они являются соглашением всех пользователей в том,
как ими пользоваться. (Например, bignums и рациональные числа могут быть
реализованы, как Lisp код, оперирующий fixnum. Тем не менее, важно для
концептуальной целостности языка то, что они используются пользователями как
примитивы, и они достаточны для основания стандарта.) FIXME


For the most part, this book defines a programming language, not a
programming environment.  A few interfaces are defined for
invoking such standard programming tools as a compiler, an editor,
a program trace facility, and a debugger, but very little is said
about their nature or operation.  It is expected that one or more
extensive programming environments will be built using Common Lisp as a
foundation, and will be documented separately.

По большей части, данная книга описывает язык программирования, но не средства
программирования. Несколько интерфейсов определены для обращения к таким
стандартным программным средствам, как компилятор, редактор, функции
трассировки, и отладчик, но очень мало сказано об их
функционировании. Ожидается, что одна или более обширных сред программирования
будут построены, используя Common Lisp, в качестве основы, и они будут отдельно
документированы. 

\begin{newer}
There are now many implementations of Common Lisp,
some programmed by research groups in universities
and some by companies that sell them commercially,
and a number of useful
programming environments have indeed grown up around
these implementations.
What is more, all the goals stated above have been achieved,
most notably that of portability.  Moving large bodies
of Lisp code from one computer to another is now routine.
\end{newer}

\section{Notational Conventions Условные обозначения}

A number of special notational conventions are used throughout this book
for the sake of conciseness.

В книге используется некоторое количество условных обозначений для выразительности. 

\subsection{Decimal Numbers Десятичные числа}

All numbers in this book are in decimal notation unless
there is an explicit indication to the contrary.
(Decimal notation is normally taken for granted, of course.
Unfortunately, for certain other dialects of Lisp, MacLisp in particular,
the default notation for numbers is octal (base 8) rather than decimal,
and so the use of decimal notation for describing Common Lisp is,
taken in its historical context, a bit unusual!)

Все числа в данной книге представлены в десятичной системе счисления, кроме мест,
где система счисления указывается явно. 
(Конечно, десятичная система обычно и используется.
К несчастью, в некоторых других диалектах Lisp'а, в частности MacLisp'а,
нотацией по умолчанию является восьмеричная (основание 8), вместо десятичной, и
использование десятичной системы в описании Common Lisp'а в историческом
контексте слегка необычно!) 

\subsection{Nil, False, and the Empty List Nil, False и пустой список}

In Common Lisp, as in most Lisp dialects, the symbol \cdf{nil}
 is used to represent both the empty list and the ``false'' value
for Boolean tests.  An empty list may, of course, also be written
\cd{()}; this normally denotes the same object as \cdf{nil}.
(It is possible, by extremely perverse manipulation of the package system,
to cause the sequence of letters \cdf{nil} to be recognized
not as the symbol that represents the empty list but as another
symbol with the same name.  This obscure possibility will be ignored
in this book.)
These two notations may be used interchangeably as far as the Lisp
system is concerned.  However, as a matter of style,
this book
uses the notation {\emptylist} when it is desirable to emphasize
the use of an empty list, and uses the notation {\false}
when it is desirable to emphasize the use of the Boolean ``false''.
The notation \cd{'nil} (note the explicit quotation mark) is used to emphasize
the use of a symbol.
For example:

В Common Lisp'е, как и во многих диалектах Lisp'а, символ \cdf{nil} используется
для представления пустого списка и булева значения <<false>>. Пустой список,
конечно, может, также быть записан так: \cd{()}; это обычно означает то же, что
и \cdf{nil}.
(Конечно существует возможность крайне извращенным способом в пакете
переопределить значение последовательности букв \cdf{nil}, которое будет 
обозначать не пустой список, а другой символ с этим именем. Эта мутная
возможность игнорируется в данной книге.)
Эти две записи могут использоваться взаимозаменяемо настолько, насколько
позволяет Lisp. В данной книге используется значение {\emptylist}, когда необходимо
подчеркнуть использование пустого списка, и {\false}, когда обозначается булево
значение <<false>>. Запись \cd{'nil} (явный знак кавычки) используется для
обозначения символа.
Например:

\begin{lisp}
~~~~~~~~~~~~~~~~~~~~~~~~~~~\=\kill
(defun three () 3)\>;{\rm Emphasize empty parameter list} \\
(append '{\emptylist} '{\emptylist}) \EV\ {\emptylist}\>;{\rm Emphasize use of empty lists} \\
(not {\false}) \EV\ {\true}\>;{\rm Emphasize use as Boolean ``false''} \\
(get '{\nil} 'color)\>;{\rm Emphasize use as a symbol}
\end{lisp}

\begin{lisp}
~~~~~~~~~~~~~~~~~~~~~~~~~~~\=\kill
(defun three () 3)\>;{\rm Обозначает пустой список в параметре} \\
(append '{\emptylist} '{\emptylist}) \EV\ {\emptylist}\>;{\rm Обозначает использование
пустых списков} \\
(not {\false}) \EV\ {\true}\>;{\rm Подчеркивает использование булева значения ``false''} \\
(get '{\nil} 'color)\>;{\rm Подчеркивает использование символа}
\end{lisp}

Any data object other than {\false} is construed to be Boolean
``not false'', that is, ``true''.  The symbol {\true} is conventionally
used to mean ``true'' when no other value is more appropriate.
When a function is said to ``return \textit{false}'' or to ``be \textit{false}''
in some circumstance, this means that it returns {\false}.
However, when a function is said to ``return \textit{true}'' or to ``be \textit{true}''
in some circumstance, this means that it returns some value other
than {\false}, but not necessarily {\true}.

Любой объект данных, не являющийся {\false} преобразуется в булево значение
<<not false>>, что является <<true>>. Символ {\true} обычно используется для
обозначения <<true>>, когда нет более подходящего значения.
Когда говорится, что функция <<возвращает \textit{false}>> или <<есть \textit{false}>>
в некоторых случаях, это значит, что она возвращает {\false}.
Тогда как, если говорится, что функция <<возвращает \textit{true}>> или <<есть {\it
true}>> в некоторых случаях, это значит, что она возвращает некоторое
значения отличное от {\false}, но необязательно {\true}.

\subsection{Evaluation, Expansion, and Equivalence Вычисление, Раскрытие и Равенство}

Execution of code in Lisp is called \textit{evaluation} because executing a
piece of code normally results in a data object called the \textit{value}
produced by the code.  The symbol \EV\ is used in examples to
indicate evaluation.
For example,

Выполнение Lisp кода называется \textit{вычисление} так как выполнение части кода
обычно возвращает некоторый объект данных, называемые \textit{значение} созданное
кодом. Символ \EV\ используется в примерах для обозначения вычисления.
Например,
\begin{lisp}
(+ 4 5) \EV\ 9
\end{lisp}
means ``the result of evaluating the code \cd{(+ 4 5)} is (or would be,
or would have been) \cd{9}.'' 

означает <<результат вычисления кода \cd{(+ 4 5)} является (или будет, или был) \cd{9}>>.

The symbol \EX\ is used in examples to indicate macro expansion.
For example,

Символ \EX\ используется в примерах для обозначения раскрытия макросов.
Например,
\begin{lisp}
(push x v) \EX\ (setf v (cons x v))
\end{lisp}
means ``the result of expanding the macro-call form \cd{(push x v)}
is \cd{(setf v (cons x v))}.''  This implies that the two pieces
of code do the same thing; the second piece of code is
the definition of what the first does.

означает <<результат раскрытия формы с макросом \cd{(push x v)}
является \cd{(setf v (cons x v))}>>. Это подразумевает, что две части кода
делают одно и то же действие; вторая часть кода является определением того, что
делает первая часть.

The symbol \EQ\ is used in examples to indicate code equivalence.
For example,

Символ \EQ\ используется в примерах для обозначения эквивалентности
(тождественности).
Например,
\begin{lisp}
(gcd x (gcd y z)) \EQ\ (gcd (gcd x y) z)
\end{lisp}
means ``the value and effects of evaluating the form
\cd{(gcd x (gcd y z))} are always the same as the value
and effects of
\cd{(gcd (gcd x y) z)} for any values of the
variables \cdf{x}, \cdf{y}, and \cdf{z}.''
This implies that the two pieces
of code do the same thing; however, neither directly defines
the other in the way macro expansion does.

означает <<значение и побочные эффекты вычисления формы \cd{(gcd x (gcd y z))} всегда
являются тем же, что и значение и побочные эффекты \cd{(gcd (gcd x y) z)} для любых
значений переменных \cdf{x}, \cdf{y} и \cdf{z}>>.
Это подразумевает, что две части кода делают одинаковую вещи; однако ни одна не
определяет другую путем раскрытия макросов.

\subsection{Errors Ошибки}
\label{INTRO-ERRORS}

When this book specifies that it ``is an error'' for some situation
to occur, this means that:

Когда в книге для некоторых возникающих ситуаций указывается, что <<это
ошибка>>, это значит: 
\begin{itemize}
\item No valid Common Lisp program should cause this situation to occur.

\item Некорректная Common Lisp программа должна вызывать данную ситуацию.

\item If this situation occurs, the effects and results are completely
undefined as far as adherence to the Common Lisp specification is concerned.

\item Если данная ситуация случилась, побочные эффекты и результаты полностью не
определены так же, как и строгое соблюдение спецификации Common Lisp. FIXME

\item No Common Lisp implementation is required to detect such an error.
Of course, implementors are encouraged to provide for detection
of such errors wherever reasonable.

\item Нет требования для реализации Common Lisp'а для определения этой
ошибки. Конечно, разработчики поощряются за предоставление детектирования таких
ошибок, когда это имеет место.
\end{itemize}
This is not to say that some particular implementation might not define
the effects and results for such a situation; the point is that no program
conforming to the Common Lisp specification may correctly depend on such
effects or results.

Это не говорит о том, что некоторые реализации не могут определять
побочные эффекты и результаты для данных ситуаций; смысл в том, что программа для
Common Lisp'а не может быть корректной и зависеть от таких побочных эффектов и результатов.

On the other hand, if it is specified in this book that in some situation
``an error is \textit{signaled},'' this means that:

Иначе, если это обозначено в книге, в некоторых ситуациях <<{\it
сигнализируется} ошибка>>, это значит:

\begin{itemize}
\item If this situation occurs, an error will be signaled
(see \cdf{error} and \cdf{cerror}).

\item Если данная ситуация случилась, будет сигнализирована ошибка
(см. \cdf{error} и \cdf{cerror}).

\item Valid Common Lisp programs may rely on the fact that an error will be
signaled.

\item Корректная Common Lisp программа может полагаться на тот факт, что будет
сигнализирована ошибка.

\item Every Common Lisp implementation is required to detect such an error.

\item Каждая реализация Common Lisp'а должна определять такую ошибку.
\end{itemize}

In places where it is stated that so-and-so ``must'' or ``must not''
or ``may not''  be the case, then it ``is an error'' if the stated requirement
is not met.  For example, if an argument ``must be a symbol,'' then it
``is an error'' if the argument is not a symbol.  In all cases where
an error is to be \textit{signaled}, the word ``signaled'' is always used
explicitly in this book.

В местах, где встречаются выражения <<должен>> или <<не должен>> или
<<невозможен>>, если условие не
выполняется, подразумевается <<это ошибка>>. Например: если аргумент <<должен
быть символом>> и аргумент не символ, тогда <<это
ошибка>>. Во всех случаях, где ошибка {\it
сигнализируется}, всеягда явно используется слово <<сигнализируется (генерируется)>>.

\begin{newer}
X3J13 has adopted a more elaborate terminology for errors,
and has made some effort to specify the type of error to be signaled
in situations where signaling is appropriate.  This effort
was not complete as of September 1989, and I have made little
attempt to incorporate the new error terminology or
error type specifications in this book.  However, the new terminology
is described and used in the specification of the
Common Lisp Object System appearing in chapter~\ref{CLOS}; this gives
the flavor of how erroneous situations will be described,
and appropriate actions prescribed, in the forthcoming ANSI Common
Lisp standard.
\end{newer}

\begin{table}[t]
\caption{Sample Function Description Образец описания функций}
\label{Sample-Function-Description}
\begingroup\normalsize
\begin{defun}*[Function]
sample-function arg1 arg2 &optional arg3 arg4

The function \cdf{sample-function} adds together \textit{arg1} and \textit{arg2}, and
then multiplies the result by \textit{arg3}.  If \textit{arg3} is not provided or
is {\nil}, the multiplication isn't done.  \cdf{sample-function} then returns
a list whose first element is this result and whose second element is
\textit{arg4} (which defaults to the symbol \cdf{foo}).
For example: 

Функция \cdf{sample-function} складывает вместе \textit{arg1} и \textit{arg2} и
полученную сумму умножает на \textit{arg3}. Если \textit{arg3} не задан или равен
{\nil}, умножения не производится. \cdf{sample-function} затем возвращает список,
в котором первый элемент содержит результат, а второй элемент равен \textit{arg4}
(который по умолчанию равен \cdf{foo}).
\begin{lisp}
(sample-function 3 4) \EV\ (7 foo) \\
(sample-function 1 2 2 'bar) \EV\ (6 bar)
\end{lisp}
In general,
\cd{(sample-function \textit{x} \textit{y})} \EQ\ \cd{(list (+ \textit{x} \textit{y}) 'foo)}.
\end{defun}
\endgroup
\vskip\ruletonoteskip

\hrule

\vskip\ruletonoteskip\null
\caption{Sample Variable Description Образец описания переменной}
\label{Sample-Variable-Description}
\begingroup\normalsize
\begin{defun}*[Variable]
*sample-variable*

The variable \cd{*sample-variable*} specifies how many times
the special form \cdf{sample-special-form} should iterate.
The value should always be a non-negative integer or {\nil}
(which means iterate indefinitely many times).  The initial value is \cd{0}
(meaning no iterations).

Переменная \cd{*sample-variable*} задает, сколько раз специальная
форма \cdf{sample-special-form} должна выполнятсься. Значение должно быть всего
неотрицательным числом или {\nil} (что значит, выполнение бесконечно много
раз). Начальное значение \cd{0} (означает, отсутствие выполнения).
\end{defun}
\endgroup
\vskip\ruletonoteskip


\hrule


\vskip\ruletonoteskip\null
\caption{Sample Constant Description Образец описания константы}
\label{Sample-Constant-Description}
\begingroup\normalsize
\begin{defun}*[Constant]
sample-constant

The named constant \cdf{sample-constant} has as its value
the height of the terminal screen in furlongs times
the base-2 logarithm of the implementation's total disk capacity in bytes,
as a floating-point number.

Именованная константа \cdf{sample-constant} хранит значение высоты экрана
терминала равное произведению одной восьмой и логарифма по основанию 2 от общего
объема диска в байтах, как число с плавающей точкой. FIXME

\end{defun}
\endgroup
\end{table}

\begin{table}[t]
\caption{Sample Special Form Description Образец описания специальной формы}
\label{Sample-Special-Form-Description}
\begingroup\normalsize
\begin{defspec}*
sample-special-form [name] ({var}*) {form}+

This evaluates each form in sequence as an implicit \cdf{progn}, and does this
as many times as specified by
the global variable \cd{*sample-variable*}.  Each variable \textit{var} is bound
and initialized to \cd{43} before the first iteration, and unbound after
the last iteration.
The name \textit{name}, if supplied, may be used in a \cdf{return-from} form
to exit from the loop prematurely.  If the loop ends normally,
\cdf{sample-special-form} returns {\nil}.
For example:
\\
Производит вычисление каждой формы в последовательности, как неявный \cdf{progn},
и делает это столько раз, сколько обозначено в глобальной
переменной \cd{*sample-variable*}. Каждая переменная \textit{var} связывается и
инициализируется значением \cd{43} перед тем, как выполнить первую итерацию, и
освобождается после последней итерации.
Имя \textit{name}, если задано, может быть использовано в \cdf{return-from} форме
для преждевременного выхода из цикла. Если цикл завершился
нормально, \cdf{sample-special-form} возвращает {\nil}.
Например:
\begin{lisp}
(setq *sample-variable* 3) \\
(sample-special-form {\emptylist} \textit{form1} \textit{form2})
\end{lisp}
This evaluates \textit{form1}, \textit{form2}, \textit{form1}, \textit{form2}, \textit{form1}, \textit{form2}
in that order.
\\
Здесь вычисляется \textit{form1}, \textit{form2}, \textit{form1},
\textit{form2}, \textit{form1}, \textit{form2} в указанном порядке.  
\end{defspec}
\endgroup
\vskip\ruletonoteskip
\hrule
\vskip\ruletonoteskip\null
\caption{Sample Macro Description Образец описания макроса}
\label{Sample-Macro-Description}
\begingroup\normalsize
\begin{defmac}*
sample-macro var <declaration* | doc-string> {tag | statement}*

This evaluates the statements as a \cdf{prog} body,
with the variable \textit{var} bound to \cd{43}.
\\
Вычисляет выражения, как тело \cdf{prog} с переменной \textit{var} связанной со
значением \cd{43}.
\begin{lisp}
(sample-macro x (return (+ x x))) \EV\ 86 \\
(sample-macro \textit{var} . \textit{body}) \EX\ (prog ((\textit{var} 43)) . \textit{body})
\end{lisp}
\end{defmac}
\endgroup
\end{table}

\subsection{Descriptions of Functions and Other Entities Описания функций и
других объектов}
\label{FUNCTION-HEADER-NOTATION-SECTION}

Functions, variables, named constants, special forms, and macros are described
using a distinctive typographical format.
Table~\ref{Sample-Function-Description} illustrates the manner
in which Common Lisp functions are documented.
The first line specifies the name of the function,
the manner in which it accepts arguments,
and the fact that it is a function.
If the function takes many arguments, then the names of the arguments
may spill across two or three lines.
The paragraphs following this standard header
explain the definition and uses of the function and often
present examples or related functions.

Функции, переменные, именованные константы, специальные формы и маросы
описываются с помощью особого типографского формата.
Таблица~\ref{Sample-Function-Description} показывает способ, которым
документируются Common Lisp функции.
Первая строка определяет имя функции, способ передачи аргументов, и тот факт,
что это функция.
Если функция принимает много аргументов, тогда имена аргументов могут быть
разнесены на две или три строки.
Параграф, следуемый за этим стандартным заголовком, разъясняет определение и
использование данной функции, а также предоставляет примеры или связанные
функции.

Sometimes two or more related functions are explained in a single
combined description.  In this situation the headers for all the
functions appear together, followed by the combined description.

Иногда две и более связанных функций описываются в одном комбинированном
параграфе. В такой ситуации заголовки для всех функций отображаются совместно, с
последующим описанием.

In general, actual code (including actual names of functions)
appears in this typeface: \cd{(cons a b)}.
Names that stand for pieces of code (metavariables) are written in
\textit{italics}.  In a function description, the names of the parameters appear
in italics for expository purposes.  The word \cd{\&optional} in the
list of parameters indicates that all arguments past that point are
optional; the default values for the parameters are described in the
text.  Parameter lists may also contain \cd{\&rest}, indicating that an
indefinite number of arguments may appear, or \cd{\&key}, indicating
that keyword arguments are accepted.
(The \cd{\&optional}/\cd{\&rest}/\cd{\&key}
syntax is actually used in Common Lisp function definitions for these purposes.)

В целом, текущий код (включая текущие имена функций) предоставляется в данном
шрифте: \cd{(cons a b)}.
Имена, встречающиеся в частях кода (метапеременные) пишутся \textit{наклонным
шрифтом}. В описании функции, именя параметров предоставляются в наклонном
шрифте. Слово \cd{\&optional} в списке параметров указывает на то, что все
последующие аргументы являются необязательными; значения по умолчанию для
параметров описываются далее в тексте. Список параметров может также
включать \cd{\&rest}, указывающий на возможность бесконечного количества
аргументов, или \cd{\&key}, указывающий на то, что могут аргументы могут
приниматься по имени.
(\cd{\&optional}/\cd{\&rest}/\cd{\&key} синтаксис фактически используется в
определениях Common Lisp функций для этих целей).

Table~\ref{Sample-Variable-Description} illustrates the manner in
which a global variable is documented.  The first line specifies the
name of the variable and the fact that it is a variable.
Purely as a matter of convention, all global variables used
by Common Lisp have names beginning and ending with an asterisk.

Таблица~\ref{Sample-Variable-Description} показывает способ, с помощью которого
документируются глобальные переменные. Первая строка определяет имя переменной и 
факт, того что это переменная.
Фактически все глобальные переменные Common Lisp'а имеют имена, начинающиеся и
заканчивающиеся звездочкой (asterisk).


Table~\ref{Sample-Constant-Description} illustrates the manner in
which a named constant is documented.  The first line specifies the
name of the constant and the fact that it is a constant.
(A constant is just like a global variable, except that it is
an error ever to alter its value or to bind it to a new value.)

Таблица~\ref{Sample-Constant-Description} отображает способ, с помощью которого
документируются константы. Первая строка определяет имя константы и то, что это
константа.
(Константа является просто глобальной переменной, за исключчением того, что
возникает ошибка при попытке связывания это переменной с другим значением.)

Tables~\ref{Sample-Special-Form-Description}
and~\ref{Sample-Macro-Description} illustrate the documentation
of special forms and macros, which are closely related in purpose.
These are very different from functions.
Functions are called according to a single, specific, consistent syntax;
the \cd{\&optional}/\cd{\&rest}/\cd{\&key} syntax specifies how the function uses its arguments
internally but does not affect the syntax of a call.
In contrast, each special form or macro can have its own idiosyncratic syntax.
It is by special forms and macros that the syntax of Common Lisp is defined
and extended.

Таблицы~\ref{Sample-Special-Form-Description} и ~\ref{Sample-Macro-Description}
показывают документирование специальных форм и макросов, у которых тесно
связанное предназначение.
Они очень сильно отличаются от функций.
Функции вызываются в соответствии с одним определенным неизменным механизмом;
\cd{\&optional}/\cd{\&rest}/\cd{\&key} синтаксис задает то, как функция
внутренне использует свои аргументы, но не влияет на механизм вызова.
В отличие от этого, каждая специальная форма или макрос может иметь свой
особенный идиосинкразический механизм. Синтаксис Common Lisp'а задается и
раширяется с помощью специальных форм и макросов.

In the description of a special form or macro, an italicized word names a
corresponding part of the form that invokes the special form or macro.
Parentheses stand for themselves and should be
written as such when invoking the special form or macro.
Brackets, braces, stars, plus signs, and vertical bars are metasyntactic
marks. 
Brackets,
$\lbrack$ and $\rbrack$, indicate that what they enclose is optional
(may appear zero times or one time in that place); the square
brackets should not be written in code.
Braces, $\lbrace$ and $\rbrace$, simply parenthesize what they enclose
but may be followed by a star, ${}^*$, or a plus sign, ${}^+$;
a star indicates that what the braces enclose may appear any number of times
(including zero, that is, not at all), whereas a plus sign indicates
that what the braces enclose may appear any non-zero number of times
(that is, must appear at least once).  Within braces or brackets,
a vertical bar, $|$, separates mutually exclusive choices.
In summary, the notation \Mstar{x} means zero or more occurrences
of \textit{x}, the notation \Mplus{x} means one or more occurrences
of \textit{x}, and the notation \Mopt{x} means zero or one occurrence
of \textit{x}.  These notations are also used for syntactic
descriptions expressed as BNF-like productions, as
in table~\ref{NUMBER-SYNTAX-TABLE}.

В описании специальных форм или макросов, наклонные слова обозначают
соответствующуя часть формы, которая вызывает специальную форму или макрос.
Круглые скобки означают сами себя, и таким же образом должны быть указаны при
вызове специальной формы или макроса.
Квадратные скобки, фигурные скобки, звезды, знаки плюса, и вертикальные скобки
является метасинтаксическими знаками.
Квадратные скобки,
$\lbrack$ и $\rbrack$ показывают, что заключенное в них выражение является
необязательным (может встречаться ноль и один раз в данном месте); квадратные
скобки не должны записываться в коде.
Фигурные скобки, $\lbrace$ и $\rbrace$, просто отображают заключенное в них
выражение, однако после закрывающей скобки может следовать звездочка, ${}^*$ или
знак плюс ${}^+$; звездочка показывает, что выражение в скобках может
встречаться НОЛЬ и более раз, тогда как плюс показывает, что выражение может
встречаться ОДИН и более раз. Внутри скобок, может использоваться вертикальная
черта $|$, она разделяет взаимоисключаемые элементы выбора.
В целом, запись \Mstar{x} значит, что \textit{x} может встречаться ноль и
более раз, запись \Mplus{x} значит, что \textit{x} может встречаться один и
более раз, и запись \Mopt{x} значит, что \textit{x} может встречаться ноль или
один раз. Такие записи также используются для описания выражений в стиле БНФ,
как в таблице~\ref{NUMBER-SYNTAX-TABLE}.

\begin{newer}
Double brackets, $\dlbrack$ and $\drbrack$, indicate that any number of the
alternatives enclosed may be used, and those used
may occur in any order, but each
alternative may be used at most once unless followed by a star.
For example,

Двойные скобки, $\dlbrack$ и $\drbrack$, показывают, что может использоваться
любое количество альтернатив перечисленных в скобках в любом порядке, но каждая
альтернатива может использоваться только один раз, если только за ней нет
звездочки.
Например,
\begin{tabbing}
\textit{p} \Mchoice{x {\Mor} \Mstar{y} {\Mor} z} \textit{q}
\end{tabbing}
means that
at most one \textit{x}, any number of \textit{y}'s, and at most one \textit{z}
may appear between the mandatory occurrences of \textit{p}
and \textit{q}, and those that appear may be in any order.

означает, что, как максимум один \textit{x}, любое количество \textit{y}, и как максимум
один \textit{z} могут в любом порядке использоваться между \textit{p} и \textit{q}.

A downward arrow, \Mind{}, indicates a form of syntactic indirection
that helps to make \Mchoice{~} notation more readable.  If \textit{X} is
some non-terminal symbol occurring on the left-hand side of some BNF
production, then the right-hand
side of that production is to be textually substituted for any occurrence
of \Mind{X}.  Thus the two fragments

Стрелочка вниз, \Mind{}, показывает, что ниже будет раскрываться данная
форма. Это делает запись \Mchoice{~} более читаемой. Если \textit{X} является
некоторым нетерминальным символом стоящим слева в некоторой БНФ форме, правая
часть должна быть подставлена вместо символа \Mind{X} во всех случаях его
использования. Вот два фрагмента

\begin{tabbing}
\textit{p} \Mchoice{\Mind{xyz-mixture}} \textit{q} \\
\textit{xyz-mixture} ::= \textit{x\/} {\Mor} \Mstar{y} {\Mor} \textit{z\/}
\end{tabbing}
are together equivalent to the previous example.

вместе составляют эквивалент для предыдущего примера.
\end{newer}

In the last example in table~\ref{Sample-Macro-Description}, notice the
use of dot notation.  The dot appearing in the expression
\cd{(sample-macro \textit{var} . \textit{body})} means that the name \textit{body} stands
for a list of forms, not just a single form, at the end of a list.  This
notation is often used in examples.

В последнем примере в таблице~\ref{Sample-Macro-Description}, рассматривается
использование записи с точкой. Точка, встречающаяся в выражении
\cd{(sample-macro \textit{var} . \textit{body})}, означает то, что имя \textit{body}
является списком форм, и не одиночной формой в конце списка. Эта запись 
часто используется в примерах.

\begin{newer}
In the heading line in table~\ref{Sample-Macro-Description}, notice the
use of \Mchoice{~} notation to indicate that any number of declarations
may appear but at most one documentation string (which may appear before,
after, or somewhere in the middle of any declarations).

В заглавной строке в таблице~\ref{Sample-Macro-Description}, запись \Mchoice{~}
означает, что может указываться любое количество деклараций, 
но максимум одна строка документации (которая может указываться перед, после,
или в где-то в середине любого определения).
\end{newer}

\subsection{The Lisp Reader Лисп считыватель}

The term ``Lisp reader'' refers not to you, the reader of this book,
nor to some person reading Lisp code, but specifically
to a Lisp procedure, namely the function \cdf{read},
which reads characters from an input stream and interprets them by parsing
as representations of Lisp objects.

Термин <<Лисп считыватель>> не относится к вам, читатель этой книги, и не к
какому-либо человеку читающему код на Lisp'е, а именно к Lisp процедуре, которая
называется \cdf{read}. Она читает символы из входного потока и интерпретирует их
с помощью парсинга, как Lisp объекты.

\subsection{Overview of Syntax Обзор синтаксиса}

Certain characters are used in special ways in the syntax of Common Lisp.
The complete syntax is explained in detail in chapter~\ref{IO},
but a quick summary here may be useful:

В Common Lisp некоторые строковые символы используется в определенных целях. Полное
описание синтаксиса можно прочесть в главе~\ref{IO}, но небольшой обзор здесь
может быть также полезен:
\begin{indentdesc}{1.2pc}
\item[\cd{(}]
A left parenthesis begins a list of items.  The list may
contain any number of items, including zero.  Lists may be nested.
For example, \cd{(cons (car x) (cdr y))} is a list of three things,
of which the last two are themselves lists.

\item[\cd{(}]
Левая круглая скобка начинает список элементов. Список может содержать любое
количество элементов, включая ноль (пустой список). Списки могут быть
вложенными. Напрмер, \cd{(cons (car x) (cdr y))} список из трех элементов, в
котором два последних также являются списками.

\item[\cd{)}] A right parenthesis ends a list of items.

\item[\cd{)}] Правая круглая скобка завершает список элементов.

\item[\cd{\Xquote}] An acute accent (also called single
quote or apostrophe) followed by an expression \textit{form}
is an abbreviation for \cd{(quote \textit{form})}.  Thus \cd{'foo} means
\cd{(quote foo)} and \cd{'(cons 'a 'b)} means \cd{(quote (cons (quote a) (quote b)))}.

\item[\cd{\Xquote}] Одинарная кавычка или апостроф с последующим выражением {\it
form} является сокращением для \cd{(quote \textit{form})}. 

\item[\cd{;}] Semicolon is the comment character.  It and all
characters up to the end of the line are discarded.

\item[\cd{;}] Точка с запятой обозначает комментарий. Она и все символы после
нее до конца строки игнорируются.

\item[\cd{"}] Double quotes surround character strings: \\
\cd{"This is a thirty-nine-character string."}

\item[\cd{"}] Двойная кавычка окружает символьные строки: \\
\cd{"This is a thirty-nine-character string."}

\item[\cd{{\Xbackslash}}] Backslash is an escape character. 
It causes the next character to be treated as a letter rather than for its usual
syntactic purpose.  For example, \cd{A{\Xbackslash}(B} denotes a symbol whose
name consists of the three characters \cdf{A}, \cd{(}, and \cdf{B}. Similarly,
\cd{"{\Xbackslash}""} denotes a character string containing one character, a
double quote, because the first and third double quotes serve to delimit the
string, and the second double quote serves as the contents of the string.  The
backslash causes the second double quote to be taken literally and prevents it
from being interpreted as the terminating delimiter of the string.

\item[\cd{{\Xbackslash}}] Обратная наклонная черта является экранирующим
символом. Она показывает, что следующий символ считывается как обычный, не
влияющий на синтаксическую конструкцию. Напрмер, \cd{A{\Xbackslash}(B} означает
символ, имя которого содержит три знака \cdf{A}, \cd{(} и \cdf{B}. Подобным
образом  cd{"{\Xbackslash}""} означает, что строка содержит один знак - двойную
кавычку. Первыя и последняя двойные кавычки обозначают начало и конец
строки. Обратная наклонная черта обозначает, что вторая двойная кавычка
интерпретируется как знак, а не как синтаксическая конструкция для обозначения
начала и конца строки.

\item[\cd{|}] Vertical bars are used in pairs
to surround the name (or part of the name) of a symbol that has
many special characters in it.  It is roughly equivalent to putting a
backslash in front of every character so surrounded.  For example,
\cd{|A(B)|}, \cd{A|(|B|)|}, and \cd{A{\Xbackslash}(B{\Xbackslash})} all mean the symbol whose name
consists of the four characters \cdf{A}, \cd{(}, \cdf{B}, and \cd{)}.

\item[\cd{|}] Вертикальные черты использутся попарно, для окружения имени (или
части имени) символа, которое содержит много специальных знаков. Это равнозначно
тому, что перед каждым из них ставилась бы обратная косая
черта. Например, \cd{|A(B)|}, \cd{A|(|B|)|}
и \cd{A{\Xbackslash}(B{\Xbackslash})} все означают одно и то же имя.

\item[\cd{\#}] The number sign signals the beginning of a
complicated syntactic structure.
The next character designates the precise syntax to follow.
For example, \cd{\#o105} means $105_{8}$ (105 in octal notation);
\cd{\#x105} means $105_{16}$ (105 in hexadecimal notation);
\cd{\#b1011} means $1011_{2}$ (1011 in binary notation);
\cd{\#{\Xbackslash}L} denotes a character object for the character \cdf{L}; and
\cd{\#(a b c)} denotes a vector of three elements \cdf{a}, \cdf{b}, and \cdf{c}.
A particularly important case is that \cd{\#'\textit{fn}} means \cd{(function \textit{fn})},
in a manner analogous to \cd{'\textit{form}} meaning \cd{(quote \textit{form})}.

\item[\cd{\#}] Знак решетки (диез) обозначает начало сложной управляющей
конструкции. Следующий символ определяет синтаксис следуемой конструкции.
Например, \cd{\#o105} означает $105_{8}$ (105 в восьмеричной системе счисления);
\cd{\#x105} означает $105_{16}$ (105 в шестнадцатиричной системе счисления);
\cd{\#b1011} означает $1011_{2}$ (1011 в двоичной системе счисления);
\cd{\#{\Xbackslash}L} определяет строковый символ \cdf{L}; и \cd{\#(a b c)}
обозначает вектор из трех элементов \cdf{a}, \cdf{b} и \cdf{c}. В частности важным
случаем является то, что \cd{\#'\textit{fn}} означает \cd{(function \textit{fn})}, на
манер использования одинарной кавычки \cd{'\textit{form}} обозначающей \cd{(quote
\textit{form})}.

\item[\cd{{\Xbq}}] Grave accent (``backquote'') signals that
the next expression is a template that may contain commas.  The backquote syntax
represents a program that will construct a data structure
according to the template.

\item[\cd{{\Xbq}}] Обратная одинарная кавычка показывает, что следуемое
выражение является шаблоном, который может содержать запятые. Синтаксис этой
обратной кавычки представляет программу, которая может создавать структуры
данных в соответствии с шаблоном.

\item[\cd{,}] Commas are used within the backquote syntax.

\item[\cd{,}] Запятые используются внутри конструкции с обратной кавычкой.

\item[\cd{:}] Colon is used to indicate which package a
symbol belongs to. For example, \cd{network:reset} denotes the symbol named
\cdf{reset} in the package named \cdf{network}.  A leading colon indicates a {\it
keyword}, a symbol that always evaluates to itself.
The colon character is not actually part of the print name
of the symbol.
This is all explained in chapter~\ref{XPACK}; until you read
that, just keep in mind that a symbol notated with a leading colon
is in effect a constant that evaluates to itself.

\item[\cd{:}] Двоеточие используется для отображения того, к какому пакету
приндалежит символ. Например, \cd{network:reset} показывает, что символ с
именем \cdf{reset} принадлежит пакету \cdf{network}. Двоеточие в начале обозначает 
keyword (прим. перев.: это не ключевое слово в понимании других языков 
программирования), символ, который вычислется сам в себя. Двоеточие не является
частью печатаемого имени символа. 
Это все объясняется в главе~\ref{XPACK}; пока ты ее не прочел, просто держи в
голове, что символ с двоеточием в начале являлется константой, вычисляемой сама
в себя.
\end{indentdesc}

\vskip 0pt plus 2pt%manual

\begin{new}%CORR
\textit{Notice of correction.}
In the first edition, the characters ``\cd{,}'' and ``\cd{:}'' at the
left margin above were inadvertently omitted.
\end{new}

Brackets, braces, question mark, and exclamation point
(that is, \cd{{\Xlbracket}}, \cd{{\Xrbracket}}, \cd{{\Xlbrace}}, \cd{{\Xrbrace}},
\cd{?}, and \cd{!}) are not used for any purpose in standard Common Lisp syntax.
These characters are explicitly reserved to the user, primarily
for use as \textit{macro characters} for user-defined lexical syntax extensions
(see section~\ref{MACRO-CHARACTERS-SECTION}).

Квадратные и фигурные скобки, вопросительный и восклицательные знаки, (\cd{{\Xlbracket}}, \cd{{\Xrbracket}}, \cd{{\Xlbrace}}, \cd{{\Xrbrace}},
\cd{?} и  \cd{!}) не используются ни для каких целей в стандартном Common Lisp
синтаксисе. Эти символы явно зарезервированы для пользователей, преимущественно
для использования в качестве \textit{макросимволов} для пользовательских расширений
синтаксиса (см. раздел~\ref{MACRO-CHARACTERS-SECTION}).

\begin{obsolete}
All code in this book is written using lowercase letters.
Common Lisp is generally insensitive to the case in which code
is written.  Internally, names of symbols are ordinarily
converted to and stored in uppercase form.
There are ways to force case conversion on output if desired;
see \cd{*print-case*}.
In this book, wherever an interactive exchange between a user
and the Lisp system is shown, the input is exhibited with lowercase
letters and the output with uppercase letters.
\end{obsolete}

\begin{newer}
X3J13 voted in June 1989 \issue{READ-CASE-SENSITIVITY} to introduce
\cdf{readtable-case}.  Certain settings allow the names of symbols
to be case-sensitive.  The default behavior, however, is as described
in the previous paragraph.  In any event, only uppercase letters
appear in the internal print names of symbols naming the
standard Common Lisp facilities described in this book.

X3J13 voted in June 1989 \issue{READ-CASE-SENSITIVITY}
ввел \cdf{readtable-case}. Данные настройки позволяют именам символов быть
регистрозависимыми. Однако, поведение по умолчанию такое, как описано в
предыдущем параграфе. В любом случае, описанные в книге имена символов внутри
представлены с помощью букв в верхнем регистре.
\end{newer}
