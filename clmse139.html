<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Programmer Interface Concepts</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-06 17:14:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 56--><p class="noindent" > <div id="main_container"> <div id="content"> <!--l. 56--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse140.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch27.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch27.html#tailclmch27.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse139.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch27.html#clmse139.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">27.1   </span> <a 
href="clm.html#QQ2-171-390" id="x171-34900027.1">Programmer Interface Concepts</a></h3>
<!--l. 58--><p class="noindent" >The Объектная система Common Lisp&#x2019;а (CLOS) is an object-oriented extension
to Common Lisp. It is based on generic functions, multiple inheritance,
declarative method combination, and a meta-object protocol.
<!--l. 62--><p class="indent" >   The ﬁrst two parts of this speciﬁcation describe the standard Programmer
Interface for the Объектная система Common Lisp&#x2019;а. The ﬁrst part,
Programmer Interface Concepts, contains a description of the concepts of the
Объектная система Common Lisp&#x2019;а, and the second part, Functions in
the Programmer Interface, contains a description of the functions and
macros in the Объектная система Common Lisp&#x2019;а Programmer Interface.
The third part, The Объектная система Common Lisp&#x2019;а Meta-Object
Protocol, explains how the Объектная система Common Lisp&#x2019;а can be
customized. [The third part has not yet been approved by X3J13 for inclusion
in the forthcoming Common Lisp standard and is not included in this
book.—GLS]
<!--l. 73--><p class="indent" >   The fundamental objects of the Объектная система Common Lisp&#x2019;а are
classes, instances, generic functions, and methods.
<!--l. 76--><p class="indent" >   A <i>class</i> object determines the structure and behavior of a set of other objects,
which are called its <i>instances</i>. Every Common Lisp object is an <i>instance</i> of a
class. The class of an object determines the set of operations that can be
performed on the object.
<!--l. 81--><p class="indent" >   A <i>generic function</i> is a function whose behavior depends on the classes or
identities of the arguments supplied to it. A generic function object contains a set
of methods, a lambda-list, a method combination type, and other information.
The <i>methods</i> deﬁne the class-speciﬁc behavior and operations of the generic
function; a method is said to <i>specialize</i> a generic function. When invoked, a
generic function executes a subset of its methods based on the classes of its
arguments.
<!--l. 90--><p class="indent" >   A generic function can be used in the same ways as an ordinary function in
Common Lisp; in particular, a generic function can be used as an argument to
<tt><a 
href="clmse36.html#x48-94004r69">funcall</a></tt> and <tt><a 
href="clmse36.html#x48-94002r68">apply</a></tt> and can be given a global or a local name.
<!--l. 95--><p class="indent" >   A <i>method</i> is an object that contains a method function, a sequence of
<i>parameter specializers</i> that specify when the given method is applicable, and a
                                                                          

                                                                          
sequence of <i>qualiﬁers</i> that is used by the <i>method combination</i> facility to
distinguish among methods. Each required formal parameter of each method has
an associated parameter specializer, and the method will be invoked only on
arguments that satisfy its parameter specializers.
<!--l. 103--><p class="indent" >   The method combination facility controls the selection of methods, the order
in which they are run, and the values that are returned by the generic
function. The Объектная система Common Lisp&#x2019;а oﬀers a default method
combination type and provides a facility for declaring new types of method
combination.
<!--l. 109--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.1   </span> <a 
href="clmli1.html#QQ2-171-391" id="x171-35000027.1.1">Error Terminology</a></h4>
<!--l. 112--><p class="noindent" >The terminology used in this chapter to describe erroneous situations diﬀers from
the terminology used in the ﬁrst edition. The new terminology involves <i>situations</i>;
a situation is the evaluation of an expression in some speciﬁc context. For
example, a situation might be the invocation of a function on arguments that fail
to satisfy some speciﬁed constraints.
<!--l. 120--><p class="indent" >   In the speciﬁcation of the Объектная система Common Lisp&#x2019;а, the behavior
of programs in all situations is described, and the options available to the
implementor are deﬁned. No implementation is allowed to extend the syntax or
semantics of the Объектная система except as explicitly deﬁned in the
Объектная система speciﬁcation. In particular, no implementation is allowed to
extend the syntax of the Объектная система in such a way that ambiguity
between the speciﬁed syntax of the Объектная система and those extensions is
possible.
<div class=flushdesc>
<!--l. 129--><p class="indent" >
      <ul><li><b>
“When situation <i>S</i> occurs, an error is signaled.” </b></li>
      <!--l. 131--><p class="noindent" >This terminology has the following meaning:
           <ul class="itemize1">
           <li class="itemize">If this situation occurs, an error will be signaled in the interpreter
           and in code compiled under all compiler safety optimization levels.
                                                                          

                                                                          
           </li>
           <li class="itemize">Valid programs may rely on the fact that an error will be signaled
           in the interpreter and in code compiled under all compiler safety
           optimization levels.
           </li>
           <li class="itemize">Every  implementation  is  required  to  detect  such  an  error  in
           the interpreter and in code compiled under all compiler safety
           optimization levels.
           </li></ul>
      <li><b>
“When situation <i>S</i> occurs, an error should be signaled.” </b></li>
      <!--l. 151--><p class="noindent" >This terminology has the following meaning:
           <ul class="itemize1">
           <li class="itemize">If this situation occurs, an error will be signaled at least in the
           interpreter and in code compiled under the safest compiler safety
           optimization level.
           </li>
           <li class="itemize">Valid programs may not rely on the fact that an error will be
           signaled.
           </li>
           <li class="itemize">Every implementation is required to detect such an error at least
           in the interpreter and in code compiled under the safest compiler
           safety optimization level.
           </li>
           <li class="itemize">When  an  error  is  not  signaled,  the  results  are  undeﬁned  (see
           below).
           </li></ul>
      <li><b>
“When situation <i>S</i> occurs, the results are undeﬁned.” </b></li>
      <!--l. 173--><p class="noindent" >This terminology has the following meaning:
                                                                          

                                                                          
           <ul class="itemize1">
           <li class="itemize">If this situation occurs, the results are unpredictable. The results
           may range from harmless to fatal.
           </li>
           <li class="itemize">Implementations are allowed to detect this situation and signal an
           error, but no implementation is required to detect the situation.
           </li>
           <li class="itemize">No valid program may depend on the eﬀects of this situation, and
           all valid programs are required to treat the eﬀects of this situation
           as unpredictable.
           </li></ul>
      <li><b>
“When situation <i>S</i> occurs, the results are unspeciﬁed.” </b></li>
      <!--l. 192--><p class="noindent" >This terminology has the following meaning:
           <ul class="itemize1">
           <li class="itemize">The eﬀects of this situation are not speciﬁed in the Объектная
           система, but the eﬀects are harmless.
           </li>
           <li class="itemize">Implementations are allowed to specify the eﬀects of this situation.
           </li>
           <li class="itemize">No portable program can depend on the eﬀects of this situation,
           and all portable programs are required to treat the situation as
           unpredictable but harmless.
           </li></ul>
      <li><b>
“The Объектная система Common Lisp&#x2019;а may be extended to cover situation <i>S</i>.” </b></li>
      <!--l. 211--><p class="noindent" >The meaning of this terminology is that an implementation is free to treat
      situation <i>S</i> in one of three ways:
           <ul class="itemize1">
           <li class="itemize">When  situation  <i>S</i> occurs,  an  error  is  signaled  at  least  in  the
                                                                          

                                                                          
           interpreter and in code compiled under the safest compiler safety
           optimization level.
           </li>
           <li class="itemize">When situation <i>S</i> occurs, the results are undeﬁned.
           </li>
           <li class="itemize">When situation <i>S</i> occurs, the results are deﬁned and speciﬁed.
           </li></ul>
      <!--l. 227--><p class="noindent" >In addition, this terminology has the following meaning:
           <ul class="itemize1">
           <li class="itemize">No portable program can depend on the eﬀects of this situation,
           and all portable programs are required to treat the situation as
           undeﬁned.
           </li></ul>
      <li><b>
“Implementations are free to extend the syntax <i>S</i>.” </b></li>
      <!--l. 240--><p class="noindent" >This terminology has the following meaning:
           <ul class="itemize1">
           <li class="itemize">Implementations are allowed to deﬁne unambiguous extensions to
           syntax <i>S</i>.
           </li>
           <li class="itemize">No  portable  program  can  depend  on  this  extension,  and  all
           portable programs are required to treat the syntax as meaningless.
           </li></ul>
      </ul>
</div>
<!--l. 254--><p class="indent" >   The Объектная система Common Lisp&#x2019;а speciﬁcation may disallow certain
extensions while allowing others.
                                                                          

                                                                          
<!--l. 257--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.2   </span> <a 
href="clmli1.html#QQ2-171-392" id="x171-35100027.1.2">Classes</a></h4>
<!--l. 260--><p class="noindent" >A <i>class</i> is an object that determines the structure and behavior of a set of other
objects, which are called its <i>instances</i>.
<!--l. 263--><p class="indent" >   A class can inherit structure and behavior from other classes. A class whose
deﬁnition refers to other classes for the purpose of inheriting from them is said to
be a <i>subclass</i> of each of those classes. The classes that are designated
for purposes of inheritance are said to be <i>superclasses</i> of the inheriting
class.
<!--l. 270--><p class="indent" >   A class can have a <i>name</i>. The function <tt><a 
href="clmse140.html#x172-400012r830">class-name</a></tt> takes a class object and
returns its name. The name of an anonymous class is <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. A symbol can <i>name</i> a
class. The function <tt><a 
href="clmse140.html#x172-404038r857">find-class</a></tt> takes a symbol and returns the class that
the symbol names. A class has a <i>proper name</i> if the name is a symbol
and if the name of the class names that class. That is, a class <i>C</i> has the
<i>proper name</i> <i>S</i> if <i>S</i> <span class="math"> =</span> <tt>(class-name <i>C</i>)</tt> and <i>C</i> <span class="math"> =</span> <tt>(find-class <i>S</i>)</tt>.
Notice that it is possible for <tt>(find-class <span class="math">S<sub>1</sub></span>)</tt> <span class="math"> =</span> <tt>(find-class <span class="math">S<sub>2</sub></span>)</tt>
and <span class="math">S<sub>1</sub>≠<i>S</i><sub>2</sub></span>. If <i>C</i> <span class="math"> =</span> <tt>(find-class <i>S</i>)</tt>, we say that <i>C</i> is the <i>class named</i>
<i>S</i>.
<!--l. 283--><p class="indent" >   A class <span class="math">C<sub>1</sub></span> is a <i>direct superclass</i> of a class <span class="math">C<sub>2</sub></span> if <span class="math">C<sub>2</sub></span> explicitly designates <span class="math">C<sub>1</sub></span> as
a superclass in its deﬁnition. In this case, <span class="math">C<sub>2</sub></span> is a <i>direct subclass</i> of <span class="math">C<sub>1</sub></span>. A class <span class="math">C<sub>n</sub></span>
is a <i>superclass</i> of a class <span class="math">C<sub>1</sub></span> if there exists a series of classes <span class="math">C<sub>2</sub>,…,C<sub>n−1</sub></span> such that
<span class="math">C<sub>i+1</sub></span> is a direct superclass of <span class="math">C<sub>i</sub></span> for <span class="math">1 ≤<i>i</i> &#x003C; <i>n</i></span>. In this case, <span class="math">C<sub>1</sub></span> is a <i>subclass</i> of <span class="math">C<sub>n</sub></span>.
A class is considered neither a superclass nor a subclass of itself. That is, if
<span class="math">C<sub>1</sub></span> is a superclass of <span class="math">C<sub>2</sub></span>, then <span class="math">C<sub>1</sub>≠C<sub>2</sub></span>. The set of classes consisting of
some given class <i>C</i> along with all of its superclasses is called “<i>C</i> and its
superclasses.”
<!--l. 298--><p class="indent" >   Each class has a <i>class precedence list</i>, which is a total ordering on the set of
the given class and its superclasses. The total ordering is expressed as a list
ordered from most speciﬁc to least speciﬁc. The class precedence list is used in
several ways. In general, more speciﬁc classes can <i>shadow</i>, or override, features
that would otherwise be inherited from less speciﬁc classes. The method selection
and combination process uses the class precedence list to order methods from
most speciﬁc to least speciﬁc.
<!--l. 307--><p class="indent" >   When a class is deﬁned, the order in which its direct superclasses are
mentioned in the deﬁning form is important. Each class has a <i>local precedence
order</i>, which is a list consisting of the class followed by its direct superclasses in
the order mentioned in the deﬁning form.
<!--l. 313--><p class="indent" >   A class precedence list is always consistent with the local precedence order of
                                                                          

                                                                          
each class in the list. The classes in each local precedence order appear within the
class precedence list in the same order. If the local precedence orders are
inconsistent with each other, no class precedence list can be constructed, and an
error is signaled. The class precedence list and its computation is discussed in
section <a 
href="#x171-36200027.1.5">27.1.5<!--tex4ht:ref: Determining-the-Class-Precedence-List-SECTION --></a>.
<!--l. 321--><p class="indent" >   Classes are organized into a <i>directed acyclic graph</i>. There are two
distinguished classes, named <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> and <tt>standard-object</tt>. The class named <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> has no
superclasses. It is a superclass of every class except itself. The class named
<tt>standard-object</tt> is an instance of the class <tt>standard-class</tt> and is a
superclass of every class that is an instance of <tt>standard-class</tt> except
itself.
<!--l. 328--><p class="indent" >   There is a mapping from the Common Lisp Object System class space into the
Common Lisp type space. Many of the standard Common Lisp types have a
corresponding class that has the same name as the type. Some Common Lisp
types do not have a corresponding class. The integration of the type and class
systems is discussed in section <a 
href="#x171-36100027.1.4">27.1.4<!--tex4ht:ref: Integrating-Types-and-Classes-SECTION --></a>.
<!--l. 335--><p class="indent" >   Classes are represented by objects that are themselves instances of
classes. The class of the class of an object is termed the <i>metaclass</i> of
that object. When no misinterpretation is possible, the term <i>metaclass</i>
will be used to refer to a class that has instances that are themselves
classes. The metaclass determines the form of inheritance used by the
classes that are its instances and the representation of the instances of
those classes. The Объектная система Common Lisp&#x2019;а provides a default
metaclass, <tt>standard-class</tt>, that is appropriate for most programs. The
meta-object protocol provides mechanisms for deﬁning and using new
metaclasses.
<!--l. 346--><p class="indent" >   Except where otherwise speciﬁed, all classes mentioned in this chapter are
instances of the class <tt>standard-class</tt>, all generic functions are instances of the
class <tt>standard-generic-function</tt>, and all methods are instances of the class
<tt>standard-method</tt>.
<!--l. 351--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-35200027.1.2" id="x171-35200027.1.2">Deﬁning Classes</a></h5>
<!--l. 353--><p class="noindent" >The macro <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> is used to deﬁne a new named class. The deﬁnition of a class
includes the following:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">The name of the new class. For newly deﬁned classes this is a proper
      name.
      </li>
      <li class="itemize">The list of the direct superclasses of the new class.
      </li>
      <li class="itemize">A set of <i>slot speciﬁers</i>. Each slot speciﬁer includes the name of the
      slot and zero or more <i>slot options</i>. A slot option pertains only to a
      single slot. If a class deﬁnition contains two slot speciﬁers with the same
      name, an error is signaled.
      </li>
      <li class="itemize">A set of <i>class options</i>. Each class option pertains to the class as a whole.</li></ul>
<!--l. 371--><p class="noindent" >The slot options and class options of the <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form provide mechanisms for the
following:
      <ul class="itemize1">
      <li class="itemize">Supplying a default initial value form for a given slot.
      </li>
      <li class="itemize">Requesting  that  methods  for  generic  functions  be  automatically
      generated for reading or writing slots.
      </li>
      <li class="itemize">Controlling whether a given slot is shared by instances of the class or
      whether each instance of the class has its own slot.
      </li>
      <li class="itemize">Supplying a set of initialization arguments and initialization argument
      defaults to be used in instance creation.
      </li>
      <li class="itemize">Indicating that the metaclass is to be other than the default.
      </li>
      <li class="itemize">Indicating the expected type for the value stored in the slot.
                                                                          

                                                                          
      </li>
      <li class="itemize">Indicating the documentation string for the slot.
      </li></ul>
<!--l. 398--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-35300027.1.2" id="x171-35300027.1.2">Creating Instances of Classes</a></h5>
<!--l. 400--><p class="noindent" >The generic function <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> creates and returns a new instance of a
class. The Объектная система provides several mechanisms for specifying how a
new instance is to be initialized. For example, it is possible to specify the initial
values for slots in newly created instances either by giving arguments to
<tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> or by providing default initial values.
<!--l. 407--><p class="indent" >   Further initialization activities can be performed by methods written for
generic functions that are part of the initialization protocol. The complete
initialization protocol is described in section <a 
href="#x171-38000027.1.9">27.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<!--l. 412--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-35400027.1.2" id="x171-35400027.1.2">Slots</a></h5>
<!--l. 414--><p class="noindent" >An object that has <tt>standard-class</tt> as its metaclass has zero or more named
slots. The slots of an object are determined by the class of the object. Each slot
can hold one value. The name of a slot is a symbol that is syntactically valid for
use as a variable name.
<!--l. 420--><p class="indent" >   When a slot does not have a value, the slot is said to be <i>unbound</i>.
When an unbound slot is read, the generic function <tt><a 
href="clmse140.html#x172-407065r896">slot-unbound</a></tt> is
invoked. The system-supplied primary method for <tt><a 
href="clmse140.html#x172-407065r896">slot-unbound</a></tt> signals an
error.
<!--l. 424--><p class="indent" >   The default initial value form for a slot is deﬁned by the  <tt>:initform</tt>
slot option. When the <tt>:initform</tt> form is used to supply a value, it is
evaluated in the lexical environment in which the <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form was
evaluated. The <tt>:initform</tt> along with the lexical environment in which
the <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form was evaluated is called a <i>captured</i> <tt>:initform</tt>. See
section <a 
href="#x171-38000027.1.9">27.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<!--l. 432--><p class="indent" >   A <i>local slot</i> is deﬁned to be a slot that is visible to exactly one instance,
namely the one in which the slot is allocated. A <i>shared slot</i> is deﬁned to be
a slot that is visible to more than one instance of a given class and its
subclasses.
                                                                          

                                                                          
<!--l. 437--><p class="indent" >   A class is said to <i>deﬁne</i> a slot with a given name when the <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form for
that class contains a slot speciﬁer with that name. Deﬁning a local slot does not
immediately create a slot; it causes a slot to be created each time an
instance of the class is created. Deﬁning a shared slot immediately creates a
slot.
<!--l. 443--><p class="indent" >   The <tt>:allocation</tt> slot option to <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> controls the kind of slot that is
deﬁned. If the value of the <tt>:allocation</tt> slot option is <tt>:instance</tt>, a local
slot is created. If the value of <tt>:allocation</tt> is <tt>:class</tt>, a shared slot is
created.
<!--l. 448--><p class="indent" >   A slot is said to be <i>accessible</i> in an instance of a class if the slot is deﬁned by
the class of the instance or is inherited from a superclass of that class. At most
                                                                          

                                                                          
one slot of a given name can be accessible in an instance. A shared slot deﬁned by
a class is accessible in all instances of that class. A detailed explanation of the
inheritance of slots is given in section <a 
href="#x171-35800027.1.3">27.1.3<!--tex4ht:ref: Inheritance-of-Slots-and-Slot-Options-SECTION --></a>.
<!--l. 456--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-35500027.1.2" id="x171-35500027.1.2">Accessing Slots</a></h5>
<!--l. 458--><p class="noindent" >Slots can be accessed in two ways: by use of the primitive function <tt><a 
href="clmse140.html#x172-407067r897">slot-value</a></tt>
and by use of generic functions generated by the <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form.
<!--l. 462--><p class="indent" >   The function <tt><a 
href="clmse140.html#x172-407067r897">slot-value</a></tt> can be used with any slot name speciﬁed in the
<tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form to access a speciﬁc slot accessible in an instance of the given
class.
<!--l. 466--><p class="indent" >   The macro <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> provides syntax for generating methods to read and
write slots. If a <i>reader</i> is requested, a method is automatically generated for
reading the value of the slot, but no method for storing a value into it is
generated. If a <i>writer</i> is requested, a method is automatically generated for
storing a value into the slot, but no method for reading its value is generated. If
an <i>accessor</i> is requested, a method for reading the value of the slot and a method
for storing a value into the slot are automatically generated. Reader and writer
methods are implemented using <tt><a 
href="clmse140.html#x172-407067r897">slot-value</a></tt>.
<!--l. 477--><p class="indent" >   When a reader or writer is speciﬁed for a slot, the name of the generic
function to which the generated method belongs is directly speciﬁed. If the
name speciﬁed for the writer option is the symbol <i>name</i>, the name of the
generic function for writing the slot is the symbol <i>name</i>, and the generic
function takes two arguments: the new value and the instance, in that order.
If the name speciﬁed for the accessor option is the symbol <i>name</i>, the
name of the generic function for reading the slot is the symbol name, and
the name of the generic function for writing the slot is the list <tt>(setf
<i>name</i>)</tt>.
<!--l. 488--><p class="indent" >   A generic function created or modiﬁed by supplying reader, writer,
or accessor slot options can be treated exactly as an ordinary generic
function.
<!--l. 492--><p class="indent" >   Note that <tt><a 
href="clmse140.html#x172-407067r897">slot-value</a></tt> can be used to read or write the value of a slot whether
or not reader or writer methods exist for that slot. When <tt><a 
href="clmse140.html#x172-407067r897">slot-value</a></tt> is used, no
reader or writer methods are invoked.
<!--l. 497--><p class="indent" >   The macro <tt><a 
href="clmse140.html#x172-409002r904">with-slots</a></tt> can be used to establish a lexical environment in
which speciﬁed slots are lexically available as if they were variables. The
                                                                          

                                                                          
macro <tt><a 
href="clmse140.html#x172-409002r904">with-slots</a></tt> invokes the function <tt><a 
href="clmse140.html#x172-407067r897">slot-value</a></tt> to access the speciﬁed
slots.
<!--l. 502--><p class="indent" >   The macro <tt><a 
href="clmse140.html#x172-407077r902">with-accessors</a></tt> can be used to establish a lexical environment in
which speciﬁed slots are lexically available through their accessors as if they were
variables. The macro <tt><a 
href="clmse140.html#x172-407077r902">with-accessors</a></tt> invokes the appropriate accessors to access
the speciﬁed slots. Any accessors speciﬁed by <tt><a 
href="clmse140.html#x172-407077r902">with-accessors</a></tt> must already have
been deﬁned before they are used.
                                                                          

                                                                          
<!--l. 511--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.3   </span> <a 
href="clmli1.html#QQ2-171-397" id="x171-35600027.1.3">Inheritance</a></h4>
<!--l. 514--><p class="noindent" >A class can inherit methods, slots, and some <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> options from its
superclasses. The following sections describe the inheritance of methods, the
inheritance of slots and slot options, and the inheritance of class options.
<!--l. 519--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-35700027.1.3" id="x171-35700027.1.3">Inheritance of Methods</a></h5>
<!--l. 522--><p class="noindent" >A subclass inherits methods in the sense that any method applicable to all
instances of a class is also applicable to all instances of any subclass of that
class.
<!--l. 526--><p class="indent" >   The inheritance of methods acts the same way regardless of whether the
method was created by using one of the method-deﬁning forms or by
using one of the <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> options that causes methods to be generated
automatically.
<!--l. 531--><p class="indent" >   The inheritance of methods is described in detail in section <a 
href="#x171-37100027.1.7">27.1.7<!--tex4ht:ref: Method-Selection-and-Combination-SECTION --></a>.
<!--l. 535--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-35800027.1.3" id="x171-35800027.1.3">Inheritance of Slots and Slot Options</a></h5>
<!--l. 538--><p class="noindent" >The set of names of all slots accessible in an instance of a class <i>C</i> is the
union of the sets of names of slots deﬁned by <i>C</i> and its superclasses.
The <i>structure</i> of an instance is the set of names of local slots in that
instance.
<!--l. 543--><p class="indent" >   In the simplest case, only one class among <i>C</i> and its superclasses deﬁnes a slot
with a given slot name. If a slot is deﬁned by a superclass of <i>C</i>, the slot is said to
be <i>inherited</i>. The characteristics of the slot are determined by the slot speciﬁer of
the deﬁning class. Consider the deﬁning class for a slot <i>S</i>. If the value of the
<tt>:allocation</tt> slot option is <tt>:instance</tt>, then <i>S</i> is a local slot and each instance
of <i>C</i> has its own slot named <i>S</i> that stores its own value. If the value
of the <tt>:allocation</tt> slot option is <tt>:class</tt>, then <i>S</i> is a shared slot, the
class that deﬁned <i>S</i> stores the value, and all instances of <i>C</i> can access
that single slot. If the <tt>:allocation</tt> slot option is omitted, <tt>:instance</tt> is
used.
                                                                          

                                                                          
<!--l. 556--><p class="indent" >   In general, more than one class among <i>C</i> and its superclasses can
deﬁne a slot with a given name. In such cases, only one slot with the
given name is accessible in an instance of <i>C</i>, and the characteristics of
that slot are a combination of the several slot speciﬁers, computed as
follows:
      <ul class="itemize1">
      <li class="itemize">All the slot speciﬁers for a given slot name are ordered from most
      speciﬁc to least speciﬁc, according to the order in <i>C</i>&#x2019;s class precedence
      list of the classes that deﬁne them. All references to the speciﬁcity of
      slot speciﬁers immediately following refer to this ordering.
      </li>
      <li class="itemize">The allocation of a slot is controlled by the most speciﬁc slot speciﬁer.
      If the most speciﬁc slot speciﬁer does not contain an <tt>:allocation</tt> slot
      option, <tt>:instance</tt> is used. Less speciﬁc slot speciﬁers do not aﬀect the
      allocation.
      </li>
      <li class="itemize">The default initial value form for a slot is the value of the <tt>:initform</tt>
      slot option in the most speciﬁc slot speciﬁer that contains one. If no
      slot speciﬁer contains an <tt>:initform</tt> slot option, the slot has no default
      initial value form.
      </li>
      <li class="itemize">The contents of a slot will always be of type <tt>(and <span class="math">T<sub>1</sub></span>  <span class="math">…</span> <span class="math">T<sub>n</sub></span>)</tt> where
      <span class="math">T<sub>1</sub>,…,T<sub>n</sub></span> are the values of the <tt>:type</tt> slot options contained in all of the
      slot speciﬁers. If no slot speciﬁer contains the <tt>:type</tt> slot option, the
      contents of the slot will always be of type <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>. The result of attempting
      to store in a slot a value that does not satisfy the type of the slot is
      undeﬁned.
      </li>
      <li class="itemize">The set of initialization arguments that initialize a given slot is the
      union of the initialization arguments declared in the <tt>:initarg</tt> slot
      options in all the slot speciﬁers.
      </li>
      <li class="itemize">The documentation string for a slot is the value of the <tt>:documentation</tt>
                                                                          

                                                                          
      slot option in the most speciﬁc slot speciﬁer that contains one. If no
      slot speciﬁer contains a <tt>:documentation</tt> slot option, the slot has no
      documentation string.</li></ul>
<!--l. 600--><p class="indent" >   A consequence of the allocation rule is that a shared slot can be shadowed. For
example, if a class <span class="math">C<sub>1</sub></span> deﬁnes a slot named <i>S</i> whose value for the <tt>:allocation</tt>
slot option is <tt>:class</tt>, that slot is accessible in instances of <span class="math">C<sub>1</sub></span> and all of its
subclasses. However, if <span class="math">C<sub>2</sub></span> is a subclass of <span class="math">C<sub>1</sub></span> and also deﬁnes a slot named <i>S</i>,
<span class="math">C<sub>1</sub></span>&#x2019;s slot is not shared by instances of <span class="math">C<sub>2</sub></span> and its subclasses. When a class <span class="math">C<sub>1</sub></span>
deﬁnes a shared slot, any subclass <span class="math">C<sub>2</sub></span> of <span class="math">C<sub>1</sub></span> will share this single slot unless the
<tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form for <span class="math">C<sub>2</sub></span> speciﬁes a slot of the same name or there is a superclass of
<span class="math">C<sub>2</sub></span> that precedes <span class="math">C<sub>1</sub></span> in the class precedence list of <span class="math">C<sub>2</sub></span> that deﬁnes a slot of the
same name.
<!--l. 613--><p class="indent" >   A consequence of the type rule is that the value of a slot satisﬁes the type
constraint of each slot speciﬁer that contributes to that slot. Because the result of
attempting to store in a slot a value that does not satisfy the type constraint
for the slot is undeﬁned, the value in a slot might fail to satisfy its type
constraint.
<!--l. 619--><p class="indent" >   The <tt>:reader</tt>, <tt>:writer</tt>, and <tt>:accessor</tt> slot options create methods rather
than deﬁne the characteristics of a slot. Reader and writer methods are inherited
in the sense described in section <a 
href="#x171-35700027.1.3">27.1.3<!--tex4ht:ref: Inheritance-of-Methods-SECTION --></a>.
<!--l. 624--><p class="indent" >   Methods that access slots use only the name of the slot and the type of the
slot&#x2019;s value. Suppose a superclass provides a method that expects to access a
shared slot of a given name, and a subclass deﬁnes a local slot with the same
name. If the method provided by the superclass is used on an instance of the
subclass, the method accesses the local slot.
<!--l. 631--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-35900027.1.3" id="x171-35900027.1.3">Inheritance of Class Options</a></h5>
<!--l. 633--><p class="noindent" >The <tt>:default-initargs</tt> class option is inherited. The set of defaulted
initialization arguments for a class is the union of the sets of initialization
arguments speciﬁed in the <tt>:default-initargs</tt> class options of the class and its
superclasses. When more than one default initial value form is supplied for a given
initialization argument, the default initial value form that is used is the one
supplied by the class that is most speciﬁc according to the class precedence
list.
<!--l. 643--><p class="indent" >   If a given <tt>:default-initargs</tt> class option speciﬁes an initialization argument
                                                                          

                                                                          
of the same name more than once, an error is signaled.
<!--l. 647--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-36000027.1.3" id="x171-36000027.1.3">Examples</a></h5>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass C1 ()
</td></tr></table>
<!--l. 650--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ((S1 :initform 5.4 :type number)</td></tr></table>
<!--l. 651--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (S2 :allocation :class)))</td></tr></table>
<!--l. 652--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 653--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass C2 (C1)</td></tr></table>
<!--l. 654--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ((S1 :initform 5 :type integer)</td></tr></table>
<!--l. 655--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (S2 :allocation :instance)</td></tr></table>
<!--l. 656--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (S3 :accessor C2-S3)))</td></tr></table>
<!--l. 658--><p class="indent" >
</div>
</div>
<!--l. 660--><p class="noindent" >Instances of the class <tt>C1</tt> have a local slot named <tt>S1</tt>, whose default initial value is
5.4 and whose value should always be a number. The class <tt>C1</tt> also has a shared
slot named <tt>S2</tt>.
<!--l. 664--><p class="indent" >   There is a local slot named <tt>S1</tt> in instances of <tt>C2</tt>. The default initial value of
<tt>S1</tt> is 5. The value of <tt>S1</tt> will be of type <tt>(and integer number)</tt>. There are also
local slots named <tt>S2</tt> and <tt>S3</tt> in instances of <tt>C2</tt>. The class <tt>C2</tt> has a method for
<tt>C2-S3</tt> for reading the value of slot <tt>S3</tt>; there is also a method for <tt>(setf C2-S3)</tt>
that writes the value of <tt>S3</tt>.
<!--l. 673--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.4   </span> <a 
href="clmli1.html#QQ2-171-402" id="x171-36100027.1.4">Integrating Types and Classes</a></h4>
<!--l. 676--><p class="noindent" >The Объектная система Common Lisp&#x2019;а maps the space of classes into the
Common Lisp type space. Every class that has a proper name has a corresponding
type with the same name.
                                                                          

                                                                          
<!--l. 680--><p class="indent" >   The proper name of every class is a valid type speciﬁer. In addition, every class
object is a valid type speciﬁer. Thus the expression <tt>(typep <i>object class</i>)</tt>
evaluates to true if the class of <i>object</i> is <i>class</i> itself or a subclass of class. The
evaluation of the expression <tt>(subtypep <i>class1 class2</i>)</tt> returns the values
<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> and <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> if <i>class1</i> is a subclass of <i>class2</i> or if they are the same class;
otherwise it returns the values <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> and <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>. If <i>I</i> is an instance of some class <i>C</i>
named <i>S</i> and <i>C</i> is an instance of <tt>standard-class</tt>, the evaluation of the
expression <tt>(type-of <i>I</i>)</tt> will return <i>S</i> if <i>S</i> is the proper name of <i>C</i>; if <i>S</i>
is not the proper name of <i>C</i>, the expression <tt>(type-of <i>I</i>)</tt> will return
<i>C</i>.
<!--l. 694--><p class="indent" >   Because the names of classes and class objects are type speciﬁers, they may be
used in the special form <tt><a 
href="clmse49.html#x63-153002r126">the</a></tt> and in type declarations.
<!--l. 697--><p class="indent" >   Many but not all of the predeﬁned Common Lisp type speciﬁers have a
corresponding class with the same proper name as the type. These type speciﬁers
are listed in table <a 
href="#x171-3610021">27.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a>. For example, the type <tt>array</tt> has a corresponding class
named <tt>array</tt>. No type speciﬁer that is a list, such as <tt>(vector double-float
100)</tt>, has a corresponding class. The form <tt><a 
href="clmse23.html#x32-50002r6">deftype</a></tt> does not create any
classes.
<!--l. 704--><p class="indent" >   Each class that corresponds to a predeﬁned Common Lisp type speciﬁer can
be implemented in one of three ways, at the discretion of each implementation. It
can be a <i>standard class</i> (of the kind deﬁned by <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt>), a <i>structure class</i>
(deﬁned by <tt><a 
href="clmse97.html#x121-225002r561">defstruct</a></tt>), or a <i>built-in class</i> (implemented in a special,
non-extensible way).
<!--l. 711--><p class="indent" >   A built-in class is one whose instances have restricted capabilities or special
representations. Attempting to use <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> to deﬁne subclasses of a built-in
class signals an error. Calling <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> to create an instance of a built-in
class signals an error. Calling <tt><a 
href="clmse140.html#x172-407067r897">slot-value</a></tt> on an instance of a built-in
class signals an error. Redeﬁning a built-in class or using <tt><a 
href="clmse140.html#x172-400008r828">change-class</a></tt>
to change the class of an instance to or from a built-in class signals an
error. However, built-in classes can be used as parameter specializers in
methods.
<!--l. 726--><p class="indent" >   It is possible to determine whether a class is a built-in class by checking the
metaclass. A standard class is an instance of <tt>standard-class</tt>, a built-in class is
an instance of <tt>built-in-class</tt>, and a structure class is an instance of
<tt>structure-class</tt>.
<!--l. 732--><p class="indent" >   Each structure type created by <tt><a 
href="clmse97.html#x121-225002r561">defstruct</a></tt> without using the <tt>:type</tt> option has
a corresponding class. This class is an instance of <tt>structure-class</tt>. The
<tt>:include</tt> option of <tt><a 
href="clmse97.html#x121-225002r561">defstruct</a></tt> creates a direct subclass of the class that
                                                                          

                                                                          
corresponds to the included structure.
<!--l. 743--><p class="indent" >   The purpose of specifying that many of the standard Common Lisp type
speciﬁers have a corresponding class is to enable users to write methods that
discriminate on these types. Method selection requires that a class precedence list
can be determined for each class.
<!--l. 749--><p class="indent" >   The hierarchical relationships among the Common Lisp type speciﬁers are
mirrored by relationships among the classes corresponding to those types. The
existing type hierarchy is used for determining the class precedence list for each
class that corresponds to a predeﬁned Common Lisp type. In some cases, the ﬁrst
edition did not specify a local precedence order for two supertypes of a given type
speciﬁer. For example, <tt><a 
href="clmse31.html#x42-76002r22">null</a></tt> is a subtype of both <tt><a 
href="clmch10.html#x64-15500010">symbol</a></tt> and <tt><a 
href="clmse80.html#x100-201034r441">list</a></tt>, but the ﬁrst
edition did not specify whether <tt><a 
href="clmch10.html#x64-15500010">symbol</a></tt> is more speciﬁc or less speciﬁc
than <tt><a 
href="clmse80.html#x100-201034r441">list</a></tt>. The CLOS speciﬁcation deﬁnes those relationships for all such
classes.
<!--l. 761--><p class="indent" >   Table <a 
href="#x171-3610021">27.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a> lists the set of classes required by the Объектная система that
correspond to predeﬁned Common Lisp type speciﬁers. The superclasses of each
such class are presented in order from most speciﬁc to most general, thereby
deﬁning the class precedence list for the class. The local precedence order for each
class that corresponds to a Common Lisp type speciﬁer can be derived from this
table.
<!--l. 769--><p class="indent" >   Individual implementations may be extended to deﬁne other type speciﬁers to
have a corresponding class. Individual implementations can be extended to
add other subclass relationships and to add other elements to the class
precedence lists in the above table as long as they do not violate the type
relationships and disjointness requirements speciﬁed in section <a 
href="clmse16.html#x23-410002.14">2.14<!--tex4ht:ref: DATA-TYPE-RELATIONSHIPS --></a>. A
standard class deﬁned with no direct superclasses is guaranteed to be
disjoint from all of the classes in the table, except for the class named
<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>.
<!--l. 779--><p class="indent" >   [At this point the original CLOS report speciﬁed that certain Common Lisp
types were to appear in table <a 
href="#x171-3610021">27.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a> if and only if X3J13 voted to make them
disjoint from <tt><a 
href="clmse79.html#x99-200062r423">cons</a></tt>, <tt><a 
href="clmch10.html#x64-15500010">symbol</a></tt>, <tt>array</tt>, <tt>number</tt>, and <tt><a 
href="clmse73.html#x91-192002r341">character</a></tt>. X3J13 voted to do so
in June 1988 <a 
 id="dx171-361001"></a>. I have added these types and their class precedence lists to the
table; the new types are indicated by asterisks.—GLS]
   <div class="table">
                                                                          

                                                                          
<!--l. 789--><p class="indent" >   <a 
 id="x171-3610021"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 27.1: </span><span  
class="content">Class Precedence Lists for Predeﬁned Types</span></div><!--tex4ht:label?: x171-3610021 -->
<div class="flushleft" 
>
<!--l. 792--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Predeﬁned Common Lisp Type</td><td align="left" >Class Precedence List for Corresponding Class</td>
</tr><tr><td align="left" >array                                  </td><td align="left" >(array t)                                                  </td>
</tr><tr><td align="left" >bit-vector                            </td><td align="left" >(bit-vector vector array sequence t)               </td>
</tr><tr><td align="left" >character                             </td><td align="left" >(character t)                                            </td>
</tr><tr><td align="left" >complex                              </td><td align="left" >(complex number t)                                   </td>
</tr><tr><td align="left" >cons                                   </td><td align="left" >(cons list sequence t)                                 </td>
</tr><tr><td align="left" >ﬂoat                                   </td><td align="left" >(ﬂoat number t)                                        </td>
</tr><tr><td align="left" >function *                            </td><td align="left" >(function t)                                              </td>
</tr><tr><td align="left" >hash-table *                         </td><td align="left" >(hash-table t)                                           </td>
</tr><tr><td align="left" >integer                                </td><td align="left" >(integer rational number t)                          </td>
</tr><tr><td align="left" >list                                     </td><td align="left" >(list sequence t)                                        </td>
</tr><tr><td align="left" >null                                    </td><td align="left" >(null symbol list sequence t)                        </td>
</tr><tr><td align="left" >number                               </td><td align="left" >(number t)                                               </td>
</tr><tr><td align="left" >package *                            </td><td align="left" >(package t)                                              </td>
</tr><tr><td align="left" >pathname *                          </td><td align="left" >(pathname t)                                            </td>
</tr><tr><td align="left" >random-state *                     </td><td align="left" >(random-state t)                                       </td>
</tr><tr><td align="left" >ratio                                   </td><td align="left" >(ratio rational number t)                            </td>
</tr><tr><td align="left" >rational                               </td><td align="left" >(rational number t)                                   </td>
</tr><tr><td align="left" >readtable *                          </td><td align="left" >(readtable t)                                            </td>
</tr><tr><td align="left" >sequence                              </td><td align="left" >(sequence t)                                             </td>
</tr><tr><td align="left" >stream *                              </td><td align="left" >(stream t)                                                </td>
</tr><tr><td align="left" >string                                 </td><td align="left" >(string vector array sequence t)                    </td>
</tr><tr><td align="left" >symbol                                </td><td align="left" >(symbol t)                                               </td>
</tr><tr><td align="left" >t                                        </td><td align="left" >(t)                                                          </td>
</tr><tr><td align="left" >vector                                 </td><td align="left" >(vector array sequence t)                            </td></tr></table>
</div></div>
<!--l. 823--><p class="noindent" >[An asterisk indicates a type added to this table as a consequence of a portion of
the CLOS speciﬁcation that was conditional on X3J13 voting to make that type
disjoint from certain other built-in types <a 
 id="dx171-361003"></a>.—GLS]
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
   <h4 class="subsectionHead"><span class="titlemark">27.1.5   </span> <a 
href="clmli1.html#QQ2-171-404" id="x171-36200027.1.5">Determining the Class Precedence List</a></h4>
<!--l. 833--><p class="noindent" >The <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form for a class provides a total ordering on that class and its
direct superclasses. This ordering is called the <i>local precedence order</i>. It is an
ordered list of the class and its direct superclasses. The <i>class precedence list</i> for a
class <i>C</i> is a total ordering on <i>C</i> and its superclasses that is consistent with the
local precedence orders for <i>C</i> and its superclasses.
<!--l. 840--><p class="indent" >   A class precedes its direct superclasses, and a direct superclass precedes all
other direct superclasses speciﬁed to its right in the superclasses list of the
<tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form. For every class <i>C</i>, deﬁne
<span class="math">
                  R<sub>C</sub> = {(C,C<sub>1</sub>), (C<sub>1</sub>,C<sub>2</sub>),…, (C<sub>n−1</sub>,C<sub>n</sub>)}
</span> where <span class="math">C<sub>1</sub>,…,C<sub>n</sub></span> are the direct superclasses of <i>C</i> in the order in which they are
mentioned in the <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form. These ordered pairs generate the total ordering
on the class <i>C</i> and its direct superclasses.
<!--l. 851--><p class="indent" >   Let <span class="math">S<sub>C</sub></span> be the set of <i>C</i> and its superclasses. Let <i>R</i> be
<span class="math">
                                                                          

                                                                          
                             R = ⋃
  <sub>c ∈ S<sub>
C</sub></sub>R<sub>c</sub>
</span>
<!--l. 854--><p class="indent" >   The set <i>R</i> may or may not generate a partial ordering, depending on whether
the <span class="math">R<sub>c</sub></span>, <span class="math">c ∈ S<sub>C</sub></span>, are consistent; it is assumed that they are consistent and that <i>R</i>
generates a partial ordering. When the <span class="math">R<sub>c</sub></span> are not consistent, it is said that <i>R</i> is
inconsistent.
<!--l. 861--><p class="indent" >   To compute the class precedence list for <i>C</i>, topologically sort the elements
of <span class="math">S<sub>C</sub></span> with respect to the partial ordering generated by <i>R</i>. When the
topological sort must select a class from a set of two or more classes, none of
which are preceded by other classes with respect to <i>R</i>, the class selected is
chosen deterministically, as described below. If <i>R</i> is inconsistent, an error is
signaled.
                                                                          

                                                                          
<!--l. 872--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-36300027.1.5" id="x171-36300027.1.5">Topological Sorting</a></h5>
<!--l. 874--><p class="noindent" >Topological sorting proceeds by ﬁnding a class <i>C</i> in <span class="math">S<sub>C</sub></span> such that no other class
precedes that element according to the elements in <i>R</i>. The class <i>C</i> is placed ﬁrst
in the result. Remove <i>C</i> from <span class="math">S<sub>C</sub></span>, and remove all pairs of the form <span class="math">(C,D)</span>,
<span class="math">D ∈ S<sub>C</sub></span>, from <i>R</i>. Repeat the process, adding classes with no predecessors to
the end of the result. Stop when no element can be found that has no
predecessor.
<!--l. 883--><p class="indent" >   If <span class="math">S<sub>C</sub></span> is not empty and the process has stopped, the set <i>R</i> is inconsistent. If
every class in the ﬁnite set of classes is preceded by another, then <i>R</i> contains a
loop. That is, there is a chain of classes <span class="math">C<sub>1</sub>,…,C<sub>n</sub></span> such that <span class="math">C<sub>i</sub></span> precedes <span class="math">C<sub>i+1</sub></span>,
<span class="math">1 ≤ i &#x003C; n</span>, and <span class="math">C<sub>n</sub></span> precedes <span class="math">C<sub>1</sub></span>.
<!--l. 891--><p class="indent" >   Sometimes there are several classes from <span class="math">S<sub>C</sub></span> with no predecessors. In this case
select the one that has a direct subclass rightmost in the class precedence list
computed so far. If there is no such candidate class, <i>R</i> does not generate a partial
ordering—the <span class="math">R<sub>c</sub></span>, <span class="math">c ∈ S<sub>C</sub></span>, are inconsistent.
<!--l. 901--><p class="indent" >   In more precise terms, let <span class="math">{N<sub>1</sub>,…,N<sub>m</sub>}</span>, <span class="math">m ≥ 2</span>, be the classes from <span class="math">S<sub>C</sub></span> with no
predecessors. Let <span class="math">(C<sub>1</sub>…C<sub>n</sub>)</span>, <span class="math">n ≥ 1</span>, be the class precedence list constructed so far.
<span class="math">C<sub>1</sub></span> is the most speciﬁc class, and <span class="math">C<sub>n</sub></span> is the least speciﬁc. Let <span class="math">1 ≤ j ≤ n</span> be the
largest number such that there exists an <i>i</i> where <span class="math">1 ≤ i ≤ m</span> and <span class="math">N<sub>i</sub></span> is a direct
superclass of <span class="math">C<sub>j</sub></span>; <span class="math">N<sub>i</sub></span> is placed next.
<!--l. 912--><p class="indent" >   The eﬀect of this rule for selecting from a set of classes with no predecessors is
that classes in a simple superclass chain are adjacent in the class precedence
list and that classes in each relatively separated subgraph are adjacent
in the class precedence list. For example, let <span class="math">T<sub>1</sub></span> and <span class="math">T<sub>2</sub></span> be subgraphs
whose only element in common is the class <i>J</i>. Suppose that no superclass
of <i>J</i> appears in either <span class="math">T<sub>1</sub></span> or <span class="math">T<sub>2</sub></span>. Let <span class="math">C<sub>1</sub></span> be the bottom of <span class="math">T<sub>1</sub></span>; and let
<span class="math">C<sub>2</sub></span> be the bottom of <span class="math">T<sub>2</sub></span>. Suppose <i>C</i> is a class whose direct superclasses
are <span class="math">C<sub>1</sub></span> and <span class="math">C<sub>2</sub></span> in that order; then the class precedence list for <i>C</i> will
start with <i>C</i> and will be followed by all classes in <span class="math">T<sub>1</sub></span> except <i>J</i>. All the
classes of <span class="math">T<sub>2</sub></span> will be next. The class <i>J</i> and its superclasses will appear
last.
<!--l. 927--><p class="noindent" >
                                                                          

                                                                          
   <h5 class="subsubsectionHead"><a 
href="#x171-36400027.1.5" id="x171-36400027.1.5">Examples</a></h5>
<!--l. 929--><p class="noindent" >This example determines a class precedence list for the class <tt>pie</tt>. The following
classes are deﬁned:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass pie (apple cinnamon) ())
</td></tr></table>
<!--l. 933--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass apple (fruit) ())</td></tr></table>
<!--l. 934--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass cinnamon (spice) ())</td></tr></table>
<!--l. 935--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass fruit (food) ())</td></tr></table>
<!--l. 936--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass spice (food) ())</td></tr></table>
<!--l. 937--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass food () ())</td></tr></table>
<!--l. 939--><p class="indent" >
</div>
</div>
<div class="flushleft" 
>
<!--l. 941--><p class="noindent" >
<!--l. 948--><p class="indent" >                                                                             The set
<span class="math">S = {<tt>pie</tt>,<tt>apple</tt>,<tt>cinnamon</tt>,<tt>fruit</tt>,<tt>spice</tt>,<tt>food</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>,<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>}</span>. The
set <span class="math">R =
{(<tt>pie</tt>,<tt>apple</tt>), (<tt>apple</tt>,<tt>cinnamon</tt>), (<tt>cinnamon</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>apple</tt>,<tt>fruit</tt>), (<tt>fruit</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>cinnamon</tt>,<tt>spice</tt>), (<tt>spice</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>fruit</tt>,<tt>food</tt>), (<tt>food</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>spice</tt>,<tt>food</tt>), (<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>,<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>)}</span>.
<!--l. 980--><p class="indent" >  [The original CLOS speciﬁcation <span class="cite">[<a 
href="clmli5.html#XSIGPLAN-CLOS">5</a>, <a 
href="clmli5.html#XLASC-CLOS-PART-1">6</a>]</span> contained a minor error in this
example: the pairs <span class="math">(<tt>cinnamon</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>)</span>,
<span class="math">(<tt>fruit</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>)</span>, and <span class="math">(<tt>spice</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>)</span> were
inadvertently omitted from <i>R</i> in the preceding paragraph. It is important to
understand that <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> implicitly appends the class <tt>standard-object</tt>
to the list of superclasses when the metaclass is <tt>standard-class</tt> (the
normal situation), in order to insure that <tt>standard-object</tt> will be a
superclass of every instance of <tt>standard-class</tt> except <tt>standard-object</tt>
itself (see section <a 
href="#x171-35100027.1.2">27.1.2<!--tex4ht:ref: Classes-SECTION --></a>). <span class="math">R<sub>c</sub></span> is then generated from this augmented list of
superclasses; this is where the extra pairs come from. I have corrected the
example by adding these pairs as appropriate throughout the example. The
                                                                          

                                                                          
ﬁnal result, the class precedence list for <tt>pie</tt>, is unchanged.—GLS]
<!--l. 1001--><p class="indent" >  The class <tt>pie</tt> is not preceded by anything, so it comes ﬁrst; the result so
far is <tt>(pie)</tt>. Remove <tt>pie</tt> from <i>S</i> and pairs mentioning <tt>pie</tt> from <i>R</i> to get
<span class="math">S = {<tt>apple</tt>,<tt>cinnamon</tt>,<tt>fruit</tt>,<tt>spice</tt>,<tt>food</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>,<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>}</span> and <span class="math">R =
{(<tt>apple</tt>,<tt>cinnamon</tt>), (<tt>cinnamon</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>apple</tt>,<tt>fruit</tt>), (<tt>fruit</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>cinnamon</tt>,<tt>spice</tt>), (<tt>spice</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>fruit</tt>,<tt>food</tt>), (<tt>food</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>spice</tt>,<tt>food</tt>), (<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>,<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>)}</span>.
<!--l. 1032--><p class="indent" >  The class <tt>apple</tt> is not preceded by anything, so it is next; the result is
<tt>(pie apple)</tt>. Removing <tt>apple</tt> and the relevant pairs results in
<span class="math">S = {<tt>cinnamon</tt>,<tt>fruit</tt>,<tt>spice</tt>,<tt>food</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>,<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>}</span> and <span class="math">R =
{(<tt>cinnamon</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>fruit</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>cinnamon</tt>,<tt>spice</tt>), (<tt>spice</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>fruit</tt>,<tt>food</tt>), (<tt>food</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>spice</tt>,<tt>food</tt>), (<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>,<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>)}</span>.
<!--l. 1056--><p class="indent" >  The classes <tt>cinnamon</tt> and <tt>fruit</tt> are not preceded by anything, so the
one with a direct subclass rightmost in the class precedence list computed
so far goes next. The class <tt>apple</tt> is a direct subclass of <tt>fruit</tt>, and the class
<tt>pie</tt> is a direct subclass of <tt>cinnamon</tt>. Because <tt>apple</tt> appears to the right of
<tt>pie</tt> in the precedence list, <tt>fruit</tt> goes next, and the result so far is <tt>(pie
apple fruit)</tt>. <span class="math">S = {<tt>cinnamon</tt>,<tt>spice</tt>,<tt>food</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>,<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>}</span>; <span class="math">R =
{(<tt>cinnamon</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>cinnamon</tt>,<tt>spice</tt>), (<tt>spice</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>food</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>spice</tt>,<tt>food</tt>), (<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>,<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>)}</span>.
<!--l. 1079--><p class="indent" >  The class <tt>cinnamon</tt> is next, giving the result so far as <tt>(pie apple fruit
cinnamon)</tt>. At this point <span class="math">S = {<tt>spice</tt>,<tt>food</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>,<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>}</span>; <span class="math">R =
{(<tt>spice</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>food</tt>,<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>), (<tt>spice</tt>,<tt>food</tt>), (<tt>standard<tt><a 
href="clmse104.html#x129-237008r571">-</a></tt>object</tt>,<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>)}</span>.</div>
<!--l. 1093--><p class="indent" >   The classes <tt>spice</tt>, <tt>food</tt>, <tt>standard-object</tt>, and <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> are then added in that
order, and the ﬁnal class precedence list for <tt>pie</tt> is <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pie apple fruit cinnamon spice food standard-object t)
</td></tr></table>
<!--l. 1097--><p class="indent" >
</div>
</div>
<!--l. 1099--><p class="indent" >   It is possible to write a set of class deﬁnitions that cannot be ordered. For
example:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass new-class (fruit apple) ())
</td></tr></table>
                                                                          

                                                                          
<!--l. 1103--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass apple (fruit) ())</td></tr></table>
<!--l. 1105--><p class="indent" >
</div>
</div>
<!--l. 1107--><p class="indent" >   The class <tt>fruit</tt> must precede <tt>apple</tt> because the local ordering of
superclasses must be preserved. The class <tt>apple</tt> must precede <tt>fruit</tt> because a
class always precedes its own superclasses. When this situation occurs, an
error is signaled when the system tries to compute the class precedence
list.
<!--l. 1113--><p class="indent" >   The following might appear to be a conﬂicting set of deﬁnitions:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass pie (apple cinnamon) ())
</td></tr></table>
<!--l. 1116--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass pastry (cinnamon apple) ())</td></tr></table>
<!--l. 1117--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass apple () ())</td></tr></table>
<!--l. 1118--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass cinnamon () ())</td></tr></table>
<!--l. 1120--><p class="indent" >
</div>
</div>
<!--l. 1122--><p class="indent" >   The class precedence list for <tt>pie</tt> is <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pie apple cinnamon standard-object t)
</td></tr></table>
<!--l. 1125--><p class="indent" >
</div>
</div>
<!--l. 1127--><p class="indent" >   The class precedence list for <tt>pastry</tt> is <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pastry cinnamon apple standard-object t)
</td></tr></table>
<!--l. 1130--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1132--><p class="indent" >   It is not a problem for <tt>apple</tt> to precede <tt>cinnamon</tt> in the ordering of
the superclasses of <tt>pie</tt> but not in the ordering for <tt>pastry</tt>. However, it
is not possible to build a new class that has both <tt>pie</tt> and <tt>pastry</tt> as
superclasses.
<!--l. 1138--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.6   </span> <a 
href="clmli1.html#QQ2-171-407" id="x171-36500027.1.6">Generic Functions and Methods</a></h4>
<!--l. 1140--><p class="noindent" >A <i>generic function</i> is a function whose behavior depends on the classes or
identities of the arguments supplied to it. The <i>methods</i> deﬁne the class-speciﬁc
behavior and operations of the generic function. The following sections describe
generic functions and methods.
<!--l. 1146--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-36600027.1.6" id="x171-36600027.1.6">Introduction to Generic Functions</a></h5>
<!--l. 1148--><p class="noindent" >A generic function object contains a set of methods, a lambda-list, a method
combination type, and other information.
<!--l. 1151--><p class="indent" >   Like an ordinary Lisp function, a generic function takes arguments, performs a
series of operations, and perhaps returns useful values. An ordinary function
has a single body of code that is always executed when the function is
called. A generic function has a set of bodies of code of which a subset is
selected for execution. The selected bodies of code and the manner of their
combination are determined by the classes or identities of one or more of
the arguments to the generic function and by its method combination
type.
<!--l. 1160--><p class="indent" >   Ordinary functions and generic functions are called with identical function-call
syntax.
<!--l. 1163--><p class="indent" >   Generic functions are true functions that can be passed as arguments, returned
as values, used as the ﬁrst argument to <tt><a 
href="clmse36.html#x48-94004r69">funcall</a></tt> and <tt><a 
href="clmse36.html#x48-94002r68">apply</a></tt>, and otherwise used in
all the ways an ordinary function may be used.
<!--l. 1167--><p class="indent" >   A name can be given to an ordinary function in one of two ways: a <i>global</i> name
can be given to a function using the <tt><a 
href="clmse29.html#x39-66002r13">defun</a></tt> construct; a <i>local</i> name can be given
using the <tt><a 
href="clmse38.html#x50-102002r77">flet</a></tt> or <tt><a 
href="clmse38.html#x50-102004r78">labels</a></tt> special forms. A generic function can be given a global
name using the <tt><a 
href="clmse140.html#x172-403002r839">defmethod</a></tt> or <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt> construct. A generic function
                                                                          

                                                                          
can be given a local name using the <tt><a 
href="clmse140.html#x172-404048r862">generic-flet</a></tt>, <tt><a 
href="clmse140.html#x172-406002r864">generic-labels</a></tt>, or
<tt><a 
href="clmse140.html#x172-408004r903">with-added-methods</a></tt> special forms. The name of a generic function, like the name
of an ordinary function, can be either a symbol or a two-element list whose ﬁrst
element is <tt><a 
href="clmse35.html#x47-89002r64">setf</a></tt> and whose second element is a symbol. This is true for both local
and global names.
<!--l. 1179--><p class="indent" >   The <tt><a 
href="clmse140.html#x172-404048r862">generic-flet</a></tt> special form creates new local generic functions using the
set of methods speciﬁed by the method deﬁnitions in the <tt><a 
href="clmse140.html#x172-404048r862">generic-flet</a></tt> form. The
scoping of generic function names within a <tt><a 
href="clmse140.html#x172-404048r862">generic-flet</a></tt> form is the same as for
<tt><a 
href="clmse38.html#x50-102002r77">flet</a></tt>.
<!--l. 1184--><p class="indent" >   The <tt><a 
href="clmse140.html#x172-406002r864">generic-labels</a></tt> special form creates a set of new mutually recursive local
generic functions using the set of methods speciﬁed by the method deﬁnitions in
the <tt><a 
href="clmse140.html#x172-406002r864">generic-labels</a></tt> form. The scoping of generic function names within a
<tt><a 
href="clmse140.html#x172-406002r864">generic-labels</a></tt> form is the same as for <tt><a 
href="clmse38.html#x50-102004r78">labels</a></tt>.
<!--l. 1190--><p class="indent" >   The <tt><a 
href="clmse140.html#x172-408004r903">with-added-methods</a></tt> special form creates new local generic functions by
adding the set of methods speciﬁed by the method deﬁnitions with a given name
in the <tt><a 
href="clmse140.html#x172-408004r903">with-added-methods</a></tt> form to copies of the methods of the lexically visible
generic function of the same name. If there is a lexically visible ordinary function
of the same name as one of the speciﬁed generic functions, that function becomes
the method function of the default method for the new generic function of that
name.
<!--l. 1199--><p class="indent" >   The <tt><a 
href="clmse140.html#x172-405002r863">generic-function</a></tt> macro creates an anonymous generic function with
the set of methods speciﬁed by the method deﬁnitions that appear in the
<tt>generic-function</tt> form.
<!--l. 1203--><p class="indent" >   When a <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt> form is evaluated, one of three actions is taken:
      <ul class="itemize1">
      <li class="itemize">If a generic function of the given name already exists, the existing
      generic function object is modiﬁed. Methods speciﬁed by the current
      <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt> form are added, and any methods in the existing generic
      function that were deﬁned by a previous <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt> form are removed.
      Methods added by the current <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt> form might replace methods
      deﬁned by <tt><a 
href="clmse140.html#x172-403002r839">defmethod</a></tt> or <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt>. No other methods in the generic
      function are aﬀected or replaced.
      </li>
      <li class="itemize">If the given name names a non-generic function, a macro, or a special
      form, an error is signaled.
                                                                          

                                                                          
      </li>
      <li class="itemize">Otherwise a generic function is created with the methods speciﬁed by
      the method deﬁnitions in the <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt> form.
      </li></ul>
<!--l. 1226--><p class="indent" >   Some forms specify the options of a generic function, such as the type of
method combination it uses or its argument precedence order. They will be
referred to as “forms that specify generic function options.” These forms are
<tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt>, <tt><a 
href="clmse140.html#x172-405002r863">generic-function</a></tt>, <tt><a 
href="clmse140.html#x172-404048r862">generic-flet</a></tt>, <tt><a 
href="clmse140.html#x172-406002r864">generic-labels</a></tt>, and
<tt><a 
href="clmse140.html#x172-408004r903">with-added-methods</a></tt>.
<!--l. 1233--><p class="indent" >   Some forms deﬁne methods for a generic function. They will be referred to
as “method-deﬁning forms.” These forms are <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt>, <tt><a 
href="clmse140.html#x172-403002r839">defmethod</a></tt>,
<tt><a 
href="clmse140.html#x172-405002r863">generic-function</a></tt>, <tt><a 
href="clmse140.html#x172-404048r862">generic-flet</a></tt>, <tt><a 
href="clmse140.html#x172-406002r864">generic-labels</a></tt>, <tt><a 
href="clmse140.html#x172-408004r903">with-added-methods</a></tt>, and
<tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt>. Note that all the method-deﬁning forms except <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> and
<tt><a 
href="clmse140.html#x172-403002r839">defmethod</a></tt> are also forms that specify generic function options.
<!--l. 1241--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-36700027.1.6" id="x171-36700027.1.6">Introduction to Methods</a></h5>
<!--l. 1244--><p class="noindent" >A method object contains a method function, a sequence of <i> parameter
specializers</i> that specify when the given method is applicable, a lambda-list, and a
sequence of <i>qualiﬁers</i> that are used by the method combination facility to
distinguish among methods.
<!--l. 1250--><p class="indent" >   A method object is not a function and cannot be invoked as a function.
Various mechanisms in the Объектная система take a method object
and invoke its method function, as is the case when a generic function
is invoked. When this occurs it is said that the method is invoked or
called.
<!--l. 1255--><p class="indent" >   A method-deﬁning form contains the code that is to be run when the
arguments to the generic function cause the method that it deﬁnes to be invoked.
When a method-deﬁning form is evaluated, a method object is created and one of
four actions is taken:
      <ul class="itemize1">
      <li class="itemize">If a generic function of the given name already exists and if a method
      object  already  exists  that  agrees  with  the  new  one  on  parameter
      specializers and qualiﬁers, the new method object replaces the old one.
                                                                          

                                                                          
      For a deﬁnition of one method agreeing with another on parameter
      specializers and qualiﬁers, see section <a 
href="#x171-36800027.1.6">27.1.6<!--tex4ht:ref: Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION --></a>.
      </li>
      <li class="itemize">If a generic function of the given name already exists and if there is no
      method object that agrees with the new one on parameter specializers
      and qualiﬁers, the existing generic function object is modiﬁed to contain
      the new method object.
      </li>
      <li class="itemize">If the given name names a non-generic function, a macro, or a special
      form, an error is signaled.
      </li>
      <li class="itemize">Otherwise a generic function is created with the methods speciﬁed by
      the method-deﬁning form.
      </li></ul>
<!--l. 1282--><p class="indent" >   If the lambda-list of a new method is not congruent with the lambda-list of the
generic function, an error is signaled. If a method-deﬁning form that cannot
specify generic function options creates a new generic function, a lambda-list for
that generic function is derived from the lambda-lists of the methods in the
method-deﬁning form in such a way as to be congruent with them. For a
discussion of <i>congruence</i>, see section <a 
href="#x171-36900027.1.6">27.1.6<!--tex4ht:ref: Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION --></a>.
<!--l. 1291--><p class="indent" >   Each method has a <i>specialized lambda-list</i>, which determines when that
method can be applied. A specialized lambda-list is like an ordinary lambda-list
except that a <i>specialized parameter</i> may occur instead of the name of a
required parameter. A specialized parameter is a list <tt>(<i>variable-name
parameter-specializer-name</i>)</tt>, where <i>parameter-specializer-name</i> is either a
name that names a class or a list <tt>(<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> <i>form</i>)</tt>. A parameter specializer name
denotes a parameter specializer as follows:
      <ul class="itemize1">
      <li class="itemize">A name that names a class denotes that class.
      </li>
      <li class="itemize">The list <tt>(<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> <i>form</i>)</tt> denotes the type speciﬁer <tt>(<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> <i>object</i>)</tt>, where
      <i>object</i> is the result of evaluating <i>form</i>. The form <i>form</i> is evaluated in
                                                                          

                                                                          
      the lexical environment in which the method-deﬁning form is evaluated.
      Note  that  <i>form</i> is  evaluated  only  once,  at  the  time  the  method  is
      deﬁned, not each time the generic function is called.</li></ul>
<!--l. 1311--><p class="indent" >   Parameter specializer names are used in macros intended as the user-level
interface (<tt><a 
href="clmse140.html#x172-403002r839">defmethod</a></tt>), while parameter specializers are used in the functional
interface.
<!--l. 1315--><p class="indent" >   [It is very important to understand clearly the distinction made in the
preceding paragraph. A parameter specializer name has the form of a type
speciﬁer but is semantically quite diﬀerent from a type speciﬁer: a parameter
specializer name of the form <tt>(<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> <i>form</i>)</tt> is not a type speciﬁer, for it contains a
<i>form</i> to be evaluated. Type speciﬁers never contain forms to be evaluated.
All parameter specializers (as opposed to parameter specializer names)
are valid type speciﬁers, but not all type speciﬁers are valid parameter
specializers. Macros such as <tt><a 
href="clmse140.html#x172-403002r839">defmethod</a></tt> take parameter specializer names
and treat them as speciﬁcations for constructing certain type speciﬁers
(parameter specializers) that may then be used with such functions as
<tt><a 
href="clmse140.html#x172-404042r859">find-method</a></tt>.—GLS]
<!--l. 1329--><p class="indent" >   Only required parameters may be specialized, and there must be a parameter
specializer for each required parameter. For notational simplicity, if some required
parameter in a specialized lambda-list in a method-deﬁning form is simply
a variable name, its parameter specializer defaults to the class named
<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>.
<!--l. 1335--><p class="indent" >   Given a generic function and a set of arguments, an <i>applicable method</i> is a
method for that generic function whose parameter specializers are satisﬁed by
their corresponding arguments. The following deﬁnition speciﬁes what it means
for a method to be applicable and for an argument to satisfy a parameter
specializer.
<!--l. 1341--><p class="indent" >   Let <span class="math">⟨A<sub>1</sub>,…,A<sub>n</sub>⟩</span> be the required arguments to a generic function in
order. Let <span class="math">⟨P<sub>1</sub>,…,P<sub>n</sub>⟩</span> be the parameter specializers corresponding to the
required parameters of the method <i>M</i> in order. The method <i>M</i> is <i>applicable</i>
when each <span class="math">A<sub>i</sub></span> <i>satisﬁes</i> <span class="math">P<sub>i</sub></span>. If <span class="math">P<sub>i</sub></span> is a class, and if <span class="math">A<sub>i</sub></span> is an instance of
a class <i>C</i>, then it is said that <span class="math">A<sub>i</sub></span> <i>satisﬁes</i> <span class="math">P<sub>i</sub></span> when <span class="math">C = P<sub>i</sub></span> or when C
is a subclass of <span class="math">P<sub>i</sub></span>. If <span class="math">P<sub>i</sub></span> is of the form <tt>(<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> <i>object</i>)</tt>, then it is said
that <span class="math">A<sub>i</sub></span> satisﬁes <span class="math">P<sub>i</sub></span> when the function <tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> applied to <span class="math">A<sub>i</sub></span> and <i>object</i> is
true.
<!--l. 1357--><p class="indent" >   Because a parameter specializer is a type speciﬁer, the function <tt><a 
href="clmse31.html#x42-75002r20">typep</a></tt> can be
used during method selection to determine whether an argument satisﬁes a
                                                                          

                                                                          
parameter specializer. In general a parameter specializer cannot be a type speciﬁer
list, such as <tt>(<tt>vector single-float</tt>)</tt>. The only parameter specializer that can be
a list is <tt>(<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> <i>object</i>)</tt>. This requires that Common Lisp deﬁne the type speciﬁer
<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> as if the following were evaluated:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deftype eql (<i>object</i>) ‘(member ,<i>object</i>))
</td></tr></table>
<!--l. 1368--><p class="indent" >
</div>
</div>
<!--l. 1369--><p class="noindent" >[See section <a 
href="clmse19.html#x28-460004.3">4.3<!--tex4ht:ref: PREDICATING-TYPE-SPECIFIERS-SECTION --></a>.—GLS]
<!--l. 1371--><p class="indent" >   A method all of whose parameter specializers are the class named <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> is called a
<i>default method</i>; it is always applicable but may be shadowed by a more speciﬁc
method.
<!--l. 1375--><p class="indent" >   Methods can have <i>qualiﬁers</i>, which give the method combination procedure a
way to distinguish among methods. A method that has one or more qualiﬁers is
called a <i>qualiﬁed</i> method. A method with no qualiﬁers is called an <i>unqualiﬁed
method</i>. A qualiﬁer is any object other than a list, that is, any non-<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> atom. The
qualiﬁers deﬁned by standard method combination and by the built-in method
combination types are symbols.
<!--l. 1383--><p class="indent" >   In this speciﬁcation, the terms <i>primary method</i> and <i> auxiliary method</i> are used
to partition methods within a method combination type according to their
intended use. In standard method combination, primary methods are unqualiﬁed
methods, and auxiliary methods are methods with a single qualiﬁer that is one of
<tt>:around</tt>, <tt>:before</tt>, or <tt>:after</tt>. When a method combination type is deﬁned using
the short form of <tt><a 
href="clmse140.html#x172-402005r838">define-method-combination</a></tt>, primary methods are methods
qualiﬁed with the name of the type of method combination, and auxiliary
methods have the qualiﬁer <tt>:around</tt>. Thus the terms <i>primary method</i> and
<i>auxiliary method</i> have only a relative deﬁnition within a given method
combination type.
<!--l. 1396--><p class="noindent" >
                                                                          

                                                                          
   <h5 class="subsubsectionHead"><a 
href="#x171-36800027.1.6" id="x171-36800027.1.6">Agreement on Parameter Specializers and Qualiﬁers</a></h5>
<!--l. 1399--><p class="noindent" >Two methods are said to agree with each other on parameter specializers and
qualiﬁers if the following conditions hold:
      <ul class="itemize1">
      <li class="itemize">Both methods have the same number of required parameters. Suppose
      the  parameter  specializers  of  the  two  methods  are  <span class="math">P<sub>1,1</sub>…P<sub>1,n</sub></span>  and
      <span class="math">P<sub>2,1</sub>…P<sub>2,n</sub></span>.
      </li>
      <li class="itemize">For each <span class="math">1 ≤ i ≤ n</span>, <span class="math">P<sub>1,i</sub></span> agrees with <span class="math">P<sub>2,i</sub></span>. The parameter specializer
      <span class="math">P<sub>1,i</sub></span>  agrees with <span class="math">P<sub>2,i</sub></span>  if <span class="math">P<sub>1,i</sub></span>  and <span class="math">P<sub>2,i</sub></span>  are the same class or if <span class="math">P<sub>1,i</sub>  =
      <tt>(<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> object<sub>1</sub>)</tt></span>,  <span class="math">P<sub>2,i</sub>   =   <tt>(<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> object<sub>2</sub>)</tt></span>,  and  <tt>(<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> <span class="math">object<sub>1</sub></span>  <span class="math">object<sub>2</sub></span>)</tt>.
      Otherwise <span class="math">P<sub>1,i</sub></span> and <span class="math">P<sub>2,i</sub></span> do not agree.
      </li>
      <li class="itemize">The lists of qualiﬁers of both methods contain the same non-<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> atoms
      in the same order. That is, the lists are <tt><a 
href="clmse32.html#x43-77006r46">equal</a></tt>.
      </li></ul>
<!--l. 1426--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-36900027.1.6" id="x171-36900027.1.6">Congruent Lambda-Lists for All Methods of a Generic Function</a></h5>
<!--l. 1429--><p class="noindent" >These rules deﬁne the congruence of a set of lambda-lists, including the
lambda-list of each method for a given generic function and the lambda-list
speciﬁed for the generic function itself, if given.
      <ul class="itemize1">
      <li class="itemize">Each lambda-list must have the same number of required parameters.
      </li>
      <li class="itemize">Each lambda-list must have the same number of optional parameters.
      Each method can supply its own default for an optional parameter.
      </li>
      <li class="itemize">If  any  lambda-list  mentions  <tt>&#x0026;rest</tt> or  <tt>&#x0026;key</tt>,  each  lambda-list  must
      mention one or both of them.
                                                                          

                                                                          
      </li>
      <li class="itemize">If the generic function lambda-list mentions <tt>&#x0026;key</tt>, each method must
      accept  all  of  the  keyword  names  mentioned  after  <tt>&#x0026;key</tt>,  either  by
      accepting  them  explicitly,  by  specifying  <tt>&#x0026;allow-other-keys</tt>,  or  by
      specifying <tt>&#x0026;rest</tt> but not <tt>&#x0026;key</tt>. Each method can accept additional
      keyword arguments of its own. The checking of the validity of keyword
      names  is  done  in  the  generic  function,  not  in  each  method.  A
      method is invoked as if the keyword argument pair whose keyword is
      <tt>:allow-other-keys</tt> and whose value is <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> were supplied, though no
      such argument pair will be passed.
      </li>
      <li class="itemize">The  use  of  <tt>&#x0026;allow-other-keys</tt>  need  not  be  consistent  across
      lambda-lists. If <tt>&#x0026;allow-other-keys</tt> is mentioned in the lambda-list
      of  any  applicable  method  or  of  the  generic  function,  any  keyword
      arguments may be mentioned in the call to the generic function.
      </li>
      <li class="itemize">The use of <tt>&#x0026;aux</tt> need not be consistent across methods.</li></ul>
<!--l. 1465--><p class="indent" >   If a method-deﬁning form that cannot specify generic function options creates
a generic function, and if the lambda-list for the method mentions keyword
arguments, the lambda-list of the generic function will mention <tt>&#x0026;key</tt> (but no
keyword arguments).
<!--l. 1471--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-37000027.1.6" id="x171-37000027.1.6">Keyword Arguments in Generic Functions and Methods</a></h5>
<!--l. 1473--><p class="noindent" >When a generic function or any of its methods mentions <tt>&#x0026;key</tt> in a lambda-list,
the speciﬁc set of keyword arguments accepted by the generic function varies
according to the applicable methods. The set of keyword arguments accepted by
the generic function for a particular call is the union of the keyword arguments
accepted by all applicable methods and the keyword arguments mentioned after
<tt>&#x0026;key</tt> in the generic function deﬁnition, if any. A method that has <tt>&#x0026;rest</tt> but not
<tt>&#x0026;key</tt> does not aﬀect the set of acceptable keyword arguments. If the lambda-list
of any applicable method or of the generic function deﬁnition contains
<tt>&#x0026;allow-other-keys</tt>, all keyword arguments are accepted by the generic
function.
                                                                          

                                                                          
<!--l. 1485--><p class="indent" >   The lambda-list congruence rules require that each method accept all of the
keyword arguments mentioned after <tt>&#x0026;key</tt> in the generic function deﬁnition, by
accepting them explicitly, by specifying <tt>&#x0026;allow-other-keys</tt>, or by specifying
<tt>&#x0026;rest</tt> but not <tt>&#x0026;key</tt>. Each method can accept additional keyword arguments of its
own, in addition to the keyword arguments mentioned in the generic function
deﬁnition.
                                                                          

                                                                          
<!--l. 1495--><p class="indent" >   If a generic function is passed a keyword argument that no applicable method
accepts, an error is signaled.
<!--l. 1498--><p class="indent" >   For example, suppose there are two methods deﬁned for <tt>width</tt> as
follows:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod width ((c character-class) &#x0026;key font) ...)
</td></tr></table>
<!--l. 1502--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1503--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod width ((p picture-class) &#x0026;key pixel-size) ...)</td></tr></table>
<!--l. 1505--><p class="indent" >
</div>
</div>
<!--l. 1507--><p class="noindent" >Assume that there are no other methods and no generic function deﬁnition for
<tt>width</tt>. The evaluation of the following form will signal an error because
the keyword argument <tt>:pixel-size</tt> is not accepted by the applicable
method.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(width (make-instance &#x2019;character-class :char #\Q)
</td></tr></table>
<!--l. 1513--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :font &#x2019;baskerville :pixel-size 10)</td></tr></table>
<!--l. 1515--><p class="indent" >
</div>
</div>
<!--l. 1517--><p class="indent" >   The evaluation of the following form will signal an error.
<div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(width (make-instance &#x2019;picture-class :glyph (glyph #\Q))
</td></tr></table>
<!--l. 1520--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :font &#x2019;baskerville :pixel-size 10)</td></tr></table>
<!--l. 1522--><p class="indent" >
</div>
</div>
<!--l. 1524--><p class="indent" >   The evaluation of the following form will not signal an error if the class named
<tt>character-picture-class</tt> is a subclass of both <tt>picture-class</tt> and
<tt>character-class</tt>.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(width (make-instance &#x2019;character-picture-class :char #\Q)
</td></tr></table>
<!--l. 1529--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :font &#x2019;baskerville :pixel-size 10)</td></tr></table>
<!--l. 1531--><p class="indent" >
</div>
</div>
<!--l. 1534--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.7   </span> <a 
href="clmli1.html#QQ2-171-413" id="x171-37100027.1.7">Method Selection and Combination</a></h4>
<!--l. 1537--><p class="noindent" >When a generic function is called with particular arguments, it must determine
the code to execute. This code is called the <i>eﬀective method</i> for those arguments.
The eﬀective method is a <i> combination</i> of the applicable methods in the
generic function. A combination of methods is a Lisp expression that
contains calls to some or all of the methods. If a generic function is called
and no methods apply, the generic function <tt><a 
href="clmse140.html#x172-407030r879">no-applicable-method</a></tt> is
invoked.
<!--l. 1546--><p class="indent" >   When the eﬀective method has been determined, it is invoked with the same
arguments that were passed to the generic function. Whatever values it returns
are returned as the values of the generic function.
                                                                          

                                                                          
<!--l. 1550--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-37200027.1.7" id="x171-37200027.1.7">Determining the Eﬀective Method</a></h5>
<!--l. 1553--><p class="noindent" >The eﬀective method for a set of arguments is determined by the following
three-step procedure:
<!--l. 1556--><p class="indent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x171-372002x1">Select the applicable methods.
      </li>
      <li 
  class="enumerate" id="x171-372004x2">Sort the applicable methods by precedence order, putting the most
      speciﬁc method ﬁrst.
      </li>
      <li 
  class="enumerate" id="x171-372006x3">Apply method combination to the sorted list of applicable methods,
      producing the eﬀective method.
      </li></ol>
<b>
<!--l. 1568--><p class="indent" >   Selecting the Applicable Methods.</b> This step is described in
section <a 
href="#x171-36700027.1.6">27.1.6<!--tex4ht:ref: Introduction-to-Methods-SECTION --></a>.
<b>
<!--l. 1572--><p class="indent" >   Sorting the Applicable Methods by Precedence Order.</b> To compare the
precedence of two methods, their parameter specializers are examined in order.
The default examination order is from left to right, but an alternative
order may be speciﬁed by the <tt>:argument-precedence-order</tt> option to
<tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt> or to any of the other forms that specify generic function
options.
<!--l. 1579--><p class="indent" >   The corresponding parameter specializers from each method are compared.
When a pair of parameter specializers are equal, the next pair are compared for
equality. If all corresponding parameter specializers are equal, the two methods
must have diﬀerent qualiﬁers; in this case, either method can be selected to
precede the other.
<!--l. 1586--><p class="indent" >   If some corresponding parameter specializers are not equal, the ﬁrst pair of
parameter specializers that are not equal determines the precedence. If both
parameter specializers are classes, the more speciﬁc of the two methods
is the method whose parameter specializer appears earlier in the class
precedence list of the corresponding argument. Because of the way in which
the set of applicable methods is chosen, the parameter specializers are
                                                                          

                                                                          
guaranteed to be present in the class precedence list of the class of the
argument.
<!--l. 1595--><p class="indent" >   If just one parameter specializer is <tt>(<tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> object)</tt>, the method with that
parameter specializer precedes the other method. If both parameter specializers
are <tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt> forms, the specializers must be the same (otherwise the two methods
would not both have been applicable to this argument).
<!--l. 1602--><p class="indent" >   The resulting list of applicable methods has the most speciﬁc method ﬁrst and
the least speciﬁc method last.
<b>
<!--l. 1605--><p class="indent" >   Applying Method Combination to the Sorted List of Applicable
Methods.</b> In the simple case—if standard method combination is used and all
applicable methods are primary methods—the eﬀective method is the most
speciﬁc method. That method can call the next most speciﬁc method by using the
function <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt>. The method that <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> will call
is referred to as the <i>next method</i>. The predicate <tt><a 
href="clmse140.html#x172-407026r877">next-method-p</a></tt> tests
whether a next method exists. If <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> is called and there is
no next most speciﬁc method, the generic function <tt><a 
href="clmse140.html#x172-407034r881">no-next-method</a></tt> is
invoked.
<!--l. 1616--><p class="indent" >   In general, the eﬀective method is some combination of the applicable
methods. It is deﬁned by a Lisp form that contains calls to some or all of the
applicable methods, returns the value or values that will be returned as the value
or values of the generic function, and optionally makes some of the methods
accessible by means of <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt>. This Lisp form is the body of the
eﬀective method; it is augmented with an appropriate lambda-list to make it a
function.
<!--l. 1624--><p class="indent" >   The role of each method in the eﬀective method is determined by its method
qualiﬁers and the speciﬁcity of the method. A qualiﬁer serves to mark a method,
and the meaning of a qualiﬁer is determined by the way that these marks are used
by this step of the procedure. If an applicable method has an unrecognized
qualiﬁer, this step signals an error and does not include that method in the
eﬀective method.
<!--l. 1632--><p class="indent" >   When standard method combination is used together with qualiﬁed methods,
the eﬀective method is produced as described in section <a 
href="#x171-37300027.1.7">27.1.7<!--tex4ht:ref: Standard-Method-Combination-SECTION --></a>.
<!--l. 1636--><p class="indent" >   Another type of method combination can be speciﬁed by using the
<tt>:method-combination</tt> option of <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt> or of any of the other forms that
specify generic function options. In this way this step of the procedure can be
customized.
<!--l. 1641--><p class="indent" >   New types of method combination can be deﬁned by using the
                                                                          

                                                                          
<tt><a 
href="clmse140.html#x172-402005r838">define-method-combination</a></tt> macro.
<!--l. 1645--><p class="indent" >   The meta-object level also oﬀers a mechanism for deﬁning new types of
method combination. The generic function <tt>compute-effective-method</tt> receives
as arguments the generic function, the method combination object, and the sorted
list of applicable methods. It returns the Lisp form that deﬁnes the eﬀective
method. A method for <tt>compute-effective-method</tt> can be deﬁned directly by
using <tt><a 
href="clmse140.html#x172-403002r839">defmethod</a></tt> or indirectly by using <tt><a 
href="clmse140.html#x172-402005r838">define-method-combination</a></tt>. A <i>method
combination object</i> is an object that encapsulates the method combination type
and options speciﬁed by the <tt>:method-combination</tt> option to forms that specify
generic function options.
<div class=implementation>
<!--l. 1661--><p class="noindent" ><b>Заметка для реализации:</b> In the simplest implementation, the generic function
would compute the eﬀective method each time it was called. In practice, this will be too
ineﬃcient for some implementations. Instead, these implementations might employ a
variety of optimizations of the three-step procedure. Some illustrative examples of such
optimizations are the following:
      <ul class="itemize1">
      <li class="itemize">Use a hash table keyed by the class of the arguments to store the eﬀective
      method.
      </li>
      <li class="itemize">Compile the eﬀective method and save the resulting compiled function in a
      table.
      </li>
      <li class="itemize">Recognize the Lisp form as an instance of a pattern of control structure and
      substitute a closure that implements that structure.
      </li>
      <li class="itemize">Examine the parameter specializers of all methods for the generic function
      and enumerate all possible eﬀective methods. Combine the eﬀective methods,
      together with code to select from among them, into a single function and
      compile that function. Call that function whenever the generic function is
      called.</li></ul>
</div>
                                                                          

                                                                          
<!--l. 1691--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-37300027.1.7" id="x171-37300027.1.7">Standard Method Combination</a></h5>
<!--l. 1694--><p class="noindent" >Standard method combination is supported by the class <tt>standard-generic-function</tt>.
It is used if no other type of method combination is speciﬁed or if the built-in
method combination type <tt>standard</tt> is speciﬁed.
<i>
<!--l. 1700--><p class="indent" >   Primary methods</i> deﬁne the main action of the eﬀective method, while
<i>auxiliary methods</i> modify that action in one of three ways. A primary method has
no method qualiﬁers.
<!--l. 1704--><p class="indent" >   An auxiliary method is a method whose method qualiﬁer is <tt>:before</tt>, <tt>:after</tt>,
or <tt>:around</tt>. Standard method combination allows no more than one qualiﬁer per
method; if a method deﬁnition speciﬁes more than one qualiﬁer per method, an
error is signaled.
      <ul class="itemize1">
      <li class="itemize">A <tt>:before</tt> method has the keyword <tt>:before</tt> as its only qualiﬁer. A
      <tt>:before</tt> method speciﬁes code that is to be run before any primary
      method.
      </li>
      <li class="itemize">An <tt>:after</tt> method has the keyword <tt>:after</tt> as its only qualiﬁer. An
      <tt>:after</tt> method speciﬁes code that is to be run after primary methods.
      </li>
      <li class="itemize">An <tt>:around</tt> method has the keyword <tt>:around</tt> as its only qualiﬁer.
      An <tt>:around</tt> method speciﬁes code that is to be run instead of other
      applicable methods but that is able to cause some of them to be run.
      </li></ul>
<!--l. 1728--><p class="noindent" >The semantics of standard method combination are as follows:
      <ul class="itemize1">
      <li class="itemize">If there are any <tt>:around</tt> methods, the most speciﬁc <tt>:around</tt> method
      is called. It supplies the value or values of the generic function.
      </li>
      <li class="itemize">Inside the body of an <tt>:around</tt> method, <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> can be
                                                                          

                                                                          
      used to call the next method. When the next method returns, the
      <tt>:around</tt> method can execute more code, perhaps based on the returned
      value or values. The generic function <tt><a 
href="clmse140.html#x172-407034r881">no-next-method</a></tt> is invoked if
      <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> is used and there is no applicable method to call.
      The function <tt><a 
href="clmse140.html#x172-407026r877">next-method-p</a></tt> may be used to determine whether a next
      method exists.
      </li>
      <li class="itemize">If  an  <tt>:around</tt> method  invokes  <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt>,  the  next  most
      speciﬁc <tt>:around</tt> method is called, if one is applicable. If there are no
      <tt>:around</tt> methods or if <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> is called by the least speciﬁc
      <tt>:around</tt> method, the other methods are called as follows:
           <ul class="itemize2">
           <li class="itemize">All the <tt>:before</tt> methods are called, in most-speciﬁc-ﬁrst order.
           Their values are ignored. An error is signaled if <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt>
           is used in a <tt>:before</tt> method.
           </li>
           <li class="itemize">The most speciﬁc primary method is called. Inside the body of
           a primary method, <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> may be used to call the
           next most speciﬁc primary method. When that method returns,
           the  previous  primary  method  can  execute  more  code,  perhaps
           based  on  the  returned  value  or  values.  The  generic  function
           <tt><a 
href="clmse140.html#x172-407034r881">no-next-method</a></tt> is  invoked  if  <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> is  used  and
           there  are  no  more  applicable  primary  methods.  The  function
           <tt><a 
href="clmse140.html#x172-407026r877">next-method-p</a></tt> may be used to determine whether a next method
           exists. If <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> is not used, only the most speciﬁc
           primary method is called.
           </li>
           <li class="itemize">All  the  <tt>:after</tt> methods  are  called  in  most-speciﬁc-last  order.
           Their values are ignored. An error is signaled if <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt>
           is used in an <tt>:after</tt> method.</li></ul>
      </li>
      <li class="itemize">If no <tt>:around</tt> methods were invoked, the most speciﬁc primary method
      supplies the value or values returned by the generic function. The value or
      values returned by the invocation of <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> in the least speciﬁc
                                                                          

                                                                          
      <tt>:around</tt> method are those returned by the most speciﬁc primary
      method.
      </li></ul>
<!--l. 1783--><p class="indent" >   In standard method combination, if there is an applicable method but no
applicable primary method, an error is signaled.
<!--l. 1786--><p class="indent" >   The <tt>:before</tt> methods are run in most-speciﬁc-ﬁrst order and the <tt>:after</tt>
methods are run in least-speciﬁc-ﬁrst order. The design rationale for this
diﬀerence can be illustrated with an example. Suppose class <span class="math">C<sub>1</sub></span> modiﬁes the
behavior of its superclass, <span class="math">C<sub>2</sub></span>, by adding <tt>:before</tt> and <tt>:after</tt> methods. Whether
the behavior of the class <span class="math">C<sub>2</sub></span> is deﬁned directly by methods on <span class="math">C<sub>2</sub></span> or is inherited
from its superclasses does not aﬀect the relative order of invocation of methods on
instances of the class <span class="math">C<sub>1</sub></span>. Class <span class="math">C<sub>1</sub></span>&#x2019;s <tt>:before</tt> method runs before all of
class <span class="math">C<sub>2</sub></span>&#x2019;s methods. Class <span class="math">C<sub>1</sub></span>&#x2019;s <tt>:after</tt> method runs after all of class <span class="math">C<sub>2</sub></span>&#x2019;s
methods.
<!--l. 1798--><p class="indent" >   By contrast, all <tt>:around</tt> methods run before any other methods run.
Thus a less speciﬁc <tt>:around</tt> method runs before a more speciﬁc primary
method.
<!--l. 1802--><p class="indent" >   If only primary methods are used and if <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> is not used, only
the most speciﬁc method is invoked; that is, more speciﬁc methods shadow more
general ones.
<!--l. 1806--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-37400027.1.7" id="x171-37400027.1.7">Declarative Method Combination</a></h5>
<!--l. 1808--><p class="noindent" >The macro <tt><a 
href="clmse140.html#x172-402005r838">define-method-combination</a></tt> deﬁnes new forms of method
combination. It provides a mechanism for customizing the production of the
eﬀective method. The default procedure for producing an eﬀective method is
described in section <a 
href="#x171-37200027.1.7">27.1.7<!--tex4ht:ref: Determining-the-Effective-Method-SECTION --></a>. There are two forms of <tt><a 
href="clmse140.html#x172-402005r838">define-method-combination</a></tt>.
The short form is a simple facility; the long form is more powerful and more
verbose. The long form resembles <tt><a 
href="clmse44.html#x57-143004r118">defmacro</a></tt> in that the body is an expression that
computes a Lisp form; it provides mechanisms for implementing arbitrary control
structures within method combination and for arbitrary processing of method
qualiﬁers. The syntax and use of both forms of <tt><a 
href="clmse140.html#x172-402005r838">define-method-combination</a></tt> are
explained in section <a 
href="clmse140.html#x172-39900027.2">27.2<!--tex4ht:ref: Functions-in-the-Programmer-Interface-SECTION --></a>.
                                                                          

                                                                          
<!--l. 1824--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-37500027.1.7" id="x171-37500027.1.7">Built-in Method Combination Types</a></h5>
<!--l. 1827--><p class="noindent" >The Объектная система Common Lisp&#x2019;а provides a set of built-in method
combination types. To specify that a generic function is to use one of these
method combination types, the name of the method combination type is given as
the argument to the <tt>:method-combination</tt> option to <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt> or to the
<tt>:method-combination</tt> option to any of the other forms that specify generic
function options.
<!--l. 1834--><p class="indent" >   The names of the built-in method combination types are <tt><a 
href="clmse104.html#x129-237002r568">+</a></tt>, <tt><a 
href="clmse33.html#x44-78004r49">and</a></tt>, <tt><a 
href="clmse128.html#x158-320002r780">append</a></tt>, <tt><a 
href="clmse80.html#x100-201034r441">list</a></tt>,
<tt><a 
href="clmse62.html#x79-176014r179">max</a></tt>, <tt><a 
href="clmse62.html#x79-176016r180">min</a></tt>, <tt><a 
href="clmse128.html#x158-320006r782">nconc</a></tt>, <tt><a 
href="clmse33.html#x44-79002r50">or</a></tt>, <tt><a 
href="clmse37.html#x49-95002r71">progn</a></tt>, and <tt>standard</tt>.
<!--l. 1838--><p class="indent" >   The semantics of the <tt>standard</tt> built-in method combination type were
described in section <a 
href="#x171-37300027.1.7">27.1.7<!--tex4ht:ref: Standard-Method-Combination-SECTION --></a>. The other built-in method combination types are
called <i>simple built-in method combination types.</i>
<!--l. 1843--><p class="indent" >   The simple built-in method combination types act as though they were deﬁned
by the short form of <tt><a 
href="clmse140.html#x172-402005r838">define-method-combination</a></tt>. They recognize two roles for
methods:
      <ul class="itemize1">
      <li class="itemize">An  <tt>:around</tt> method  has  the  keyword  symbol  <tt>:around</tt> as  its  sole
      qualiﬁer. The meaning of <tt>:around</tt> methods is the same as in standard
      method  combination.  Use  of  the  functions  <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> and
      <tt><a 
href="clmse140.html#x172-407026r877">next-method-p</a></tt> is supported in <tt>:around</tt> methods.
      </li>
      <li class="itemize">A primary method has the name of the method combination type as
      its sole qualiﬁer. For example, the built-in method combination type
      <tt><a 
href="clmse33.html#x44-78004r49">and</a></tt> recognizes methods whose sole qualiﬁer is <tt><a 
href="clmse33.html#x44-78004r49">and</a></tt>; these are primary
      methods. Use of the functions <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> and <tt><a 
href="clmse140.html#x172-407026r877">next-method-p</a></tt>
      is not supported in primary methods.
      </li></ul>
<!--l. 1863--><p class="noindent" >The semantics of the simple built-in method combination types are as follows:
      <ul class="itemize1">
      <li class="itemize">If there are any <tt>:around</tt> methods, the most speciﬁc <tt>:around</tt> method
      is called. It supplies the value or values of the generic function.
                                                                          

                                                                          
      </li>
      <li class="itemize">Inside the body of an <tt>:around</tt> method, the function <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt>
      can   be   used   to   call   the   next   method.   The   generic   function
      <tt><a 
href="clmse140.html#x172-407034r881">no-next-method</a></tt> is invoked if <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> is used and there is
      no applicable method to call. The function <tt><a 
href="clmse140.html#x172-407026r877">next-method-p</a></tt> may be used
      to determine whether a next method exists. When the next method
      returns, the <tt>:around</tt> method can execute more code, perhaps based on
      the returned value or values.
      </li>
      <li class="itemize">If an <tt>:around</tt> method invokes <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt>, the next most speciﬁc
      <tt>:around</tt> method is called, if one is applicable. If there are no <tt>:around</tt>
      methods or if <tt><a 
href="clmse140.html#x172-400002r825">call-next-method</a></tt> is called by the least speciﬁc <tt>:around</tt>
      method, a Lisp form derived from the name of the built-in method
      combination type and from the list of applicable primary methods is
      evaluated to produce the value of the generic function. Suppose the name of
      the method combination type is <i>operator</i> and the call to the generic function
      is of the form <div class=lisp><div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(<i>generic-function</i> <span class="math">a<sub>1</sub></span> ... <span class="math">a<sub>n</sub></span>)
</td></tr></table>
      <!--l. 1891--><p class="noindent" >
</div>
</div>
      <!--l. 1892--><p class="noindent" >Let <span class="math">M<sub>1</sub>,…,M<sub>k</sub></span> be the applicable primary methods in order; then the derived
      Lisp form is <div class=lisp><div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(<i>operator</i> <span class="math">⟨M<sub>1</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span> ... <span class="math">⟨M<sub>k</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span>)
</td></tr></table>
      <!--l. 1897--><p class="noindent" >
</div>
</div>
                                                                          

                                                                          
      <!--l. 1898--><p class="noindent" >If the expression <span class="math">⟨M<sub>i</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span> is evaluated, the method <span class="math">M<sub>i</sub></span> will be applied to
      the arguments <span class="math">a<sub>1</sub>…a<sub>n</sub></span>. For example, if <i>operator</i> is <tt><a 
href="clmse33.html#x44-79002r50">or</a></tt>, the expression
      <span class="math">⟨M<sub>i</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span> is evaluated only if <span class="math">⟨M<sub>j</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span>, <span class="math">1 ≤ j &#x003C; i</span>, returned
      <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>.
      <!--l. 1908--><p class="noindent" >The default order for the primary methods is <tt>:most-specific-first</tt>.
      However, the order can be reversed by supplying <tt>:most-specific-last</tt> as
      the second argument to the <tt>:method-combination</tt> option.
      </li></ul>
<!--l. 1915--><p class="indent" >   The simple built-in method combination types require exactly one qualiﬁer per
method. An error is signaled if there are applicable methods with no qualiﬁers or
with qualiﬁers that are not supported by the method combination type. An error
is signaled if there are applicable <tt>:around</tt> methods and no applicable primary
methods.
<!--l. 1922--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.8   </span> <a 
href="clmli1.html#QQ2-171-418" id="x171-37600027.1.8">Meta-objects</a></h4>
<!--l. 1924--><p class="noindent" >The implementation of the Объектная система manipulates classes,
methods, and generic functions. The meta-object protocol speciﬁes a set of
generic functions deﬁned by methods on classes; the behavior of those
generic functions deﬁnes the behavior of the Объектная система. The
instances of the classes on which those methods are deﬁned are called
<i>meta-objects</i>. Programming at the meta-object protocol level involves
deﬁning new classes of meta-objects along with methods specialized on these
classes.
                                                                          

                                                                          
<!--l. 1934--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-37700027.1.8" id="x171-37700027.1.8">Metaclasses</a></h5>
<!--l. 1936--><p class="noindent" >The <i>metaclass</i> of an object is the class of its class. The metaclass determines the
representation of instances of its instances and the forms of inheritance used by its
instances for slot descriptions and method inheritance. The metaclass
mechanism can be used to provide particular forms of optimization or to
tailor the Объектная система Common Lisp&#x2019;а for particular uses. The
protocol for deﬁning metaclasses is discussed in the third part of the CLOS
speciﬁcation, The Объектная система Common Lisp&#x2019;а Meta-Object
Protocol. [The third part has not yet been approved by X3J13 for inclusion
in the forthcoming Common Lisp standard and is not included in this
book.—GLS]
<!--l. 1948--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-37800027.1.8" id="x171-37800027.1.8">Standard Metaclasses</a></h5>
<!--l. 1950--><p class="noindent" >The Объектная система Common Lisp&#x2019;а provides a number of predeﬁned
metaclasses. These include the classes <tt>standard-class</tt>, <tt>built-in-class</tt>, and
<tt>structure-class</tt>:
      <ul class="itemize1">
      <li class="itemize">The class <tt>standard-class</tt> is the default class of classes deﬁned by
      <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt>.
      </li>
      <li class="itemize">The  class  <tt>built-in-class</tt> is  the  class  whose  instances  are  classes
      that  have  special  implementations  with  restricted  capabilities.  Any
      class  that  corresponds  to  a  standard  Common  Lisp  type  might  be
      an instance of <tt>built-in-class</tt>. The predeﬁned Common Lisp type
      speciﬁers  that  are  required  to  have  corresponding  classes  are  listed
      in table <a 
href="#x171-3610021">27.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a>. It is implementation-dependent whether each of these
      classes is implemented as a built-in class.
      </li>
      <li class="itemize">All   classes   deﬁned   by   means   of   <tt><a 
href="clmse97.html#x121-225002r561">defstruct</a></tt>  are   instances   of
      <tt>structure-class</tt>.</li></ul>
                                                                          

                                                                          
<!--l. 1975--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-37900027.1.8" id="x171-37900027.1.8">Standard Meta-objects</a></h5>
<!--l. 1977--><p class="noindent" >The Объектная система supplies a standard set of meta-objects, called
<i>standard meta-objects</i>. These include the class <tt>standard-object</tt> and
instances of the classes <tt>standard-method</tt>, <tt>standard-generic-function</tt>, and
<tt>method-combination</tt>.
      <ul class="itemize1">
      <li class="itemize">The class <tt>standard-method</tt> is the default class of methods that are
      deﬁned  by  the  forms  <tt><a 
href="clmse140.html#x172-403002r839">defmethod</a></tt>,  <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt>,  <tt><a 
href="clmse140.html#x172-405002r863">generic-function</a></tt>,
      <tt><a 
href="clmse140.html#x172-404048r862">generic-flet</a></tt>, <tt><a 
href="clmse140.html#x172-406002r864">generic-labels</a></tt>, and <tt><a 
href="clmse140.html#x172-408004r903">with-added-methods</a></tt>.
      </li>
      <li class="itemize">The class <tt>standard-generic-function</tt> is the default class of generic
      functions                     deﬁned                     by                     the
      forms  <tt><a 
href="clmse140.html#x172-403002r839">defmethod</a></tt>,  <tt><a 
href="clmse140.html#x172-401002r836">defgeneric</a></tt>,  <tt><a 
href="clmse140.html#x172-405002r863">generic-function</a></tt>,  <tt><a 
href="clmse140.html#x172-404048r862">generic-flet</a></tt>,
      <tt><a 
href="clmse140.html#x172-406002r864">generic-labels</a></tt>, <tt><a 
href="clmse140.html#x172-408004r903">with-added-methods</a></tt>, and <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt>.
      </li>
      <li class="itemize">The  class  named  <tt>standard-object</tt> is  an  instance  of  the  class
      <tt>standard-class</tt> and is a superclass of every class that is an instance
      of <tt>standard-class</tt> except itself.
      </li>
      <li class="itemize">Every method combination object is an instance of a subclass of the
      class <tt>method-combination</tt>.
      </li></ul>
<!--l. 2006--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.9   </span> <a 
href="clmli1.html#QQ2-171-422" id="x171-38000027.1.9">Object Creation and Initialization</a></h4>
<!--l. 2009--><p class="noindent" >The generic function <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> creates and returns a new instance of a
class. The ﬁrst argument is a class or the name of a class, and the remaining
arguments form an <i>initialization argument</i> list.
                                                                          

                                                                          
<!--l. 2014--><p class="indent" >   The initialization of a new instance consists of several distinct steps, including
the following: combining the explicitly supplied initialization arguments with
default values for the unsupplied initialization arguments, checking the
validity of the initialization arguments, allocating storage for the instance,
ﬁlling slots with values, and executing user-supplied methods that perform
additional initialization. Each step of <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> is implemented by a
generic function to provide a mechanism for customizing that step. In
addition, <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> is itself a generic function and thus also can be
customized.
<!--l. 2025--><p class="indent" >   The Объектная система speciﬁes system-supplied primary methods for each
step and thus speciﬁes a well-deﬁned standard behavior for the entire initialization
process. The standard behavior provides four simple mechanisms for controlling
initialization:
      <ul class="itemize1">
      <li class="itemize">Declaring  a  symbol  to  be  an  initialization  argument  for  a  slot.  An
      initialization argument is declared by using the <tt>:initarg</tt> slot option
      to <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt>. This provides a mechanism for supplying a value for a
      slot in a call to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt>.
      </li>
      <li class="itemize">Supplying a default value form for an initialization argument. Default
      value  forms  for  initialization  arguments  are  deﬁned  by  using  the
      <tt>:default-initargs</tt> class  option  to  <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt>.  If  an  initialization
      argument is not explicitly provided as an argument to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt>,
      the default value form is evaluated in the lexical environment of the
      <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form that deﬁned it, and the resulting value is used as the
      value of the initialization argument.
      </li>
      <li class="itemize">Supplying  a  default  initial  value  form  for  a  slot.  A  default  initial
      value form for a slot is deﬁned by using the <tt>:initform</tt> slot option
      to  <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt>.  If  no  initialization  argument  associated  with  that
      slot  is  given  as  an  argument  to  <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> or  is  defaulted  by
      <tt>:default-initargs</tt>, this default initial value form is evaluated in the
      lexical  environment  of  the  <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form  that  deﬁned  it,  and  the
      resulting value is stored in the slot. The <tt>:initform</tt> form for a local slot
      may be used when creating an instance, when updating an instance to
                                                                          

                                                                          
      conform to a redeﬁned class, or when updating an instance to conform
      to the deﬁnition of a diﬀerent class. The <tt>:initform</tt> form for a shared
      slot may be used when deﬁning or re-deﬁning the class.
      </li>
      <li class="itemize">Deﬁning methods for <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> and <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>.
      The                                                                          slot-ﬁlling
      behavior described above is implemented by a system-supplied primary
      method for <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> which invokes <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>.
      The  generic  function  <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> implements  the  parts  of
      initialization shared by these four situations: when making an instance,
      when re-initializing an instance, when updating an instance to conform
      to  a  redeﬁned  class,  and  when  updating  an  instance  to  conform
      to  the  deﬁnition  of  a  diﬀerent  class.  The  system-supplied  primary
      method  for  <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> directly  implements  the  slot-ﬁlling
      behavior described above, and <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> simply invokes
      <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>.
      </li></ul>
<!--l. 2074--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-38100027.1.9" id="x171-38100027.1.9">Initialization Arguments</a></h5>
<!--l. 2076--><p class="noindent" >An initialization argument controls object creation and initialization. It is often
convenient to use keyword symbols to name initialization arguments, but the
name of an initialization argument can be any symbol, including <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. An
initialization argument can be used in two ways: to ﬁll a slot with a value or to
provide an argument for an initialization method. A single initialization argument
can be used for both purposes.
<!--l. 2084--><p class="indent" >   An <i>initialization argument list</i> is a list of alternating initialization argument
names and values. Its structure is identical to a property list and also to the
portion of an argument list processed for <tt>&#x0026;key</tt> parameters. As in those lists, if an
initialization argument name appears more than once in an initialization
argument list, the leftmost occurrence supplies the value and the remaining
occurrences are ignored. The arguments to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> (after the ﬁrst
argument) form an initialization argument list. Error checking of initialization
argument names is disabled if the keyword argument pair whose keyword is
<tt>:allow-other-keys</tt> and whose value is non-<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> appears in the initialization
                                                                          

                                                                          
argument list.
<!--l. 2097--><p class="indent" >   An initialization argument can be associated with a slot. If the initialization
argument has a value in the initialization argument list, the value is stored into
the slot of the newly created object, overriding any <tt>:initform</tt> form associated
with the slot. A single initialization argument can initialize more than one slot.
An initialization argument that initializes a shared slot stores its value into the
shared slot, replacing any previous value.
<!--l. 2105--><p class="indent" >   An initialization argument can be associated with a method. When an object
is created and a particular initialization argument is supplied, the generic
functions <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt>, <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>, and <tt>allocate-instance</tt>
are called with that initialization argument&#x2019;s name and value as a keyword
argument pair. If a value for the initialization argument is not supplied in the
initialization argument list, the method&#x2019;s lambda-list supplies a default
value.
<!--l. 2114--><p class="indent" >   Initialization arguments are used in four situations: when making an instance,
when re-initializing an instance, when updating an instance to conform to a
redeﬁned class, and when updating an instance to conform to the deﬁnition of a
diﬀerent class.
<!--l. 2119--><p class="indent" >   Because initialization arguments are used to control the creation and
initialization of an instance of some particular class, we say that an initialization
argument is “an initialization argument for” that class.
<!--l. 2125--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-38200027.1.9" id="x171-38200027.1.9">Declaring the Validity of Initialization Arguments</a></h5>
<!--l. 2128--><p class="noindent" >Initialization arguments are checked for validity in each of the four situations that
use them. An initialization argument may be valid in one situation and not
another. For example, the system-supplied primary method for <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt>
deﬁned for the class <tt>standard-class</tt> checks the validity of its initialization
arguments and signals an error if an initialization argument is supplied that is not
declared valid in that situation.
<!--l. 2137--><p class="indent" >   There are two means of declaring initialization arguments valid.
      <ul class="itemize1">
      <li class="itemize">Initialization  arguments  that  ﬁll  slots  are  declared  valid  by  the
      <tt>:initarg</tt> slot  option  to  <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt>.  The  <tt>:initarg</tt> slot  option  is
      inherited  from  superclasses.  Thus  the  set  of  valid  initialization
                                                                          

                                                                          
      arguments that ﬁll slots for a class is the union of the initialization
      arguments that ﬁll slots declared valid by that class and its superclasses.
      Initialization arguments that ﬁll slots are valid in all four contexts.
      </li>
      <li class="itemize">Initialization  arguments  that  supply  arguments  to  methods  are
      declared valid by deﬁning those methods. The keyword name of each
      keyword  parameter  speciﬁed  in  the  method&#x2019;s  lambda-list  becomes
      an  initialization  argument  for  all  classes  for  which  the  method
      is  applicable.  Thus  method  inheritance  controls  the  set  of  valid
      initialization arguments that supply arguments to methods. The generic
      functions for which method deﬁnitions serve to declare initialization
      arguments valid are as follows:
           <ul class="itemize2">
           <li class="itemize">Making                                                                        an
           instance of a class: <tt>allocate-instance</tt>, <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt>,
           and <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>. Initialization arguments declared valid
           by these methods are valid when making an instance of a class.
           </li>
           <li class="itemize">Re-initializing                          an                          instance:
           the functions <tt><a 
href="clmse140.html#x172-407043r885">reinitialize-instance</a></tt> and <tt>shared-initialize</tt>.
           Initialization arguments declared valid by these methods are valid
           when re-initializing an instance.
           </li>
           <li class="itemize">Updating         an         instance         to         conform         to
           a redeﬁned class: <tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt> and
           <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>. Initialization arguments declared valid by
           these methods are valid when updating an instance to conform to
           a redeﬁned class.
           </li>
           <li class="itemize">Updating   an   instance   to   conform   to   the   deﬁnition   of   a
           diﬀerent   class:   <tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt>  and
           <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>. Initialization arguments declared valid by
           these methods are valid when updating an instance to conform to
           the deﬁnition of a diﬀerent class.</li></ul>
                                                                          

                                                                          
      </li></ul>
<!--l. 2184--><p class="indent" >   The set of valid initialization arguments for a class is the set of valid
initialization arguments that either ﬁll slots or supply arguments to methods,
along with the predeﬁned initialization argument <tt>:allow-other-keys</tt>. The
default value for <tt>:allow-other-keys</tt> is <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. The meaning of <tt>:allow-other-keys</tt>
is the same here as when it is passed to an ordinary function.
<!--l. 2193--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-38300027.1.9" id="x171-38300027.1.9">Defaulting of Initialization Arguments</a></h5>
<!--l. 2195--><p class="noindent" >A <i>default value form</i> can be supplied for an initialization argument by using the
<tt>:default-initargs</tt> class option. If an initialization argument is declared valid by
some particular class, its default value form might be speciﬁed by a diﬀerent class.
In this case <tt>:default-initargs</tt> is used to supply a default value for an inherited
initialization argument.
<!--l. 2202--><p class="indent" >   The <tt>:default-initargs</tt> option is used only to provide default values for
initialization arguments; it does not declare a symbol as a valid initialization
argument name. Furthermore, the <tt>:default-initargs</tt> option is used only
to provide default values for initialization arguments when making an
instance.
<!--l. 2208--><p class="indent" >   The argument to the <tt>:default-initargs</tt> class option is a list of alternating
initialization argument names and forms. Each form is the default value form for
the corresponding initialization argument. The default value form of an
initialization argument is used and evaluated only if that initialization argument
does not appear in the arguments to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> and is not defaulted by a
more speciﬁc class. The default value form is evaluated in the lexical environment
of the <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form that supplied it; the result is used as the initialization
argument&#x2019;s value.
<!--l. 2219--><p class="indent" >   The initialization arguments supplied to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> are combined with
defaulted initialization arguments to produce a <i> defaulted initialization argument
list</i>. A defaulted initialization argument list is a list of alternating initialization
argument names and values in which unsupplied initialization arguments are
defaulted and in which the explicitly supplied initialization arguments appear
earlier in the list than the defaulted initialization arguments. Defaulted
initialization arguments are ordered according to the order in the class precedence
list of the classes that supplied the default values.
<!--l. 2229--><p class="indent" >   There is a distinction between the purposes of the <tt>:default-initargs</tt> and
                                                                          

                                                                          
the <tt>:initform</tt> options with respect to the initialization of slots. The
<tt>:default-initargs</tt> class option provides a mechanism for the user to
give a default value form for an initialization argument without knowing
whether the initialization argument initializes a slot or is passed to a
method. If that initialization argument is not explicitly supplied in a call to
<tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt>, the default value form is used, just as if it had been supplied in
the call. In contrast, the <tt>:initform</tt> slot option provides a mechanism for the
user to give a default initial value form for a slot. An <tt>:initform</tt> form is
used to initialize a slot only if no initialization argument associated with
that slot is given as an argument to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> or is defaulted by
<tt>:default-initargs</tt>.
<!--l. 2244--><p class="indent" >   The order of evaluation of default value forms for initialization arguments and
the order of evaluation of <tt>:initform</tt> forms are undeﬁned. If the order of
evaluation matters, use <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> or <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>
methods.
<!--l. 2250--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-38400027.1.9" id="x171-38400027.1.9">Rules for Initialization Arguments</a></h5>
<!--l. 2253--><p class="noindent" >The <tt>:initarg</tt> slot option may be speciﬁed more than once for a given slot. The
following rules specify when initialization arguments may be multiply
deﬁned:
      <ul class="itemize1">
      <li class="itemize">A given initialization argument can be used to initialize more than one
      slot if the same initialization argument name appears in more than one
      <tt>:initarg</tt> slot option.
      </li>
      <li class="itemize">A given initialization argument name can appear in the lambda-list of
      more than one initialization method.
      </li>
      <li class="itemize">A given initialization argument name can appear both in an <tt>:initarg</tt>
      slot option and in the lambda-list of an initialization method.
      </li></ul>
                                                                          

                                                                          
<!--l. 2273--><p class="indent" >   If two or more initialization arguments that initialize the same slot are given in
the arguments to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt>, the leftmost of these initialization arguments in
the initialization argument list supplies the value, even if the initialization
arguments have diﬀerent names.
<!--l. 2279--><p class="indent" >   If two or more diﬀerent initialization arguments that initialize the same slot have
default values and none is given explicitly in the arguments to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt>,
the initialization argument that appears in a <tt>:default-initargs</tt> class
option in the most speciﬁc of the classes supplies the value. If a single
<tt>:default-initargs</tt> class option speciﬁes two or more initialization arguments
that initialize the same slot and none is given explicitly in the arguments to
<tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt>, the leftmost argument in the <tt>:default-initargs</tt> class option
supplies the value, and the values of the remaining default value forms are
ignored.
<!--l. 2290--><p class="indent" >   Initialization arguments given explicitly in the arguments to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt>
appear to the left of defaulted initialization arguments. Suppose that the classes
<span class="math">C<sub>1</sub></span> and <span class="math">C<sub>2</sub></span> supply the values of defaulted initialization arguments for diﬀerent
slots, and suppose that <span class="math">C<sub>1</sub></span> is more speciﬁc than <span class="math">C<sub>2</sub></span>; then the defaulted
initialization argument whose value is supplied by <span class="math">C<sub>1</sub></span> is to the left of the defaulted
initialization argument whose value is supplied by <span class="math">C<sub>2</sub></span> in the defaulted
initialization argument list. If a single <tt>:default-initargs</tt> class option supplies
the values of initialization arguments for two diﬀerent slots, the initialization
argument whose value is speciﬁed farther to the left in the <tt>default-initargs</tt>
class option appears farther to the left in the defaulted initialization argument
list.
<!--l. 2304--><p class="indent" >   If a slot has both an <tt>:initform</tt> form and an <tt>:initarg</tt> slot option, and the
initialization argument is defaulted using <tt>:default-initargs</tt> or is supplied
to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt>, the captured <tt>:initform</tt> form is neither used nor
evaluated.
<!--l. 2309--><p class="indent" >   The following is an example of the preceding rules:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass q () ((x :initarg a)))
</td></tr></table>
<!--l. 2312--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2313--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass r (q) ((x :initarg b))</td></tr></table>
                                                                          

                                                                          
<!--l. 2314--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (:default-initargs a 1 b 2))</td></tr></table>
<!--l. 2316--><p class="indent" >
</div>
</div>
<div class="flushleft" 
>
<!--l. 2318--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >                                             </td><td align="left" >Defaulted Initialization</td><td align="left" >Contents</td></tr><tr><td align="left" >Form  </td> <td align="left" >Argument List </td> <td align="left" >of Slot</td>
</tr><tr><td align="left" ><tt>(make-instance &#x2019;r)</tt>           </td><td align="left" ><tt>(a 1 b 2)</tt>          </td><td align="left" ><tt>1</tt>      </td>
</tr><tr><td align="left" ><tt>(make-instance &#x2019;r &#x2019;a 3)</tt>      </td><td align="left" ><tt>(a 3 b 2)</tt>          </td><td align="left" ><tt>3</tt>      </td>
</tr><tr><td align="left" ><tt>(make-instance &#x2019;r &#x2019;b 4)</tt>      </td><td align="left" ><tt>(b 4 a 1)</tt>          </td><td align="left" ><tt>4</tt>      </td>
</tr><tr><td align="left" ><tt>(make-instance &#x2019;r &#x2019;a 1 &#x2019;a 2)</tt> </td><td align="left" ><tt>(a 1 a 2 b 2)</tt>      </td><td align="left" ><tt>1</tt>      </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" >  </td></tr></table>
</div></div>
<!--l. 2331--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-38500027.1.9" id="x171-38500027.1.9">Shared-Initialize</a></h5>
<!--l. 2334--><p class="noindent" >The generic function <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> is used to ﬁll the slots of an instance
using initialization arguments and <tt>:initform</tt> forms when an instance is created,
when an instance is re-initialized, when an instance is updated to conform to a
redeﬁned class, and when an instance is updated to conform to a diﬀerent class. It
uses standard method combination. It takes the following arguments:
the instance to be initialized, a speciﬁcation of a set of names of slots
accessible in that instance, and any number of initialization arguments.
The arguments after the ﬁrst two must form an initialization argument
list.
<!--l. 2345--><p class="indent" >   The second argument to <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> may be one of the following:
      <ul class="itemize1">
      <li class="itemize">It can be a list of slot names, which speciﬁes the set of those slot names.
      </li>
      <li class="itemize">It can be <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>, which speciﬁes the empty set of slot names.
      </li>
      <li class="itemize">It can be the symbol <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>, which speciﬁes the set of all of the slots.
      </li></ul>
                                                                          

                                                                          
<!--l. 2360--><p class="indent" >   There is a system-supplied primary method for <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> whose
ﬁrst parameter specializer is the class <tt>standard-object</tt>. This method behaves as
follows on each slot, whether shared or local:
      <ul class="itemize1">
      <li class="itemize">If an initialization argument in the initialization argument list speciﬁes
      a value for that slot, that value is stored into the slot, even if a value
      has  already  been  stored  in  the  slot  before  the  method  is  run.  The
      aﬀected slots are independent of which slots are indicated by the second
      argument to <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>.
      </li>
      <li class="itemize">Any slots indicated by the second argument that are still unbound
      at this point are initialized according to their <tt>:initform</tt> forms. For
      any such slot that has an <tt>:initform</tt> form, that form is evaluated in
      the lexical environment of its deﬁning <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form and the result is
      stored into the slot. For example, if a <tt>:before</tt> method stores a value in
      the slot, the <tt>:initform</tt> form will not be used to supply a value for the
      slot. If the second argument speciﬁes a name that does not correspond
      to any slots accessible in the instance, the results are unspeciﬁed.
      </li>
      <li class="itemize">The rules mentioned in section <a 
href="#x171-38400027.1.9">27.1.9<!--tex4ht:ref: Rules-for-Initialization-Arguments-SECTION --></a> are obeyed.
      </li></ul>
<!--l. 2387--><p class="indent" >   The generic function <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> is called by the system-supplied
primary methods for the generic functions <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt>,
<tt><a 
href="clmse140.html#x172-407043r885">reinitialize-instance</a></tt>, <tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt>, and
<tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt>. Thus methods can be written for
<tt>shared-initialize</tt> to specify actions that should be taken in all of these
contexts.
<!--l. 2398--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-38600027.1.9" id="x171-38600027.1.9">Initialize-Instance</a></h5>
<!--l. 2400--><p class="noindent" >The generic function <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> is called by <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> to
initialize a newly created instance. It uses standard method combination. Methods
for <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> can be deﬁned in order to perform any initialization
                                                                          

                                                                          
that cannot be achieved with the simple slot-ﬁlling mechanisms.
                                                                          

                                                                          
<!--l. 2409--><p class="indent" >   During initialization, <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> is invoked after the following
actions have been taken:
      <ul class="itemize1">
      <li class="itemize">The  defaulted  initialization  argument  list  has  been  computed  by
      combining the supplied initialization argument list with any default
      initialization arguments for the class.
      </li>
      <li class="itemize">The  validity  of  the  defaulted  initialization  argument  list  has  been
      checked. If any of the initialization arguments has not been declared
      valid, an error is signaled.
      </li>
      <li class="itemize">A new instance whose slots are unbound has been created.
      </li></ul>
<!--l. 2426--><p class="indent" >   The generic function <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> is called with the new instance
and the defaulted initialization arguments. There is a system-supplied primary
method for <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> whose parameter specializer is the class
<tt>standard-object</tt>. This method calls the generic function <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> to
ﬁll in the slots according to the initialization arguments and the <tt>:initform</tt>
forms for the slots; the generic function <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> is called with
the following arguments: the instance, <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>, and the defaulted initialization
arguments.
<!--l. 2436--><p class="indent" >   Note that <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> provides the defaulted initialization
argument list in its call to <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>, so the ﬁrst step performed by the
system-supplied primary method for <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> takes into account both
the initialization arguments provided in the call to <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> and the
defaulted initialization argument list.
<!--l. 2443--><p class="indent" >   Methods for <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> can be deﬁned to specify actions
to be taken when an instance is initialized. If only <tt>:after</tt> methods for
<tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> are deﬁned, they will be run after the system-supplied
primary method for initialization and therefore they will not interfere with the
default behavior of <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt>.
<!--l. 2450--><p class="indent" >   The Объектная система provides two functions that are useful in the bodies
of <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> methods. The function <tt><a 
href="clmse140.html#x172-407053r890">slot-boundp</a></tt> returns a boolean
value that indicates whether a speciﬁed slot has a value; this provides a
                                                                          

                                                                          
mechanism for writing <tt>:after</tt> methods for <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> that
initialize slots only if they have not already been initialized. The function
<tt><a 
href="clmse140.html#x172-407057r892">slot-makunbound</a></tt> causes the slot to have no value.
<!--l. 2459--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-38700027.1.9" id="x171-38700027.1.9">Deﬁnitions of Make-Instance and Initialize-Instance</a></h5>
<!--l. 2461--><p class="noindent" >The generic function <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> behaves as if it were deﬁned as follows,
except that certain optimizations are permitted:
                                                                          

                                                                          
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod make-instance ((class standard-class) &#x0026;rest initargs)
</td></tr></table>
<!--l. 2467--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setq initargs (default-initargs class initargs))</td></tr></table>
<!--l. 2468--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 2469--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((instance (apply #&#x2019;allocate-instance class initargs)))</td></tr></table>
<!--l. 2470--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (apply #&#x2019;initialize-instance instance initargs)</td></tr></table>
<!--l. 2471--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    instance))</td></tr></table>
<!--l. 2472--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2473--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod make-instance ((class-name symbol) &#x0026;rest initargs)</td></tr></table>
<!--l. 2474--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (apply #&#x2019;make-instance (ﬁnd-class class-name) initargs))</td></tr></table>
<!--l. 2476--><p class="indent" >
</div>
</div>
<!--l. 2501--><p class="indent" >   The elided code in the deﬁnition of <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> checks the supplied
initialization arguments to determine whether an initialization argument was
supplied that neither ﬁlled a slot nor supplied an argument to an applicable
method. This check could be implemented using the generic functions
<tt>class-prototype</tt>, <tt><a 
href="clmse140.html#x172-400020r834">compute-applicable-methods</a></tt>, <tt><a 
href="clmse140.html#x172-404046r861">function-keywords</a></tt>, and
<tt>class-slot-initargs</tt>. See the third part of the Объектная система
Common Lisp&#x2019;а speciﬁcation for a description of this initialization argument
check. [The third part has not yet been approved by X3J13 for inclusion
in the forthcoming Common Lisp standard and is not included in this
book.—GLS]
<!--l. 2513--><p class="indent" >   The generic function <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> behaves as if it were deﬁned as
follows, except that certain optimizations are permitted:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod initialize-instance
</td></tr></table>
<!--l. 2517--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           ((instance standard-object) &#x0026;rest initargs)</td></tr></table>
                                                                          

                                                                          
<!--l. 2518--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (apply #&#x2019;shared-initialize instance t initargs)))</td></tr></table>
<!--l. 2520--><p class="indent" >
</div>
</div>
<!--l. 2522--><p class="indent" >   These procedures can be customized at either the Programmer Interface level,
the meta-object level, or both.
<!--l. 2525--><p class="indent" >   Customizing at the Programmer Interface level includes using the <tt>:initform</tt>,
<tt>:initarg</tt>, and <tt>:default-initargs</tt> options to <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt>, as well as deﬁning
methods for <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt> and <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt>. It is also possible to
deﬁne methods for <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>, which would be invoked by the generic
functions <tt><a 
href="clmse140.html#x172-407043r885">reinitialize-instance</a></tt>, <tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt>,
<tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt>, and <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt>. The
meta-object level supports additional customization by allowing methods to be
deﬁned on <tt><a 
href="clmse140.html#x172-407012r870">make-instance</a></tt>, <tt>default-initargs</tt>, and <tt>allocate-instance</tt>.
Parts 2 and 3 of the Объектная система Common Lisp&#x2019;а speciﬁcation
document each of these generic functions and the system-supplied primary
methods. [The third part has not yet been approved by X3J13 for inclusion
in the forthcoming Common Lisp standard and is not included in this
book.—GLS]
<!--l. 2542--><p class="indent" >   Implementations are permitted to make certain optimizations to
<tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt> and <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>. The description of
<tt>shared-initialize</tt> in section <a 
href="clmse140.html#x172-39900027.2">27.2<!--tex4ht:ref: Functions-in-the-Programmer-Interface-SECTION --></a> mentions the possible optimizations.
<!--l. 2549--><p class="indent" >   Because of optimization, the check for valid initialization arguments
might not be implemented using the generic functions <tt>class-prototype</tt>,
<tt>compute-applicable-methods</tt>, <tt><a 
href="clmse140.html#x172-404046r861">function-keywords</a></tt>, and <tt>class-slot-initargs</tt>.
In addition, methods for the generic function <tt>default-initargs</tt> and the
system-supplied primary methods for <tt>allocate-instance</tt>, <tt><a 
href="clmse140.html#x172-407004r866">initialize-instance</a></tt>,
and <tt>shared-initialize</tt> might not be called on every call to <tt>make-instance</tt> or
might not receive exactly the arguments that would be expected.
<!--l. 2561--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.10   </span> <a 
href="clmli1.html#QQ2-171-430" id="x171-38800027.1.10">Redeﬁning Classes</a></h4>
<!--l. 2564--><p class="noindent" >A class that is an instance of <tt>standard-class</tt> can be redeﬁned if the new class
will also be an instance of <tt>standard-class</tt>. Redeﬁning a class modiﬁes the
existing class object to reﬂect the new class deﬁnition; it does not create a new
class object for the class. Any method object created by a <tt>:reader</tt>, <tt>:writer</tt>, or
                                                                          

                                                                          
<tt>:accessor</tt> option speciﬁed by the old <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form is removed from the
corresponding generic function. Methods speciﬁed by the new <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form are
added.
<!--l. 2577--><p class="indent" >   When the class <i>C</i> is redeﬁned, changes are propagated to its instances and to
instances of any of its subclasses. Updating such an instance occurs at an
implementation-dependent time, but no later than the next time a slot of that
instance is read or written. Updating an instance does not change its identity as
deﬁned by the <tt><a 
href="clmse32.html#x43-77002r44">eq</a></tt> function. The updating process may change the slots of that
particular instance, but it does not create a new instance. Whether updating an
instance consumes storage is implementation-dependent.
<!--l. 2586--><p class="indent" >   Note that redeﬁning a class may cause slots to be added or deleted. If a class is
redeﬁned in a way that changes the set of local slots accessible in instances, the
instances will be updated. It is implementation-dependent whether instances are
updated if a class is redeﬁned in a way that does not change the set of local slots
accessible in instances.
<!--l. 2593--><p class="indent" >   The value of a slot that is speciﬁed as shared both in the old class and in the
new class is retained. If such a shared slot was unbound in the old class, it will be
unbound in the new class. Slots that were local in the old class and that
are shared in the new class are initialized. Newly added shared slots are
initialized.
<!--l. 2599--><p class="indent" >   Each newly added shared slot is set to the result of evaluating the captured
<tt>:initform</tt> form for the slot that was speciﬁed in the <tt><a 
href="clmse140.html#x172-400022r835">defclass</a></tt> form for the new
class. If there is no <tt>:initform</tt> form, the slot is unbound.
<!--l. 2604--><p class="indent" >   If a class is redeﬁned in such a way that the set of local slots accessible in an
instance of the class is changed, a two-step process of updating the instances of
the class takes place. The process may be explicitly started by invoking the
generic function <tt><a 
href="clmse140.html#x172-407018r873">make-instances-obsolete</a></tt>. This two-step process can happen
in other circumstances in some implementations. For example, in some
implementations this two-step process will be triggered if the order of slots in
storage is changed.
<!--l. 2613--><p class="indent" >   The ﬁrst step modiﬁes the structure of the instance by adding new local slots
and discarding local slots that are not deﬁned in the new version of the class. The
second step initializes the newly added local slots and performs any other
user-deﬁned actions. These steps are further speciﬁed in the next two
sections.
                                                                          

                                                                          
<!--l. 2620--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-38900027.1.10" id="x171-38900027.1.10">Modifying the Structure of Instances</a></h5>
<!--l. 2622--><p class="noindent" >The ﬁrst step modiﬁes the structure of instances of the redeﬁned class to
conform to its new class deﬁnition. Local slots speciﬁed by the new class
deﬁnition that are not speciﬁed as either local or shared by the old class
are added, and slots not speciﬁed as either local or shared by the new
class deﬁnition that are speciﬁed as local by the old class are discarded.
The names of these added and discarded slots are passed as arguments
to <tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt> as described in the next
section.
<!--l. 2631--><p class="indent" >   The values of local slots speciﬁed by both the new and old classes are retained.
If such a local slot was unbound, it remains unbound.
<!--l. 2634--><p class="indent" >   The value of a slot that is speciﬁed as shared in the old class and as local in
the new class is retained. If such a shared slot was unbound, the local slot will be
unbound.
<!--l. 2639--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-39000027.1.10" id="x171-39000027.1.10">Initializing Newly Added Local Slots</a></h5>
<!--l. 2641--><p class="noindent" >The second step initializes the newly added local slots and performs any other
user-deﬁned actions. This step is implemented by the generic function
<tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt>, which is called after completion of the
ﬁrst step of modifying the structure of the instance.
<!--l. 2647--><p class="indent" >   The generic function <tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt> takes four
required arguments: the instance being updated after it has undergone the ﬁrst
step, a list of the names of local slots that were added, a list of the names of local
slots that were discarded, and a property list containing the slot names and values
of slots that were discarded and had values. Included among the discarded slots
are slots that were local in the old class and that are shared in the new
class.
<!--l. 2656--><p class="indent" >   The generic function <tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt> also takes any
number of initialization arguments. When it is called by the system to update an
instance whose class has been redeﬁned, no initialization arguments are
provided.
<!--l. 2661--><p class="indent" >   There is a system-supplied primary method for the generic function
<tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt> whose parameter specializer for its
instance argument is the class <tt>standard-object</tt>. First this method checks the
                                                                          

                                                                          
validity of initialization arguments and signals an error if an initialization
argument is supplied that is not declared valid (see section <a 
href="#x171-38200027.1.9">27.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>.) Then it calls
the generic function <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> with the following arguments: the
instance, the list of names of the newly added slots, and the initialization
arguments it received.
<!--l. 2674--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-39100027.1.10" id="x171-39100027.1.10">Customizing Class Redeﬁnition</a></h5>
<!--l. 2676--><p class="noindent" >Methods for <tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt> may be deﬁned to specify
actions to be taken when an instance is updated. If only <tt>:after</tt> methods for
<tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt> are deﬁned, they will be run after the
system-supplied primary method for initialization and therefore will not interfere
with the default behavior of <tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt>. Because no
initialization arguments are passed to <tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt>
when it is called by the system, the <tt>:initform</tt> forms for slots that are ﬁlled by
<tt>:before</tt> methods for <tt><a 
href="clmse140.html#x172-407075r901">update-instance-for-redefined-class</a></tt> will not be
evaluated by <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>.
<!--l. 2688--><p class="indent" >   Methods for <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> may be deﬁned to customize class
redeﬁnition (see section <a 
href="#x171-38500027.1.9">27.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
<!--l. 2692--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-39200027.1.10" id="x171-39200027.1.10">Extensions</a></h5>
<!--l. 2694--><p class="noindent" >There are two allowed extensions to class redeﬁnition:
      <ul class="itemize1">
      <li class="itemize">The Объектная система may be extended to permit the new class to
      be an instance of a metaclass other than the metaclass of the old class.
      </li>
      <li class="itemize">The Объектная система may be extended to support an updating
      process when either the old or the new class is an instance of a class
      other than <tt>standard-class</tt> that is not a built-in class.
      </li></ul>
                                                                          

                                                                          
<!--l. 2709--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.11   </span> <a 
href="clmli1.html#QQ2-171-435" id="x171-39300027.1.11">Changing the Class of an Instance</a></h4>
<!--l. 2712--><p class="noindent" >The function <tt><a 
href="clmse140.html#x172-400008r828">change-class</a></tt> can be used to change the class of an instance from
its current class, <span class="math">C<sub>from</sub></span>, to a diﬀerent class, <span class="math">C<sub>to</sub></span>; it changes the structure of the
instance to conform to the deﬁnition of the class <span class="math">C<sub>to</sub></span>.
<!--l. 2718--><p class="indent" >   Note that changing the class of an instance may cause slots to be added or
deleted.
<!--l. 2721--><p class="indent" >   When <tt><a 
href="clmse140.html#x172-400008r828">change-class</a></tt> is invoked on an instance, a two-step updating process
takes place. The ﬁrst step modiﬁes the structure of the instance by adding new
local slots and discarding local slots that are not speciﬁed in the new version of
the instance. The second step initializes the newly added local slots and performs
any other user-deﬁned actions. These steps are further described in the following
two sections.
<!--l. 2729--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-39400027.1.11" id="x171-39400027.1.11">Modifying the Structure of an Instance</a></h5>
<!--l. 2731--><p class="noindent" >In order to make an instance conform to the class <span class="math">C<sub>to</sub></span>, local slots speciﬁed by the
class <span class="math">C<sub>to</sub></span> that are not speciﬁed by the class <span class="math">C<sub>from</sub></span> are added, and local slots
not speciﬁed by the class <span class="math">C<sub>to</sub></span> that are speciﬁed by the class <span class="math">C<sub>from</sub></span> are
discarded.
<!--l. 2738--><p class="indent" >   The values of local slots speciﬁed by both the class <span class="math">C<sub>to</sub></span> and the class <span class="math">C<sub>from</sub></span> are
retained. If such a local slot was unbound, it remains unbound.
<!--l. 2743--><p class="indent" >   The values of slots speciﬁed as shared in the class <span class="math">C<sub>from</sub></span> and as local in the
class <span class="math">C<sub>to</sub></span> are retained.
<!--l. 2747--><p class="indent" >   This ﬁrst step of the update does not aﬀect the values of any shared
slots.
<!--l. 2751--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-39500027.1.11" id="x171-39500027.1.11">Initializing Newly Added Local Slots</a></h5>
<!--l. 2753--><p class="noindent" >The second step of the update initializes the newly added slots and performs
any other user-deﬁned actions. This step is implemented by the generic
function <tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt>. The generic function
<tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt> is invoked by <tt><a 
href="clmse140.html#x172-400008r828">change-class</a></tt> after the
ﬁrst step of the update has been completed.
<!--l. 2760--><p class="indent" >   The generic function <tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt> is invoked on
                                                                          

                                                                          
two arguments computed by <tt><a 
href="clmse140.html#x172-400008r828">change-class</a></tt>. The ﬁrst argument passed is a copy
of the instance being updated and is an instance of the class <span class="math">C<sub>from</sub></span>; this copy has
dynamic extent within the generic function <tt><a 
href="clmse140.html#x172-400008r828">change-class</a></tt>. The second argument
is the instance as updated so far by <tt><a 
href="clmse140.html#x172-400008r828">change-class</a></tt> and is an instance of the class
<span class="math">C<sub>to</sub></span>.
<!--l. 2768--><p class="indent" >   The generic function <tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt> also takes any
number of initialization arguments. When it is called by <tt><a 
href="clmse140.html#x172-400008r828">change-class</a></tt>, no
initialization arguments are provided.
<!--l. 2772--><p class="indent" >   There is a system-supplied primary method for the generic function
<tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt> that has two parameter specializers,
each of which is the class <tt>standard-object</tt>. First this method checks the validity
of initialization arguments and signals an error if an initialization argument is
supplied that is not declared valid (see section <a 
href="#x171-38200027.1.9">27.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>). Then it calls the generic
function <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> with the following arguments: the instance, a list
of names of the newly added slots, and the initialization arguments it
received.
<!--l. 2784--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-39600027.1.11" id="x171-39600027.1.11">Customizing the Change of Class of an Instance</a></h5>
<!--l. 2786--><p class="noindent" >Methods for <tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt> may be deﬁned to specify
actions to be taken when an instance is updated. If only <tt>:after</tt> methods for
<tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt> are deﬁned, they will be run after the
system-supplied primary method for initialization and will not interfere with the
default behavior of <tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt>. Because no
initialization arguments are passed to <tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt>
when it is called by <tt><a 
href="clmse140.html#x172-400008r828">change-class</a></tt>, the <tt>:initform</tt> forms for slots that are ﬁlled
by <tt>:before</tt> methods for <tt><a 
href="clmse140.html#x172-407071r899">update-instance-for-different-class</a></tt> will not be
evaluated by <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>.
<!--l. 2798--><p class="indent" >   Methods for <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> may be deﬁned to customize class
redeﬁnition (see section <a 
href="#x171-38500027.1.9">27.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
<!--l. 2801--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">27.1.12   </span> <a 
href="clmli1.html#QQ2-171-439" id="x171-39700027.1.12">Reinitializing an Instance</a></h4>
<!--l. 2804--><p class="noindent" >The generic function <tt><a 
href="clmse140.html#x172-407043r885">reinitialize-instance</a></tt> may be used to change the values
of slots according to initialization arguments.
                                                                          

                                                                          
<!--l. 2807--><p class="indent" >   The process of reinitialization changes the values of some slots and performs
any user-deﬁned actions.
<!--l. 2810--><p class="indent" >   Reinitialization does not modify the structure of an instance to add
or delete slots, and it does not use any <tt>:initform</tt> forms to initialize
slots.
<!--l. 2814--><p class="indent" >   The generic function <tt><a 
href="clmse140.html#x172-407043r885">reinitialize-instance</a></tt> may be called directly. It takes
one required argument, the instance. It also takes any number of initialization
arguments to be used by methods for <tt><a 
href="clmse140.html#x172-407043r885">reinitialize-instance</a></tt> or for
<tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt>. The arguments after the required instance must form an
initialization argument list.
<!--l. 2821--><p class="indent" >   There is a system-supplied primary method for <tt><a 
href="clmse140.html#x172-407043r885">reinitialize-instance</a></tt>
whose parameter specializer is the class <tt>standard-object</tt>. First this
method checks the validity of initialization arguments and signals an error
if an initialization argument is supplied that is not declared valid (see
section <a 
href="#x171-38200027.1.9">27.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>). Then it calls the generic function <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> with the
following arguments: the instance, <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>, and the initialization arguments it
received.
                                                                          

                                                                          
<!--l. 2833--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x171-39800027.1.12" id="x171-39800027.1.12">Customizing Reinitialization</a></h5>
<!--l. 2835--><p class="noindent" >Methods for the generic function <tt><a 
href="clmse140.html#x172-407043r885">reinitialize-instance</a></tt> may be deﬁned to
specify actions to be taken when an instance is updated. If only <tt>:after</tt>
methods for <tt><a 
href="clmse140.html#x172-407043r885">reinitialize-instance</a></tt> are deﬁned, they will be run after the
system-supplied primary method for initialization and therefore will not interfere
with the default behavior of <tt><a 
href="clmse140.html#x172-407043r885">reinitialize-instance</a></tt>.
<!--l. 2842--><p class="indent" >   Methods for <tt><a 
href="clmse140.html#x172-407051r889">shared-initialize</a></tt> may be deﬁned to customize class
redeﬁnition (see section <a 
href="#x171-38500027.1.9">27.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
                                                                          

                                                                          
   <!--l. 2846--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse140.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch27.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch27.html#tailclmch27.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse139.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch27.html#clmse139.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 2846--><p class="indent" >   <a 
 id="tailclmse139.html"></a>   </div> </div> 
</body></html> 
