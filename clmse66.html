<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Type Conversions and Component Extractions on Numbers</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-20 19:35:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 2978--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse67.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse65.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse65.html#tailclmse65.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse66.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse66.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">12.6   </span> <a 
href="clm.html#QQ2-83-211" id="x83-18400012.6">Type Conversions and Component Extractions on Numbers</a></h3>
<!--l. 2980--><p class="noindent" >While most arithmetic functions will operate on any kind of number, coercing
types if necessary, the following functions are provided to allow speciﬁc
conversions of data types to be forced when desired.
<div class=defun>
<!--l. 2984--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184001"></a><a 
 id="x83-184002r214"></a><b> ﬂoat</b>  <i>number</i> &#x0026;optional  <i>other</i>
<!--l. 2986--><p class="noindent" >This converts any non-complex number to a ﬂoating-point number. With no
second argument, if <i>number</i> is already a ﬂoating-point number, then <i>number</i> is
returned; otherwise a single-ﬂoat is produced. If the argument <i>other</i> is provided,
then it must be a ﬂoating-point number, and <i>number</i> is converted to the same
format as <i>other</i>. See also <a 
href="clmse25.html#x34-53002r7">coerce</a>.
</div>
<div class=defun>
<!--l. 2996--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184003"></a><a 
 id="x83-184004r215"></a><b> rational</b>  <i>number</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184005"></a><a 
 id="x83-184006r216"></a><b> rationalize</b>  <i>number</i>
<!--l. 2999--><p class="noindent" >Each of these functions converts any non-complex number to a rational number. If
the argument is already rational, it is returned. The two functions diﬀer in their
treatment of ﬂoating-point numbers.
<!--l. 3004--><p class="indent" >   <a 
href="#x83-184004r215">rational</a> assumes that the ﬂoating-point number is completely accurate and
returns a rational number mathematically equal to the precise value of the
ﬂoating-point number.
<!--l. 3008--><p class="indent" >   <a 
href="#x83-184006r216">rationalize</a> assumes that the ﬂoating-point number is accurate only to the
precision of the ﬂoating-point representation and may return any rational number
for which the ﬂoating-point number is the best available approximation of its
format; in doing this it attempts to keep both numerator and denominator
small.
<!--l. 3015--><p class="indent" >   It is always the case that <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬂoat (rational <i>x</i>) <i>x</i>) <span class="math"> ≡</span> <i>x</i>
</td></tr></table>
                                                                          

                                                                          
<!--l. 3018--><p class="indent" >
</div>
</div>
<!--l. 3019--><p class="noindent" >and <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬂoat (rationalize <i>x</i>) <i>x</i>) <span class="math"> ≡</span> <i>x</i>
</td></tr></table>
<!--l. 3022--><p class="indent" >
</div>
</div>
<!--l. 3023--><p class="noindent" >That is, rationalizing a ﬂoating-point number by either method and then converting
it back to a ﬂoating-point number of the same format produces the original
number. What distinguishes the two functions is that <a 
href="#x83-184004r215">rational</a> typically has a
simple, inexpensive implementation, whereas <a 
href="#x83-184006r216">rationalize</a> goes to more trouble to
produce a result that is more pleasant to view and simpler to compute with for
some purposes.
</div>
<div class=defun>
<!--l. 3032--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184007"></a><a 
 id="x83-184008r217"></a><b> numerator</b>  <i>rational</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184009"></a><a 
 id="x83-184010r218"></a><b> denominator</b>  <i>rational</i>
<!--l. 3035--><p class="noindent" >These functions take a rational number (an integer or ratio) and return as an
integer the numerator or denominator of the canonical reduced form of the
rational. The numerator of an integer is that integer; the denominator of an
integer is 1. Note that <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(gcd (numerator <i>x</i>) (denominator <i>x</i>)) <span class="math"> ⇒</span> 1
</td></tr></table>
<!--l. 3042--><p class="indent" >
</div>
</div>
<!--l. 3043--><p class="noindent" >The denominator will always be a strictly positive integer; the numerator may be any
integer. For example: <div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(numerator (/ 8 -6)) <span class="math"> ⇒</span> -4
</td></tr></table>
<!--l. 3047--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(denominator (/ 8 -6)) <span class="math"> ⇒</span> 3</td></tr></table>
<!--l. 3049--><p class="indent" >
</div>
</div>
</div>
<!--l. 3052--><p class="indent" >   There is no ﬁx function in Common Lisp because there are several interesting
ways to convert non-integral values to integers. These are provided by the
functions below, which perform not only type conversion but also some non-trivial
calculations as well.
<div class=defun>
<!--l. 3057--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184011"></a><a 
 id="x83-184012r219"></a><b> ﬂoor</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184013"></a><a 
 id="x83-184014r220"></a><b> ceiling</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184015"></a><a 
 id="x83-184016r221"></a><b> truncate</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184017"></a><a 
 id="x83-184018r222"></a><b> round</b>  <i>number</i> &#x0026;optional  <i>divisor</i>
<!--l. 3062--><p class="noindent" >In the simple one-argument case, each of these functions converts its argument
<i>number</i> (which must not be complex) to an integer. If the argument is already an
integer, it is returned directly. If the argument is a ratio or ﬂoating-point number,
the functions use diﬀerent algorithms for the conversion.
<!--l. 3070--><p class="indent" >   <a 
href="#x83-184012r219">ﬂoor</a> converts its argument by truncating toward negative inﬁnity; that is, the
result is the largest integer that is not larger than the argument.
<!--l. 3074--><p class="indent" >   <a 
href="#x83-184014r220">ceiling</a> converts its argument by truncating toward positive inﬁnity; that is,
the result is the smallest integer that is not smaller than the argument.
<!--l. 3078--><p class="indent" >   <a 
href="#x83-184016r221">truncate</a> converts its argument by truncating toward zero; that is, the result is
the integer of the same sign as the argument and which has the greatest integral
magnitude not greater than that of the argument.
<!--l. 3083--><p class="indent" >   <a 
href="#x83-184018r222">round</a> converts its argument by rounding to the nearest integer; if <i>number</i> is
exactly halfway between two integers (that is, of the form <span class="math">integer + 0.5</span>), then it is
rounded to the one that is even (divisible by 2).
<!--l. 3088--><p class="indent" >   The following table shows what the four functions produce when given various
arguments.
<div class="flushleft" 
>
<!--l. 3091--><p class="noindent" >
                                                                          

                                                                          
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Argument</td><td align="left" >ﬂoor</td><td align="left" >ceiling</td><td align="left" >truncate</td><td align="left" >round</td>
</tr><tr><td align="left" >     2.6    </td><td align="left" >  2 </td><td align="left" >    3   </td><td align="left" >     2    </td><td align="left" >   3  </td></tr><tr><td align="left" >  2.5 </td> <td align="left" >  2 </td> <td align="left" >  3 </td> <td align="left" >  2 </td> <td align="left" >  2</td>
</tr><tr><td align="left" >     2.4    </td><td align="left" >  2 </td><td align="left" >    3   </td><td align="left" >     2    </td><td align="left" >   2  </td></tr><tr><td align="left" >  0.7 </td> <td align="left" >  0 </td> <td align="left" >  1 </td> <td align="left" >  0 </td> <td align="left" >  1</td>
</tr><tr><td align="left" >     0.3    </td><td align="left" >  0 </td><td align="left" >    1   </td><td align="left" >     0    </td><td align="left" >   0  </td></tr><tr><td align="left" > -0.3 </td> <td align="left" > -1 </td> <td align="left" >  0 </td> <td align="left" >  0 </td> <td align="left" >  0</td>
</tr><tr><td align="left" >    -0.7    </td><td align="left" >  -1  </td><td align="left" >    0   </td><td align="left" >     0    </td><td align="left" >   -1   </td></tr><tr><td align="left" > -2.4 </td> <td align="left" > -3 </td> <td align="left" > -2 </td> <td align="left" > -2 </td> <td align="left" > -2</td>
</tr><tr><td align="left" >    -2.5    </td><td align="left" >  -3  </td><td align="left" >   -2   </td><td align="left" >    -2    </td><td align="left" >   -2   </td></tr><tr><td align="left" > -2.6 </td> <td align="left" > -3 </td> <td align="left" > -2 </td> <td align="left" > -2 </td> <td align="left" > -3</td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
<!--l. 3110--><p class="indent" >   If a second argument <i>divisor</i> is supplied, then the result is the appropriate
type of rounding or truncation applied to the result of dividing the <i>number</i> by the
<i>divisor</i>. For example, (ﬂoor 5 2) <span class="math"> ≡</span> (ﬂoor (/ 5 2)) but is potentially more
eﬃcient. <div class=new>This statement is not entirely accurate; one should instead say that
(values (ﬂoor 5 2)) <span class="math"> ≡</span> (values (ﬂoor (/ 5 2))), because there is a second value to
consider, as discussed below. In other words, the ﬁrst values returned by the two
forms will be the same, but in general the second values will diﬀer. Indeed, we
have <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬂoor 5 2) <span class="math"> ⇒</span> 2 and 1
</td></tr></table>
<!--l. 3122--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬂoor (/ 5 2)) <span class="math"> ⇒</span> 2 and 1/2</td></tr></table>
<!--l. 3124--><p class="indent" >
</div>
</div>
<!--l. 3125--><p class="noindent" >for this example.
</div> The <i>divisor</i> may be any non-complex number. <div class=new>It is generally accepted that it is
an error for the <i>divisor</i> to be zero.
</div> The one-argument case is exactly like the two-argument case where the second
argument is 1.
<div class=newer>
<!--l. 3135--><p class="indent" >   In other words, the one-argument case returns an integer and fractional part
for the <i>number</i>: (truncate 5.3) <span class="math"> ⇒</span> 5.0 and 0.3, for example.
</div> Each of the functions actually returns <i>two</i> values, whether given one or two
arguments. The second result is the remainder and may be obtained using
<a 
href="clmse43.html#x55-134002r111">multiple-value-bind</a> and related constructs. If any of these functions is given two
arguments <span class="math"><i>x</i></span> and <span class="math"><i>y</i></span> and produces results <span class="math"><i>q</i></span> and <span class="math"><i>r</i></span>, then <span class="math"><i>q</i> ⋅<i>y</i> + <i>r</i> = <i>x</i></span>. The
ﬁrst result <span class="math"><i>q</i></span> is always an integer. The remainder <span class="math"><i>r</i></span> is an integer if both
arguments are integers, is rational if both arguments are rational, and is
ﬂoating-point if either argument is ﬂoating-point. One consequence is that in the
                                                                          

                                                                          
one-argument case the remainder is always a number of the same type as the
argument.
<!--l. 3152--><p class="indent" >   When only one argument is given, the two results are exact; the mathematical
sum of the two results is always equal to the mathematical value of the
argument.
<div class=incompatibility>
<!--l. 3159--><p class="noindent" ><b>Compatibility note:</b> The names of the functions <a 
href="#x83-184012r219">ﬂoor</a>, <a 
href="#x83-184014r220">ceiling</a>, <a 
href="#x83-184016r221">truncate</a>, and <a 
href="#x83-184018r222">round</a> are
more accurate than names like ﬁx that have heretofore been used in various Lisp
systems. The names used here are compatible with standard mathematical
terminology (and with PL/1, as it happens). In Fortran iﬁx means <a 
href="#x83-184016r221">truncate</a>. Algol 68
provides <a 
href="#x83-184018r222">round</a> and uses entier to mean <a 
href="#x83-184012r219">ﬂoor</a>. In MacLisp, ﬁx and iﬁx both mean
<a 
href="#x83-184012r219">ﬂoor</a> (one is generic, the other ﬂonum-in/ﬁxnum-out). In Interlisp, ﬁx means
<a 
href="#x83-184016r221">truncate</a>. In Lisp Machine Lisp, ﬁx means <a 
href="#x83-184012r219">ﬂoor</a> and ﬁxr means <a 
href="#x83-184018r222">round</a>. Standard
Lisp provides a ﬁx function but does not specify precisely what it does. The
existing usage of the name ﬁx is so confused that it seemed best to avoid it
altogether.
<!--l. 3176--><p class="indent" >   The names and deﬁnitions given here have recently been adopted by Lisp Machine
Lisp, and MacLisp and NIL (New Implementation of Lisp) seem likely to follow
suit.
</div>
</div>
<div class=defun>
<!--l. 3182--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184019"></a><a 
 id="x83-184020r223"></a><b> mod</b>  <i>number</i> <i>divisor</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184021"></a><a 
 id="x83-184022r224"></a><b> rem</b>  <i>number</i> <i>divisor</i>
<!--l. 3185--><p class="noindent" ><a 
href="#x83-184020r223">mod</a> performs the operation <a 
href="#x83-184012r219">ﬂoor</a> on its two arguments and returns the <i>second</i>
result of <a 
href="#x83-184012r219">ﬂoor</a> as its only result. Similarly, <a 
href="#x83-184022r224">rem</a> performs the operation <a 
href="#x83-184016r221">truncate</a>
on its arguments and returns the <i>second</i> result of <a 
href="#x83-184016r221">truncate</a> as its only
result.
<!--l. 3192--><p class="indent" >   <a 
href="#x83-184020r223">mod</a> and <a 
href="#x83-184022r224">rem</a> are therefore the usual modulus and remainder functions when
applied to two integer arguments. In general, however, the arguments may be
integers or ﬂoating-point numbers. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:292;" 
class="tabbing">(mod 13 4) <span class="math"> ⇒</span> 1                           </td><td  
class="tabbing">(rem 13 4) <span class="math"> ⇒</span> 1
</td></tr></table>
<!--l. 3198--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:292;" 
class="tabbing">(mod -13 4) <span class="math"> ⇒</span> 3                          </td><td  
class="tabbing">(rem -13 4) <span class="math"> ⇒</span> -1</td></tr></table>
<!--l. 3199--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:292;" 
class="tabbing">(mod 13 -4) <span class="math"> ⇒</span> -3                         </td><td  
class="tabbing">(rem 13 -4) <span class="math"> ⇒</span> 1</td></tr></table>
<!--l. 3200--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:292;" 
class="tabbing">(mod -13 -4) <span class="math"> ⇒</span> -1                        </td><td  
class="tabbing">(rem -13 -4) <span class="math"> ⇒</span> -1</td></tr></table>
<!--l. 3201--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:292;" 
class="tabbing">(mod 13.4 1) <span class="math"> ⇒</span> 0.4                       </td><td  
class="tabbing">(rem 13.4 1) <span class="math"> ⇒</span> 0.4</td></tr></table>
                                                                          

                                                                          
<!--l. 3202--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:292;" 
class="tabbing">(mod -13.4 1) <span class="math"> ⇒</span> 0.6                      </td><td  
class="tabbing">(rem -13.4 1) <span class="math"> ⇒</span> -0.4</td></tr></table>
<!--l. 3204--><p class="indent" >
</div>
</div>
<div class=incompatibility>
<!--l. 3207--><p class="noindent" ><b>Compatibility note:</b> The Interlisp function remainder is essentially equivalent to the
Common Lisp function <a 
href="#x83-184022r224">rem</a>. The MacLisp function remainder is like <a 
href="#x83-184022r224">rem</a> but accepts
only integer arguments.
</div>
</div>
<div class=defun>
<!--l. 3215--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184023"></a><a 
 id="x83-184024r225"></a><b> ﬄoor</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184025"></a><a 
 id="x83-184026r226"></a><b> fceiling</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184027"></a><a 
 id="x83-184028r227"></a><b> ftruncate</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184029"></a><a 
 id="x83-184030r228"></a><b> fround</b>  <i>number</i> &#x0026;optional  <i>divisor</i>
<!--l. 3220--><p class="noindent" >These functions are just like <a 
href="#x83-184012r219">ﬂoor</a>, <a 
href="#x83-184014r220">ceiling</a>, <a 
href="#x83-184016r221">truncate</a>, and <a 
href="#x83-184018r222">round</a>, except that the
result (the ﬁrst result of two) is always a ﬂoating-point number rather than an
integer. It is roughly as if <a 
href="#x83-184024r225">ﬄoor</a> gave its arguments to <a 
href="#x83-184012r219">ﬂoor</a>, and then applied <a 
href="#x83-184002r214">ﬂoat</a>
to the ﬁrst result before passing them both back. In practice, however, <a 
href="#x83-184024r225">ﬄoor</a> may
be implemented much more eﬃciently. Similar remarks apply to the other three
functions. If the ﬁrst argument is a ﬂoating-point number, and the second
argument is not a ﬂoating-point number of longer format, then the ﬁrst result will
be a ﬂoating-point number of the same type as the ﬁrst argument. For example:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬄoor -4.7) <span class="math"> ⇒</span> -5.0 and 0.3
</td></tr></table>
<!--l. 3233--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬄoor 3.5d0) <span class="math"> ⇒</span> 3.0d0 and 0.5d0</td></tr></table>
<!--l. 3235--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 3238--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184031"></a><a 
 id="x83-184032r229"></a><b> decode-ﬂoat</b>  <i>ﬂoat</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184033"></a><a 
 id="x83-184034r230"></a><b> scale-ﬂoat</b>  <i>ﬂoat</i> <i>integer</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184035"></a><a 
 id="x83-184036r231"></a><b> ﬂoat-radix</b>  <i>ﬂoat</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184037"></a><a 
 id="x83-184038r232"></a><b> ﬂoat-sign</b>  <i>ﬂoat1</i> &#x0026;optional  <i>ﬂoat2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184039"></a><a 
 id="x83-184040r233"></a><b> ﬂoat-digits</b>  <i>ﬂoat</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184041"></a><a 
 id="x83-184042r234"></a><b> ﬂoat-precision</b>  <i>ﬂoat</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184043"></a><a 
 id="x83-184044r235"></a><b> integer-decode-ﬂoat</b>  <i>ﬂoat</i>
<!--l. 3246--><p class="noindent" >The function <a 
href="#x83-184032r229">decode-ﬂoat</a> takes a ﬂoating-point number and returns three
values.
<!--l. 3250--><p class="indent" >   The ﬁrst value is a new ﬂoating-point number of the same format representing
the signiﬁcand; the second value is an integer representing the exponent; and the
third value is a ﬂoating-point number of the same format indicating the sign
(<span class="math"> − 1.0</span> or <span class="math">1.0</span>). Let <i>b</i> be the radix for the ﬂoating-point representation; then
<a 
href="#x83-184032r229">decode-ﬂoat</a> divides the argument by an integral power of <i>b</i> so as to bring its
value between 1/<i>b</i> (inclusive) and 1 (exclusive) and returns the quotient as the
ﬁrst value. If the argument is zero, however, the result is equal to the absolute
value of the argument (that is, if there is a negative zero, its signiﬁcand is
considered to be a positive zero).
<!--l. 3262--><p class="indent" >   The second value of <a 
href="#x83-184032r229">decode-ﬂoat</a> is the integer exponent <i>e</i> to which <i>b</i> must be
raised to produce the appropriate power for the division. If the argument is zero,
any integer value may be returned, provided that the identity shown below for
<a 
href="#x83-184034r230">scale-ﬂoat</a> holds.
<!--l. 3268--><p class="indent" >   The third value of <a 
href="#x83-184032r229">decode-ﬂoat</a> is a ﬂoating-point number, of the same format
as the argument, whose absolute value is 1 and whose sign matches that of the
argument.
<!--l. 3272--><p class="indent" >   The function <a 
href="#x83-184034r230">scale-ﬂoat</a> takes a ﬂoating-point number <i>f </i> (not necessarily
between 1/<i>b</i> and 1) and an integer <i>k</i>, and returns (* <i>f </i> (expt (ﬂoat <i>b</i> <i>f </i>) <i>k</i>)). (The
use of <a 
href="#x83-184034r230">scale-ﬂoat</a> may be much more eﬃcient than using exponentiation and
multiplication and avoids intermediate overﬂow and underﬂow if the ﬁnal result is
representable.)
<!--l. 3279--><p class="indent" >   Note that <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(multiple-value-bind (signif expon sign)
</td></tr></table>
<!--l. 3281--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                     (decode-ﬂoat <i>f </i>)</td></tr></table>
<!--l. 3282--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (scale-ﬂoat signif expon))</td></tr></table>
<!--l. 3283--><p class="indent" >                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><span class="math"> ≡</span> (abs <i>f </i>)</td></tr></table>
<!--l. 3285--><p class="indent" >
</div>
                                                                          

                                                                          
</div>
<!--l. 3286--><p class="noindent" >and <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(multiple-value-bind (signif expon sign)
</td></tr></table>
<!--l. 3288--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                     (decode-ﬂoat <i>f </i>)</td></tr></table>
<!--l. 3289--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (* (scale-ﬂoat signif expon) sign))</td></tr></table>
<!--l. 3290--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><span class="math"> ≡</span> <i>f </i></td></tr></table>
<!--l. 3292--><p class="indent" >
</div>
</div>
<!--l. 3294--><p class="indent" >   The function <a 
href="#x83-184036r231">ﬂoat-radix</a> returns (as an integer) the radix <i>b</i> of the
ﬂoating-point argument.
<!--l. 3297--><p class="indent" >   The function <a 
href="#x83-184038r232">ﬂoat-sign</a> returns a ﬂoating-point number <span class="math"><i>z</i></span> such that <span class="math"><i>z</i></span> and
<i>ﬂoat1</i> have the same sign and also such that <span class="math"><i>z</i></span> and <i>ﬂoat2</i> have the same
absolute value. The argument <i>ﬂoat2</i> defaults to the value of (ﬂoat 1 <i>ﬂoat1</i>);
(ﬂoat-sign x) therefore always produces a 1.0 or -1.0 of appropriate format
according to the sign of x. (Note that if an implementation has distinct
representations for negative zero and positive zero, then (ﬂoat-sign -0.0)
<span class="math"> ⇒</span> -1.0.)
<!--l. 3307--><p class="indent" >   The function <a 
href="#x83-184040r233">ﬂoat-digits</a> returns, as a non-negative integer, the number of
radix-<i>b</i> digits used in the representation of its argument (including any implicit
digits, such as a “hidden bit”). The function <a 
href="#x83-184042r234">ﬂoat-precision</a> returns, as a
non-negative integer, the number of signiﬁcant radix-<i>b</i> digits present in the
argument; if the argument is (a ﬂoating-point) zero, then the result is
(an integer) zero. For normalized ﬂoating-point numbers, the results of
<a 
href="#x83-184040r233">ﬂoat-digits</a> and <a 
href="#x83-184042r234">ﬂoat-precision</a> will be the same, but the precision will be
less than the number of representation digits for a denormalized or zero
number.
<!--l. 3321--><p class="indent" >   The function <a 
href="#x83-184044r235">integer-decode-ﬂoat</a> is similar to <a 
href="#x83-184032r229">decode-ﬂoat</a> but for its ﬁrst
value returns, as an integer, the signiﬁcand scaled so as to be an integer. For an
argument <i>f </i>, this integer will be strictly less than <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(expt <i>b</i> (ﬂoat-precision <i>f </i>))
</td></tr></table>
<!--l. 3327--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 3328--><p class="noindent" >but no less than <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(expt <i>b</i> (- (ﬂoat-precision <i>f </i>) 1))
</td></tr></table>
<!--l. 3331--><p class="indent" >
</div>
</div>
<!--l. 3332--><p class="noindent" >except that if <i>f </i> is zero, then the integer value will be zero.
<!--l. 3334--><p class="indent" >   The second value bears the same relationship to the ﬁrst value as for
<a 
href="#x83-184032r229">decode-ﬂoat</a>: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(multiple-value-bind (signif expon sign)
</td></tr></table>
<!--l. 3337--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                     (integer-decode-ﬂoat <i>f </i>)</td></tr></table>
<!--l. 3338--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (scale-ﬂoat (ﬂoat signif <i>f </i>) expon))</td></tr></table>
<!--l. 3339--><p class="indent" >                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><span class="math"> ≡</span> (abs <i>f </i>)</td></tr></table>
<!--l. 3341--><p class="indent" >
</div>
</div>
<!--l. 3343--><p class="indent" >   The third value of <a 
href="#x83-184044r235">integer-decode-ﬂoat</a> will be 1 or -1.
<div class=rationale>
<!--l. 3346--><p class="noindent" ><b>Rationale:</b> These functions allow the writing of machine-independent, or at least
machine-parameterized, ﬂoating-point software of reasonable eﬃciency.
</div>
</div>
<div class=defun>
<!--l. 3354--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184045"></a><a 
 id="x83-184046r236"></a><b> complex</b>  <i>realpart</i> &#x0026;optional  <i>imagpart</i>
<!--l. 3356--><p class="noindent" >The arguments must be non-complex numbers; a number is returned that has
<i>realpart</i> as its real part and <i>imagpart</i> as its imaginary part, possibly converted
according to the rule of ﬂoating-point contagion (thus both components will be of
the same type). If <i>imagpart</i> is not speciﬁed, then (coerce 0 (type-of <i>realpart</i>)) is
eﬀectively used. Note that if both the <i>realpart</i> and <i>imagpart</i> are rational and
the <i>imagpart</i> is zero, then the result is just the <i>realpart</i> because of the
                                                                          

                                                                          
rule of canonical representation for complex rationals. It follows that the
result of <a 
href="#x83-184046r236">complex</a> is not always a complex number; it may be simply a
<a 
href="#x83-184004r215">rational</a>.
</div>
<div class=defun>
<!--l. 3370--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184047"></a><a 
 id="x83-184048r237"></a><b> realpart</b>  <i>number</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184049"></a><a 
 id="x83-184050r238"></a><b> imagpart</b>  <i>number</i>
<!--l. 3373--><p class="noindent" >These return the real and imaginary parts of a complex number. If <i>number</i> is a
non-complex number, then <a 
href="#x83-184048r237">realpart</a> returns its argument <i>number</i> and <a 
href="#x83-184050r238">imagpart</a>
returns (* 0 <i>number</i>), which has the eﬀect that the imaginary part of a rational is
0 and that of a ﬂoating-point number is a ﬂoating-point zero of the same
format.
<div class=newer>
<!--l. 3382--><p class="indent" >   A clever way to multiply a complex number <i>z</i> by <i>i</i> is to write <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(complex (- (imagpart <i>z</i>)) (realpart <i>z</i>))
</td></tr></table>
<!--l. 3385--><p class="indent" >
</div>
</div>
<!--l. 3386--><p class="noindent" >instead of (* <i>z</i> #c(0 1)). This cleverness is not always gratuitous; it may be of
particular importance in the presence of minus zero. For example, if we are using
IEEE standard ﬂoating-point arithmetic and <span class="math">z = 4 + 0<i>i</i></span>, the result of the clever
expression is <span class="math"> − 0 + 4<i>i</i></span>, a true <span class="math">90<sup>∘</sup></span> rotation of <span class="math"><i>z</i></span>, whereas the result of (* <i>z</i>
#c(0 1)) is likely to be <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><span class="math">(4 + 0<i>i</i>)(+0 + <i>i</i>) = ((4)(+0) − (+0)(1)) + ((4)(1) + (+0)(+0))<i>i</i></span>
</td></tr></table>
<!--l. 3393--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      <span class="math"> = ((+0) − (+0)) + ((4) + (+0))<i>i</i> = +0 + 4<i>i</i></span></td></tr></table>
<!--l. 3395--><p class="indent" >
</div>
<!--l. 3396--><p class="noindent" >which could land on the wrong side of a branch cut, for example.
</div>
</div>
                                                                          

                                                                          
   <!--l. 3402--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse67.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse65.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse65.html#tailclmse65.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse66.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse66.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 3402--><p class="indent" >   <a 
 id="tailclmse66.html"></a>  
</body></html> 
