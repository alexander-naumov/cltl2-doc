<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Logical Operations on Numbers Логические операции над числами</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-30 23:01:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 3700--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse67.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse65.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse65.html#tailclmse65.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse66.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse66.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">12.7   </span> <a 
href="clm.html#QQ2-83-211" id="x83-18400012.7">Logical Operations on Numbers Логические операции над
числами</a></h3>
<!--l. 3702--><p class="noindent" >The logical operations in this section require integers as arguments; it is an error
to supply a non-integer as an argument. The functions all treat integers as if they
were represented in two&#x2019;s- complement notation.
<!--l. 3707--><p class="indent" >   Логические операции в данном разделе в качестве аргументов требуют
целых чисел. Передача числа любого другого формата является ошибкой.
Функции обрабатывают целые числа, как если бы они были представлены в
двух системах счисления. FIXME
<div class=implementation>
<!--l. 3713--><p class="noindent" ><b>Заметка для реализации:</b> Internally, of course, an implementation of Common Lisp
may or may not use a two&#x2019;s-complement representation. All that is necessary is that the
logical operations perform calculations so as to give this appearance to the
user.
<!--l. 3719--><p class="indent" >   Внутренне, конечно, реализация Common Lisp&#x2019;а может использовать и может и
нет представление числа с дополнительным кодом. Все, что необходимо это
чтобы логические операции выполняли вычисление так, как описано в
разделе.
</div>
<!--l. 3725--><p class="indent" >   The logical operations provide a convenient way to represent an inﬁnite vector
of bits. Let such a conceptual vector be indexed by the non-negative integers.
Then bit <span class="math">j</span> is assigned a “weight” <span class="math">2<sup>j</sup></span>. Assume that only a ﬁnite number of
bits are 1&#x2019;s or only a ﬁnite number of bits are 0&#x2019;s. A vector with only a
ﬁnite number of one-bits is represented as the sum of the weights of the
one-bits, a positive integer. A vector with only a ﬁnite number of zero-bits is
represented as <tt>-1</tt> minus the sum of the weights of the zero-bits, a negative
integer.
<!--l. 3736--><p class="indent" >   Логические операции предоставляют удобный способ для представления
бесконечного вектора битов. Пусть такой концептуальный вектор будет
индексироваться с помощью неотрицательного целого. Тогда биту <span class="math">j</span>
присваивается «вес (weight)» <span class="math">2<sup>j</sup></span>. Предположим, что лишь конечное число
                                                                          

                                                                          
битов являются 1 или только конечное число битов являются 0. Вектор, у
которого конечное число битов 1, представлен как сумма всех весов этих
битов, и является положительным числом. Вектор, у которого конечное
число битов 0, представлен как <tt>-1</tt> минус сумма всех весов этих битов, и
является отрицательным числом. FIXME
<!--l. 3746--><p class="indent" >   This method of using integers to represent bit-vectors can in turn be used to
represent sets. Suppose that some (possibly countably inﬁnite) universe of
discourse for sets is mapped into the non-negative integers. Then a set can be
represented as a bit vector; an element is in the set if the bit whose index
corresponds to that element is a one-bit. In this way all ﬁnite sets can be
represented (by positive integers), as well as all sets whose complement are ﬁnite
(by negative integers). The functions <tt><a 
href="#x83-184002r239">logior</a></tt>, <tt><a 
href="#x83-184006r241">logand</a></tt>, and <tt><a 
href="#x83-184004r240">logxor</a></tt> deﬁned below
then compute the union, intersection, and symmetric diﬀerence operations on sets
represented in this way.
<!--l. 3759--><p class="indent" >   Данный метод использования целых чисел для представления битовых
векторов может в свою очередь использоваться для представления множеств.
Предположим, что некоторая (возможно бесконечная) совокупность
рассуждений для множеств отображается в неотрицательные целые числа.
FIXME Тогда множество может быть представлено как битовый вектор.
Элемент принадлежит множеству, если бит, индекс которого соотвествует
элементу, является 1. Таким образом все конечные множества могут быть
представлены с помощью положительных целых, и множества, дополнения
которых конечны, с помощью отрицательных чисел. Функции <tt><a 
href="#x83-184002r239">logior</a></tt>, <tt><a 
href="#x83-184006r241">logand</a></tt>
и <tt><a 
href="#x83-184004r240">logxor</a></tt>, определенные ниже, вычисляют объединение, пересечение и
симметричную разность для таких множеств.
<div class=defun>
<!--l. 3771--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184001"></a><a 
 id="x83-184002r239"></a><b> logior</b>  &#x0026;rest  <i>integers</i>
<!--l. 3773--><p class="noindent" >This returns the bit-wise logical <i>inclusive or</i> of its arguments. If no argument is
given, then the result is zero, which is an identity for this operation.
<!--l. 3778--><p class="indent" >   Функция возвращает побитовое логическое <i>или</i> для аргументов. Если ни
один аргумент не задан, возвращается ноль.
</div>
<div class=defun>
<!--l. 3782--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184003"></a><a 
 id="x83-184004r240"></a><b> logxor</b>  &#x0026;rest  <i>integers</i>
<!--l. 3784--><p class="noindent" >This returns the bit-wise logical <i>exclusive or</i> of its arguments. If no argument is
given, then the result is zero, which is an identity for this operation.
<!--l. 3789--><p class="indent" >   Функция возвращает побитовое логическое <i>исключающее или</i> для
аргументов. Если ни один аргумент не задан, возвращается ноль.
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 3793--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184005"></a><a 
 id="x83-184006r241"></a><b> logand</b>  &#x0026;rest  <i>integers</i>
<!--l. 3795--><p class="noindent" >This returns the bit-wise logical <i>and</i> of its arguments. If no argument is given,
then the result is <tt>-1</tt>, which is an identity for this operation.
<!--l. 3800--><p class="indent" >   Функция возвращает побитовое логическое <i>и</i> для аргументов. Если ни
один аргумент не задан, возвращается ноль.
</div>
<div class=defun>
<!--l. 3804--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184007"></a><a 
 id="x83-184008r242"></a><b> logeqv</b>  &#x0026;rest  <i>integers</i>
<!--l. 3806--><p class="noindent" >This returns the bit-wise logical <i>equivalence</i> (also known as <i>exclusive nor</i>) of its
arguments. If no argument is given, then the result is <tt>-1</tt>, which is an identity for
this operation.
<!--l. 3812--><p class="indent" >   Функция возвращает побитовую логическую <i>эквивалентность</i> (также
известную как <i>исключающее отрицающее или</i> для аргументов. Если ни один
аргумент не задан, возвращается ноль.
</div>
<div class=defun>
<!--l. 3817--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184009"></a><a 
 id="x83-184010r243"></a><b> lognand</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184011"></a><a 
 id="x83-184012r244"></a><b> lognor</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184013"></a><a 
 id="x83-184014r245"></a><b> logandc1</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184015"></a><a 
 id="x83-184016r246"></a><b> logandc2</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184017"></a><a 
 id="x83-184018r247"></a><b> logorc1</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx83-184019"></a><a 
 id="x83-184020r248"></a><b> logorc2</b>  <i>integer1</i> <i>integer2</i>
<!--l. 3824--><p class="noindent" >These are the other six non-trivial bit-wise logical operations on two arguments.
Because they are not associative, they take exactly two arguments rather than
any non-negative number of arguments. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(lognand <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (lognot (logand <i>n1</i> <i>n2</i>))
</td></tr></table>
<!--l. 3830--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(lognor <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (lognot (logior <i>n1</i> <i>n2</i>))
</td></tr></table>
<!--l. 3831--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logandc1 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logand (lognot <i>n1</i>) <i>n2</i>)
</td></tr></table>
<!--l. 3832--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logandc2 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logand <i>n1</i> (lognot <i>n2</i>))
</td></tr></table>
<!--l. 3833--><p class="indent" >
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logorc1 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logior (lognot <i>n1</i>) <i>n2</i>)
</td></tr></table>
<!--l. 3834--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logorc2 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logior <i>n1</i> (lognot <i>n2</i>))
</td></tr></table>
<!--l. 3836--><p class="indent" >
</div>
</div>
<!--l. 3838--><p class="indent" >   Данные функции служат для шести нетривиальные битовый логический
операций для двух аргументов. Так как они не ассоциативны, они принимают
только два аргумента. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(lognand <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (lognot (logand <i>n1</i> <i>n2</i>))
</td></tr></table>
<!--l. 3842--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(lognor <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (lognot (logior <i>n1</i> <i>n2</i>))
</td></tr></table>
<!--l. 3843--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logandc1 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logand (lognot <i>n1</i>) <i>n2</i>)
</td></tr></table>
<!--l. 3844--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logandc2 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logand <i>n1</i> (lognot <i>n2</i>))
</td></tr></table>
<!--l. 3845--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logorc1 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logior (lognot <i>n1</i>) <i>n2</i>)
</td></tr></table>
<!--l. 3846--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logorc2 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logior <i>n1</i> (lognot <i>n2</i>))
</td></tr></table>
<!--l. 3848--><p class="indent" >
</div>
</div>
</div>
<!--l. 3851--><p class="indent" >   The ten bit-wise logical operations on two integers are summarized in the
following table:
<div class="flushleft" 
>
<!--l. 3853--><p class="noindent" >
                                                                          

                                                                          
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" > <i>integer1</i></td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td>
</tr><tr><td align="left" > <i>integer2</i></td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >Operation Name                                  </td>
</tr><tr><td align="left" >logand  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >and                                                   </td>
</tr><tr><td align="left" > logior  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >inclusive or                                         </td>
</tr><tr><td align="left" > logxor  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >exclusive or                                        </td>
</tr><tr><td align="left" >logeqv  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >equivalence (exclusive nor)                    </td>
</tr><tr><td align="left" >lognand </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >not-and                                             </td>
</tr><tr><td align="left" > lognor  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >not-or                                               </td>
</tr><tr><td align="left" >logandc1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >and complement of <i>integer1</i> with <i>integer2</i></td>
</tr><tr><td align="left" >logandc2</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >and <i>integer1</i> with complement of <i>integer2</i></td>
</tr><tr><td align="left" > logorc1 </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >or complement of <i>integer1</i> with <i>integer2</i>  </td>
</tr><tr><td align="left" > logorc2 </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >or <i>integer1</i> with complement of <i>integer2</i>  </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table></div></div>
<!--l. 3873--><p class="indent" >   В следующей таблице перечислены десять битовых логических операций
для двух целых чисел.
<div class="flushleft" 
>
<!--l. 3875--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" > <i>integer1</i></td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td>
</tr><tr><td align="left" > <i>integer2</i></td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >Имя операции                                                 </td>
</tr><tr><td align="left" >logand  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >и                                                                   </td>
</tr><tr><td align="left" > logior  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >или                                                                </td>
</tr><tr><td align="left" > logxor  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >исключающее или                                            </td>
</tr><tr><td align="left" >logeqv  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >эквивалентность (исключающее отрицающее или)</td>
</tr><tr><td align="left" >lognand </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >не и                                                               </td>
</tr><tr><td align="left" > lognor  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >не или                                                            </td>
</tr><tr><td align="left" >logandc1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >не <i>integer1</i> и <i>integer2</i>                                     </td>
</tr><tr><td align="left" >logandc2</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" ><i>integer1</i> и не <i>integer2</i>                                     </td>
</tr><tr><td align="left" > logorc1 </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >не <i>integer1</i> или <i>integer2</i>                                  </td>
</tr><tr><td align="left" > logorc2 </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" ><i>integer1</i> или не <i>integer2</i>                                  </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table></div></div>
<div class=defun>
<!--l. 3895--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184021"></a><a 
 id="x83-184022r249"></a><b> boole</b>  <i>op</i> <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184023"></a><a 
 id="x83-184024r250"></a><b> boole-clr</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184025"></a><a 
 id="x83-184026r251"></a><b> boole-set</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184027"></a><a 
 id="x83-184028r252"></a><b> boole-1</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184029"></a><a 
 id="x83-184030r253"></a><b> boole-2</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184031"></a><a 
 id="x83-184032r254"></a><b> boole-c1</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184033"></a><a 
 id="x83-184034r255"></a><b> boole-c2</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184035"></a><a 
 id="x83-184036r256"></a><b> boole-and</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184037"></a><a 
 id="x83-184038r257"></a><b> boole-ior</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184039"></a><a 
 id="x83-184040r258"></a><b> boole-xor</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184041"></a><a 
 id="x83-184042r259"></a><b> boole-eqv</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184043"></a><a 
 id="x83-184044r260"></a><b> boole-nand</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184045"></a><a 
 id="x83-184046r261"></a><b> boole-nor</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184047"></a><a 
 id="x83-184048r262"></a><b> boole-andc1</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184049"></a><a 
 id="x83-184050r263"></a><b> boole-andc2</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184051"></a><a 
 id="x83-184052r264"></a><b> boole-orc1</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx83-184053"></a><a 
 id="x83-184054r265"></a><b> boole-orc2</b>
<!--l. 3913--><p class="noindent" >The function <tt><a 
href="#x83-184022r249">boole</a></tt> takes an operation <i>op</i> and two integers, and returns
an integer produced by performing the logical operation speciﬁed by <i>op</i>
on the two integers. The precise values of the sixteen constants are
implementation-dependent, but they are suitable for use as the ﬁrst argument to
<tt><a 
href="#x83-184022r249">boole</a></tt>:
<div class="flushleft" 
>
<!--l. 3919--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >     <i>integer1</i></td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td>
</tr><tr><td align="left" >     <i>integer2</i></td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >Operation Performed                            </td>
</tr><tr><td align="left" >  boole-clr  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >always 0                                            </td>
</tr><tr><td align="left" > boole-set  </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >always 1                                            </td>
</tr><tr><td align="left" >boole-1    </td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" ><i>integer1</i>                                          </td>
</tr><tr><td align="left" >boole-2    </td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" ><i>integer2</i>                                          </td>
</tr><tr><td align="left" > boole-c1   </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >complement of <i>integer1</i>                       </td>
</tr><tr><td align="left" > boole-c2   </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >complement of <i>integer2</i>                       </td>
</tr><tr><td align="left" >boole-and  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >and                                                   </td></tr><tr><td align="left" > boole-ior  </td> <td align="left" >0</td> <td align="left" >1</td> <td align="left" >1</td> <td align="left" >1</td> <td align="left" >inclusive or</td>
</tr><tr><td align="left" > boole-xor  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >exclusive or                                        </td>
</tr><tr><td align="left" >boole-eqv  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >equivalence (exclusive nor)                    </td>
</tr><tr><td align="left" >boole-nand </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >not-and                                             </td></tr><tr><td align="left" > boole-nor  </td> <td align="left" >1</td> <td align="left" >0</td> <td align="left" >0</td> <td align="left" >0</td> <td align="left" >not-or</td>
</tr><tr><td align="left" >boole-andc1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >and complement of <i>integer1</i> with <i>integer2</i></td>
</tr><tr><td align="left" >boole-andc2</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >and <i>integer1</i> with complement of <i>integer2</i></td>
</tr><tr><td align="left" > boole-orc1 </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >or complement of <i>integer1</i> with <i>integer2</i>  </td>
</tr><tr><td align="left" > boole-orc2 </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >or <i>integer1</i> with complement of <i>integer2</i>  </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table></div></div>
<!--l. 3945--><p class="indent" >   Функция <tt><a 
href="#x83-184022r249">boole</a></tt> принимает операцию <i>op</i> и два целых числа, и возвращает
целое число полученное применением операции <i>op</i> к этим двум числам.
Точные значения шестнадцати констант зависят от реализации, но
они подходят для использования в качестве первого аргумента для
<tt><a 
href="#x83-184022r249">boole</a></tt>:
<div class="flushleft" 
>
<!--l. 3949--><p class="noindent" >
                                                                          

                                                                          
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >     <i>integer1</i></td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td>
</tr><tr><td align="left" >     <i>integer2</i></td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >ВЫполняемая операция                                       </td>
</tr><tr><td align="left" >  boole-clr  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >всегда 0                                                             </td>
</tr><tr><td align="left" > boole-set  </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >всегда 1                                                             </td>
</tr><tr><td align="left" >boole-1    </td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" ><i>integer1</i>                                                         </td>
</tr><tr><td align="left" >boole-2    </td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" ><i>integer2</i>                                                         </td>
</tr><tr><td align="left" > boole-c1   </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >дополнение <i>integer1</i>                                          </td>
</tr><tr><td align="left" > boole-c2   </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >дополнение <i>integer2</i>                                          </td>
</tr><tr><td align="left" >boole-and  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >и                                                                       </td></tr><tr><td align="left" > boole-ior  </td> <td align="left" >0</td> <td align="left" >1</td> <td align="left" >1</td> <td align="left" >1</td> <td align="left" >или</td>
</tr><tr><td align="left" > boole-xor  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >исключающее или                                               </td>
</tr><tr><td align="left" >boole-eqv  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >эквивалентность (исключительное отрицающее или)</td>
</tr><tr><td align="left" >boole-nand </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >не и                                                                   </td></tr><tr><td align="left" > boole-nor  </td> <td align="left" >1</td> <td align="left" >0</td> <td align="left" >0</td> <td align="left" >0</td> <td align="left" >не или</td>
</tr><tr><td align="left" >boole-andc1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >не <i>integer1</i> и <i>integer2</i>                                        </td>
</tr><tr><td align="left" >boole-andc2</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" ><i>integer1</i> и не <i>integer2</i>                                        </td>
</tr><tr><td align="left" > boole-orc1 </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >не <i>integer1</i> или <i>integer2</i>                                     </td>
</tr><tr><td align="left" > boole-orc2 </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" ><i>integer1</i> или не <i>integer2</i>                                     </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table></div></div>
<tt>
<!--l. 3975--><p class="indent" >   <a 
href="#x83-184022r249">boole</a></tt> can therefore compute all sixteen logical functions on two arguments. In
general, <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(boole boole-and x y) <span class="math"> ≡</span> (logand x y)
</td></tr></table>
<!--l. 3979--><p class="indent" >
</div>
</div>
<!--l. 3980--><p class="noindent" >and the latter is more perspicuous. However, <tt><a 
href="#x83-184022r249">boole</a></tt> is useful when it is necessary to
parameterize a procedure so that it can use one of several logical operations.
<!--l. 3984--><p class="indent" >   Таким образом <tt><a 
href="#x83-184022r249">boole</a></tt> может вычислять все шестнадцать логических
функций для двух аргументов. В целом, <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(boole boole-and x y) <span class="math"> ≡</span> (logand x y)
</td></tr></table>
<!--l. 3988--><p class="indent" >
</div>
</div>
<!--l. 3989--><p class="noindent" >и далее по аналогии. <tt><a 
href="#x83-184022r249">boole</a></tt> полезна, когда необходимо параметризировать
процедуру так, что они может использовать одну из нескольких логических
операций.
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 3994--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184055"></a><a 
 id="x83-184056r266"></a><b> lognot</b>  <i>integer</i>
<!--l. 3996--><p class="noindent" >This returns the bit-wise logical <i>not</i> of its argument. Every bit of the result is the
complement of the corresponding bit in the argument. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp <i>j</i> (lognot <i>x</i>)) <span class="math"> ≡</span> (not (logbitp <i>j</i> <i>x</i>))
</td></tr></table>
<!--l. 4002--><p class="indent" >
</div>
</div>
<!--l. 4004--><p class="indent" >   Функция возвращает битовое логическое <i>отрицание</i> аргумента. Каждый
бит результата является дополнение соотвествующего исходного бита
аргумента. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp <i>j</i> (lognot <i>x</i>)) <span class="math"> ≡</span> (not (logbitp <i>j</i> <i>x</i>))
</td></tr></table>
<!--l. 4009--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 4012--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184057"></a><a 
 id="x83-184058r267"></a><b> logtest</b>  <i>integer1</i> <i>integer2</i>
<!--l. 4014--><p class="noindent" ><tt><a 
href="#x83-184058r267">logtest</a></tt> is a predicate that is true if any of the bits designated by the 1&#x2019;s in
<i>integer1</i> are 1&#x2019;s in <i>integer2</i>. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logtest <i>x</i> <i>y</i>) <span class="math"> ≡</span> (not (zerop (logand <i>x</i> <i>y</i>)))
</td></tr></table>
<!--l. 4019--><p class="indent" >
</div>
</div>
<tt>
<!--l. 4021--><p class="indent" >   <a 
href="#x83-184058r267">logtest</a></tt> является предикатом, который истинен, если любой бит
определенный как 1 в <i>integer1</i> также является соответствующим битом 1 в
<i>integer2</i>. <div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logtest <i>x</i> <i>y</i>) <span class="math"> ≡</span> (not (zerop (logand <i>x</i> <i>y</i>)))
</td></tr></table>
<!--l. 4026--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 4029--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184059"></a><a 
 id="x83-184060r268"></a><b> logbitp</b>  <i>index</i> <i>integer</i>
<!--l. 4031--><p class="noindent" ><tt><a 
href="#x83-184060r268">logbitp</a></tt> is true if the bit in <i>integer</i> whose index is <i>index</i> (that is, its weight is
<span class="math">2<sup>index</sup></span>) is a one-bit; otherwise it is false. For example: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp 2 6) is true
</td></tr></table>
<!--l. 4037--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp 0 6) is false</td></tr></table>
<!--l. 4038--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp <i>k</i> <i>n</i>) <span class="math"> ≡</span> (ldb-test (byte 1 <i>k</i>) <i>n</i>)</td></tr></table>
<!--l. 4040--><p class="indent" >
</div>
</div>
<!--l. 4042--><p class="indent" >   The <i>index</i> must be a non-negative integer.
<!--l. 4044--><p class="indent" >   Предикат <tt><a 
href="#x83-184060r268">logbitp</a></tt> является истиной, если бит в позиции <i>index</i> в целом
числе <i>integer</i> (то есть, его вес <span class="math">2<sup>index</sup></span>), является 1, иначе предикат ложен.
Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp 2 6) is true
</td></tr></table>
<!--l. 4049--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp 0 6) is false</td></tr></table>
<!--l. 4050--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp <i>k</i> <i>n</i>) <span class="math"> ≡</span> (ldb-test (byte 1 <i>k</i>) <i>n</i>)</td></tr></table>
<!--l. 4052--><p class="indent" >
</div>
</div>
<i>
<!--l. 4054--><p class="indent" >   index</i> должен быть неотрицательным целым числом.
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 4057--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184061"></a><a 
 id="x83-184062r269"></a><b> ash</b>  <i>integer</i> <i>count</i>
<!--l. 4059--><p class="noindent" >This function shifts <i>integer</i> arithmetically left by <i>count</i> bit positions if <i>count</i> is
positive, or right by <span class="math"> −<i>count</i></span> bit positions if <i>count</i> is negative. The sign of the
result is always the same as the sign of <i>integer</i>.
<!--l. 4065--><p class="indent" >   Mathematically speaking, this operation performs the computation
<span class="math"><i>ﬂoor</i>(<i>integer</i> ⋅ 2<sup>count</sup></span>).
<!--l. 4068--><p class="indent" >   Logically, this moves all of the bits in <i>integer</i> to the left, adding zero-bits at
the bottom, or moves them to the right, discarding bits. (In this context the
question of what gets shifted in on the left is irrelevant; integers, viewed as strings
of bits, are “half-inﬁnite,” that is, conceptually extend inﬁnitely far to the left.)
For example: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp <i>j</i> (ash <i>n</i> <i>k</i>)) <span class="math"> ≡</span> (and (&#x003E;= <i>j</i> <i>k</i>) (logbitp (- <i>j</i> <i>k</i>) <i>n</i>))
</td></tr></table>
<!--l. 4076--><p class="indent" >
</div>
</div>
<!--l. 4078--><p class="indent" >   Если <i>count</i> положительное число, данная функция арифметически
сдвигает число <i>integer</i> влево на количество бит <i>count</i>. Если <i>count</i>
отрицательное число, функция сдвигает число <i>integer</i> вправо. Знак
результата всегда такое же как и исходного числа <i>integer</i>.
<!--l. 4083--><p class="indent" >   Говоря математически, эта операция выполняет вычисления
<span class="math"><i>ﬂoor</i>(<i>integer</i> ⋅ 2<sup>count</sup></span>).
<!--l. 4086--><p class="indent" >   Логически, функция перемещает все биты числа <i>integer</i> влева, добавляя
нулевый биты в конец, или вправо отбрасывая биты в конце числа. (В этом
контексте вопрос о том, что сдвигается налево, не относится к делу. Целые
числое, рассматриваемые как строки битов, являются «полубесконечными»,
то есть концептуально расширяются бесконечно влево FIXME.) Например:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp <i>j</i> (ash <i>n</i> <i>k</i>)) <span class="math"> ≡</span> (and (&#x003E;= <i>j</i> <i>k</i>) (logbitp (- <i>j</i> <i>k</i>) <i>n</i>))
</td></tr></table>
<!--l. 4094--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 4097--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184063"></a><a 
 id="x83-184064r270"></a><b> logcount</b>  <i>integer</i>
<!--l. 4099--><p class="noindent" >The number of bits in <i>integer</i> is determined and returned. If <i>integer</i> is positive,
the <tt>1</tt>-bits in its binary representation are counted. If <i>integer</i> is negative, the <tt>0</tt>-bits
in its two&#x2019;s-complement binary representation are counted. The result is always a
non-negative integer. For example: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount 13) <span class="math"> ⇒</span> 3      ;Binary representation is ...0001101
</td></tr></table>
<!--l. 4107--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount -13) <span class="math"> ⇒</span> 2     ;Binary representation is ...1110011</td></tr></table>
<!--l. 4108--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount 30) <span class="math"> ⇒</span> 4      ;Binary representation is ...0011110</td></tr></table>
<!--l. 4109--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount -30) <span class="math"> ⇒</span> 4     ;Binary representation is ...1100010</td></tr></table>
<!--l. 4111--><p class="indent" >
</div>
</div>
<!--l. 4112--><p class="noindent" >The following identity always holds: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount x) <span class="math"> ≡</span> (logcount (- (+ x 1)))
</td></tr></table>
<!--l. 4114--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             <span class="math"> ≡</span> (logcount (lognot x))</td></tr></table>
<!--l. 4116--><p class="indent" >
</div>
</div>
<!--l. 4118--><p class="indent" >   Функция возвращает количество бит в числе <i>integer</i>. Если <i>integer</i>
положительное число, тогда подсчитаны будут биты <tt>1</tt>. Если число <i>integer</i>
отрицательно, то в два раза дополненной (two&#x2019;s-complement) бинарной
форме будут подсчитаны биты <tt>0</tt>. FIXME Результатом всегда является
неотрицательное целое число. Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount 13) <span class="math"> ⇒</span> 3      ;Бинарное представление ...0001101
</td></tr></table>
<!--l. 4126--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount -13) <span class="math"> ⇒</span> 2     ;Бинарное представление ...1110011</td></tr></table>
<!--l. 4127--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount 30) <span class="math"> ⇒</span> 4      ;Бинарное представление ...0011110</td></tr></table>
<!--l. 4128--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount -30) <span class="math"> ⇒</span> 4     ;Бинарное представление ...1100010</td></tr></table>
<!--l. 4130--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 4131--><p class="noindent" >Следующее тождество всегда верно: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount x) <span class="math"> ≡</span> (logcount (- (+ x 1)))
</td></tr></table>
<!--l. 4133--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             <span class="math"> ≡</span> (logcount (lognot x))</td></tr></table>
<!--l. 4135--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 4138--><p class="noindent" ><i>[Function]</i><a 
 id="dx83-184065"></a><a 
 id="x83-184066r271"></a><b> integer-length</b>  <i>integer</i>
<!--l. 4140--><p class="noindent" >This function performs the computation <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><span class="math"><i>ceiling</i>(log <sub>2</sub>(<b>if</b> <i>integer</i> &#x003C; 0 <b>then</b> −<i>integer</i> <b>else</b> <i>integer</i> + 1))</span>
</td></tr></table>
<!--l. 4145--><p class="indent" >
</div>
<!--l. 4146--><p class="noindent" >This is useful in two diﬀerent ways. First, if <i>integer</i> is non-negative, then its value can
be represented in unsigned binary form in a ﬁeld whose width in bits is no smaller
than <tt>(integer-length <i>integer</i>)</tt>. Second, regardless of the sign of <i>integer</i>, its
value can be represented in signed binary two&#x2019;s-complement form in a ﬁeld whose
width in bits is no smaller than <tt>(+ (integer-length <i>integer</i>) 1)</tt>. For
example: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 0) <span class="math"> ⇒</span> 0
</td></tr></table>
<!--l. 4155--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 1) <span class="math"> ⇒</span> 1</td></tr></table>
<!--l. 4156--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 3) <span class="math"> ⇒</span> 2</td></tr></table>
<!--l. 4157--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 4) <span class="math"> ⇒</span> 3</td></tr></table>
<!--l. 4158--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 7) <span class="math"> ⇒</span> 3</td></tr></table>
<!--l. 4159--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -1) <span class="math"> ⇒</span> 0</td></tr></table>
<!--l. 4160--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -4) <span class="math"> ⇒</span> 2</td></tr></table>
<!--l. 4161--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -7) <span class="math"> ⇒</span> 3</td></tr></table>
                                                                          

                                                                          
<!--l. 4162--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -8) <span class="math"> ⇒</span> 3</td></tr></table>
<!--l. 4164--><p class="indent" >
</div>
</div>
<!--l. 4166--><p class="indent" >   Данная функция выполняет следующие вычисления <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><span class="math"><i>ceiling</i>(log <sub>2</sub>(if <i>integer</i> &#x003C; 0 then −<i>integer</i> else <i>integer</i> + 1))</span>
</td></tr></table>
<!--l. 4170--><p class="indent" >
</div>
<!--l. 4171--><p class="noindent" >Эта функция полезна в двух случаях. Первое, если целое число <i>integer</i> не
отрицательно, тогда его значение может быть представлено в беззнаковой
бинарной форме в поле, ширина которого в битах не меньше чем
<tt>(integer-length <i>integer</i>)</tt>. Второе, независимо от знака числа <i>integer</i>, его
значение может быть представлено как знаковая бинарная два раза
дополненная (two&#x2019;s-complement) форма в поле, ширина которого в битах не
меньше чем <tt>(+ (integer-length <i>integer</i>) 1)</tt>. FIXME Например:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 0) <span class="math"> ⇒</span> 0
</td></tr></table>
<!--l. 4181--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 1) <span class="math"> ⇒</span> 1</td></tr></table>
<!--l. 4182--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 3) <span class="math"> ⇒</span> 2</td></tr></table>
<!--l. 4183--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 4) <span class="math"> ⇒</span> 3</td></tr></table>
<!--l. 4184--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 7) <span class="math"> ⇒</span> 3</td></tr></table>
<!--l. 4185--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -1) <span class="math"> ⇒</span> 0</td></tr></table>
<!--l. 4186--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -4) <span class="math"> ⇒</span> 2</td></tr></table>
<!--l. 4187--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -7) <span class="math"> ⇒</span> 3</td></tr></table>
<!--l. 4188--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -8) <span class="math"> ⇒</span> 3</td></tr></table>
<!--l. 4190--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
   <!--l. 4194--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse67.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse65.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse65.html#tailclmse65.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse66.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse66.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 4194--><p class="indent" >   <a 
 id="tailclmse66.html"></a>  
</body></html> 
