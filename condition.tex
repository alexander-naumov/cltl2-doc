%%%Chapter of Common Lisp Manual.  Copyright 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\chapterauthor{Kent M. Pitman}

\def\SU#1{\({}_{#1}\)}

\chapter{Conditions}
\label{CONDITION}

\prefaceword
\begin{new}
The language defined by the first edition contained an enormous lacuna:
although facilities were specified for signaling errors,
no means was defined for handling errors.  This occurred not through neglect
of the issue, but because this part of the Lisp language generally
was in a state of flux.  There were several proposals at the
time.  The committee, finding that it could not agree on any one proposal,
agreed to disagree and omit error handling from Common Lisp for the time being.
This defect has now been addressed.
\end{new}

X3J13 voted in June 1988
\issue{CONDITION-SYSTEM}
to adopt the Common Lisp Condition System
as a part of the forthcoming draft Common Lisp standard.
X3J13 voted in March 1989 \issue{ZLOS-CONDITIONS}
to amend the specification of conditions to integrate them
with the Common Lisp Object System (see chapter~\ref{CLOS}). 
X3J13 voted in June 1989 \issue{CONDITION-RESTARTS} to amend the
specification of restarts in certain ways. These amendments have
been incorporated here with little further comment.

This chapter presents the bulk of the Common Lisp
Condition System proposal, written by Kent~M. Pitman
and amended by X3J13.  I have edited it only very lightly
to conform to the overall style of this book and have inserted a small
number of bracketed remarks identified by the initials GLS.
Please see the Acknowledgments to this second edition for the author's
acknowledgments to others who contributed to the Condition System proposal.

\noindent\hbox to \textwidth{\hss---Guy L. Steele Jr.}
\vskip 8pt plus 3pt minus 2pt



\section{Introduction}

Often we find it useful to describe a function in terms of its behavior in
``normal situations.'' For example, we may say informally that the function
\cd{+} returns the sum of its arguments or that the function
\cd{read-char} returns the next available character on a given input
stream.

Sometimes, however, an ``exceptional situation'' will arise that does not fit
neatly into such descriptions. For example, \cd{+} might receive an argument
that is not a number, or \cd{read-char} might receive as a single argument
a stream that has no more available characters.  This distinction between normal
and exceptional situations is in some sense arbitrary but is often very
useful in practice.

For example, suppose a function \cd{f} were defined to allow only
integer arguments but also guaranteed to
detect and signal an error for non-integer arguments.
Such a description is in fact internally inconsistent (that is,
paradoxical) because the function's behavior is well-defined for non-integers.
Yet we would not want this annoying paradox to force description of \cd{f}
as a function that accepts any kind of argument (just in case \cd{f}
is being called only as a quick way to signal an error, for example).
Using the normal/exceptional distinction, we can say clearly that \cd{f} accepts integers
in the normal situation and signals an error in exceptional situations.
Moreover, we can say that when we refer to the definition of a
function informally, it is acceptable to speak only of its normal behavior.
For example, we can speak informally about \cd{f} as a function that accepts only
integers without feeling that we are committing some awful fraud.

Not all exceptional situations are errors.  For example, a program that is
directing the typing of a long line of text may come to an end-of-line.
It is possible that no real harm will result from failing to signal end-of-line
to its caller because the operating system will simply force a carriage
return on the output device, which will continue typing on the next line. However, it
may still be interesting to establish a protocol whereby the printing program can
inform its caller of end-of-line exceptions. The caller could
then opt to deal with these situations in interesting ways at certain times.
For example, a caller might choose to terminate printing, obtaining an end-of-line
truncation. The important thing, however, is that the failure of the
caller to provide advice about the situation need not prevent
the printer program from operating correctly.

Mechanisms for dealing with exceptional situations vary widely. When an
exceptional situation is encountered, a program may attempt to handle
it by returning a distinguished value, returning an additional value,
setting a variable, calling a function, performing a special transfer of
control, or stopping the program altogether and entering the debugger.

For the most part, the facilities described in this chapter do not introduce
any fundamentally new way of dealing with exceptional situations. Rather, they
encapsulate and formalize useful patterns of data and control flow that have
been seen to be useful in dealing with exceptional situations.

A proper conceptual approach to errors should perhaps begin from first
principles, with a discussion of {\it conditions} in general, and eventually work
up to the concept of an {\it error} as just one of the many kinds of
conditions. However, given the primitive state of error-handling
technology, a proper buildup may be as inappropriate as requiring that a
beggar learn to cook a gourmet meal before being allowed to eat.  Thus,
we deal first with the essentials---error handling---and then
go back later to fill in the missing details.

\section{Changes in Terminology}

In this section, we introduce changes to the terminology
defined in section~\ref{INTRO-ERRORS}.

A {\it condition} is an interesting situation in a program that has been
detected and announced. Later we allow this term also to refer to
objects that programs use to represent such situations.

An {\it error} is a condition in which normal program execution may not
continue without some form of intervention (either interactively by the user
or under some sort of program control, as described below).

The process by which a condition is formally announced by a program is called
{\it signaling}. The function \cd{signal} is the primitive mechanism by which such
announcement is done. Other abstractions, such as \cd{error} and \cd{cerror}, are built
using \cd{signal}.

The first edition is ambiguous about the reason why a particular program action
``is an error.'' There are two principal reasons why an action may be an error
without being required to signal an error:
\begin{itemize}
\item Detecting the error might be prohibitively expensive.

   For example, \cd{(+ nil 3)} is an error. It is likely that the designers of
   Common Lisp believed this would be an error in all implementations but
   felt it might be excessively expensive to detect the problem
   in compiled code on stock hardware, so they did not require that it signal
   an error.

\item Some implementations might implement the behavior as an extension.

   For example, \cd{(loop for x from 1 to 3 do (print x))} is an error because \cd{loop}
   is not defined to take atoms in its body.
   In fact, however, some
   implementations offer an extension that makes this well-defined. In order
   to leave room for such extensions, the first edition used the ``is an error''
   terminology to keep implementors from being forced to signal an error in
   the extended implementations.

   [This example was written well before the vote by X3J13 in January 1989
    to add exactly this extension to the forthcoming draft standard
    (see chapter~\ref{LOOP}).---GLS]
\end{itemize}

In this chapter, we use the following terminology.
[Compare this to the terminology presented
in section~\ref{Error-Terminology-SECTION}.---GLS]
\begin{itemize}
\item
   If the signaling of a condition or error is part of a function's contract
   in all situations, we say that it ``signals'' or ``must signal'' that
   condition or error.

\item
   If the signaling of a condition or error is optional for some important
   reason (such as performance), we say that the program ``might signal''
   that condition or error. In this case, we are defining the operation to be
   illegal in all implementations, but allowing some implementations to fail to
   detect the error.

\item
   If an action is left undefined for the sake of implementation-dependent
   extension, we say that it ``is undefined'' or ``has undefined effect.''
   This means that it is not possible to depend portably upon the effects of
   that action. A program that has undefined effect may enter the debugger,
   transfer control, or modify data in unpredictable ways.

\item
   In the special case where only the return value of an operation is not
   well defined but any side effect and transfer-of-control behavior is
   well defined, we say that it has ``undefined value.'' In this case,
   the number and nature of the return values is not defined, but the
   function can reasonably be expected to return. It is worth noting that
   under this description, there are some (though not many) legitimate ways
   in which such return value(s) can be used. For example, if the function
   \cd{foo} has no side effects and undefined value, the expression 
   \cd{(length (list (foo)))} is completely well defined even for portable code.
   However, the effect of \cd{(print (list (foo)))} is not well defined.
\end{itemize}


\section{Survey of Concepts}

This section discusses various aspects of the condition system by topic,
illustrating them with extensive examples.  The next section contains
definitions of specific functions, macros, and other facilities.

\subsection{Signaling Errors}

Conceptually, signaling an error in a program is an admission by that program
that it does not know how to continue and requires external intervention. Once
an error is signaled, any decision about how to continue must come from the
``outside.''

The simplest way to signal an error is to use the \cd{error} function with
\cd{format}-style arguments describing the error for the sake of the user interface.
If \cd{error} is called and there are no active handlers (described
in sections~\ref{TRAPPING-ERRORS} and~\ref{HANDLING-CONDITIONS}), the
debugger will be entered and the error message will be typed out. For example:
\begin{lisp}
Lisp> (defun factorial (x) \\*
~~~~~~~~(cond ((or (not (typep x 'integer)) (minusp x)) \\*
~~~~~~~~~~~~~~~(error "{\Xtilde}S is not a valid argument to FACTORIAL." \\*
~~~~~~~~~~~~~~~~~~~~~~x)) \\
~~~~~~~~~~~~~~((zerop x) 1) \\
~~~~~~~~~~~~~~(t (* x (factorial (- x 1)))))) \\*
~\EV\ FACTORIAL \\
Lisp> (factorial 20) \\*
~\EV\ 2432902008176640000 \\
Lisp> (factorial -1) \\*
Error: -1 is not a valid argument to FACTORIAL. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Return to Lisp Toplevel. \\*
Debug> 
\end{lisp}
In general, a call to \cd{error} cannot directly return. Unless special work has
been done to override this behavior, the debugger will be entered and there
will be no option to simply continue.

The only exception may be that some implementations may provide debugger
commands for interactively returning from individual stack frames; even then,
however, such commands should never be used except by someone who has read the
erring code and understands the consequences of continuing from that point. In
particular, the programmer should feel confident
about writing code like this:
\begin{lisp}
(defun wargames:no-win-scenario () \\*
~~(when (true) (error "Pushing the button would be stupid.")) \\*
~~(push-the-button))
\end{lisp}
In this scenario, there should be no chance that the function \cd{error} will return
and the button will be pushed.

\beforenoterule
\begin{sideremark}
It should be noted that the notion of
``no chance'' that the button will be pushed is relative only to the language
model; it assumes that the language is accurately implemented.  In practice,
compilers have bugs, computers have glitches, and users have been known
to interrupt at inopportune moments and use the debugger to return from
arbitrary stack frames.  Such violations of the language model are
beyond the scope of the condition system but not necessarily beyond the
scope of potential failures that the programmer should consider and defend against.
The possibility of such unusual failures may of course also influence the design of
code meant to handle less drastic situations,
such as maintaining a database uncorrupted.---KMP and GLS
\end{sideremark}
\afternoterule

In some cases, the programmer may have a single, well-defined idea of a
reasonable recovery strategy for this particular error. In that case, he can
use the function \cd{cerror}, which specifies information about what would happen
if the user did simply continue from the call to \cd{cerror}. For example:
\begin{lisp}
Lisp> (defun factorial (x) \\*
~~~~~~~~(cond ((not (typep x 'integer)) \\*
~~~~~~~~~~~~~~~(error "{\Xtilde}S is not a valid argument to FACTORIAL." \\*
~~~~~~~~~~~~~~~~~~~~~~x)) \\
~~~~~~~~~~~~~~((minusp x) \\*
~~~~~~~~~~~~~~~(let ((x-magnitude (- x))) \\*
~~~~~~~~~~~~~~~~~(cerror "Compute -({\Xtilde}D!) instead." \\*
~~~~~~~~~~~~~~~~~~~~~~~~~"(-{\Xtilde}D)! is not defined." x-magnitude) \\*
~~~~~~~~~~~~~~~~~(- (factorial x-magnitude)))) \\
~~~~~~~~~~~~~~((zerop x) 1) \\
~~~~~~~~~~~~~~(t (* x (factorial (- x 1)))))) \\*
~\EV\ FACTORIAL \\
Lisp> (factorial -3) \\*
Error: (-3)! is not defined. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Compute -(3!) instead. \\*
~2: Return to Lisp Toplevel. \\*
Debug> :continue 1 \\
~\EV\ -6
\end{lisp}


\subsection{Trapping Errors}
\label{TRAPPING-ERRORS}

By default, a call to \cd{error} will force entry into the debugger.  You can
override that behavior in a variety of ways. The simplest (and most blunt)
tool for inhibiting entry to the debugger on an error is to use \cd{ignore-errors}.
In the normal situation, forms in the body of \cd{ignore-errors} are evaluated
sequentially and the last value is returned. If a condition of type \cd{error} is
signaled, \cd{ignore-errors} immediately returns two values, namely \cd{nil} and the
condition that was signaled; the debugger is not entered and no error
message is printed. For example:
\begin{lisp}
Lisp> (setq filename "nosuchfile") \\
~\EV\ "nosuchfile" \\
Lisp> (ignore-errors (open filename :direction :input)) \\
~\EV\ NIL {\rm and} \#<FILE-ERROR 3437523>
\end{lisp}
The second return value is an object that represents the kind of error. This
is explained in greater detail in section~\ref{OBJECT-0RIENTED-BASIS}.

In many cases, however, \cd{ignore-errors} is not desirable because it deals with
too many kinds of errors. Contrary to the belief of some, a program that
does not enter the debugger is not necessarily better than one that does.
Excessive use of \cd{ignore-errors} may keep the program out of the debugger, but it may
not increase the program's reliability, because the program may continue
to run after encountering errors other than those you meant to work past. In
general, it is better to attempt to deal only with the particular kinds of
errors that you believe could legitimately happen. That way, if an unexpected
error comes along, you will still find out about it.

\cd{ignore-errors} is a useful special case built from a more general facility,
\cd{handler-case}, that allows the programmer to deal with particular kinds of
conditions (including non-error conditions) without affecting what happens
when other kinds of conditions are signaled. For example, an effect 
equivalent to that of \cd{ignore-errors} above is achieved in the following example:
\begin{lisp}
Lisp> (setq filename "nosuchfile") \\
~\EV\ "nosuchfile" \\
Lisp> (handler-case (open filename :direction :input) \\
~~~~~~~~(error (condition) \\
~~~~~~~~~~(values nil condition))) \\
~\EV\ NIL {\rm and} \#<FILE-ERROR 3437525>
\end{lisp}
However, using \cd{handler-case}, one can indicate a more specific condition
type than just ``error.'' Condition types are explained in detail later, but the
syntax looks roughly like the following:
\begin{lisp}
Lisp> (makunbound 'filename) \\
~\EV\ FILENAME \\
Lisp> (handler-case (open filename :direction :input) \\
~~~~~~~~(file-error (condition) \\
~~~~~~~~~~(values nil condition))) \\
Error: The variable FILENAME is unbound. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Retry getting the value of FILENAME. \\
~2: Specify a value of FILENAME to use this time. \\
~3: Specify a value of FILENAME to store and use. \\
~4: Return to Lisp Toplevel. \\
Debug> 
\end{lisp}


\subsection{Handling Conditions}
\label{HANDLING-CONDITIONS}

Blind transfer of control to a \cd{handler-case} is only one possible kind
of recovery action that can be taken when a condition is signaled.  The
low-level mechanism offers great flexibility in how to continue once
a condition has been signaled. 

The basic idea behind condition handling is that a piece of code called the
{\it signaler} recognizes and announces the existence of an exceptional
situation using \cd{signal} or some function built on \cd{signal} (such as \cd{error}). 

The process of signaling involves the search for and invocation of a
{\it handler}, a piece of code that will attempt to deal appropriately with
the situation. 

If a handler is found, it may either {\it handle} the situation, by performing
some non-local transfer of control, or {\it decline} to handle it, by failing to perform a
non-local transfer of control. If it declines, other handlers are sought.

Since the lexical environment of the signaler might not be available to
handlers, a data structure called a {\it condition} is created to represent
explicitly the relevant state of the situation. A condition either is created
explicitly using \cd{make-condition} and then passed to a function such as \cd{signal},
or is created implicitly by a function such as \cd{signal} when given appropriate
non-condition arguments.

In order to handle the error, a handler is permitted to use any non-local
transfer of control such as \cd{go} to a tag in a \cd{tagbody},
\cd{return} from a \cd{block}, or
\cd{throw} to a \cd{catch}. In addition, structured abstractions of these
primitives are provided for convenience in exception handling.

A handler can be made dynamically accessible to a program by use of
\cd{handler-bind}. For example, to create a handler for a condition of type
\cd{arithmetic-error}, one might write:
\begingroup
\makeatletter
\def\@listi{\leftmargin\leftmargini \labelsep\leftmargin
   \parsep 3pt\relax
   \topsep 4pt plus 9pt\relax
   \itemsep\topsep}
\makeatother
\begin{lisp}
(handler-bind ((arithmetic-error {\it handler})){\it body})
\end{lisp}
The handler is a function of one argument, the condition. If a condition of
the designated type is signaled while the {\it body} is executing (and there are no
intervening handlers), the handler would be invoked on the given condition,
allowing it the option of transferring control. For example, one might write a
macro that executes a body, returning either its value(s) or the two values
\cd{nil} and the condition:
\begin{lisp}
(defmacro without-arithmetic-errors (\&body forms) \\
~~(let ((tag (gensym))) \\
~~~~`(block ,tag \\
~~~~~~ (handler-bind ((arithmetic-error \\
~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda (c)~~~~~;{\rm Argument \cd{c} is a condition} \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (return-from ,tag (values nil c))))) \\
~~~~~~~~~,@body)))) \\
\end{lisp}
\endgroup
The handler is executed in the dynamic context of the signaler, except
that the set of available condition handlers will have been rebound to
the value that was active at the time the condition handler was made
active. If a handler declines (that is, it does not transfer control), other 
handlers are sought. If no handler is found and the condition was signaled
by \cd{error} or \cd{cerror} (or some function such as \cd{assert} that behaves like
these functions), the debugger is entered, still in the dynamic context 
of the signaler.

\subsection{Object-Oriented Basis of Condition Handling}
\label{OBJECT-0RIENTED-BASIS}

Of course, the ability of the handler to usefully handle an exceptional
situation is related to the quality of the information it is provided. For
example, if all errors were signaled by
\begin{lisp}
(error "{\it some format string}")
\end{lisp}
then the only piece of information that would be accessible to the handler
would be an object of type \cd{simple-error} that had a slot containing the
format string.

If this were done, \cd{string-equal} would be the preferred way to tell one error
from another, and it would be very hard to allow flexibility in the
presentation of error messages because existing handlers would tend to be
broken by even tiny variations in the wording of an error message. This
phenomenon has been the major failing of most error systems previously
available in Lisp. It is fundamentally important to decouple the error
message string (the human interface) from the objects that formally
represent the error state (the program interface). We therefore have the
notion of typed conditions, and of formal operations on those conditions
that make them inspectable in a structured way.

This object-oriented approach to condition handling has the following
important advantages over a text-based approach:
\begin{itemize}
\item
   Conditions are classified according to subtype relationships, making
   it easy to test for categories of conditions.

\item
   Conditions have named slot values through which parameters are conveyed
   from the program that signals the condition to the program that handles it.

\item
   Inheritance of methods and slots reduces the amount of explicit
   specification necessary to achieve various interesting effects.
\end{itemize}

Some condition types are defined by this document, but the set of 
condition types is extensible using \cd{define-condition}.
Common Lisp condition types are in fact CLOS classes, and condition objects
are ordinary CLOS objects; \cd{define-condition} merely
provides an abstract interface that is a bit more convenient than
\cd{defclass} for defining conditions.

Here, as an example,
we define a two-argument function called \cd{divide} that is patterned after
the \cd{/} function but does some stylized error checking:
\begin{lisp}
(defun divide (numerator denominator) \\
~~(cond ((or (not (numberp numerator)) \\
~~~~~~~~~~~~~(not (numberp denominator))) \\
~~~~~~~~~(error "(DIVIDE '{\Xtilde}S '{\Xtilde}S) - Bad arguments." \\
~~~~~~~~~~~~~~~~numerator denominator)) \\
~~~~~~~~((zerop denominator) \\
~~~~~~~~~(error 'division-by-zero \\
~~~~~~~~~~~~~~~~:operator 'divide \\
~~~~~~~~~~~~~~~~:operands (list numerator denominator))) \\
~~~~~~~~(t ...)))
\end{lisp}
Note that in the first clause we have used \cd{error} with a string argument
and in the second clause we have named a particular condition type,
\cd{division-by-zero}. In the case of a string argument, the condition type that
will be signaled is \cd{simple-error}.

The particular kind of error that is signaled may be important
in cases where handlers are active. For example, \cd{simple-error} inherits 
from type \cd{error}, which in turn inherits from type \cd{condition}. On the 
other hand, \cd{division-by-zero} inherits from \cd{arithmetic-error}, which 
inherits from \cd{error}, which inherits from \cd{condition}. So if a handler
existed for \cd{arithmetic-error} while a \cd{division-by-zero} condition was
signaled, that handler would be tried; however, if a \cd{simple-error}
condition were signaled in the same context, the handler for type
\cd{arithmetic-error} would not be tried.


\subsection{Restarts}
\label{RESTARTS}

In older Lisp dialects (such as MacLisp), an attempt to signal an error of a
given type often carried with it an implicit promise to support the standard
recovery strategy for that type of error. If the signaler knew the type of
error but for whatever reason was unable to deal with the standard recovery
strategy for that kind of error, it was necessary to signal an untyped error
(for which there was no defined recovery strategy). This sometimes led to
confusion when people signaled typed errors without realizing the full
implications of having done so, but more often than not it meant that users
simply avoided typed errors altogether.

The Common Lisp Condition System, which is modeled after the Zetalisp condition system,
corrects this troublesome aspect of previous Lisp dialects by creating a clear
separation between the act of signaling an error of a particular type and the
act of saying that a particular way of recovery is appropriate. In the \cd{divide}
example above, simply signaling an error does not imply a willingness on the
part of the signaler to cooperate in any corrective action. For example, the
following sample interaction illustrates that the only recovery action
offered for this error is ``Return to Lisp Toplevel'':
\begin{lisp}
Lisp> (+ (divide 3 0) 7) \\
Error: Attempt to divide 3 by 0. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Return to Lisp Toplevel. \\
Debug> :continue 1 \\
Returned to Lisp Toplevel. \\
Lisp>
\end{lisp}
When an error is detected and the function \cd{error} is called, execution cannot
continue normally because \cd{error} will not directly return. Control can be
transferred to other points in the program, however, by means of specially
established ``restarts.''

\subsection{Anonymous Restarts}

The simplest kind of restart involves structured transfer of control using
a macro called \cd{restart-case}. The \cd{restart-case} form allows execution of
a piece of code in a context where zero or more restarts are active, and
where if one of those restarts is ``invoked,'' control will be transferred
to the corresponding clause in the \cd{restart-case} form. For example, we could
rewrite the previous \cd{divide} example as follows.
\begin{lisp}
(defun divide (numerator denominator) \\
~~(loop \\
~~~~(restart-case \\
~~~~~~~~(return \\
~~~~~~~~~~(cond ((or (not (numberp numerator)) \\
~~~~~~~~~~~~~~~~~~~~~(not (numberp denominator))) \\
~~~~~~~~~~~~~~~~~(error "(DIVIDE '{\Xtilde}S '{\Xtilde}S) - Bad arguments." \\
~~~~~~~~~~~~~~~~~~~~~~~~~numerator denominator)) \\
~~~~~~~~~~~~~~~~((zerop denominator) \\
~~~~~~~~~~~~~~~~~(error 'division-by-zero \\
~~~~~~~~~~~~~~~~~~~~~~~~:operator 'divide \\
~~~~~~~~~~~~~~~~~~~~~~~~:operands (list numerator denominator))) \\
~~~~~~~~~~~~~~~~(t ...))) \\
~~~~~~(nil (arg1 arg2) \\
~~~~~~~~~~:report "Provide new arguments for use by DIVIDE." \\
~~~~~~~~~~:interactive \\
~~~~~~~~~~~~(lambda () \\
~~~~~~~~~~~~~~~(list (prompt-for 'number "Numerator: ") \\
~~~~~~~~~~~~~~~~~~~~~(prompt-for 'number "Denominator: "))) \\
~~~~~~~~(setq numerator arg1 denominator arg2)) \\
~~~~~~(nil (result) \\
~~~~~~~~~~:report "Provide a value to return from DIVIDE." \\
~~~~~~~~~~:interactive \\
~~~~~~~~~~~~(lambda () (list (prompt-for 'number "Result: "))) \\
~~~~~~~~(return result)))))
\end{lisp}

\beforenoterule
\begin{sideremark}
    The function \cd{prompt-for} used in this chapter in a number of places is
    not a part of Common Lisp.  It is used in the examples in this chapter only to keep
    the presentation simple.  It is assumed to accept a type specifier
     and optionally a format string and associated arguments.  It uses the
    format string and associated arguments as part of an interactive prompt,
    and uses \cd{read} to read a Lisp object; however, only an object of the
    type indicated by the type specifier is accepted.

    The question of whether or not \cd{prompt-for} (or something like it) would be a
    useful addition to Common Lisp is under consideration by X3J13, but as of
    January 1989 no action has been taken. In spite of its use in a number of examples,
    nothing in the Common Lisp Condition System depends on this function.
\end{sideremark}
\afternoterule

In the example, the \cd{nil} at the head of each clause
means that it is an ``anonymous'' restart.
Anonymous restarts are typically invoked only from within the
debugger. As we shall see later, it is possible to have ``named restarts''
that may be invoked from code without the need for user intervention.

If the arguments to anonymous restarts are not optional, then special
information must be provided about what the debugger should use as arguments.
Here the \cd{:interactive} keyword is used to specify that information.

The \cd{:report} keyword introduces information to be used when presenting the
restart option to the user (by the debugger, for example).

Here is a sample interaction that takes advantage of the restarts provided
by the revised definition of \cd{divide}:
\begin{lisp}
Lisp> (+ (divide 3 0) 7) \\
Error: Attempt to divide 3 by 0. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Provide new arguments for use by the DIVIDE function. \\
~2: Provide a value to return from the DIVIDE function. \\
~3: Return to Lisp Toplevel. \\
Debug> :continue 1 \\
1 \\
Numerator: 4 \\
Denominator: 2 \\
~\EV\ 9
\end{lisp}

\subsection{Named Restarts}

In addition to anonymous restarts, one can have named restarts, which can be invoked
by name from within code.  As a trivial example, one could write
\begin{lisp}
(restart-case (invoke-restart 'foo 3) \\
~~(foo (x) (+ x 1)))
\end{lisp}
to add \cd{3} to \cd{1}, returning \cd{4}. This trivial example is conceptually analogous to 
writing:
\begin{lisp}
(+ (catch 'something (throw 'something 3)) 1)
\end{lisp}

For a more realistic example, the code for the function \cd{symbol-value} might signal an
unbound variable error as follows:
\begin{lisp}
(restart-case (error "The variable {\Xtilde}S is unbound." variable) \\*
~~(continue () \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;{\rm Argument \cd{s} is a stream} \\*
~~~~~~~~~~(format s "Retry getting the value of {\Xtilde}S." variable)) \\*
~~~~(symbol-value variable)) \\
~~(use-value (value) \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;{\rm Argument \cd{s} is a stream} \\*
~~~~~~~~~~(format s "Specify a value of {\Xtilde}S to use this time." \\*
~~~~~~~~~~~~~~~~~~variable)) \\*
~~~~value) \\
~~(store-value (value) \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;{\rm Argument \cd{s} is a stream} \\*
~~~~~~~~~~(format s "Specify a value of {\Xtilde}S to store and use." \\*
~~~~~~~~~~~~~~~~~~variable)) \\*
~~~~(setf (symbol-value variable) value) \\*
~~~~value))
\end{lisp}
If this were part of the implementation of \cd{symbol-value}, then it would be possible
for users to write a variety of automatic handlers for unbound variable
errors. For example, to make unbound variables evaluate to themselves, one
might write
\begin{lisp}
(handler-bind ((unbound-variable \\
~~~~~~~~~~~~~~~~~\#'(lambda (c)~~~~~;{\rm Argument \cd{c} is a condition} \\
~~~~~~~~~~~~~~~~~~~~~(when (find-restart 'use-value) \\
~~~~~~~~~~~~~~~~~~~~~~~(invoke-restart 'use-value \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(cell-error-name c)))))) \\
~~{\it body})
\end{lisp}

\subsection{Restart Functions}

For commonly used restarts, it is conventional to define a program interface
that hides the use of \cd{invoke-restart}. Such program interfaces to restarts
are called {\it restart functions}.

The normal convention is for the function to share the name of the restart.
The pre-defined functions \cd{abort}, \cd{continue}, \cd{muffle-warning}, \cd{store-value}, and
\cd{use-value} are restart functions. With \cd{use-value} the above example of 
\cd{handler-bind} could have been written more concisely as
\begin{lisp}
(handler-bind ((unbound-variable \\
~~~~~~~~~~~~~~~~~~~\#'(lambda (c)~~~~~;{\rm Argument \cd{c} is a condition} \\
~~~~~~~~~~~~~~~~~~~~~~~(use-value (cell-error-name c))))) \\
~~{\it body})
\end{lisp}

\subsection{Comparison of Restarts and Catch/Throw}
  
One important feature that \cd{restart-case} (or \cd{restart-bind}) offers that
\cd{catch} does not is the ability to reason about the available points to
which control might be transferred without actually attempting the
transfer. One could, for example, write
\begin{lisp}
(ignore-errors (throw ...))
\end{lisp}
which is a sort of poor man's variation of
\begin{lisp}
(when (find-restart 'something) \\*
~~(invoke-restart 'something))
\end{lisp}
but there is no way to use \cd{ignore-errors} and \cd{throw} to simulate something
like
\begin{lisp}
(when (and (find-restart 'something) \\*
~~~~~~~~~~~(find-restart 'something-else)) \\*
~~(invoke-restart 'something))
\end{lisp}
or even just
\begin{lisp}
(when (and (find-restart 'something) \\
~~~~~~~~~~~(yes-or-no-p "Do something? ")) \\
~~(invoke-restart 'something))
\end{lisp}
because the degree of inspectability that comes with simply writing
\begin{lisp}
(ignore-errors (throw ...))
\end{lisp}
is too primitive---getting the desired information also forces
transfer of control, perhaps at a time when it is not desirable.

Many programmers have previously evolved strategies like the following
on a case-by-case basis:
\begin{lisp}
(defvar *foo-tag-is-available* nil) \\
\\
(defun fn-1 () \\
~~(catch 'foo \\
~~~~(let ((*foo-tag-is-available* t)) \\
~~~~~~... (fn-2) ...))) \\
\\
(defun fn-2 () \\
~~... \\
~~(if *foo-tag-is-available* (throw 'foo t)) \\
~~...)
\end{lisp}
The facility provided by \cd{restart-case} and \cd{find-restart} is intended to
provide a standardized protocol for this sort of information to be
communicated between programs that were developed independently so that
individual variations from program to program
do not thwart the overall modularity and debuggability of programs.

Another difference between the restart facility and the \cd{catch}/\cd{throw}
facility is that a \cd{catch} with any given tag completely shadows any
outer pending \cd{catch} that uses the same tag. Because of the presence
of \cd{compute-restarts}, however, it is possible to see shadowed restarts,
which may be very useful in some situations (particularly in an
interactive debugger).

\penalty-10000 %required

\subsection{Generalized Restarts}
\label{LAST-RESTARTS-SECTION}

\cd{restart-case} is a mechanism that allows only imperative transfer of control
for its associated restarts. \cd{restart-case} is built on a lower-level mechanism
called \cd{restart-bind}, which does not force transfer of control.

\cd{restart-bind} is to \cd{restart-case} as \cd{handler-bind} is to
\cd{handler-\discretionary{}{}{}case}.
The syntax is
\begin{lisp}
(restart-bind (({\it name} {\it function} . {\it options})) . {\it body})
\end{lisp}
The {\it body} is executed in a dynamic context within which the {\it function}
will be called whenever 
\cd{(invoke-restart '{\it name})} is executed. The {\it options} are keyword-style and are
used to pass information such as that provided with the
\cd{:report} keyword in \cd{restart-case}.

A \cd{restart-case} expands into a call to \cd{restart-bind} where the function
simply does an unconditional transfer of control to a particular body
of code, passing along ``argument'' information in a structured way.

It is also possible to write restarts that do not transfer control. Such
restarts may be useful in implementing various special commands for the
debugger that are of interest only in certain situations. For example,
one might imagine a situation where file space was exhausted and the
following was done in an attempt to free space in directory \cd{dir}:
\begin{lisp}
(restart-bind ((nil \#'(lambda () (expunge-directory dir)) \\
~~~~~~~~~~~~~~~~~~~~:report-function \\
~~~~~~~~~~~~~~~~~~~~~~\#'(lambda (stream) \\
~~~~~~~~~~~~~~~~~~~~~~~~~~(format stream "Expunge {\Xtilde}A." \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(directory-namestring dir))))) \\
~~(cerror "Try this file operation again." \\
~~~~~~~~~~'directory-full :directory dir))
\end{lisp}
In this case, the debugger might be entered and the user could first
perform the expunge (which would not transfer control from the debugger
context) and then retry the file operation:
\begin{lisp}
Lisp> (open "FOO" :direction :output) \\
Error: The directory PS:<JDOE> is full. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Try this file operation again. \\
~2: Expunge PS:<JDOE>. \\
~3: Return to Lisp Toplevel. \\
Debug> :continue 2 \\
Expunging PS:<JDOE> ... 3 records freed. \\
Debug> :continue 1 \\
~\EV\ \#<OUTPUT-STREAM "PS:<JDOE>FOO.LSP" 2323473>
\end{lisp}


\subsection{Interactive Condition Handling}

When a program does not know how to continue, and no active handler is able to
advise it, the ``interactive condition handler,'' or ``debugger,'' can be
entered. This happens implicitly through the use of functions such as \cd{error}
and \cd{cerror}, or explicitly through the use of the function \cd{invoke-debugger}.

The interactive condition handler never returns directly; it returns only
through structured non-local transfer of control to specially defined restart
points that can be set up either by the system or by user code. The
mechanisms that support the establishment of such structured restart points
for portable code are outlined
in sections~\ref{RESTARTS} through~\ref{LAST-RESTARTS-SECTION}.

Actually, implementations may also provide extended debugging facilities that
allow return from arbitrary stack frames. Although such commands are frequently
useful in practice, their effects are implementation-dependent because they
violate the Common Lisp program abstraction. The effect of using such
commands is undefined with respect to Common Lisp.


\subsection{Serious Conditions}

The \cd{ignore-errors} macro will trap conditions of type \cd{error}. There are,
however, conditions that are not of type \cd{error}.

Some conditions are not considered errors but are still very serious, so
we call them {\it serious conditions} and we use the type \cd{serious-condition} to
represent them. Conditions such as those that might be signaled for
``stack overflow'' or ``storage exhausted'' are in this category.

The type \cd{error} is a subtype of \cd{serious-condition}, and it would technically
be correct to use the term ``serious condition'' to refer to all serious
conditions whether errors or not. However, normally we use the term 
``serious condition'' to refer to things of type \cd{serious-condition} but not
of type \cd{error}.

The point of the distinction between errors and other serious conditions
is that some conditions are known to occur for reasons that are beyond the
scope of Common Lisp to specify clearly. For example, we know that a stack
will generally be used to implement function calling, and we know that stacks
tend to be of finite size and are prone to overflow. Since the available
stack size may vary from implementation to implementation, from session
to session, or from function call to function call, it would be confusing
to have expressions such as \cd{(ignore-errors (+~a~b))} return a number sometimes
and \cd{nil} other times if \cd{a} and \cd{b} were always bound to numbers and the stack
just happened to overflow on a particular call. For this reason, only
conditions of type \cd{error} and not all conditions of type \cd{serious-condition}
are trapped by \cd{ignore-errors}. To trap other conditions, a lower-level
facility must be used (such as \cd{handler-bind} or \cd{handler-case}).

By convention, the function \cd{error} is preferred over \cd{signal} to signal conditions
of type \cd{serious-condition} (including those of type \cd{error}). It is the use of
the function \cd{error}, and not the type of the condition being signaled, that
actually causes the debugger to be entered.

\beforenoterule
\begin{incompatibility}
The Common Lisp Condition System differs from that of Zeta{}lisp in this respect.
In Zetalisp the debugger is entered for an unhandled signal if the \cd{error}
function is used {\it or} if the condition is of type \cd{error}.
\end{incompatibility}
\afternoterule

\subsection{Non-Serious Conditions}

Some conditions are neither errors nor serious conditions. They are signaled
to give other programs a chance to intervene, but if no action is taken,
computation simply continues normally.

For example, an implementation might choose to signal a non-serious (and
implementation-dependent) condition
called \cd{end-of-line} when output reaches the last character position on a line
of character output. In such an implementation, the signaling of this
condition might allow a convenient way for other programs to intervene,
producing output that is truncated at the end of a line.

By convention, the function \cd{signal} is used to signal conditions that are not
serious. It would be possible to signal serious conditions using \cd{signal}, and
the debugger would not be entered if the condition went unhandled.  However,
by convention,
handlers will generally tend to assume that serious conditions and errors
were signaled by calling the \cd{error} function (and will therefore
force entry to the interactive condition handler) and that they should
work to avoid this.


\subsection{Condition Types}

Some types of conditions are predefined by the system. All types of conditions
are subtypes of \cd{condition}. That is, \cd{(typep~{\it x} 'condition)} is true if
and only if the value of {\it x} is a condition. 

Implementations supporting multiple (or non-hierarchical) type inheritance
are expressly permitted to exploit multiple inheritance in the tree of
condition types as implementation-dependent extensions, as long as such
extensions are compatible with the specifications in this chapter.
[X3J13 voted in March 1989 \issue{ZLOS-CONDITIONS}
to integrate the Condition System and the Object System,
so multiple inheritance is always available for condition types.---GLS]

In order to avoid problems in portable code that runs both in systems with
multiple type inheritance and in systems without it, programmers are explicitly
warned that while all correct Common Lisp implementations will ensure that
\cd{(typep~{\it c} 'condition)}
is true for all conditions {\it c} (and all subtype relationships indicated in this
chapter will also be true), it should {\it not} be assumed that two condition
types specified to be subtypes of the same third type are disjoint.
(In some cases,
disjoint subtypes are identified explicitly, but such disjointness is not to be assumed by
default.)  For example, it follows from the subtype descriptions contained in
this chapter that in all implementations
\cd{(typep~{\it c}~'control-error)} implies \cd{(typep~{\it c}~'error)},
but note that
\cd{(typep~{\it c}~'control-error)} does {\it not}
imply \cd{(not~(typep~{\it c}~'cell-error))}.


\subsection{Signaling Conditions}

When a condition is signaled, the system tries to locate the most appropriate
handler for the condition and to invoke that handler.

Handlers are established dynamically using \cd{handler-bind} or abstractions built
on \cd{handler-bind}.

If an appropriate handler is found, it is called. In some circumstances, 
the handler may {\it decline} simply by returning without performing a 
non-local transfer of control. In such cases, the search for an 
appropriate handler is picked up where it left off, as if the called 
handler had never been present.

If no handler is found, or if all handlers that were found decline,
\cd{signal} returns \cd{nil}.

Although it follows from the description above, it is perhaps worth noting
explicitly that the lookup procedure described here will prefer a general 
but more (dynamically) local handler over a specific but less (dynamically)
local handler. Experience with existing condition systems suggests that
this is a reasonable approach and works adequately in most situations. 
Some care should be taken when binding handlers for very general kinds of
conditions, such as is done in \cd{ignore-errors}. Often, binding for a more
specific condition type than \cd{error} is more appropriate.


\subsection{Resignaling Conditions}

[The contents of this section are still a subject of some debate within X3J13.
The reader may wish to take this section with a grain of salt.---GLS]

Note that signaling a condition has no side effect on that condition, and
that there is no dynamic state contained in a condition object. As such, it
may at times be reasonable and appropriate to consider caching condition
objects for repeated use, re-signaling conditions from within handlers,
or saving conditions away somewhere and re-signaling them later.

For example, it may be desirable for the system to pre-allocate objects of type
\cd{storage-condition} so that they can be signaled when needed without
attempting to allocate more storage.


\subsection{Condition Handlers}
\label{CONDITION-HANDLERS}

A {\it handler} is a function of one argument, the condition to be handled. The
handler may inspect the object
to be sure it is ``interested'' in handling the condition.

A handler is executed in the dynamic context of the signaler, except that the
set of available condition handlers will have been rebound to the value that
was active at the time the condition handler was made active. The intent of
this is to prevent infinite recursion because of errors in a condition handler.

After inspecting the condition, the handler should take one of the following
actions:
\begin{itemize}
  \item
    It might {\it decline} to handle the condition (by simply returning). When
    this happens, the returned values are ignored and the effect is the same
    as if the handler had been invisible to the mechanism seeking to find a
    handler. The next handler in line will be tried, or if no such handler
    exists, the condition will go unhandled.

  \item
    It might {\it handle} the condition (by performing some non-local transfer
    of control). This may be done either primitively using \cd{go}, \cd{return}, or \cd{throw},
    or more abstractly using a function such as \cd{abort} or \cd{invoke-restart}.

  \item
    It might signal another condition.

  \item
    It might invoke the interactive debugger.
\end{itemize}
In fact, the latter two actions (signaling another condition or entering the
debugger) are really just ways of putting off the decision to either handle
or decline, or trying to get someone else to make such a decision. Ultimately,
all a handler can do is to handle or decline to handle.

\subsection{Printing Conditions}

When \cd{*print-escape*} is \cd{nil} (for example,
when the \cd{princ} function or the \cd{{\Xtilde}A}
directive is used with \cd{format}), the report method for the condition will be invoked. This will
be done automatically by functions such as \cd{invoke-debugger}, \cd{break}, and \cd{warn},
but there may still be situations in which it is desirable to have a
condition report under explicit user control. For example,
\begin{lisp}
(let ((form '(open "nosuchfile"))) \\
~~(handler-case (eval form) \\
~~~~(serious-condition (c) \\
~~~~~~(format t "{\Xtilde}\&Evaluation of {\Xtilde}S failed:{\Xtilde}\%{\Xtilde}A" form c))))
\end{lisp}
might print something like
\begin{lisp}
Evaluation of (OPEN "nosuchfile") failed: \\
The file "nosuchfile" was not found.
\end{lisp}
Some suggestions about the form of text typed by report methods:
\begin{itemize}
 \item
    The message should generally be a complete sentence, beginning with a
   capital letter and ending with appropriate punctuation (usually a period).

 \item
    The message should {\it not} include any introductory text such as ``\cd{Error:}''
   or ``\cd{Warning:}'' and should not be followed by a trailing newline. Such
   text will be added as may be appropriate to context by the routine invoking
   the report method.

 \item
    Except where unavoidable, the tab character (which is only semi-standard anyway)
    should not be used in
   error messages. Its effect may vary from one implementation to another and may
   cause problems even within an implementation because it may do different
   things depending on the column at which the error report begins.

 \item
    Single-line messages are preferred, but newlines in the middle of long
   messages are acceptable.

 \item
   If any program (for example, the debugger) displays messages indented from the
   prevailing left margin (for example, indented seven spaces because they
   are prefixed by the seven-character herald ``\cd{Error:~}''), then that program
   will take care of inserting the appropriate indentation into the extra
   lines of a multi-line error message. Similarly, a program that prefixes
   error messages with semicolons so that they appear to be comments should
   take care of inserting a semicolon at the beginning of each line in a
   multi-line error message. (These rules are important because, even within
   a single implementation, there may be more than one program that presents
   error messages to the user, and they may use different styles of
   presentation. The caller of \cd{error} cannot anticipate all such possible
   styles, and so it is incumbent upon the presenter of the message to make
   any necessary adjustments.)
\end{itemize}
[Note: These recommendations expand upon those in section~\ref{ERROR-SIGNALLING-FUNCTIONS}.---GLS]

When \cd{*print-escape*} is not \cd{nil}, the object should print in some useful (but
usually fairly abbreviated) fashion according to the style of the
implementation. It is not expected that a condition will be printed in a form
suitable for \cd{read}. Something like \cd{\#<ARITHMETIC-ERROR~1734>}
is fine.


X3J13 voted in March 1989 \issue{ZLOS-CONDITIONS} to integrate the
Condition System and the Object System.
In the original Condition System proposal,
no function was provided for directly accessing or setting the printer for
a condition type, or for invoking it; the techniques described above were
the sole interface to reporting.  The vote specified that, in CLOS terms,
condition reporting is mediated through the \cd{print-object}
method for the condition type (that is, class) in question, with \cd{*print-escape*}
bound to \cd{nil}.  Specifying \cd{(:report {\it fn})} to
\cd{define-condition} when defining
condition type {\it C} is equivalent to a separate method definition:
\begin{lisp}
(defmethod print-object ((x {\it C}) stream) \\*
~~(if *print-escape* \\*
~~~~~~(call-next-method) \\*
~~~~~~(funcall \#'{\it fn} x stream)))
\end{lisp}
Note that the method uses {\it fn} to print the condition
only when \cd{*print-escape*} has the value \cd{nil}.



\section{Program Interface to the Condition System}

This section describes functions, macros, variables, and condition
types associated with the Common Lisp Condition System.


\subsection{Signaling Conditions}
\label{SIGNALLING-CONDITIONS}


The functions in this section provide various mechanisms
for signaling warnings, breaks, continuable errors, and fatal errors.


\begin{defun}[Function]
error datum &rest arguments

   [This supersedes the description of \cd{error}
   given in section~\ref{ERROR-SIGNALLING-FUNCTIONS}.---GLS]

  Invokes the signal facility on a condition. If the condition is not handled,
  \cd{(invoke-debugger {\it condition})} is executed. As a consequence of calling 
  \cd{invoke-debugger}, \cd{error} never directly returns to its caller; the only exit from this
  function can come by non-local transfer of control in a handler or by use of
  an interactive debugging command.

  If {\it datum} is a condition, then that condition is used directly. 
  In this case, it is an error for the list of {\it arguments} to be non-empty;
  that is, \cd{error} must have been called with exactly one argument, the condition.

  If {\it datum} is a condition type (a class or class name), then the condition used is effectively the result
  of \cd{(apply \#'make-condition {\it datum} {\it arguments})}.

  If {\it datum} is a string, then the condition used is effectively the result of
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string {\it datum} \\*
~~~~~~~~~~~~~~~~:format-arguments {\it arguments})
\end{lisp}
\end{defun}

\begin{defun}[Function]
cerror continue-format-string datum &rest arguments

   [This supersedes the description of \cd{cerror}
   given in section~\ref{ERROR-SIGNALLING-FUNCTIONS}.---GLS]

  The function \cd{cerror}
  invokes the error facility on a condition. If the condition is not handled,
  \cd{(invoke-debugger {\it condition})} is executed. While signaling is going on,
  and
  while control is in the debugger (if it is reached), it is possible to continue
  program execution (thereby returning from the call to \cd{cerror})
  using the \cd{continue} restart.

  If {\it datum} is a condition, then that condition is used directly. 
  In this case, the list of {\it arguments} need not be empty,
  but will be used only with the {\it continue-format-string}
  and will not be used to initialize {\it datum}.

  If {\it datum} is a condition type (a class or class name), then the condition used is effectively the result
  of \cd{(apply \#'make-condition {\it datum} {\it arguments})}.

  If {\it datum} is a string, then the condition used is effectively the result of
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string {\it datum} \\*
~~~~~~~~~~~~~~~~:format-arguments {\it arguments})
\end{lisp}

  The {\it continue-format-string} must be a string.
  Note that if {\it datum} is not a 
  string, then the format arguments used by the {\it continue-format-string} will
  still be the list of {\it arguments} (which is in keyword format if {\it datum} is a condition
  type). In this case, some care may be necessary to set up the
  {\it continue-format-string} correctly. The \cd{format} directive \cd{{\Xtilde}*},
  which ignores and skips over \cd{format} arguments,
  may be particularly 
  useful in this situation.

  The value returned by \cd{cerror} is \cd{nil}.
\end{defun}

\begin{defun}[Function]
signal datum &rest arguments

  Invokes the signal facility on a condition. If the condition is not handled,
  \cd{signal} returns \cd{nil}.

  If {\it datum} is a condition, then that condition is used directly. 
  In this case, it is an error for the list of {\it arguments} to be non-empty;
  that is, \cd{error} must have been called with exactly one argument, the condition.

  If {\it datum} is a condition type (a class or class name), then the condition used is effectively the result
  of \cd{(apply \#'make-condition {\it datum} {\it arguments})}.

  If {\it datum} is a string, then the condition used is effectively the result of
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string {\it datum} \\*
~~~~~~~~~~~~~~~~:format-arguments {\it arguments})
\end{lisp}

  Note that if \cd{(typep {\it condition} *break-on-signals*)} is true, then the debugger
  will be entered prior to beginning the process of signaling. The \cd{continue}
  restart function may be used to continue with the signaling process;
the restart is associated with the signaled condition as if by
use of \cd{with-condition-restarts}.
This is true
  also for all other functions and macros that signal conditions, such
  as \cd{warn}, \cd{error}, \cd{cerror}, \cd{assert}, and \cd{check-type}.

During the dynamic extent of a call to \cd{signal} with a
     particular condition, the effect of calling \cd{signal} again on that
     condition object for a distinct abstract event is not defined.
     For example, although a handler {\it may} resignal a condition in order to
     allow outer handlers first shot at handling the condition, two
     distinct asynchronous keyboard events must not signal an the same (\cd{eq}) condition
     object at the same time.

  For further details about signaling and handling, see the discussion of
  condition handlers in section~\ref{CONDITION-HANDLERS}.
\end{defun}


\begin{defun}[Variable]
*break-on-signals*

  This variable is intended primarily for use when the user is debugging
  programs that do signaling.
  The value of \cd{*break-on-signals*} should be suitable as a second argument to
  \cd{typep}, that is, a type or type specifier.

  When \cd{(typep {\it condition} *break-on-signals*)} is true, then calls to
  \cd{signal} (and to other advertised functions such as \cd{error} that
  implicitly call \cd{signal}) will enter the debugger prior to signaling
  that {\it condition}. The \cd{continue} restart may be used to continue with
  the normal signaling process;
the restart is associated with the signaled condition as if by
use of \cd{with-condition-restarts}.

  Note that \cd{nil} is a valid type specifier.  If the value of
  \cd{*break-on-signals*} is \cd{nil}, then \cd{signal} will never
  enter the debugger in this implicit manner.

  When setting this variable, the user is encouraged to choose the
  most restrictive specification that suffices. Setting this flag
  effectively violates the modular handling of condition signaling
  that this chapter seeks to establish. Its complete effect may be
  unpredictable in some cases, since the user may not be aware of the
  variety or number of calls to \cd{signal} that are used in programs
  called only incidentally.

  By default---and certainly in any ``production'' use---the value
  of this variable should be \cd{nil}, both for reasons of performance and
  for reasons of modularity and abstraction.

\begin{newer}
X3J13 voted in March 1989
\issue{BREAK-ON-WARNINGS-OBSOLETE}
to remove \cd{*break-on-warnings*} from the language;
\cd{*break-on-signals*} offers all the power of
  \cd{*break-on-warnings*} and more.
\end{newer}

\beforenoterule
  \begin{incompatibility}
  This variable is similar to the Zetalisp
  variable \cd{trace-conditions} except for the obvious difference that
  \cd{zl:trace-conditions} takes a type or list of types while
  \cd{*break-on-signals*} takes a single type specifier.

  [There is no loss of generality in Common Lisp
  because the \cd{or} type specifier may be used to indicate that
  any of a set of conditions should enter the debugger.---GLS]
  \end{incompatibility}
\afternoterule
\end{defun}


\subsection{Assertions}
\label{CONDITION-ASSERTIONS}


These facilities are designed to make it convenient for the user
to insert error checks into code.

\begin{defmac}
check-type place typespec [string]

   [This supersedes the description of \cd{check-type}
   given in section~\ref{SPECIALIZED-ERROR-SIGNALLING}.---GLS]

  A \cd{check-type} form signals an error of type
  \cd{type-error} if the contents of {\it place} are not of the
  desired type.

  If a condition is signaled, handlers of this condition can use the
  functions \cd{type-error-datum} and \cd{type-error-expected-type} to access the
  contents of {\it place} and the {\it typespec}, respectively.

  This function can return only if the \cd{store-value} restart is invoked, either
  explicitly from a handler or implicitly as one of the options offered by the
  debugger.
The restart is associated with the signaled condition as if by
use of \cd{with-condition-restarts}.

  If \cd{store-value} is called, \cd{check-type} will store the new value that is
  the argument to \cd{store-value} (or that is prompted for interactively by
  the debugger) in {\it place} and start over, checking the type of the new value
  and signaling another error if it is still not the desired type. Subforms
  of {\it place} may be evaluated multiple times because of the implicit loop
  generated. \cd{check-type} returns \cd{nil}.

  The {\it place} must be a generalized variable reference acceptable to \cd{setf}. The
  {\it typespec} must be a type specifier; it is not evaluated.  The \cd{string} should
  be an English description of the type, starting with an indefinite article
  (``a'' or ``an''); it is evaluated. If the {\it string} is not supplied, it is computed
  automatically from the {\it typespec}. (The optional {\it string} argument is allowed 
  because some applications of \cd{check-type} may require a more specific
  description of what is wanted than can be generated automatically from the
  type specifier.)

  The error message will mention the {\it place}, its contents, and the desired type.

  \beforenoterule
  \begin{implementation}
  An implementation may choose to generate a somewhat
  differently worded error message if it recognizes that {\it place} is of a
  particular form, such as one of the arguments to the function that called
  \cd{check-type}.
  \end{implementation}
\afternoterule

\begin{lisp}
Lisp> (setq aardvarks '(sam harry fred)) \\*
~\EV\ (SAM HARRY FRED) \\
Lisp> (check-type aardvarks (array * (3))) \\*
Error: The value of AARDVARKS, (SAM HARRY FRED), \\*
~~~~~~~is not a 3-long array. \\
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Use Value: \#(sam fred harry) \\*
~\EV\ NIL \\
Lisp> aardvarks \\*
~\EV\ \#<ARRAY-3 13571> \\
Lisp> (map 'list \#'identity aardvarks) \\*
~\EV\ (SAM FRED HARRY) \\
Lisp> (setq aacount 'foo) \\*
~\EV\ FOO \\
Lisp> (check-type aacount (integer 0 *) "a non-negative integer") \\*
Error: The value of AACOUNT, FOO, is not a non-negative integer. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 2 \\*
Lisp> 
\end{lisp}

\beforenoterule
  \begin{incompatibility}
  In Zetalisp, the equivalent facility is called \cd{check-arg-type}.
  \end{incompatibility}
\afternoterule
\end{defmac}


\begin{defmac}
assert test-form [({place}*) [datum {argument}*]]

   [This supersedes the description of \cd{assert}
   given in section~\ref{SPECIALIZED-ERROR-SIGNALLING}.---GLS]

  An \cd{assert} form signals an error if the value of the {\it test-form} is \cd{nil}.
  Continuing from this
  error using the \cd{continue} restart will allow the user to alter the values
  of some variables, and \cd{assert} will then start over, evaluating the {\it test-form}
  again.
(The restart is associated with the signaled condition as if by
use of \cd{with-condition-restarts}.)
\cd{assert} returns \cd{nil}.

  The {\it test-form} may be any form. Each {\it place} (there may be any number of them, 
  or none) must be a generalized variable reference acceptable to \cd{setf}.
  These should be variables on which {\it test-form} depends, whose values
  may sensibly be changed by the user in attempting to correct the error.
  Subforms of each {\it place} are evaluated only if an error is signaled, and
  may be re-evaluated if the error is re-signaled (after continuing without
  actually fixing the problem).

  The {\it datum} and {\it argument\/}s are evaluated only if an error is to be
  signaled, and re-evaluated if the error is to be signaled again.

  If {\it datum} is a condition, then that condition is used directly. 
  In this case, it is an error to specify any {\it argument\/}s.

  If {\it datum} is a condition type (a class or class name), then the condition used is effectively the result
  of \cd{(apply \#'make-condition {\it datum} (list \Mstar{argument}))}.

  If {\it datum} is a string, then the condition used is effectively the result of
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string {\it datum} \\*
~~~~~~~~~~~~~~~~:format-arguments (list \Mstar{argument}))
\end{lisp}

  If {\it datum} is omitted, then a condition of type \cd{simple-error} is 
  constructed using the {\it test-form} as data. For example, the following
  might be used:
\begin{lisp}
(make-condition 'simple-error \\
~~:format-string "The assertion {\Xtilde}S failed." \\
~~:format-arguments '({\it test-form}))
\end{lisp}
Note that the {\it test-form} itself, and not its value, is used as the format argument.

\beforenoterule
  \begin{implementation}
  The debugger need not include the {\it test-form} in
  the error message, and any {\it places} should not be included in the message,
  but they should be made available for the user's perusal. If the user
  gives the ``continue'' command, an opportunity should be presented
  to alter the values of any or all of the references. The details of this
  depend on the implementation's style of user interface, of course.
  \end{implementation}
\afternoterule

Here is an example of the use of \cd{assert}:
\begin{lisp}
(setq x (make-array '(3 5) :initial-element 3)) \\
(setq y (make-array '(3 5) :initial-element 7)) \\
 \\
(defun matrix-multiply (a b) \\*
~~(let ((*print-array* nil)) \\*
~~~~(assert (and (= (array-rank a) (array-rank b) 2) \\*
~~~~~~~~~~~~~~~~~(= (array-dimension a 1) \\*
~~~~~~~~~~~~~~~~~~~~(array-dimension b 0))) \\*
~~~~~~~~~~~~(a b) \\*
~~~~~~~~~~~~"Cannot multiply {\Xtilde}S by {\Xtilde}S." a b) \\*
~~~~(really-matrix-multiply a b))) \\
 \\
(matrix-multiply x y) \\
Error: Cannot multiply \#<ARRAY-3-5 12345> by \#<ARRAY-3-5 12364>. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify new values. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Value for A: x \\*
Value for B: (make-array '(5 3) :initial-element 6) \\
~\EV \#2A(\=(54 54 54 54 54) \\
\>(54 54 54 54 54) \\*
\>(54 54 54 54 54) \\*
\>(54 54 54 54 54) \\*
\>(54 54 54 54 54))
\end{lisp}
\end{defmac}


\subsection{Exhaustive Case Analysis}
\label{EXHAUSTIVE-CASE-ANALYSIS-CONDITIONS}

The syntax for \cd{etypecase} and \cd{ctypecase} is the same as for \cd{typecase}, except
that no \cd{otherwise} clause is permitted. Similarly, the syntax for \cd{ecase} and
\cd{ccase} is the same as for \cd{case} except for the \cd{otherwise} clause.

\cd{etypecase} and \cd{ecase} are similar to \cd{typecase} and \cd{case}, respectively, but signal
a non-continuable error rather than returning \cd{nil} if no clause is selected.

\cd{ctypecase} and \cd{ccase} are also similar to \cd{typecase} and \cd{case}, respectively,
but signal a
continuable error if no clause is selected.

\begin{defmac}
etypecase keyform {(type {\,form}*)}*

   [This supersedes the description of \cd{etypecase}
   given in section~\ref{EXHAUSTIVE-CASE-ANALYSIS}.---GLS]

  This control construct is similar to \cd{typecase}, but no explicit \cd{otherwise}
  or \cd{t} clause is permitted. If no clause is satisfied, \cd{etypecase} signals 
  an error (of type \cd{type-error}) with a message constructed from the clauses.
  It is not permissible to continue from this error. To supply an error
  message, the user should use \cd{typecase} with an \cd{otherwise} clause containing 
  a call to \cd{error}. The name of this function stands for ``exhaustive type
  case'' or ``error-checking type case.''

  Example:
\begin{lisp}
Lisp> (setq x 1/3) \\*
~\EV\ 1/3 \\
Lisp> (etypecase x \\*
~~~~~~~~(integer (* x 4)) \\*
~~~~~~~~(symbol~(symbol-value x))) \\
Error: The value of X, 1/3, is neither an integer nor a symbol. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Return to Lisp Toplevel. \\*
Debug>
\end{lisp}
\end{defmac}

\begin{defmac}
ctypecase keyplace {(type {\,form}*)}*

   [This supersedes the description of \cd{ctypecase}
   given in section~\ref{EXHAUSTIVE-CASE-ANALYSIS}.---GLS]

  This control construct is similar to \cd{typecase}, but no explicit 
  \cd{otherwise} or \cd{t} clause is permitted.

  The {\it keyplace} must be a generalized variable reference acceptable to \cd{setf}.
  If no clause is satisfied, \cd{ctypecase} signals an error (of type \cd{type-error})
  with a message constructed from the clauses. This error may be continued
  using the \cd{store-value} restart. The argument to \cd{store-value} is stored in
  {\it keyplace} and then \cd{ctypecase} starts over, making the type tests again. 
  Subforms of {\it keyplace} may be evaluated multiple times. If the \cd{store-value}
  restart is invoked interactively, the user will be prompted for the value
  to be used.
  
  The name of this function is mnemonic for ``continuable (exhaustive) 
  type case.''


  Example:
\begin{lisp}
Lisp> (setq x 1/3) \\*
~\EV\ 1/3 \\
Lisp> (ctypecase x \\*
~~~~~~~~(integer (* x 4)) \\*
~~~~~~~~(symbol (symbol-value x))) \\
Error: The value of X, 1/3, is neither an integer nor a symbol. \\*
To continue, type :CONTINUE followed by an option number: \\
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Use value: 3.7 \\
Error: The value of X, 3.7, is neither an integer nor a symbol. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Use value: 12 \\*
~\EV\ 48
\end{lisp}
\end{defmac}


\begin{defmac}
ecase keyform {({({key}*) | key} {\,form}*)}*

   [This supersedes the description of \cd{ecase}
   given in section~\ref{EXHAUSTIVE-CASE-ANALYSIS}.---GLS]

  This control construct is similar to \cd{case}, but no explicit \cd{otherwise} or \cd{t}
  clause is permitted. If no clause is satisfied, \cd{ecase} signals an error
  (of type \cd{type-error}) with a message constructed from the clauses. It is not
  permissible to continue from this error. To supply an error message, the
  user should use \cd{case} with an \cd{otherwise} clause containing a call to \cd{error}.
  The name of this function stands for ``exhaustive case'' or ``error-checking
  case.''

Example:
\begin{lisp}
Lisp> (setq x 1/3) \\*
~\EV\ 1/3 \\
Lisp> (ecase x \\*
~~~~~~~~(alpha (foo)) \\*
~~~~~~~~(omega (bar)) \\*
~~~~~~~~((zeta phi) (baz))) \\
Error: The value of X, 1/3, is not ALPHA, OMEGA, ZETA, or PHI. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Return to Lisp Toplevel. \\*
Debug>
\end{lisp}
\end{defmac}

\begin{defmac}
ccase keyplace {({({key}*) | key} {\,form}*)}*

   [This supersedes the description of \cd{ccase}
   given in section~\ref{EXHAUSTIVE-CASE-ANALYSIS}.---GLS]

  This control construct is similar to \cd{case}, but no explicit \cd{otherwise} or
  \cd{t} clause is permitted.

  The {\it keyplace} must be a generalized variable reference acceptable to \cd{setf}.
  If no clause is satisfied, \cd{ccase} signals an error (of type \cd{type-error})
  with a message constructed from the clauses. This error may be continued
  using the \cd{store-value} restart. The argument to \cd{store-value} is stored in
  {\it keyplace} and then \cd{ccase} starts over, making the type tests again. Subforms
  of {\it keyplace} may be evaluated multiple times. If the \cd{store-value} restart is
  invoked interactively, the user will be prompted for the value to be used.

  The name of this function is mnemonic for ``continuable (exhaustive) case.''

\beforenoterule
\begin{implementation}
  The \cd{type-error} signaled by \cd{ccase} and \cd{ecase} is free to
  choose any representation of the acceptable argument type that it wishes
  for placement in the expected-type slot. It will always work to use type
  \cd{(member . {\it keys})}, but in some cases it may be more efficient, for example,
  to use a type that represents an integer subrange or a type composed using the
  \cd{or} type specifier.
\end{implementation}
\afternoterule
\end{defmac}


\subsection{Handling Conditions}

These macros allow a program to gain control when a condition is signaled.

\begin{defmac}
handler-case expression {(typespec ([var]) {\,form}*)}*

  Executes the given {\it expression} in a context where various specified handlers are active.

  Each {\it typespec} may be any type specifier. If during the execution of the \cd{expression}
  a condition is signaled for which there is an appropriate clause---that is, one
  for which \cd{(typep {\it condition} '{\it typespec})} is true---and if there is no intervening
  handler for conditions of that type, then control is transferred to the body
  of the relevant clause (unwinding the dynamic state appropriately in the
  process) and the given variable \cd{var} is bound to the condition that was signaled. If
  no such condition is signaled and the computation runs to completion, then
  the values resulting from the \cd{expression} are returned by the \cd{handler-case} form.

  If more than one case is provided, those cases are made accessible in
  parallel. That is, in
\begin{lisp}
(handler-case {\it expression} \\*
~~({\it type\SU{1}} ({\it var\SU{1}}) {\it form\SU{1}}) \\*
~~({\it type\SU{2}} ({\it var\SU{2}}) {\it form\SU{2}}))
\end{lisp}
  if the first clause (containing {\it form\SU{1}}) has been selected, the handler
  for the second is no longer visible (and vice versa).

  The cases are searched sequentially from top to bottom. If a signaled condition
  matches more than one case (possible if there is type
  overlap) the earlier of the two cases will be selected.


\penalty-10000 %required

  If the variable {\it var} is not needed, it may be omitted. That is, a clause such as
\begin{lisp}
({\it type} ({\it var}) (declare (ignore {\it var})) {\it form})
\end{lisp}
may be written using the following shorthand notation:
\begin{lisp}
({\it type} () {\it form})
\end{lisp}

  If there are no forms in a selected case, the case returns \cd{nil}.
Note that
\begin{lisp}
(handler-case {\it expression} \\*
~~({\it type\SU{1}} ({\it var\SU{1}}) . {\it body\SU{1}}) \\*
~~({\it type\SU{2}} ({\it var\SU{2}}) . {\it body\SU{2}}) \\*
~~...)
\end{lisp}
is approximately equivalent to
\begin{lisp}
(block \#1=\#:block-1 \\*
~~(let (\#2=\#:var-2) \\*
~~~~(tagbody \\*
~~~~~~(handler-bind (({\it type\SU{1}} \pushtabs\=\#'(lambda (temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#3=\#:tag-3)))\poptabs \\
~~~~~~~~~~~~~~~~~~~~~({\it type\SU{2}} \pushtabs\=\#'(lambda (temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#4=\#:tag-4)))\poptabs \\*
~~~~~~~~~~~~~~~~~~~~~...) \\*
~~~~~~~~(return-from \#1\# {\it expression})) \\
~~~~~~\#3\# (return-from \#1\# (let (({\it var\SU{1}} \#2\#)) . {\it body\SU{1}})) \\*
~~~~~~\#4\# (return-from \#1\# (let (({\it var\SU{2}} \#2\#)) . {\it body\SU{2}})) \\*
~~~~~~...)))
\end{lisp}
[Note the use of ``gensyms'' such as \cd{\#:block-1}
as block names, variables, and \cd{tagbody} tags in this example,
and the use of \cd{\#{\it n}=} and \cd{\#{\it n}\#} read-macro syntax
to indicate that the very same gensym appears in multiple places.---GLS]

  As a special case, the {\it typespec} can also be the symbol \cd{:no-error} in the last clause.
  If it is, it designates a clause that will take control if the {\it expression} returns
  normally. In that case, a completely general lambda-list may follow the symbol \cd{:no-error},
  and the arguments to which the lambda-list parameters are bound are like those for
  \cd{multiple-value-call} on the return value of the {\it expression}.
For example,

\penalty-10000 %required

\begin{lisp}
(handler-case {\it expression} \\*
~~({\it type\SU{1}} ({\it var\SU{1}}) . {\it body\SU{1}}) \\*
~~({\it type\SU{2}} ({\it var\SU{2}}) . {\it body\SU{2}}) \\*
~~... \\*
~~({\it type\SU{\hbox{\scriptsize\it n}}} ({\it var\SU{\hbox{\scriptsize\it n}}}) . {\it body\SU{\hbox{\scriptsize\it n}}}) \\*
~~(:no-error ({\it nvar\SU{1}} {\it nvar\SU{2}} ... {\it nvar\SU{\hbox{\scriptsize\it m}}}) . {\it nbody}))
\end{lisp}
is approximately equivalent to
\begin{lisp}
(block \#1=\#:error-return \\*
~~(multiple-value-call \#'(lambda ({\it nvar\SU{1}} {\it nvar\SU{2}} ... {\it nvar\SU{\hbox{\scriptsize\it m}}}) . {\it nbody}) \\*
~~~~(block \#2=\#:normal-return \\*
~~~~~~(return-from \#1\# \\*
~~~~~~~~(handler-case (return-from \#2\# {\it expression}) \\*
~~~~~~~~~~({\it type\SU{1}} ({\it var\SU{1}}) . {\it body\SU{1}}) \\*
~~~~~~~~~~({\it type\SU{2}} ({\it var\SU{2}}) . {\it body\SU{2}}) \\*
~~~~~~~~~~... \\*
~~~~~~~~~~({\it type\SU{\hbox{\scriptsize\it n}}} ({\it var\SU{\hbox{\scriptsize\it n}}}) . {\it body\SU{\hbox{\scriptsize\it n}}}))))))
\end{lisp}



  Examples of the use of \cd{handler-case}:
\begin{lisp}
(handler-case (/ x y) \\*
~~(division-by-zero () nil)) \\
 \\
(handler-case (open *the-file* :direction :input) \\*
~~(file-error (condition) (format t "{\Xtilde}\&Fooey: {\Xtilde}A{\Xtilde}\%" condition))) \\
 \\
(handler-case (some-user-function) \\*
~~(file-error (condition) condition) \\*
~~(division-by-zero () 0) \\*
~~((or unbound-variable undefined-function) () 'unbound)) \\
 \\
(handler-case (intern x y) \\*
~~(error (condition) condition) \\*
~~(:no-error (symbol status) \\*
~~~~(declare (ignore symbol)) \\*
~~~~status))
\end{lisp}
\end{defmac}

\begin{defmac}
ignore-errors {\,form}*

  Executes its body in a context that handles conditions of type \cd{error} by
  returning control to this form. If no such condition is signaled, any
  values returned by the last form are returned by \cd{ignore-errors}. Otherwise,
  two values are returned: \cd{nil} and the \cd{error} condition that was signaled.

\cd{ignore-errors} could be defined by
\begin{lisp}
(defmacro ignore-errors (\&body forms) \\*
~~{\Xbq}(handler-case (progn ,{\Xatsign}forms) \\*
~~~~~(error (c) (values nil c)))
\end{lisp}
\end{defmac}


\begin{defmac}
handler-bind ({(typespec handler)}*) {\,form}*

  Executes body in a dynamic context where the given handler bindings 
  are in effect.
  Each {\it typespec} may be any type specifier.
  Each {\it handler} form should evaluate to a function to be used to handle conditions 
  of the given type(s) during execution of the {\it form\/}s. This function should
  take a single argument, the condition being signaled.

  If more than one binding is specified, the bindings are searched 
  sequentially from top to bottom in search of a match (by visual analogy
  with \cd{typecase}). If an appropriate {\it typespec} is found, the associated handler 
  is run in a context where none of the handler bindings are visible (to avoid
  recursive errors). For example, in the case of
\begin{lisp}
(handler-bind ((unbound-variable \#'(lambda ...)) \\*
~~~~~~~~~~~~~~~(error \#'(lambda ...))) \\*
~~...)
\end{lisp}
  if an unbound variable error is signaled in the body (and not handled
  by an intervening handler), the first function will be called. If any
  other kind of error is signaled, the second function will be called.
  In either case, neither handler will be active while executing the code
  in the associated function.
\end{defmac}


\subsection{Defining Conditions}


[The contents of this section are still a subject of some debate within X3J13.
The reader may wish to take this section with a grain of salt, two aspirin
tablets, and call a hacker in the morning.---GLS]

\begin{defmac}
define-condition name ({parent-type}*)
                 [({slot-specifier}*) {option}*]

  Defines a new condition type called {\it name}, which is a subtype of each given
  {\it parent-type}.  Except as otherwise noted, the arguments are not evaluated.

  Objects of this condition type will have all of the indicated {\it slot\/}s, plus
  any additional slots inherited from the parent types (its superclasses).
  If the {\it slot\/}s list is omitted, the empty list is assumed.

  A {\it slot} must have the form
\begin{tabbing}
{\it slot-specifier\/} ::= {\it slot-name\/} {\Mor} ({\it slot-name\/}  $\lbrack\!\lbrack\downarrow\!\hbox{{\it slot-option}}\,\rbrack\!\rbrack$)
\end{tabbing}
For the syntax of a {\it slot-option}, see \cd{defclass}.
The slots of a condition object are normal CLOS slots.
Note that \cd{with-slots} may be used instead of accessor functions to access slots of a
condition object.

  \cd{make-condition} will accept keywords (in the keyword package) with the
  print name of any of the designated slots, and will initialize the
  corresponding slots in conditions it creates.

  Accessors are created according to the same rules as used by \cd{defclass}.

  The valid {\it options} are as follows:

\begin{flushdesc}
\item[\cd{(:documentation {\it doc-string})}]

     The {\it doc-string} should be either \cd{nil} or
     a string that describes the purpose of the
     condition type. If this option is omitted, \cd{nil} is assumed.
     Calling \cd{(documentation '{\it name} 'type)} will retrieve this information.

\item[\cd{(:report {\it exp})}]

     If {\it exp} is not a literal string, it must be a suitable argument to the
     \cd{function} special form. The expression \cd{(function~{\it exp})} will be evaluated
     in the current lexical environment. It should produce a function of two
     arguments, a condition and a stream, that prints on the stream a
     description of the condition. This function is called whenever the
     condition is printed while \cd{*print-escape*} is \cd{nil}.

     If {\it exp} is a literal string, it is shorthand for
\begin{lisp}
(lambda (c s) \\*
~~(declare (ignore c)) \\*
~~(write-string {\it exp} s))
\end{lisp}
     [That is, a function is provided that will simply write the given string literally
     to the stream, regardless of the particular condition object supplied.---GLS]

     The \cd{:report} option is processed {\it after} the new condition type has been defined,
     so use of the slot accessors within the report function is permitted.
     If this option is not specified, information about how to report this
     type of condition will be inherited from the {\it parent-type}.
\end{flushdesc}

[X3J13 voted in March 1989 \issue{ZLOS-CONDITIONS} to integrate the
Condition System and the Object System.
In the original Condition System proposal, \cd{define-condition}
allowed only one {\it parent-type} (the inheritance structure was a simple
hierarchy).
Slot descriptions were much simpler, even simpler than those for \cd{defstruct}:
\begin{tabbing}
{\it slot} ::= {\it slot-name} {\Mor} ({\it slot-name}) {\Mor} ({\it slot-name} {\it default-value})
\end{tabbing}
Similarly, \cd{define-condition} allowed
a \cd{:conc-name} option similar to that of \cd{defstruct}:
\begin{flushdesc}
\item[\cd{(:conc-name {\it symbol-or-string})}]

     {\bf Not now part of Common Lisp.}
     As with \cd{defstruct}, this sets up automatic prefixing of the names 
     of slot accessors. Also as in \cd{defstruct}, the default behavior 
     is to use the name of the new type, {\it name}, followed by a hyphen.
     (Generated names are interned in the package that is current at the time that the 
     \cd{define-condition} is processed).
\end{flushdesc}
One consequence of the vote was to make \cd{define-condition} slot descriptions
like those of \cd{defclass}.---GLS]

Here are some examples of the use of \cd{define-condition}.

\vskip 6pt plus 3 pt minus 2 pt

  The following form defines a condition of type \cd{peg/hole-mismatch} that
  inherits from a condition type called \cd{blocks-world-error}:
\begin{lisp}
(define-condition peg/hole-mismatch (blocks-world-error) \\*
~~~~~~~~~~~~~~~~~~(peg-shape hole-shape) \\*
~~(:report \\
~~~~(lambda (condition stream) \\*
~~~~~~(with-slots (peg-shape hole-shape) condition \\*
~~~~~~~~(format stream "A {\Xtilde}A peg cannot go in a {\Xtilde}A hole." \\*
~~~~~~~~~~~~~~~~peg-shape hole-shape))))
\end{lisp}
  The new type has slots \cd{peg-shape} and \cd{hole-shape}, so \cd{make-condition} will
  accept \cd{:peg-shape} and \cd{:hole-shape} keywords. The \cd{with-slots} macro 
  may be used to access the \cd{peg-shape} and \cd{hole-shape} slots,
  as illustrated in the \cd{:report} information.

  Here is another example. This defines a condition called \cd{machine-error}
  that inherits from \cd{error}:
\begin{lisp}
(define-condition machine-error (error) \\*
~~~~~~~~~~~~~~~~~~((machine-name \\*
~~~~~~~~~~~~~~~~~~~~:reader machine-error-machine-name)) \\
~~(:report (lambda (condition stream) \\*
~~~~~~~~~~~~~(format stream "There is a problem with {\Xtilde}A." \\*
~~~~~~~~~~~~~~~~~~~~~(machine-error-machine-name condition)))))
\end{lisp}
  Building on this definition, we can define a new error condition that
  is a subtype of \cd{machine-error} for use when machines are not available: 
\begin{lisp}
(define-condition machine-not-available-error (machine-error) () \\*
~~(:report (lambda (condition stream) \\*
~~~~~~~~~~~~~(format stream "The machine {\Xtilde}A is not available." \\*
~~~~~~~~~~~~~~~~~~~~~(machine-error-machine-name condition)))))
\end{lisp}
  We may now define a still more specific condition, built upon 
  \cd{machine-\discretionary{}{}{}not-\discretionary{}{}{}available-\discretionary{}{}{}error},
  that provides a default for \cd{machine-name}
  but does not provide any new slots or report information. It just
  gives the \cd{machine-name} slot a default initialization:
\begin{lisp}
(define-condition my-favorite-machine-not-available-error \\*
~~~~~~~~~~~~~~~~~~(machine-not-available-error) \\*
~~~~~~~~~~~~~~~~~~((machine-name :initform "MC.LCS.MIT.EDU")))
\end{lisp}
  Note that since no \cd{:report} clause was given, the information inherited from
  \cd{machine-not-available-error} will be used to report this type of condition.
\end{defmac}


\subsection{Creating Conditions}

The function \cd{make-condition} is the basic means for
creating condition objects.

\begin{defun}[Function]
make-condition type &rest slot-initializations

   Constructs a condition object of the given {\it type} using {\it slot-initializations}
   as a specification of the initial value of the slots. The newly created
   condition is returned.

   The {\it slot-initializations} are alternating keyword/value pairs.
   For example:
\begin{lisp}
(make-condition 'peg/hole-mismatch \\*
~~~~~~~~~~~~~~~~:peg-shape 'square :hole-shape 'round)
\end{lisp}
\end{defun}


\subsection{Establishing Restarts}

The lowest-level form that creates restart points is called \cd{restart-bind}.
The \cd{restart-case} macro is an abstraction that addresses many common needs for
\cd{restart-\discretionary{}{}{}bind} while offering a more\vadjust{\penalty-10000}
palatable syntax. See also 
\cd{with-\discretionary{}{}{}simple-\discretionary{}{}{}restart}.
The function that transfers control to a restart
point established by one of these macros is called \cd{invoke-\discretionary{}{}{}restart}.

All restarts have dynamic extent; a restart does not survive execution of the form
that establishes it.

\begin{defmac}
with-simple-restart (name format-string {\,format-argument}*)
                    {\,form}*

  This is shorthand for one of the most common uses of \cd{restart-case}.

  If the restart designated by {\it name} is not invoked while executing the {\it form\/}s,
  all values returned by the last {\it form} are returned. If that
  restart is invoked, control is transferred to the \cd{with-simple-restart}
  form, which immediately returns the two values \cd{nil} and \cd{t}.

  The {\it name} may be \cd{nil}, in which case an anonymous restart
  is established.

  \cd{with-simple-restart} could be defined by
\begin{lisp}
(defmacro with-simple-restart ((restart-name format-string \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\&rest format-arguments) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\&body forms) \\
~~{\Xbq}(restart-case (progn ,{\Xatsign}forms) \\*
~~~~~(,restart-name () \\*
~~~~~~~:report \\*
~~~~~~~~~(lambda (stream) \\*
~~~~~~~~~~~(format stream ,format-string ,{\Xatsign}format-arguments)) \\*
~~~~~~~(values nil t))))
\end{lisp}

Here is an example of the use of \cd{with-simple-restart}.
\begin{lisp}
Lisp> (defun read-eval-print-loop (level) \\*
~~~~~~~~(with-simple-restart \\*
~~~~~~~~~~~~(abort "Exit command level {\Xtilde}D." level) \\*
~~~~~~~~~~(loop \\*
~~~~~~~~~~~~(with-simple-restart \\*
~~~~~~~~~~~~~~~~(abort "Return to command level {\Xtilde}D." level) \\*
~~~~~~~~~~~~~~(let ((form (prog2 (fresh-line) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(read) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(fresh-line)))) \\*
~~~~~~~~~~~~~~~~(prin1 (eval form))))))) \\*
~\EV\ READ-EVAL-PRINT-LOOP \\
Lisp> (read-eval-print-loop 1) \\*
(+ 'a 3) \\
Error: The argument, A, to the function + was of the wrong type. \\*
~~~~~~~The function expected a number. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use this time. \\*
~2: Return to command level 1. \\*
~3: Exit command level 1. \\*
~4: Return to Lisp Toplevel. \\*
Debug> 
\end{lisp}

\beforenoterule
\begin{incompatibility}
In contrast to the way that Zetalisp has traditionally
  defined \cd{abort} as a kind of condition to be handled,
  the Common Lisp Condition System defines \cd{abort} as a
  way to restart (``proceed'' in Zetalisp terms).
\end{incompatibility}
\betweennoterule
\begin{sideremark}
    Some readers may wonder what ought to be done by the ``abort'' key (or whatever
    the implementation's interrupt key is---Control-C or Control-G, 
    for example). Such interrupts, whether synchronous or asynchronous
    in nature, are beyond the scope of this chapter and indeed are not currently
    addressed by Common Lisp at all. This may be a topic
    worth standardizing under separate cover. Here is some speculation
    about some possible things that might happen.

    An implementation might simply call \cd{abort} or \cd{break} directly
    without signaling any condition.

    Another implementation might signal some condition related to
    the fact that a key had been pressed rather than to the action that
    should be taken. This is one way to allow user customization.
    Perhaps there would be an implementation-dependent \cd{keyboard-interrupt}
    condition type with a slot containing the key that was pressed---or
    perhaps there would be such a condition type, but rather than its having
    slots, different subtypes of that type with names like \cd{keyboard-abort},
    \cd{keyboard-break}, and so on might be signaled. That implementation would
    then document the action it would take if user programs failed
    to handle the condition, and perhaps ways for user programs to
    usefully dismiss the interrupt.
\end{sideremark}
\betweennoterule
\begin{implementation}
  Implementors are encouraged to make sure that there
  is always a restart named \cd{abort} around any user code so that user code 
  can call \cd{abort} at any time and expect something reasonable to happen;
  exactly what the reasonable thing is may vary somewhat. Typically, in an
  interactive program, invoking \cd{abort} should return the user to top level,
  though in some batch or multi-processing situations
  killing the running process might be
  more appropriate.
\end{implementation}
\afternoterule
\end{defmac}


\begin{defmac}
restart-case expression {(case-name arglist
                         {keyword value}*
                         {\,form}*)}*

  The {\it expression} is evaluated in a dynamic context where the clauses have 
  special meanings as points to which control may be transferred. If the {\it expression}
  finishes executing and returns any values, all such values are simply
  returned by the \cd{restart-case} form. While the {\it expression} is running, any code may
  transfer control to one of the clauses (see \cd{invoke-restart}). If a transfer
  occurs, the {\it form\/}s in the body of that clause will be evaluated and any values
  returned by the last such {\it form} will be returned by the \cd{restart-case} form.

As a special case,
if the {\it expression} is a list whose {\it car} is \cd{signal}, \cd{error},
     \cd{cerror}, or \cd{warn}, then \cd{with-condition-restarts} is implicitly
     used to associate the restarts with the condition to be signaled.
For example,
\begin{lisp}
(restart-case (signal weird-error) \\*
~~(become-confused ...) \\*
~~(rewind-line-printer ...) \\*
~~(halt-and-catch-fire ...))
\end{lisp}
     is equivalent to
\begin{lisp}
(restart-case (with-condition-restarts \\*
~~~~~~~~~~~~~~~~weird-error  \\*
~~~~~~~~~~~~~~~~(list (find-restart 'become-confused)  \\*
~~~~~~~~~~~~~~~~~~~~~~(find-restart 'rewind-line-printer) \\*
~~~~~~~~~~~~~~~~~~~~~~(find-restart 'halt-and-catch-fire)) \\*
~~~~~~~~~~~~~~~~(signal weird-error)) \\
~~(become-confused ...) \\*
~~(rewind-line-printer ...) \\*
~~(halt-and-catch-fire ...))
\end{lisp}

  If there are no {\it form\/}s in a selected clause, \cd{restart-case} returns \cd{nil}.

  The {\it case-name} may be \cd{nil} or a symbol naming this restart.

  It is possible to have more than one clause use the same {\it case-name}.
  In this case, the first clause with that name will be found by
  \cd{find-restart}. The other clauses are accessible using \cd{compute-restarts}.
  [In this respect, \cd{restart-case} is rather different from \cd{case}!---GLS]

  Each {\it arglist} is a normal lambda-list containing parameters
  to be bound during the execution of 
  its corresponding {\it form\/}s. These parameters are used to pass any necessary 
  data from a call to \cd{invoke-restart} to the \cd{restart-case} clause.

  By default, \cd{invoke-restart-interactively} will pass no arguments and
  all parameters must be optional in order to accommodate interactive
  restarting. However, the parameters need not be optional if the
  \cd{:interactive} keyword has been used to inform \cd{invoke-restart-interactively}
  about how to compute a proper argument list.

  The valid {\it keyword value} pairs are the following:
\begin{flushdesc}
\item[\cd{:test {\it fn}}]

    The {\it fn} must be a suitable argument for the \cd{function} special form. The
    expression \cd{(function~{\it fn})} will be evaluated in the current lexical
    environment. It should produce a function of one argument, a condition.
    If this function returns \cd{nil} when given some condition, functions such as
\cd{find-restart}, \cd{compute-restart}, and \cd{invoke-restart}
will not consider this restart when searching for restarts associated with
that condition.  If this pair is not supplied, it is as if
\begin{lisp}
(lambda (c) (declare (ignore c)) t)
\end{lisp}
were used for the {\it fn}.

\item[\cd{:interactive {\it fn}}]

    The {\it fn} must be a suitable argument for the \cd{function} special form. The
    expression \cd{(function~{\it fn})} will be evaluated in the current lexical
    environment. It should produce a function of no arguments that 
    returns arguments to be used by \cd{invoke-restart-interactively} when
    invoking this function. This function will be called in the dynamic
    environment available prior to any restart attempt. It may interact with the user
    on the stream in \cd{*query-io*}.

    If a restart is invoked interactively but no \cd{:interactive} option
    was supplied, the argument list used in the invocation is the empty
    list.

\item[\cd{:report {\it exp}}]

    If {\it exp} is not a literal string, it must be a suitable argument to the
    \cd{function} special form. The expression \cd{(function~{\it exp})} will be evaluated
    in the current lexical environment. It should produce a function of one
    argument, a stream, that prints on the stream a description of the
    restart. This function is called whenever the restart is printed while
    \cd{*print-escape*} is \cd{nil}.

    If {\it exp} is a literal string, it is shorthand for
\begin{lisp}
(lambda (s) (write-string {\it exp} s))
\end{lisp}
[That is, a function is provided that will simply write the given string literally
to the stream.---GLS]

    If a named restart is asked to report but no report information has been
    supplied, the name of the restart is used in generating default report text.

    When \cd{*print-escape*} is \cd{nil}, the printer will use the report information for
    a restart. For example, a debugger might announce the action of typing
    ``\cd{:continue}'' by executing the equivalent of
\begin{lisp}
(format *debug-io* "{\Xtilde}\&{\Xtilde}S -- {\Xtilde}A{\Xtilde}\%" ':continue some-restart)
\end{lisp}
    which might then display as something like
\begin{lisp}
:CONTINUE -- Return to command level.
\end{lisp}

    It is an error if an unnamed restart is used and no report information
    is provided.

\beforenoterule
    \begin{rationale}
    Unnamed restarts are required to have report information
    on the grounds that they are generally only useful interactively,
    and an interactive option that has no description is of little value.
    \end{rationale}
\betweennoterule
\begin{implementation}
      Implementations are encouraged to warn about this error at compilation time.

      At run time, this error might be noticed when entering
      the debugger. Since signaling an error would probably cause recursive
      entry into the debugger (causing yet another recursive error, and so on), it is
      suggested that the debugger print some indication of such problems when
      they occur, but not actually signal errors.
\end{implementation}
\afternoterule
\end{flushdesc}

Note that 
\begin{lisp}
(restart-case {\it expression} \\*
~~({\it name\SU{1}} {\it arglist\SU{1}} {\it options\SU{1}} . {\it body\SU{1}}) \\*
~~({\it name\SU{2}} {\it arglist\SU{2}} {\it options\SU{2}} . {\it body\SU{2}}) \\*
~~...)
\end{lisp}
is essentially equivalent to
\begin{lisp}
(block \#1=\#:block-1 \\*
~~(let ((\#2=\#:var-2 nil)) \\*
~~~~(tagbody \\*
~~~~~~(restart-bind (({\it name\SU{1}} \pushtabs\=\#'(lambda (\&rest temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#3=\#:tag-3)) \\*
\>{\rm $\langle$slightly transformed {\it options\SU{1}}$\rangle$})\poptabs \\
~~~~~~~~~~~~~~~~~~~~~({\it name\SU{2}} \pushtabs\=\#'(lambda (\&rest temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#4=\#:tag-4)) \\*
\>{\rm $\langle$slightly transformed {\it options\SU{2}}$\rangle$})\poptabs \\*
~~~~~~~~~~~~~~~~~~~~~...) \\*
~~~~~~~~(return-from \#1\# expression)) \\
~~~~~~\#3\# (return-from \#1\# \\*
~~~~~~~~~~~~~~~~(apply \#'(lambda {\it arglist\SU{1}} . {\it body\SU{1}}) \#2\#)) \\
~~~~~~\#4\# (return-from \#1\# \\*
~~~~~~~~~~~~~~~~(apply \#'(lambda {\it arglist\SU{2}} . {\it body\SU{2}}) \#2\#)) \\*
~~~~~~...)))
\end{lisp}
[Note the use of ``gensyms'' such as \cd{\#:block-1} as block names,
variables, and \cd{tagbody} tags in this example,
and the use of \cd{\#{\it n}=} and \cd{\#{\it n}\#} read-macro syntax
to indicate that the very same gensym appears in multiple places.---GLS]


Here are some examples of the use of \cd{restart-case}.
\begin{lisp}
(loop \\*
~~(restart-case (return (apply function some-args)) \\*
~~~~(new-function (new-function) \\*
~~~~~~~~:report "Use a different function." \\*
~~~~~~~~:interactive \\*
~~~~~~~~~~(lambda () \\*
~~~~~~~~~~~~(list (prompt-for 'function "Function: "))) \\*
~~~~~~(setq function new-function)))) \\
 \\
(loop \\*
~~(restart-case (return (apply function some-args)) \\*
~~~~(nil (new-function) \\*
~~~~~~~~:report "Use a different function." \\*
~~~~~~~~:interactive \\*
~~~~~~~~~~(lambda () \\*
~~~~~~~~~~~~(list (prompt-for 'function "Function: "))) \\*
~~~~~~(setq function new-function)))) \\
 \\
(restart-case (a-command-loop) \\*
~~(return-from-command-level () \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;{\rm Argument \cd{s} is a stream} \\*
~~~~~~~~~~(format s "Return from command level {\Xtilde}D." level)) \\*
~~~~nil)) \\
 \\
(loop  \\*
~~(restart-case (another-random-computation) \\*
~~~~(continue () nil)))
\end{lisp}
  The first and second examples are equivalent from the point of view of someone
  using the interactive debugger, but they differ in one important aspect for 
  non-interactive handling. If a handler ``knows about'' named restarts, as in, for example,
\begin{lisp}
(when (find-restart 'new-function) \\*
~~(invoke-restart 'new-function the-replacement))
\end{lisp}
  then only the first example, and not the second, will have control
  transferred to its correction clause, since only the first example uses
  a restart named \cd{new-function}.

\vskip 6pt plus 3pt minus 2pt

  Here is a more complete example:
\begin{lisp}
(let ((my-food 'milk) \\*
~~~~~~(my-color 'greenish-blue)) \\*
~~(do () \\*
~~~~~~((not (bad-food-color-p my-food my-color))) \\*
~~~~(restart-case (error 'bad-food-color \\*
~~~~~~~~~~~~~~~~~~~~~~~~~:food my-food :color my-color) \\*
~~~~~~(use-food (new-food) \\*
~~~~~~~~~~:report "Use another food." \\*
~~~~~~~~(setq my-food new-food)) \\
~~~~~~(use-color (new-color) \\*
~~~~~~~~~~:report "Use another color." \\*
~~~~~~~~(setq my-color new-color)))) \\*
~~;; We won't get to here until MY-FOOD \\*
~~;; and MY-COLOR are compatible. \\*
~~(list my-food my-color))
\end{lisp}
Assuming that \cd{use-food} and \cd{use-color} have been defined as
\begin{lisp}
(defun use-food (new-food) \\*
~~(invoke-restart 'use-food new-food)) \\
\\
(defun use-color (new-color) \\*
~~(invoke-restart 'use-color new-color))
\end{lisp}
a handler can then restart from the error in either of two ways.
It may correct the color or correct the food. For example:
\begin{lisp}
\#'(lambda (c) ... (use-color 'white) ...)~~~;{\rm Corrects \cd{color}} \\
\\
\#'(lambda (c) ... (use-food 'cheese) ...)~~~;{\rm Corrects \cd{food}}
\end{lisp}

  Here is an example using \cd{handler-bind} and \cd{restart-case} that refers to a
  condition type \cd{foo-error}, presumably defined elsewhere:
\begin{lisp}
(handler-bind ((foo-error \#'(lambda (ignore) (use-value 7)))) \\*
~~(restart-case (error 'foo-error) \\*
~~~~(use-value (x) (* x x)))) \\*
~\EV\ 49
\end{lisp}
\end{defmac}


\begin{defmac}
restart-bind ({(name function {keyword value}*)}*) {\,form}*

  Executes a body of forms in a dynamic context where the given restart
  bindings are in effect.

  Each {\it name} may be \cd{nil} to indicate an anonymous restart, or some other symbol
  to indicate a named restart.

  Each {\it function} is a form that
  should evaluate to a function to be used to perform the restart.
  If invoked, this function may either perform a non-local transfer of control
  or it may return normally. The function may take whatever arguments the
  programmer feels are appropriate; it will be invoked only if \cd{invoke-restart}
  is used from a program, or if a user interactively asks the debugger to
  invoke it. In the case of interactive invocation, the \cd{:interactive-function}
  option is used.

\vskip 6pt plus 3pt minus 2pt

  The valid {\it keyword value} pairs are as follows:
\begin{flushdesc}
\item[\cd{:test-function {\it form}}]

    The {\it form} will be evaluated in the current lexical environment and
     should return a function of one argument, a condition.
    If this function returns \cd{nil} when given some condition, functions such as
\cd{find-restart}, \cd{compute-restart}, and \cd{invoke-restart}
will not consider this restart when searching for restarts associated with
that condition.  If this pair is not supplied, it is as if
\begin{lisp}
\#'(lambda (c) (declare (ignore c)) t)
\end{lisp}
were used for the {\it form}.

\item[\cd{:interactive-function {\it form}}]

     The {\it form} will be evaluated in the current lexical environment and
     should return a function of no arguments that constructs a list
     of arguments to be used by \cd{invoke-restart-interactively} when invoking
     this restart. The function may prompt interactively using \cd{*query-io*}
     if necessary.

\item[\cd{:report-function {\it form}}]

     The {\it form} will be evaluated in the current lexical environment and
     should return a function of one argument, a stream, that prints on
     the stream a summary of the action this restart will take. This
     function is called whenever the restart is printed while \cd{*print-escape*}
     is \cd{nil}.
\end{flushdesc}
\end{defmac}

\begin{defmac}
with-condition-restarts condition-form restarts-form
  {declaration}* {\,form}*

The value of {\it condition-form} should be a condition {\it C} and
the value of {\it restarts-form} should be a list of restarts \cd{({\it R1} {\it R2} ...)}.
      The {\it form\/}s of the body are evaluated as an implicit \cd{progn}.
      While in the dynamic context of the body,
      an attempt to find a restart associated with a particular
      condition ${\it C}'$ will 
      consider the restarts {\it R1}, {\it R2}, $\ldots$ if ${\it C}'$ is \cd{eq} to {\it C}.

     Usually this macro is not used explicitly in code, because
     \cd{restart-case} handles most of the common uses in a way that is
     syntactically more concise.

[The X3J13 vote \issue{CONDITION-RESTARTS} left it unclear whether \cd{with-condition-restarts}
permits declarations to appear at the heads of its body.
I believe that was the intent, but this is only my interpretation.---GLS]

\end{defmac}


\subsection{Finding and Manipulating Restarts}

The following functions determine what restarts are
active and invoke restarts.

\begin{defun}[Function]
compute-restarts &optional condition

  Uses the dynamic state of the program to compute a list of the restarts
  that are currently active. See \cd{restart-bind}.

If {\it condition} is \cd{nil} or not supplied, all outstanding restarts
are returned.
If {\it condition} is not \cd{nil}, only restarts associated
with that condition are returned.

  Each restart represents a function that can be called to perform some
  form of recovery action, usually a transfer of control to an outer point
  in the running program. Implementations are free to implement these objects
  in whatever manner is most convenient; the objects need have only dynamic
  extent (relative to the scope of the binding form that instantiates them).

  The list that results from a call to \cd{compute-restarts} is ordered so that
  the inner (that is, more recently established) restarts are nearer the head
  of the list.

  Note, too, that \cd{compute-restarts} returns all valid restarts, including
  anonymous ones, even if some of them have the same name as others and
  would therefore not be found by \cd{find-restart} when given a symbol argument.

  Implementations are permitted, but not required, to return different 
  (that is, non-\cd{eq}) lists from repeated calls to \cd{compute-restarts} while in
  the same dynamic environment. It is an error to modify the list that
  is returned by \cd{compute-restarts}.
\end{defun}


\begin{defun}[Function]
restart-name restart

  Returns the name of the given {\it restart}, or \cd{nil} if it is not named.
\end{defun}

\begin{defun}[Function]
find-restart restart-identifier &optional condition

  Searches for a particular restart in the current dynamic environment.

If {\it condition} is \cd{nil} or not supplied, all outstanding restarts
are considered.
If {\it condition} is not \cd{nil}, only restarts associated
with that condition are considered.

  If the {\it restart-identifier} is a non-\cd{nil}
  symbol, then the innermost (that is, most recently
  established) restart with that name is returned;  \cd{nil} is returned if no
  such restart is found.

  If {\it restart-identifier} is a restart object, then it is simply returned,
  unless it is not currently active, in which case \cd{nil} is returned.

  Although anonymous restarts have a name of \cd{nil}, it is an error for
  the symbol \cd{nil} to be given as the {\it restart-identifier}.  Applications that 
  would seem to require this should be rewritten to make appropriate use 
  of \cd{compute-restarts} instead.
\end{defun}

\begin{defun}[Function]
invoke-restart restart-identifier &rest arguments

  Calls the function associated with the given {\it restart-identifier}, passing any given
  {\it arguments}. The {\it restart-identifier} must be a restart or the non-null name of a
  restart that is valid in the current dynamic context. If the argument
  is not valid, an error of type \cd{control-error} will be signaled.

  \beforenoterule
  \begin{implementation}
  Restart functions call this function, not vice versa.
  \end{implementation}
  \afternoterule
\end{defun}

\begin{defun}[Function]
invoke-restart-interactively restart-identifier

  Calls the function associated with the given {\it restart-identifier}, prompting for any
  necessary arguments. The {\it restart-identifier} must be a restart or the non-null name
  of a restart that is valid in the current dynamic context. If the
  argument is not valid, an error of type \cd{control-error} will be signaled.

  The function \cd{invoke-restart-interactively} will prompt for arguments by executing
  the code provided in the \cd{:interactive} keyword to \cd{restart-case} or 
  \cd{:interactive-function} keyword to \cd{restart-bind}.

  If no \cd{:interactive} or \cd{:interactive-function}
  option has been supplied in the corresponding
  \cd{restart-case} or \cd{restart-bind}, then it is an error if the restart takes
  required arguments. If the arguments are optional, an empty argument list
  will be used in this case.

  Once \cd{invoke-restart-interactively} has calculated the arguments, it simply
  performs
  \cd{(apply~\#'invoke-restart {\it restart-identifier} {\it arguments})}.

  \cd{invoke-restart-interactively} is used internally by the debugger and may also be useful
  in implementing other portable, interactive debugging tools.
\end{defun}


\subsection{Warnings}
\label{WARNING-CONDITIONS}

Warnings are a subclass of errors that are conventionally regarded as ``mild.''

\begin{defun}[Function]
warn datum &rest arguments

   [This supersedes the description of \cd{warn}
   given in section~\ref{ERROR-SIGNALLING-FUNCTIONS}.---GLS]

  Warns about a situation, by signaling a condition of type \cd{warning}.

  If {\it datum} is a condition, then that condition is used directly.
  In this case, if the condition is not of type \cd{warning} or arguments
  is non-\cd{nil}, an error of type \cd{type-error} is signaled.

  If {\it datum} is a condition type (a class or class name), then the condition used is effectively the result
  of \cd{(apply \#'make-condition {\it datum} {\it arguments})}. This result
  must be of type \cd{warning} or an error of type \cd{type-error} is signaled.

  If {\it datum} is a string, then the condition used is effectively the result of
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string {\it datum} \\*
~~~~~~~~~~~~~~~~:format-arguments {\it arguments})
\end{lisp}

  The precise mechanism for warning is as follows.
\begin{enumerate}

%%% *break-on-warnings* deleted March 1989
%\item If \cd{*break-on-warnings*} is true, then the debugger will be entered.
%     This feature is primarily for compatibility with old code; use of
%     \cd{*break-on-signals*} is preferred. See \cd{*break-on-warnings*} below.
%     If the break is continued using the \cd{continue} restart, \cd{warn} proceeds
%     with the following step.
%
%\item The warning condition is then signaled.
\item The warning condition is signaled.

     While the \cd{warning} condition is being signaled, the \cd{muffle-warning}
     restart is established for use by a handler to bypass further action
     by \cd{warn} (that is, to cause \cd{warn} to immediately return \cd{nil}).

     As part of the signaling process, if
     \cd{(typep {\it condition} *break-on-signals*)}
     is true, then a \cd{break} will occur prior to beginning the signaling
     process.

\item If no handlers for the warning condition are found, or if all such
     handlers decline, then the condition will be reported to \cd{*error-output*}
     by the \cd{warn} function (with possible implementation-specific extra
     output such as motion to a fresh line before or after the display
     of the warning, or supplying some introductory text mentioning
     the name of the function that called \cd{warn} or the fact that this
     is a warning).

\item The value returned by \cd{warn} (if it returns) is \cd{nil}.
\end{enumerate}
\end{defun}

%%% *break-on-warnings* deleted March 1989
%
%\begin{defun}[Variable]
%*break-on-warnings*
%
%   [This supersedes the description of \cd{*break-on-warnings*}
%   given in section~\ref{ERROR-SIGNALLING-FUNCTIONS}.---GLS]
%
%  If \cd{*break-on-warnings*} is true, then the function \cd{warn} will enter the
%  debugger \cd{break} before signaling the \cd{warning} condition. If the \cd{continue}
%  restart is used, \cd{warn} continues normally with the warning process.
%
%  It is intended primarily for use when the user is debugging programs that
%  issue warnings; in ``production'' use, the value of \cd{*break-on-warnings*}
%  should be \cd{nil}. 
%
%  Note: The variable \cd{*break-on-warnings*} is still part
%        of Common Lisp but is considered obsolete.
%        See \cd{*break-on-signals*}.
%\end{defun}

\subsection{Restart Functions}

Common Lisp has the following restart functions built in.

\begin{defun}[Function]
abort &optional condition

  This function transfers control to the restart named \cd{abort}. If no such
  restart exists, \cd{abort} signals an error of type \cd{control-error}.

 If {\it condition} is \cd{nil} or not supplied, all outstanding restarts
are considered.
If {\it condition} is not \cd{nil}, only restarts associated
with that condition are considered.

  The purpose of the \cd{abort} restart is generally to allow control to return to the
  innermost ``command level.''
\end{defun}

\begin{defun}[Function]
continue &optional condition

  This function transfers control to the restart named \cd{continue}. If no such
  restart exists, \cd{continue} returns \cd{nil}.

 If {\it condition} is \cd{nil} or not supplied, all outstanding restarts
are considered.
If {\it condition} is not \cd{nil}, only restarts associated
with that condition are considered.

  The \cd{continue} restart is generally part of simple protocols where there is
  a single ``obvious'' way to continue, as with \cd{break} and \cd{cerror}. Some
  user-defined protocols may also wish to incorporate it for similar reasons.
  In general, however, it is more reliable to design a special-purpose restart
  with a name that better suits the particular application.
\end{defun}

\begin{defun}[Function]
muffle-warning &optional condition

  This function transfers control to the restart named \cd{muffle-warning}.
  If no such restart exists, \cd{muffle-warning} signals an error of type 
  \cd{control-error}.
 
 If {\it condition} is \cd{nil} or not supplied, all outstanding restarts
are considered.
If {\it condition} is not \cd{nil}, only restarts associated
with that condition are considered.

  \cd{warn} sets up this restart so that handlers of \cd{warning} conditions have
  a way to tell \cd{warn} that a \cd{warning} has already been dealt with and
  that no further action is warranted.
\end{defun}

\begin{defun}[Function]
store-value value &optional condition

  This function transfers control (and one value) to the restart named
  \cd{store-value}. If no such restart exists, \cd{store-value} returns \cd{nil}.

 If {\it condition} is \cd{nil} or not supplied, all outstanding restarts
are considered.
If {\it condition} is not \cd{nil}, only restarts associated
with that condition are considered.

  The \cd{store-value} restart is generally used by handlers trying to recover
  from errors of types such as \cd{cell-error} or \cd{type-error}, where the handler
  may wish to supply a replacement datum to be stored permanently.
\end{defun}

\begin{defun}[Function]
use-value value &optional condition

  This function transfers control (and one value) to the restart named
  \cd{use-value}. If no such restart exists, \cd{use-value} returns \cd{nil}.
 
 If {\it condition} is \cd{nil} or not supplied, all outstanding restarts
are considered.
If {\it condition} is not \cd{nil}, only restarts associated
with that condition are considered.

  The \cd{use-value} restart is generally used by handlers trying to recover
  from errors of types such as \cd{cell-error}, where the handler may wish to
  supply a replacement datum for one-time use.
\end{defun}


\subsection{Debugging Utilities}
\label{DEBUGGING-UTILITIES}

Common Lisp does not specify exactly what a debugger is or does,
but it does provide certain means for indicating intent to transfer control
to a supervisory or debugging facility.

\begin{defun}[Function]
break &optional format-string &rest format-arguments

   [This supersedes the description of \cd{break}
   given in section~\ref{ERROR-SIGNALLING-FUNCTIONS}.---GLS]

  The function \cd{break} prints the message described by the
  {\it format-string} and {\it format-arguments} and then
  goes directly into the debugger without allowing any possibility of
  interception by programmed error-handling facilities.

  If no {\it format-string} is supplied, a suitable default will be generated.

  If continued, \cd{break} returns \cd{nil}.

  Note that \cd{break} is presumed to be used as a way of inserting temporary debugging
  ``breakpoints'' in a program, not as a way of signaling errors; it is
  expected that continuing from a \cd{break} will not trigger any unusual recovery
  action. For this reason, \cd{break} does not take the additional format control
  string that \cd{cerror} takes as its first argument. This and the lack of any
  possibility of interception by programmed error handling are the only
  program-visible differences between \cd{break} and \cd{cerror}. The user interface
  aspects of these functions are permitted to vary more widely; for example,
  it is permissible for a read-eval-print loop to be entered by \cd{break} rather
  than by the conventional debugger.

  \cd{break} could be defined by
\begin{lisp}
(defun break (\&optional (format-string "Break") \\*
~~~~~~~~~~~~~~\&rest format-arguments) \\*
~~(with-simple-restart (continue "Return from BREAK.") \\*
~~~~(invoke-debugger \\*
~~~~~~(make-condition 'simple-condition \\*
~~~~~~~~~~~~~~~~~~~~~~:format-string format-string \\*
~~~~~~~~~~~~~~~~~~~~~~:format-arguments format-arguments))) \\*
~~nil)
\end{lisp}
\end{defun}

\begin{defun}[Function]
invoke-debugger condition

  Attempts interactive handling of its argument, which must be a condition.

  If the variable \cd{*debugger-hook*} is not \cd{nil}, it will be called as a function on two
  arguments: the {\it condition} being handled and the value of \cd{*debugger-hook*}.
  If a hook function returns normally, the standard debugger will be tried.

  The standard debugger will never directly return. Return can occur only by a
  special transfer of control, such as the use of a restart.

\beforenoterule
\begin{sideremark}
    The exact way in which the debugger interacts with users is expected to
    vary considerably from system to system. For example, some systems may
    use a keyboard interface, while others may use a mouse interface. Of those
    systems using keyboard commands, some may use single-character commands
    and others may use parsed line-at-a-time commands. The exact set of commands
    will vary as well. The important properties of a debugger are that
it makes information about the error accessible and that
it makes the set of apparent restarts easily accessible.

    It is desirable to have a mode where the debugger allows other features,
    such as the ability to inspect data, stacks, etc. However, it may
    sometimes be appropriate to have this kind of information hidden from
    users. Experience on the Lisp Machines has shown that some users who are
    not programmers develop a terrible phobia of debuggers. The reason for
    this usually may be traced to the fact that the debugger is very foreign to them
    and provides an overwhelming amount of information of
    interest only to programmers. With the advent of restarts, there is a clear
    mechanism for the construction of ``friendly'' debuggers. Programmers can
    be taught how to get to the information they need for debugging, but it
    should be possible to construct user interfaces to the debugger that are
    natural, convenient, intelligible, and friendly even to non-programmers.
\end{sideremark}
\afternoterule
\end{defun}

\begin{defun}[Variable]
*debugger-hook*

  This variable should hold either \cd{nil} or a function of two arguments, a
  condition and the value of \cd{*debugger-hook*}. This function may either
  handle the condition (transfer control) or return normally (allowing the
  standard debugger to run).

  Note that, to minimize recursive errors while debugging, \cd{*debugger-hook*} is
  bound to \cd{nil} when calling this function. When evaluating code typed in
  by the user interactively, the hook function may want to bind
  \cd{*debugger-hook*} to the function that was its second argument so that
  recursive errors can be handled using the same interactive facility.
\end{defun}



\section{Predefined Condition Types}        
\label{PREDEFINED-CONDITIONS-SECTION}
[The proposal for the Common Lisp Condition System introduced
a new notation for documenting types, treating them in the
same syntactic manner as functions and variables.  This notation
is used in this section but is not reflected
throughout the entire book.---GLS]


X3J13 voted in March 1989 \issue{ZLOS-CONDITIONS} to integrate
the Condition System and the Object System.  All condition types
are CLOS classes and all condition objects are ordinary CLOS objects.

\begin{defun}[Type]
restart

  This is the data type used to represent a restart.
\end{defun}

\begin{table}[t]
\caption{Condition Type Hierarchy}
\label{CONDITION-HIERARCHY-TABLE}
\begin{lisp}
condition \\
~~~~simple-condition \\
~~~~serious-condition \\
~~~~~~~~error \\
~~~~~~~~~~~~simple-error \\
~~~~~~~~~~~~arithmetic-error \\
~~~~~~~~~~~~~~~~division-by-zero \\
~~~~~~~~~~~~~~~~floating-point-overflow \\
~~~~~~~~~~~~~~~~floating-point-underflow \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~cell-error \\
~~~~~~~~~~~~~~~~unbound-variable \\
~~~~~~~~~~~~~~~~undefined-function \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~control-error \\
~~~~~~~~~~~~file-error \\
~~~~~~~~~~~~package-error \\
~~~~~~~~~~~~program-error \\
~~~~~~~~~~~~stream-error \\
~~~~~~~~~~~~~~~~end-of-file \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~type-error \\
~~~~~~~~~~~~~~~~simple-type-error \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~... \\
~~~~~~~~storage-condition \\
~~~~~~~~... \\
~~~~warning \\
~~~~~~~~simple-warning \\
~~~~~~~~... \\
~~~~...
\end{lisp}
\vfill
\end{table}

The Common Lisp condition type hierarchy is illustrated in table~\ref{CONDITION-HIERARCHY-TABLE}.

The types that are not leaves in the hierarchy (that is, \cd{condition}, \cd{warning},
\cd{storage-condition}, \cd{error}, \cd{arithmetic-error}, \cd{control-error},
and so on) are provided
primarily for type inclusion purposes. Normally they would not be directly
instantiated. 

Implementations are permitted to support non-portable synonyms for these
types, as well as to introduce other types that are above, below, or between
the types shown in this tree as long as the indicated subtype relationships
are not violated.

The types \cd{simple-condition}, \cd{serious-condition}, and \cd{warning} are pairwise
disjoint. The type \cd{error} is also disjoint from types \cd{simple-condition} and
\cd{warning}.

\begin{defun}[Type]
condition

  All types of conditions, whether error or non-error, must inherit from 
  this type.
\end{defun}

\begin{defun}[Type]
warning

  All types of warnings should inherit from this type. 
  This is a subtype of \cd{condition}.
\end{defun}

\begin{defun}[Type]
serious-condition

  All serious conditions (conditions serious enough to require interactive
  intervention if not handled) should inherit from this type. This is a
  subtype of \cd{condition}.

  This condition type is provided primarily for terminological convenience.
  In fact, signaling a condition that inherits from \cd{serious-condition} does
  not force entry into the debugger. Rather, it is conventional
  to use \cd{error} (or something built on \cd{error}) to signal conditions that are
  of this type, and to use \cd{signal} to signal conditions that are not of this
  type.
\end{defun}

\begin{defun}[Type]
error

  All types of error conditions inherit from this condition.
  This is a subtype of \cd{serious-condition}.
\end{defun}


The default condition type for \cd{signal} and \cd{warn} is \cd{simple-condition}.
The default condition type for \cd{error} and \cd{cerror} is \cd{simple-error}.

\begin{defun}[Type]
simple-condition

  Conditions signaled by \cd{signal} when given a format string as a first
  argument are of this type. This is a subtype of \cd{condition}.
  The initialization keywords \cd{:format-string} and \cd{:format-arguments} are supported
  to initialize the slots, which can be accessed using
  \cd{simple-condition-format-string} and \cd{simple-condition-format-arguments}.
  If \cd{:format-arguments} is not supplied to \cd{make-condition}, the 
  format-arguments slot defaults to \cd{nil}.
\end{defun}

\begin{defun}[Type]
simple-warning

  Conditions signaled by \cd{warn} when given a format string as a first
  argument are of this type. This is a subtype of \cd{warning}.
  The initialization keywords \cd{:format-string} and \cd{:format-arguments} are supported
  to initialize the slots, which can be accessed using
  \cd{simple-condition-format-string} and \cd{simple-condition-format-arguments}.
  If \cd{:format-arguments} is not supplied to \cd{make-condition}, the 
  format-arguments slot defaults to \cd{nil}.

  In implementations supporting multiple inheritance, this type will also be
  a subtype of \cd{simple-condition}.
\end{defun}

\begin{defun}[Type]
simple-error

  Conditions signaled by \cd{error} and \cd{cerror} when given a format string 
  as a first argument are of this type. This is a subtype of \cd{error}.
  The initialization keywords \cd{:format-string} and \cd{:format-arguments} are supported
  to initialize the slots, which can be accessed using
  \cd{simple-condition-format-string} and \cd{simple-condition-format-arguments}.
  If \cd{:format-arguments} is not supplied to \cd{make-condition}, the 
  format-arguments slot defaults to \cd{nil}.

  In implementations supporting multiple inheritance, this type will also be
  a subtype of \cd{simple-condition}.
\end{defun}

\begin{defun}[Function]
simple-condition-format-string condition

  Accesses the format-string slot of a given {\it condition}, which must be
  of type \cd{simple-condition}, \cd{simple-warning}, \cd{simple-error}, or 
  \cd{simple-type-error}.
\end{defun}

\begin{defun}[Function]
simple-condition-format-arguments condition

  Accesses the format-arguments slot of a given {\it condition}, which must
  be of type \cd{simple-condition}, \cd{simple-warning}, \cd{simple-error}, or
  \cd{simple-type-error}.
\end{defun}


\begin{defun}[Type]
storage-condition

  Conditions that relate to storage overflow should inherit from this type.
  This is a subtype of \cd{serious-condition}.
\end{defun}


\begin{defun}[Type]
type-error

  Errors in the transfer of data in a program should inherit from
  this type. This is a subtype of \cd{error}. For example, conditions to
  be signaled by \cd{check-type} should inherit from this type. The
  initialization keywords \cd{:datum} and \cd{:expected-type} are supported to 
  initialize the slots, which can be accessed using
  \cd{type-error-datum} and \cd{type-error-expected-type}.
\end{defun}

\begin{defun}[Function]
type-error-datum condition

  Accesses the datum slot of a given {\it condition}, which must be of
  type \cd{type-error}.
\end{defun}

\begin{defun}[Function]
type-error-expected-type condition

  Accesses the expected-type slot of a given {\it condition}, which must be
  of type \cd{type-error}. Users of \cd{type-error} conditions are expected to
  fill this slot with an object that is a valid Common Lisp type specifier.
\end{defun}

\begin{defun}[Type]
simple-type-error

  Conditions signaled by facilities similar to \cd{check-type} may want to
  use this type. The initialization keywords \cd{:format-string} and \cd{:format-arguments}
  are supported to initialize the slots, which can be accessed using 
  \cd{simple-\discretionary{}{}{}condition-\discretionary{}{}{}format-\discretionary{}{}{}string} and
  \cd{simple-\discretionary{}{}{}condition-\discretionary{}{}{}format-\discretionary{}{}{}arguments}.
  If \cd{:format-\discretionary{}{}{}arguments} is not supplied to
  \cd{make-\discretionary{}{}{}condition}, the 
  format-arguments slot defaults to \cd{nil}.

  In implementations supporting multiple inheritance, this type will also be
  a subtype of \cd{simple-condition}.
\end{defun}

\begin{defun}[Type]
program-error

  Errors relating to incorrect program syntax that are statically
  detectable should inherit from this type (regardless of whether they
  are in fact statically detected). This is a subtype of \cd{error}. This is
  {\it not} a subtype of \cd{control-error}.
\end{defun}

\begin{defun}[Type]
control-error

  Errors in the dynamic transfer of control in a program should inherit
  from this type. This is a subtype of \cd{error}. This is {\it not} a subtype of
  \cd{program-error}.

  The errors that result from giving \cd{throw} a tag that is not
  active or from giving \cd{go} or \cd{return-from} a tag that is no longer
  dynamically available are control errors.

  On the other hand, the errors that result from naming a \cd{go} tag or \cd{return-from} tag that
  is not lexically apparent are not control errors. They are program
  errors. See \cd{program-error}.
\end{defun}


\begin{defun}[Type]
package-error

  Errors that occur during operations on packages should inherit from
  this type. This is a subtype of \cd{error}. The initialization keyword \cd{:package}
  is supported to initialize the slot, which can be accessed using
  \cd{package-error-package}.
\end{defun}

\begin{defun}[Function]
package-error-package condition

  Accesses the package (or package name) that was being modified or
  manipulated in a {\it condition} of type \cd{package-error}.
\end{defun}


\begin{defun}[Type]
stream-error

  Errors that occur during input from, output to, or closing a stream
  should inherit from this type. This is a subtype of \cd{error}. The initialization
  keyword \cd{:stream} is supported to initialize the slot, which can be
  accessed using \cd{stream-error-stream}.
\end{defun}

\begin{defun}[Function]
stream-error-stream condition

  Accesses the offending stream of a {\it condition} of type \cd{stream-error}.
\end{defun}

\begin{defun}[Type]
end-of-file

  The error that results when a read operation is done on a stream that has
  no more tokens or characters should inherit from this type. This is a subtype of 
  \cd{stream-error}.
\end{defun}

\begin{defun}[Type]
file-error

  Errors that occur during an attempt to open a file, or during some low-level
  transaction with a file system, should inherit from this type. This is a
  subtype of \cd{error}. The initialization keyword \cd{:pathname} is supported to initialize the
  slot, which can be accessed using \cd{file-error-pathname}.
\end{defun}

\begin{defun}[Function]
file-error-pathname condition

  Accesses the offending pathname of a {\it condition} of type \cd{file-error}.
\end{defun}

\begin{defun}[Type]
cell-error

  Errors that occur while accessing a location should inherit from this
  type. This is a subtype of \cd{error}.  The initialization keyword \cd{:name} is supported to 
  initialize the slot, which can be accessed using \cd{cell-error-name}.
\end{defun}

\begin{defun}[Function]
cell-error-name condition

  Accesses the offending cell name of a {\it condition} of type \cd{cell-error}.
\end{defun}

\begin{defun}[Type]
unbound-variable

  The error that results from trying to access the value of an unbound
  variable should inherit from this type. This is a subtype of \cd{cell-error}.
\end{defun}

\begin{defun}[Type]
undefined-function

  The error that results from trying to access the value of an undefined
  function should inherit from this type. This is a subtype of \cd{cell-error}.
\end{defun}

\beforenoterule
\begin{sideremark}
    [Note: This remark was written well before the vote by X3J13 in June 1988 \issue{CLOS}
    to add the Common Lisp Object System to the forthcoming draft standard
    (see chapter~\ref{CLOS}) and the vote to integrate the Condition System
    and the Object System.  I have retained the remark here for reasons
    of historical interest.---GLS]

    Some readers may wonder why \cd{undefined-function} is not defined to inherit
    from some condition such as \cd{control-error}. The answer is that any such
    arrangement would require the presence of multiple inheritance---a 
    luxury we do not currently have (without resorting to \cd{deftype}, which 
    we are currently avoiding). When the Common Lisp Object System comes
    into being, we might want to consider issues like this. 
    Multiple inheritance makes a lot of things in a condition system much
    more flexible to deal with.

   
\end{sideremark}
\afternoterule

\begin{defun}[Type]
arithmetic-error

  Errors that occur while doing arithmetic type operations should inherit
  from this type. This is a subtype of \cd{error}. The initialization keywords \cd{:operation}
  and \cd{:operands} are supported to initialize the slots, which can be accessed
  using \cd{arithmetic-error-operation} and \cd{arithmetic-error-operands}.
\end{defun}

\begin{defun}[Function]
arithmetic-error-operation condition

  Accesses the offending operation of a condition of type \cd{arithmetic-error}.
\end{defun}

\begin{defun}[Function]
arithmetic-error-operands condition

  Accesses a list of the offending operands in a condition of type 
  \cd{arithmetic-error}.
\end{defun}

\begin{defun}[Type]
division-by-zero

  Errors that occur because of division by zero should inherit from this type.
  This is a subtype of \cd{arithmetic-error}.
\end{defun}

\begin{defun}[Type]
floating-point-overflow

  Errors that occur because of floating-point overflow should inherit from
  this type. This is a subtype of \cd{arithmetic-error}.
\end{defun}

\begin{defun}[Type]
floating-point-underflow

  Errors that occur because of floating-point underflow should inherit from
  this type. This is a subtype of \cd{arithmetic-error}.
\end{defun}


