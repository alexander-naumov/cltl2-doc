<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Functions</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:21:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 339--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse30.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html#tailclmse28.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse29.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html#clmse29.html" >Up</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">5.2   </span> <a 
href="clm.html#QQ2-39-248" id="x39-2400005.2">Functions</a></h3>
<!--l. 341--><p class="noindent" >There are two ways to indicate a function to be used in a function-call form. One
is to use a symbol that names the function. This use of symbols to name functions
is completely independent of their use in naming special and lexical variables. The
other way is to use a <i>lambda-expression</i>, which is a list whose ﬁrst element is the
symbol <tt><a 
href="symbols.html#x185-2637462r462">lambda</a></tt>. A lambda-expression is <i>not</i> a form; it cannot be meaningfully
evaluated. Lambda-expressions and symbols, when used in programs as names of
functions, can appear only as the ﬁrst element of a function-call form, or as
the second element of the <tt><a 
href="symbols.html#x185-2637399r399">function</a></tt> special operator. Note that symbols
and lambda-expressions are treated as <i>names</i> of functions in these two
contexts. This should be distinguished from the treatment of symbols and
lambda-expressions as <i>function objects</i>, that is, objects that satisfy the predicate
<tt><a 
href="symbols.html#x185-2637403r403">functionp</a></tt>, as when giving such an object to <tt><a 
href="symbols.html#x185-2637081r81">apply</a></tt> or <tt><a 
href="symbols.html#x185-2637398r398">funcall</a></tt> to be
invoked.
<!--l. 358--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.1   </span> <a 
href="frontmatter.html#QQ2-39-249" id="x39-2410005.2.1">Named Functions</a></h4>
<!--l. 360--><p class="noindent" >A name can be given to a function in one of two ways. A <i>global name</i> can be given
to a function by using the <tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt> construct. A <i>local name</i> can be given to a
function by using the <tt><a 
href="symbols.html#x185-2637379r379">flet</a></tt> or <tt><a 
href="symbols.html#x185-2637461r461">labels</a></tt> special operator. When a function is named,
a lambda-expression is eﬀectively associated with that name along with
information about the entities that are lexically apparent at that point. If a
symbol appears as the ﬁrst element of a function-call form, then it refers to the
deﬁnition established by the innermost <tt><a 
href="symbols.html#x185-2637379r379">flet</a></tt> or <tt><a 
href="symbols.html#x185-2637461r461">labels</a></tt> construct that textually
contains the reference, or to the global deﬁnition (if any) if there is no such
containing construct.
<!--l. 375--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.2.2   </span> <a 
href="frontmatter.html#QQ2-39-250" id="x39-2420005.2.2">Lambda-Expressions</a></h4>
<a 
 id="dx39-242001"></a>
                                                                          

                                                                          
<!--l. 384--><p class="noindent" >A <i>lambda-expression</i> is a list with the following syntax: <div class="lisp"><div class="tabbing">
(lambda <i>lambda-list</i> . <i>body</i>)
   <br>
<!--l. 387--><p class="noindent" ></div>
<!--l. 387--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2430005.2.2" id="x39-2430005.2.2"></a></span>
<!--l. 387--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2440005.2.2" id="x39-2440005.2.2"></a></span>
</div>
<!--l. 388--><p class="indent" >   The ﬁrst element must be the symbol <tt><a 
href="symbols.html#x185-2637462r462">lambda</a></tt>. The second element must be a
list. It is called the <i>lambda-list</i>, and speciﬁes names for the <i>parameters</i> of the
function. When the function denoted by the lambda-expression is applied to
arguments, the arguments are matched with the parameters speciﬁed by the
lambda-list. The <i>body</i> may then refer to the arguments by using the parameter
names. The <i>body</i> consists of any number of forms (possibly zero). These forms are
evaluated in sequence, and the results of the <i>last</i> form only are returned
as the results of the application (the value <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> is returned if there are
zero forms in the body). The complete syntax of a lambda-expression
is:
<div class="lisp">
<!--l. 405--><p class="indent" >   <div class="tabbing">
(lambda ( {<i><i>var</i></i>}*
   <br>                             [<i><tt>&optional</tt> {<i><i>var</i> | <tt>(</tt><i>var</i>  [<i><i>initform</i>  [<i><i>svar</i></i>]</i>]<tt>)</tt></i>}*</i>] <br>
          [<i><tt>&rest</tt> <i>var</i></i>] <br>          [<i><tt>&key</tt> {<i><i>var</i> | <tt>(</tt>{<i><i>var</i> | <tt>(</tt><i>keyword</i> <i>var</i><tt>)</tt></i>}  [<i><i>initform</i>  [<i><i>svar</i></i>]</i>]<tt>)</tt></i>}*              [<i><tt>&allow-other-keys</tt></i>]</i>] <br>
          [<i><tt>&aux</tt> {<i><i>var</i> | <tt>(</tt><i>var</i>  [<i><i>initform</i></i>]<tt>)</tt></i>}*</i>] )<br>    [[<i> {<i><i></i></i>}*declaration | <i>documentation-string</i></i>]] <br>
    {<i><i>form</i></i>}* )<br>
<!--l. 414--><p class="noindent" ></div>
<!--l. 414--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2450005.2.2" id="x39-2450005.2.2"></a></span>
                                                                          

                                                                          
<!--l. 414--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2460005.2.2" id="x39-2460005.2.2"></a></span>
</div>
<!--l. 417--><p class="indent" >   Each element of a lambda-list is either a <i>parameter speciﬁer</i> or a <i>lambda-list
keyword</i>; lambda-list keywords begin with <tt>&#x0026;</tt>. (Note that lambda-list keywords are
not keywords in the usual sense; they do not belong to the keyword package. They
are ordinary symbols each of whose names begins with an ampersand.
This terminology is unfortunately confusing but is retained for historical
reasons.)
<i>
<!--l. 424--><p class="indent" >   Keyword</i> in the preceding speciﬁcation of a lambda-list may be any
symbol whatsoever, not just a keyword symbol in the <tt>keyword</tt> package. See
below.
<!--l. 428--><p class="indent" >   A lambda-list has ﬁve parts, any or all of which may be empty:
      <ul class="itemize1">
      <li class="itemize">Speciﬁers  for  the  <i>required</i> parameters.  These  are  all  the  parameter
      speciﬁers  up  to  the  ﬁrst  lambda-list  keyword;  if  there  is  no  such
      lambda-list keyword, then all the speciﬁers are for required parameters.
      </li>
      <li class="itemize">Speciﬁers   for   <i>optional</i>  parameters.   If   the   lambda-list   keyword
      <tt>&#x0026;optional</tt> is  present,  the  <i>optional</i>  parameter  speciﬁers  are  those
      following   the   lambda-list   keyword   <tt>&#x0026;optional</tt>  up   to   the   next
      lambda-list keyword or the end of the list.
      </li>
      <li class="itemize">A speciﬁer for a <i>rest</i> parameter. The lambda-list keyword <tt>&#x0026;rest</tt>, if
      present, must be followed by a single <i>rest</i> parameter speciﬁer, which
      in turn must be followed by another lambda-list keyword or the end of
      the lambda-list.
      </li>
      <li class="itemize">Speciﬁers for <i>keyword</i> parameters. If the lambda-list keyword <tt>&#x0026;key</tt> is
      present, all speciﬁers up to the next lambda-list keyword or the end
      of the list are <i>keyword</i> parameter speciﬁers. The keyword parameter
      speciﬁers  may  optionally  be  followed  by  the  lambda-list  keyword
      <tt>&#x0026;allow-other-keys</tt>.
                                                                          

                                                                          
      </li>
      <li class="itemize">Speciﬁers for <i>aux</i> variables. These are not really parameters. If the
      lambda-list keyword <tt>&#x0026;aux</tt> is present, all speciﬁers after it are <i>auxiliary
      variable</i> speciﬁers.</li></ul>
<!--l. 462--><p class="indent" >   When the function represented by the lambda-expression is applied to
arguments, the arguments and parameters are processed in order from left to
right. In the simplest case, only required parameters are present in the
lambda-list; each is speciﬁed simply by a name <i>var</i> for the parameter variable.
When the function is applied, there must be exactly as many arguments as there
are parameters, and each parameter is bound to one argument. Here, and in
general, the parameter is bound as a lexical variable unless a declaration has been
made that it should be a special binding; see <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt>, <tt><a 
href="symbols.html#x185-2637695r695">proclaim</a></tt>, and
<tt><a 
href="symbols.html#x185-2637271r271">declare</a></tt>.
<!--l. 475--><p class="indent" >   In the more general case, if there are <i>n</i> required parameters (<i>n</i> may be zero),
there must be at least <i>n</i> arguments, and the required parameters are bound to the
ﬁrst <i>n</i> arguments. The other parameters are then processed using any remaining
arguments.
<!--l. 480--><p class="indent" >   If <i>optional</i> parameters are speciﬁed, then each one is processed as follows. If
any unprocessed arguments remain, then the parameter variable <i>var</i> is bound to
the next remaining argument, just as for a required parameter. If no arguments
remain, however, then the <i>initform</i> part of the parameter speciﬁer is evaluated,
and the parameter variable is bound to the resulting value (or to <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> if no
<i>initform</i> appears in the parameter speciﬁer). If another variable name <i>svar</i>
appears in the speciﬁer, it is bound to <i>true</i> if an argument was available, and to
<i>false</i> if no argument remained (and therefore <i>initform</i> had to be evaluated). The
variable <i>svar</i> is called a <i>supplied-p</i> parameter; it is bound not to an argument but
to a value indicating whether or not an argument had been supplied for another
parameter.
<!--l. 494--><p class="indent" >   After all <i>optional</i> parameter speciﬁers have been processed, then there may or
may not be a <i>rest</i> parameter. If there is a <i>rest</i> parameter, it is bound to a list of
all as-yet-unprocessed arguments. (If no unprocessed arguments remain, the <i>rest</i>
parameter is bound to the empty list.) If there is no <i>rest</i> parameter and there are
no <i>keyword</i> parameters, then there should be no unprocessed arguments (it is an
error if there are).
<!--l. 503--><p class="indent" >   If a function has a <i>rest</i> parameter and is called using <tt><a 
href="symbols.html#x185-2637081r81">apply</a></tt>, then the list to
which the <i>rest</i> parameter is bound is permitted, but not required, to share
top-level list structure with the list that was the last argument to <tt><a 
href="symbols.html#x185-2637081r81">apply</a></tt>.
                                                                          

                                                                          
Programmers should be careful about performing side eﬀects on the top-level list
structure of a <i>rest</i> parameter.
<!--l. 510--><p class="indent" >   This was the result of a rather long discussion within X3J13 and the wider
Lisp community. To set it in its historical context, I must remark that in Lisp
Machine Lisp the list to which a <i>rest</i> parameter was bound had only dynamic
extent; this in conjunction with the technique of “cdr-coding” permitted a clever
stack-allocation technique with very low overhead. However, the early designers of
Common Lisp, after a great deal of debate, concluded that it was dangerous for
cons cells to have dynamic extent; as an example, the “obvious” deﬁnition of the
function <tt><a 
href="symbols.html#x185-2637492r492">list</a></tt> <div class="lisp"><div class="tabbing">
(defun list (&#x0026;rest x) x)
   <br>
<!--l. 521--><p class="noindent" ></div>
<!--l. 521--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2470005.2.2" id="x39-2470005.2.2"></a></span>
<!--l. 521--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2480005.2.2" id="x39-2480005.2.2"></a></span>
</div>
<!--l. 522--><p class="indent" >   could fail catastrophically. Therefore the ﬁrst edition simply implied that the
list for a <i>rest</i> parameter, like all other lists, would have indeﬁnite extent. This still
left open the ﬂip side of the question, namely, Is the list for a <i>rest</i> parameter
guaranteed fresh? This is the question addressed by the X3J13 vote. If it is always
freshly consed, then it is permissible to destroy it, for example by giving it to
<tt><a 
href="symbols.html#x185-2637605r605">nconc</a></tt>. However, the requirement always to cons fresh lists could impose an
unacceptable overhead in many implementations. The clariﬁcation approved by
X3J13 speciﬁes that the programmer may not rely on the list being fresh; if the
function was called using <tt><a 
href="symbols.html#x185-2637081r81">apply</a></tt>, there is no way to know where the list came
from.
<!--l. 534--><p class="indent" >   Next, any <i>keyword</i> parameters are processed. For this purpose the same
arguments are processed that would be made into a list for a <i>rest</i> parameter.
(Indeed, it is permitted to specify both <tt>&#x0026;rest</tt> and <tt>&#x0026;key</tt>. In this case the
remaining arguments are used for both purposes; that is, all remaining arguments
are made into a list for the <tt>&#x0026;rest</tt> parameter and are also processed for the <tt>&#x0026;key</tt>
                                                                          

                                                                          
parameters. This is the only situation in which an argument is used in the
processing of more than one parameter speciﬁer.) If <tt>&#x0026;key</tt> is speciﬁed, there must
remain an even number of arguments; these are considered as pairs, the ﬁrst
argument in each pair being interpreted as a keyword name and the second as the
corresponding value.
<!--l. 548--><p class="indent" >   A <i>keyword</i> in a lambda-list may be any symbol whatsoever, not just a keyword
symbol in the <tt>keyword</tt> package. If, after <tt>&#x0026;key</tt>, a variable appears alone or
within only one set of parentheses (possibly with an <i>initform</i> and a <i>svar</i>),
then the behavior is as before: a keyword symbol with the same name as
the variable is used as the keyword-name when matching arguments to
parameter speciﬁers. Only a parameter speciﬁer of the form <tt>((<i>keyword</i>
<i>var</i>) ...)</tt> can cause the keyword-name not to be a keyword symbol, by
specifying a symbol not in the <tt>keyword</tt> package as the <i>keyword</i>. For example:
<div class="lisp"><div class="tabbing">
(defun wager (&#x0026;key ((secret password) nil) amount)
   <br>                                                           (format nil &#x0022;You ~A $~D&#x0022;<br>
          (if (eq password &#x2019;joe-sent-me) &#x0022;win&#x0022; &#x0022;lose&#x0022;)<br>
          amount))<br>      <br>        (wager :amount 100) <span class="math"> ⇒</span> &#x0022;You lose $100&#x0022;<br>
(wager :amount 100 &#x2019;secret &#x2019;joe-sent-me) <span class="math"> ⇒</span> &#x0022;You win $100&#x0022;<br>
<!--l. 568--><p class="noindent" ></div>
<!--l. 568--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2490005.2.2" id="x39-2490005.2.2"></a></span>
<!--l. 568--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2500005.2.2" id="x39-2500005.2.2"></a></span>
</div>
<!--l. 569--><p class="indent" >   The <tt>secret</tt> word could be made even more secret in this example by
placing it in some other <tt>obscure</tt> package, so that one would have to write
<div class="lisp"><div class="tabbing">
(wager :amount 100 &#x2019;obscure:secret &#x2019;joe-sent-me) <span class="math"> ⇒</span> &#x0022;You win $100&#x0022;
   <br>
<!--l. 574--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 574--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2510005.2.2" id="x39-2510005.2.2"></a></span>
<!--l. 574--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2520005.2.2" id="x39-2520005.2.2"></a></span>
</div>
<!--l. 575--><p class="indent" >   to win anything.
<!--l. 577--><p class="indent" >   In each keyword parameter speciﬁer must be a name <i>var</i> for the parameter
variable. If an explicit <i>keyword</i> is speciﬁed, then that is the keyword name for the
parameter. Otherwise the name <i>var</i> serves to indicate the keyword name, in that
a keyword with the same name (in the <tt>keyword</tt> package) is used as the keyword.
Thus <div class="lisp"><div class="tabbing">
(defun foo (<tt>&#x0026;key</tt> radix (type &#x2019;integer)) ...)
   <br>
<!--l. 585--><p class="noindent" ></div>
<!--l. 585--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2530005.2.2" id="x39-2530005.2.2"></a></span>
<!--l. 585--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2540005.2.2" id="x39-2540005.2.2"></a></span>
</div>
<!--l. 586--><p class="indent" >   means exactly the same as <div class="lisp"><div class="tabbing">
(defun foo (<tt>&#x0026;key</tt> ((:radix radix)) ((:type type) &#x2019;integer)) ...)
   <br>
<!--l. 589--><p class="noindent" ></div>
<!--l. 589--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2550005.2.2" id="x39-2550005.2.2"></a></span>
                                                                          

                                                                          
<!--l. 589--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2560005.2.2" id="x39-2560005.2.2"></a></span>
</div>
<!--l. 591--><p class="indent" >   The keyword parameter speciﬁers are, like all parameter speciﬁers, eﬀectively
processed from left to right. For each keyword parameter speciﬁer, if there is an
argument pair whose keyword name matches that speciﬁer&#x2019;s keyword name (that
is, the names are <tt><a 
href="symbols.html#x185-2637337r337">eq</a></tt>), then the parameter variable for that speciﬁer is bound to
the second item (the value) of that argument pair. If more than one such
argument pair matches, it is not an error; the leftmost argument pair is used. If no
such argument pair exists, then the <i>initform</i> for that speciﬁer is evaluated and the
parameter variable is bound to that value (or to <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> if no <i>initform</i> was
speciﬁed). The variable <i>svar</i> is treated as for ordinary <i>optional</i> parameters: it
is bound to <i>true</i> if there was a matching argument pair, and to <i>false</i>
otherwise.
<!--l. 607--><p class="indent" >   It is an error if an argument pair has a keyword name not matched by any
parameter speciﬁer, unless at least one of the following two conditions is
met:
      <ul class="itemize1">
      <li class="itemize"><tt>&#x0026;allow-other-keys</tt> was speciﬁed in the lambda-list.
      </li>
      <li class="itemize">Somewhere among the keyword argument pairs is a pair whose keyword
      is <tt>:allow-other-keys</tt> and whose value is not <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>.</li></ul>
<!--l. 619--><p class="noindent" >If either condition obtains, then it is not an error for an argument pair to match no
parameter speciﬁed, and the argument pair is simply ignored (but such an
argument pair is accessible through the <tt>&#x0026;rest</tt> parameter if one was speciﬁed).
The purpose of these mechanisms is to allow sharing of argument lists among
several functions and to allow either the caller or the called function to specify
that such sharing may be taking place.
<!--l. 628--><p class="indent" >   After all parameter speciﬁers have been processed, the auxiliary variable
speciﬁers (those following the lambda-list keyword <tt>&#x0026;aux</tt>) are processed from left
to right. For each one, the <i>initform</i> is evaluated and the variable <i>var</i> bound to
that value (or to <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> if no <i>initform</i> was speciﬁed). Nothing can be done
with <tt>&#x0026;aux</tt> variables that cannot be done with the special operator <tt><a 
href="symbols.html#x185-2637489r489">let*</a></tt>:
<div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(lambda (x y &#x0026;aux (a (car x)) (b 2) c) ...)
   <br>                              <span class="math"> ≡</span> (lambda (x y) (let* ((a (car x)) (b 2) c) ...))<br>
<!--l. 637--><p class="noindent" ></div>
<!--l. 637--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2570005.2.2" id="x39-2570005.2.2"></a></span>
<!--l. 637--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2580005.2.2" id="x39-2580005.2.2"></a></span>
</div>
<!--l. 639--><p class="indent" >   Which to use is purely a matter of style.
<!--l. 641--><p class="indent" >   Whenever any <i>initform</i> is evaluated for any parameter speciﬁer, that form may
refer to any parameter variable to the left of the speciﬁer in which the <i>initform</i>
appears, including any supplied-p variables, and may rely on the fact that no
other parameter variable has yet been bound (including its own parameter
variable).
<!--l. 647--><p class="indent" >   Once the lambda-list has been processed, the forms in the body of the
lambda-expression are executed. These forms may refer to the arguments to the
function by using the names of the parameters. On exit from the function, either
by a normal return of the function&#x2019;s value(s) or by a non-local exit, the parameter
bindings, whether lexical or special, are no longer in eﬀect. (The bindings are not
necessarily permanently discarded, for a lexical binding can later be reinstated if a
“closure” over that binding was created, perhaps by using <tt><a 
href="symbols.html#x185-2637399r399">function</a></tt>, and saved
before the exit occurred.)
<!--l. 657--><p class="noindent" >Examples of <tt>&#x0026;optional</tt> and <tt>&#x0026;rest</tt> parameters: <div class="lisp"><div class="tabbing">
((lambda (a b) (+ a (* b 3))) 4 5) <span class="math"> ⇒</span> 19
   <br>                     ((lambda (a <tt>&#x0026;optional</tt> (b 2)) (+ a (* b 3))) 4 5) <span class="math"> ⇒</span> 19<br>
((lambda (a <tt>&#x0026;optional</tt> (b 2)) (+ a (* b 3))) 4) <span class="math"> ⇒</span> 10<br>
((lambda (<tt>&#x0026;optional</tt> (a 2 b) (c 3 d) <tt>&#x0026;rest</tt> x) (list a b c d x)))<br>
   <span class="math"> ⇒</span> (2 <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> 3 <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>)<br>
((lambda (<tt>&#x0026;optional</tt> (a 2 b) (c 3 d) <tt>&#x0026;rest</tt> x) (list a b c d x))<br>
 6)<br>                                                    <span class="math"> ⇒</span> (6 t 3 <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>)<br>
((lambda (<tt>&#x0026;optional</tt> (a 2 b) (c 3 d) <tt>&#x0026;rest</tt> x) (list a b c d x))<br>
 6 3)<br>                                                    <span class="math"> ⇒</span> (6 t 3 t <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>)<br>
((lambda (<tt>&#x0026;optional</tt> (a 2 b) (c 3 d) <tt>&#x0026;rest</tt> x) (list a b c d x))<br>
                                                                          

                                                                          
 6 3 8)<br>                                                   <span class="math"> ⇒</span> (6 t 3 t (8))<br>
((lambda (<tt>&#x0026;optional</tt> (a 2 b) (c 3 d) <tt>&#x0026;rest</tt> x) (list a b c d x))<br>
 6 3 8 9 10 11)<br>                                    <span class="math"> ⇒</span> (6 t 3 t (8 9 10 11))<br>
<!--l. 677--><p class="noindent" ></div>
<!--l. 677--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2590005.2.2" id="x39-2590005.2.2"></a></span>
<!--l. 677--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2600005.2.2" id="x39-2600005.2.2"></a></span>
</div>
<!--l. 678--><p class="indent" >   Examples of <tt>&#x0026;key</tt> parameters: <div class="lisp"><div class="tabbing">
((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) 1 2)
   <br>     <span class="math"> ⇒</span> (1 2 <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>)<br>  ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) 1 2 :c 6)<br>
   <span class="math"> ⇒</span> (1 2 6 <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>)<br>         ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) 1 2 :d 8)<br>
   <span class="math"> ⇒</span> (1 2 <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> 8)<br>     ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) 1 2 :c 6 :d 8)<br>
   <span class="math"> ⇒</span> (1 2 6 8)<br>       ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) 1 2 :d 8 :c 6)<br>
   <span class="math"> ⇒</span> (1 2 6 8)<br>       ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) :a 1 :d 8 :c 6)<br>
   <span class="math"> ⇒</span> (:a 1 6 8)<br>         ((lambda (a b <tt>&#x0026;key</tt> c d) (list a b c d)) :a :b :c :d)<br>
   <span class="math"> ⇒</span> (:a :b :d <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>)<br>
<!--l. 694--><p class="noindent" ></div>
<!--l. 694--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2610005.2.2" id="x39-2610005.2.2"></a></span>
<!--l. 694--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2620005.2.2" id="x39-2620005.2.2"></a></span>
</div>
<!--l. 695--><p class="indent" >   Examples of mixtures: <div class="lisp"><div class="tabbing">
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))
   <br>                                                                         (list a b c d x))<br>
 1) <span class="math"> ⇒</span> (1 3 <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> 1 ())<br>
<!--l. 700--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 700--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2630005.2.2" id="x39-2630005.2.2"></a></span>
<!--l. 700--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2640005.2.2" id="x39-2640005.2.2"></a></span>
</div>
<div class="lisp">
<!--l. 702--><p class="indent" >   <div class="tabbing">
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))
   <br>                                                                         (list a b c d x))<br>
 1 2) <span class="math"> ⇒</span> (1 2 <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> 1 ())<br>                                                   <br>
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))<br>        (list a b c d x))<br>
 :c 7) <span class="math"> ⇒</span> (:c 7 <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> :c ())<br>                                                  <br>
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))<br>        (list a b c d x))<br>
 1 6 :c 7) <span class="math"> ⇒</span> (1 6 7 1 (:c 7))<br>                                              <br>
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))<br>        (list a b c d x))<br>
 1 6 :d 8) <span class="math"> ⇒</span> (1 6 <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> 8 (:d 8))<br>                                           <br>
((lambda (a <tt>&#x0026;optional</tt> (b 3) <tt>&#x0026;rest</tt> x <tt>&#x0026;key</tt> c (d a))<br>        (list a b c d x))<br>
 1 6 :d 8 :c 9 :d 10) <span class="math"> ⇒</span> (1 6 9 8 (:d 8 :c 9 :d 10))<br>
<!--l. 722--><p class="noindent" ></div>
<!--l. 722--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2650005.2.2" id="x39-2650005.2.2"></a></span>
<!--l. 722--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2660005.2.2" id="x39-2660005.2.2"></a></span>
</div>
<!--l. 724--><p class="indent" >   All lambda-list keywords are permitted, but not terribly useful, in
lambda-expressions appearing explicitly as the ﬁrst element of a function-call
form. They are extremely useful, however, in functions given global names by
<tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt>.
<!--l. 729--><p class="indent" >   All symbols whose names begin with <tt>&#x0026;</tt> are conventionally reserved for
use as lambda-list keywords and should not be used as variable names.
Implementations of Common Lisp are free to provide additional lambda-list
keywords.
<div class="defun">
                                                                          

                                                                          
<!--l. 734--><p class="noindent" ><div class="defunheader"> <i>[Constant]</i><a 
 id="dx39-266001"></a><a 
 id="x39-266002r11"></a> <b>lambda-list-keywords</b>
</div>
<!--l. 737--><p class="indent" >   The value of <tt><a 
href="symbols.html#x185-2637464r464">lambda-list-keywords</a></tt> is a list of all the lambda-list keywords
used in the implementation, including the additional ones used only by
<tt><a 
href="symbols.html#x185-2637284r284">defmacro</a></tt>. This list must contain at least the symbols <tt>&#x0026;optional</tt>, <tt>&#x0026;rest</tt>, <tt>&#x0026;key</tt>,
<tt>&#x0026;allow-other-keys</tt>, <tt>&#x0026;aux</tt>, <tt>&#x0026;body</tt>, <tt>&#x0026;whole</tt>, and <tt>&#x0026;environment</tt>.
</div>
<!--l. 744--><p class="indent" >   As an example of the use of <tt>&#x0026;allow-other-keys</tt> and <tt>:allow-other-keys</tt>,
consider a function that takes two keyword arguments of its own and
also accepts additional keyword arguments to be passed to <tt><a 
href="symbols.html#x185-2637533r533">make-array</a></tt>:
<div class="lisp"><div class="tabbing">
(defun array-of-strings (str dims <tt>&#x0026;rest</tt> keyword-pairs
   <br>                            <tt>&#x0026;key</tt> (start 0) end <tt>&#x0026;allow-other-keys</tt>)<br>
  (apply #&#x2019;make-array dims<br>
         :initial-element (subseq str start end)<br>
         :allow-other-keys t<br>                             keyword-pairs))<br>
<!--l. 754--><p class="noindent" ></div>
<!--l. 754--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2670005.2.2" id="x39-2670005.2.2"></a></span>
<!--l. 754--><p class="noindent" ><span class="paragraphHead"><a 
href="#x39-2680005.2.2" id="x39-2680005.2.2"></a></span>
</div>
<!--l. 756--><p class="indent" >   This function takes a string and dimensioning information and returns an
array of the speciﬁed dimensions, each of whose elements is the speciﬁed string.
However, <tt>:start</tt> and <tt>:end</tt> keyword arguments may be used in the usual manner
(see chapter <a 
href="kseque.html#x96-119200014">14<!--tex4ht:ref: KSEQUE --></a>) to specify that a substring of the given string should be used. In
addition, the presence of <tt>&#x0026;allow-other-keys</tt> in the lambda-list indicates that the
caller may specify additional keyword arguments; the <tt>&#x0026;rest</tt> argument provides
access to them. These additional keyword arguments are fed to <tt><a 
href="symbols.html#x185-2637533r533">make-array</a></tt>. Now,
<tt><a 
href="symbols.html#x185-2637533r533">make-array</a></tt> normally does not allow the keywords <tt>:start</tt> and <tt>:end</tt> to be
used, and it would be an error to specify such keyword arguments to
<tt><a 
href="symbols.html#x185-2637533r533">make-array</a></tt>. However, the presence in the call to <tt><a 
href="symbols.html#x185-2637533r533">make-array</a></tt> of the keyword
argument <tt>:allow-other-keys</tt> with a non-<tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> value causes any extraneous
                                                                          

                                                                          
keyword arguments, including <tt>:start</tt> and <tt>:end</tt>, to be acceptable and
ignored.
<div class="defun">
<!--l. 771--><p class="noindent" ><div class="defunheader"> <i>[Constant]</i><a 
 id="dx39-268001"></a><a 
 id="x39-268002r12"></a> <b>lambda-parameters-limit</b>
</div>
<!--l. 774--><p class="indent" >   The value of <tt><a 
href="symbols.html#x185-2637465r465">lambda-parameters-limit</a></tt> is a positive integer that is the upper
exclusive bound on the number of distinct parameter names that may
appear in a single lambda-list. This bound depends on the implementation
but will not be smaller than 50. Implementors are encouraged to make
this limit as large as practicable without sacriﬁcing performance. See
<tt><a 
href="symbols.html#x185-2637168r168">call-arguments-limit</a></tt>.
</div>
                                                                          

                                                                          
<!--l. 784--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse30.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html#tailclmse28.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse29.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html#clmse29.html" >Up</a><tt>&#x003E;</tt></div><a 
 id="tailclmse29.html"></a>   </div> </div> 
</body></html> 
