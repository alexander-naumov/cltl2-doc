<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Logical operators</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:21:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 882--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="contrl.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html#tailclmse33.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse34.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="preds.html#clmse34.html" >Up</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">6.4   </span> <a 
href="clm.html#QQ2-45-399" id="x45-3910006.4">Logical operators</a></h3>
<!--l. 884--><p class="noindent" >Common Lisp provides three operators on Boolean values: <tt><a 
href="symbols.html#x185-2637078r78">and</a></tt>, <tt><a 
href="symbols.html#x185-2637642r642">or</a></tt>, and <tt><a 
href="symbols.html#x185-2637615r615">not</a></tt>. Of
these, <tt><a 
href="symbols.html#x185-2637078r78">and</a></tt> and <tt><a 
href="symbols.html#x185-2637642r642">or</a></tt> are also control structures because their arguments are
evaluated conditionally. The function <tt><a 
href="symbols.html#x185-2637615r615">not</a></tt> necessarily examines its single
argument, and so is a simple function.
<div class="defun">
<!--l. 891--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx45-391001"></a><a 
 id="x45-391002r48"></a> <b>not</b>  <i>x</i>
</div>
<tt>
<!--l. 894--><p class="indent" >   <a 
href="symbols.html#x185-2637615r615">not</a></tt> returns <tt><a 
href="symbols.html#x185-2637871r871">t</a></tt> if <i>x</i> is <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>, and otherwise returns <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>. It therefore inverts its
argument considered as a Boolean value.
<tt>
<!--l. 897--><p class="indent" >   <a 
href="symbols.html#x185-2637635r635">null</a></tt> is the same as <tt><a 
href="symbols.html#x185-2637615r615">not</a></tt>; both functions are included for the sake of
clarity. As a matter of style, it is customary to use <tt><a 
href="symbols.html#x185-2637635r635">null</a></tt> to check whether
something is the empty list and to use <tt><a 
href="symbols.html#x185-2637615r615">not</a></tt> to invert the sense of a logical
value.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 904--><p class="indent" >   <div class="tabbing">
 <i>[Macro]</i> <b>and</b> <a 
 id="dx45-391003"></a><a 
 id="x45-391004r49"></a> {form}*
   <br>
<!--l. 905--><p class="noindent" ></div>
<!--l. 905--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-3920006.4" id="x45-3920006.4"></a></span>
</div>
<tt>
<!--l. 906--><p class="indent" >   (and <i>form1</i> <i>form2</i> ... )</tt> evaluates each <i>form</i>, one at a time, from left to
right. If any <i>form</i> evaluates to <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>, the value <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> is immediately returned without
                                                                          

                                                                          
evaluating the remaining <i>form</i>s. If every <i>form</i> but the last evaluates to a non-<tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>
value, <tt><a 
href="symbols.html#x185-2637078r78">and</a></tt> returns whatever the last <i>form</i> returns. Therefore in general <tt><a 
href="symbols.html#x185-2637078r78">and</a></tt> can be
used both for logical operations, where <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> stands for <i>false</i> and non-<tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>
values stand for <i>true</i>, and as a conditional expression. An example follows.
<div class="lisp"><div class="tabbing">
(if (and (&#x003E;= n 0)
   <br>                                                  (&#x003C; n (length a-simple-vector))<br>
         (eq (elt a-simple-vector n) &#x2019;foo))<br>                 (princ &#x0022;Foo!&#x0022;))<br>
<!--l. 920--><p class="noindent" ></div>
<!--l. 920--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-3930006.4" id="x45-3930006.4"></a></span>
<!--l. 920--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-3940006.4" id="x45-3940006.4"></a></span>
</div>
<!--l. 921--><p class="indent" >   The above expression prints <tt>Foo!</tt> if element <tt>n</tt> of <tt>a-simple-vector</tt> is the
symbol <tt>foo</tt>, provided also that <tt>n</tt> is indeed a valid index for <tt>a-simple-vector</tt>.
Because <tt><a 
href="symbols.html#x185-2637078r78">and</a></tt> guarantees left-to-right testing of its parts, <tt><a 
href="symbols.html#x185-2637329r329">elt</a></tt> is not called if <tt>n</tt> is
out of range.
<!--l. 926--><p class="indent" >   To put it another way, the <tt><a 
href="symbols.html#x185-2637078r78">and</a></tt> special operator does <i>short-circuit</i> Boolean
evaluation, like the <b>and then</b> operator in Ada and what in some Pascal-like
languages is called <b>cand</b> (for “conditional and”); the Lisp <tt><a 
href="symbols.html#x185-2637078r78">and</a></tt> special operator
is unlike the Pascal or Ada <b>and</b> operator, which always evaluates both
arguments.
<!--l. 934--><p class="indent" >   In the previous example writing <div class="lisp"><div class="tabbing">
(and (&#x003E;= n 0)
   <br>                                                    (&#x003C; n (length a-simple-vector))<br>
     (eq (elt a-simple-vector n) &#x2019;foo)<br>                      (princ &#x0022;Foo!&#x0022;))<br>
<!--l. 940--><p class="noindent" ></div>
<!--l. 940--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-3950006.4" id="x45-3950006.4"></a></span>
                                                                          

                                                                          
<!--l. 940--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-3960006.4" id="x45-3960006.4"></a></span>
</div>
<!--l. 941--><p class="indent" >   would accomplish the same thing. The diﬀerence is purely stylistic. Some
programmers never use expressions containing side eﬀects within <tt><a 
href="symbols.html#x185-2637078r78">and</a></tt>, preferring
to use <tt><a 
href="symbols.html#x185-2637435r435">if</a></tt> or <tt><a 
href="symbols.html#x185-2637927r927">when</a></tt> for that purpose.
<!--l. 945--><p class="indent" >   From the general deﬁnition, one can deduce that <tt>(and <i>x</i>)</tt> <span class="math"> ≡</span> <i>x</i>. Also, <tt>(and)</tt>
evaluates to <tt><a 
href="symbols.html#x185-2637871r871">t</a></tt>, which is an identity for this operation.
<!--l. 949--><p class="indent" >   One can deﬁne <tt><a 
href="symbols.html#x185-2637078r78">and</a></tt> in terms of <tt><a 
href="symbols.html#x185-2637245r245">cond</a></tt> in this way: <div class="lisp"><div class="tabbing">
(and <i>x</i> <i>y</i> <i>z</i> ... <i>w</i>) <span class="math"> ≡</span> (cond ((not <i>x</i>) <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>)
   <br>                                                                              ((not <i>y</i>) <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>)<br>
                           ((not <i>z</i>) <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>)<br>                                 <span class="math">…</span><br>
                           (<tt><a 
href="symbols.html#x185-2637871r871">t</a></tt> <i>w</i>))<br>
<!--l. 956--><p class="noindent" ></div>
<!--l. 956--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-3970006.4" id="x45-3970006.4"></a></span>
<!--l. 956--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-3980006.4" id="x45-3980006.4"></a></span>
</div>
<!--l. 958--><p class="indent" >   See <tt><a 
href="symbols.html#x185-2637435r435">if</a></tt> and <tt><a 
href="symbols.html#x185-2637927r927">when</a></tt>, which are sometimes stylistically more appropriate than <tt><a 
href="symbols.html#x185-2637078r78">and</a></tt>
for conditional purposes. If it is necessary to test whether a predicate is true of all
elements of a list or vector (element 0 <i>and</i> element 1 <i>and</i> element 2 <i>and</i> <span class="math">…</span>), then
the function <tt><a 
href="symbols.html#x185-2637347r347">every</a></tt> may be useful.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 966--><p class="indent" >   <div class="tabbing">
 <i>[Macro]</i> <b>or</b> <a 
 id="dx45-398001"></a><a 
 id="x45-398002r50"></a> {form}*
   <br>
<!--l. 967--><p class="noindent" ></div>
<!--l. 967--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-3990006.4" id="x45-3990006.4"></a></span>
                                                                          

                                                                          
</div>
<tt>
<!--l. 968--><p class="indent" >   (or <i>form1</i> <i>form2</i> ... )</tt> evaluates each <i>form</i>, one at a time, from left to
right. If any <i>form</i> other than the last evaluates to something other than <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>, <tt><a 
href="symbols.html#x185-2637642r642">or</a></tt>
immediately returns that non-<tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> value without evaluating the remaining <i>form</i>s.
If every <i>form</i> but the last evaluates to <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>, <tt><a 
href="symbols.html#x185-2637642r642">or</a></tt> returns whatever evaluation of the
last of the <i>form</i>s returns. Therefore in general <tt><a 
href="symbols.html#x185-2637642r642">or</a></tt> can be used both for logical
operations, where <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> stands for <i>false</i> and non-<tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> values stand for <i>true</i>, and as a
conditional expression.
<!--l. 979--><p class="indent" >   To put it another way, the <tt><a 
href="symbols.html#x185-2637642r642">or</a></tt> special operator does <i>short-circuit</i> Boolean
evaluation, like the <b>or else</b> operator in Ada and what in some Pascal-like
languages is called <b>cor</b> (for “conditional or”); the Lisp <tt><a 
href="symbols.html#x185-2637642r642">or</a></tt> special operator
is unlike the Pascal or Ada <b>or</b> operator, which always evaluates both
arguments.
<!--l. 987--><p class="indent" >   From the general deﬁnition, one can deduce that <tt>(or <i>x</i>)</tt> <span class="math"> ≡</span> <i>x</i>. Also, <tt>(or)</tt>
evaluates to <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>, which is the identity for this operation.
<!--l. 991--><p class="indent" >   One can deﬁne <tt><a 
href="symbols.html#x185-2637642r642">or</a></tt> in terms of <tt><a 
href="symbols.html#x185-2637245r245">cond</a></tt> in this way: <div class="lisp"><div class="tabbing">
(or <i>x</i> <i>y</i> <i>z</i> ... <i>w</i>) <span class="math"> ≡</span> (cond (<i>x</i>) (<i>y</i>) (<i>z</i>) ... (<tt><a 
href="symbols.html#x185-2637871r871">t</a></tt> <i>w</i>))
   <br>
<!--l. 994--><p class="noindent" ></div>
<!--l. 994--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4000006.4" id="x45-4000006.4"></a></span>
<!--l. 994--><p class="noindent" ><span class="paragraphHead"><a 
href="#x45-4010006.4" id="x45-4010006.4"></a></span>
</div>
<!--l. 996--><p class="indent" >   See <tt><a 
href="symbols.html#x185-2637435r435">if</a></tt> and <tt><a 
href="symbols.html#x185-2637902r902">unless</a></tt>, which are sometimes stylistically more appropriate than
<tt><a 
href="symbols.html#x185-2637642r642">or</a></tt> for conditional purposes. If it is necessary to test whether a predicate is true of
one or more elements of a list or vector (element 0 <i>or</i> element 1 <i>or</i> element 2 <i>or</i>
<span class="math">…</span>), then the function <tt><a 
href="symbols.html#x185-2637813r813">some</a></tt> may be useful.
</div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
<!--l. 7--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="contrl.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html#tailclmse33.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse34.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="preds.html#clmse34.html" >Up</a><tt>&#x003E;</tt></div><a 
 id="tailclmse34.html"></a>   </div> </div> 
</body></html> 
