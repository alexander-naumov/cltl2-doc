<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Constants and Variables</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 16:10:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 64--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse36.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html#tailcontrl.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse35.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html#clmse35.html" >Up</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">7.1   </span> <a 
href="clm.html#QQ2-47-411" id="x47-4030007.1">Constants and Variables</a></h3>
<!--l. 67--><p class="noindent" >Because some Lisp data objects are used to represent programs, one cannot
always notate a constant data object in a program simply by writing the notation
for the object unadorned; it would be ambiguous whether a constant object or a
program fragment was intended. The <tt><a 
href="symbols.html#x187-2636707r707">quote</a></tt> special operator resolves this
ambiguity.
<!--l. 73--><p class="indent" >   There are two kinds of variables in Common Lisp, in eﬀect: ordinary variables
and function names. There are some similarities between the two kinds,
and in a few cases there are similar functions for dealing with them, for
example <tt><a 
href="symbols.html#x187-2636147r147">boundp</a></tt> and <tt><a 
href="symbols.html#x187-2636352r352">fboundp</a></tt>. However, for the most part the two kinds
of variables are used for very diﬀerent purposes: one to name deﬁned
functions, macros, and special operators, and the other to name data
                                                                          

                                                                          
objects.
<div class="newer">
<!--l. 82--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-403001"></a>to introduce the concept of a <i>function-name</i>,
which may be either a symbol or a two-element list whose ﬁrst element is the
symbol <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> and whose second element is a symbol. The primary purpose of this
is to allow <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> expander functions to be CLOS generic functions with
user-deﬁned methods. Many places in Common Lisp that used to require a symbol
for a function name are changed to allow 2-lists as well; for example, <tt><a 
href="symbols.html#x187-2636291r291">defun</a></tt>
is changed so that one may write <tt>(defun (setf foo) ...)</tt>, and the
<tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> special operator is changed to accept any function-name. See also
<tt><a 
href="symbols.html#x187-2636354r354">fdefinition</a></tt>.
<!--l. 93--><p class="indent" >   By convention, any function named <tt>(setf <i>f</i>)</tt> should return its ﬁrst argument
as its only value, in order to preserve the speciﬁcation that <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> returns its
<i>newvalue</i>. See <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt>.
<!--l. 97--><p class="indent" >   Implementations are free to extend the syntax of function-names to include
lists beginning with additional symbols other than <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> or <tt><a 
href="symbols.html#x187-2636462r462">lambda</a></tt>.
</div>
<!--l. 102--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.1.1   </span> <a 
href="frontmatter.html#QQ2-47-412" id="x47-4040007.1.1">Reference</a></h4>
<!--l. 104--><p class="noindent" >The value of an ordinary variable may be obtained simply by writing the name of
the variable as a form to be executed. Whether this is treated as the name of a
special variable or a lexical variable is determined by the presence or absence of
an applicable <tt>special</tt> declaration; see chapter <a 
href="declar.html#x64-7900009">9<!--tex4ht:ref: DECLAR --></a>.
<!--l. 111--><p class="indent" >   The following functions and special operators allow reference to the values of
constants and variables in other ways.
<div class="defspec">
<div class="defmacheader">
<!--l. 115--><p class="indent" >   <div class="tabbing">
 <i>[Special operator]</i> <b>quote</b> <a 
 id="dx47-404001"></a><a 
 id="x47-404002r51"></a> object
   <br>
<!--l. 116--><p class="noindent" ></div>
<!--l. 116--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4050007.1.1" id="x47-4050007.1.1"></a></span>
                                                                          

                                                                          
</div>
<tt>
<!--l. 117--><p class="indent" >   (quote <i>x</i>)</tt> simply returns <i>x</i>. The <i>object</i> is not evaluated and may be any Lisp
object whatsoever. This construct allows any Lisp object to be written as a
constant value in a program. For example: <div class="lisp"><div class="tabbing">
(setq a 43)
   <br>                                                  (list a (cons a 3)) <span class="math"> ⇒</span> (43 (43 . 3))<br>
(list (quote a) (quote (cons a 3)) <span class="math"> ⇒</span> (a (cons a 3))<br>
<!--l. 126--><p class="noindent" ></div>
<!--l. 126--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4060007.1.1" id="x47-4060007.1.1"></a></span>
<!--l. 126--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4070007.1.1" id="x47-4070007.1.1"></a></span>
</div>
<!--l. 127--><p class="indent" >   Since <tt><a 
href="symbols.html#x187-2636707r707">quote</a></tt> forms are so frequently useful but somewhat cumbersome to type,
a standard abbreviation is deﬁned for them: any form <i>f </i> preceded by a single quote
(<tt> &#x2019; </tt>) character is assumed to have <tt>(quote  )</tt> wrapped around it to make <tt>(quote
<i>f</i>)</tt>. For example: <div class="lisp"><div class="tabbing">
(setq x &#x2019;(the magic quote hack))
   <br>
<!--l. 135--><p class="noindent" ></div>
<!--l. 135--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4080007.1.1" id="x47-4080007.1.1"></a></span>
<!--l. 135--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4090007.1.1" id="x47-4090007.1.1"></a></span>
</div>
<!--l. 136--><p class="indent" >   is normally interpreted by <tt><a 
href="symbols.html#x187-2636717r717">read</a></tt> to mean <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(setq x (quote (the magic quote hack)))
   <br>
<!--l. 139--><p class="noindent" ></div>
<!--l. 139--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4100007.1.1" id="x47-4100007.1.1"></a></span>
<!--l. 139--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4110007.1.1" id="x47-4110007.1.1"></a></span>
</div>
<!--l. 140--><p class="indent" >   See section <a 
href="clmse112.html#x139-160400022.1.3">22.1.3<!--tex4ht:ref: MACRO-CHARACTERS-SECTION --></a>.
<!--l. 142--><p class="indent" >   It is an error to destructively modify any object that appears as a constant in
executable code, whether within a <tt><a 
href="symbols.html#x187-2636707r707">quote</a></tt> special operator or as a self-evaluating
form.
<!--l. 146--><p class="indent" >   See section <a 
href="clmse122.html#x151-198200024.2">24.2<!--tex4ht:ref: COMPILER-SECTION --></a> for a discussion of how quoted constants are treated by the
compiler.
<div class="newer">
<!--l. 150--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-411001"></a>to clarify that <tt><a 
href="symbols.html#x187-2636343r343">eval</a></tt> and <tt><a 
href="symbols.html#x187-2636231r231">compile</a></tt> are not
permitted either to copy or to coalesce (“collapse”) constants (see <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>) appearing
in the code they process; the resulting program behavior must refer to
objects that are <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> to the corresponding objects in the source code.
Moreover, the constraints introduced by the votes on issues <a 
 id="dx47-411002"></a>and <a 
 id="dx47-411003"></a>on what kinds
of objects may appear as constants apply only to <tt><a 
href="symbols.html#x187-2636232r232">compile-file</a></tt> (see
section <a 
href="clmse122.html#x151-198200024.2">24.2<!--tex4ht:ref: COMPILER-SECTION --></a>).
</div>
</div>
<div class="defspec">
<div class="defmacheader">
<!--l. 165--><p class="indent" >   <div class="tabbing">
 <i>[Special operator]</i> <b>function</b> <a 
 id="dx47-411004"></a><a 
 id="x47-411005r52"></a> fn
   <br>
<!--l. 166--><p class="noindent" ></div>
<!--l. 166--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4120007.1.1" id="x47-4120007.1.1"></a></span>
                                                                          

                                                                          
</div>
<!--l. 167--><p class="indent" >   The value of <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> is always the functional interpretation of <i>fn</i>; <i>fn</i> is
interpreted as if it had appeared in the functional position of a function
invocation. In particular, if <i>fn</i> is a symbol, the functional deﬁnition associated
with that symbol is returned; see <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt>. If <i>fn</i> is a lambda-expression,
then a “lexical closure” is returned, that is, a function that when invoked will
execute the body of the lambda-expression in such a way as to observe the rules of
lexical scoping properly.
<div class="newer">
<!--l. 179--><p class="indent" >   X3J13 voted in June 1988 <a 
 id="dx47-412001"></a>to specify that the result of a <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> special
operator is always of type <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt>. This implies that a form <tt>(function <i>fn</i>)</tt>
may be interpreted as <tt>(the (function <i>fn</i>))</tt>.
<!--l. 184--><p class="indent" >   It is an error to use the <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> special operator on a symbol that does not
denote a function in the lexical or global environment in which the special
operator appears. Speciﬁcally, it is an error to use the <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> special operator
on a symbol that denotes a macro or special operator. Some implementations may
choose not to signal this error for performance reasons, but implementations are
forbidden to extend the semantics of <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> in this respect; that is, an
implementation is not allowed to deﬁne the failure to signal an error to be a
“useful” behavior.
</div>
<tt>
<!--l. 195--><p class="indent" >   <a 
href="symbols.html#x187-2636399r399">function</a></tt> accepts any function-name (a symbol or a list whose <i>car</i> is
<tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt>—see section <a 
href="#x47-4030007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>) as well as lambda-expressions. Thus one may write
<tt>(function (setf cadr))</tt> to refer to the <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> expansion function for
<tt><a 
href="symbols.html#x187-2636167r167">cadr</a></tt>.
<a 
 id="dx47-412002"></a>
<!--l. 203--><p class="indent" >   For example: <div class="lisp"><div class="tabbing">
(defun adder (x) (function (lambda (y) (+ x y))))
   <br>
<!--l. 206--><p class="noindent" ></div>
<!--l. 206--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4130007.1.1" id="x47-4130007.1.1"></a></span>
                                                                          

                                                                          
<!--l. 206--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4140007.1.1" id="x47-4140007.1.1"></a></span>
</div>
<!--l. 207--><p class="indent" >   The result of <tt>(adder 3)</tt> is a function that will add <tt>3</tt> to its argument:
<div class="lisp"><div class="tabbing">
(setq add3 (adder 3))
   <br>                                                                  (funcall add3 5) <span class="math"> ⇒</span> 8<br>
<!--l. 212--><p class="noindent" ></div>
<!--l. 212--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4150007.1.1" id="x47-4150007.1.1"></a></span>
<!--l. 212--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4160007.1.1" id="x47-4160007.1.1"></a></span>
</div>
<!--l. 213--><p class="indent" >   This works because <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> creates a closure of the inner lambda-expression
that is able to refer to the value <tt>3</tt> of the variable <tt>x</tt> even after control has returned
from the function <tt>adder</tt>.
<!--l. 218--><p class="indent" >   More generally, a lexical closure in eﬀect retains the ability to refer to lexically
visible <i>bindings</i>, not just values. Consider this code: <div class="lisp"><div class="tabbing">
(defun two-funs (x)
   <br>                                                        (list (function (lambda () x))<br>
        (function (lambda (y) (setq x y)))))<br>       (setq funs (two-funs 6))<br>
(funcall (car funs)) <span class="math"> ⇒</span> 6<br>                    (funcall (cadr funs) 43) <span class="math"> ⇒</span> 43<br>
(funcall (car funs)) <span class="math"> ⇒</span> 43<br>
<!--l. 229--><p class="noindent" ></div>
<!--l. 229--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4170007.1.1" id="x47-4170007.1.1"></a></span>
                                                                          

                                                                          
<!--l. 229--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4180007.1.1" id="x47-4180007.1.1"></a></span>
</div>
<!--l. 230--><p class="indent" >   The function <tt>two-funs</tt> returns a list of two functions, each of which refers to
the <i>binding</i> of the variable <tt>x</tt> created on entry to the function <tt>two-funs</tt> when
it was called with argument <tt>6</tt>. This binding has the value <tt>6</tt> initially,
but <tt><a 
href="symbols.html#x187-2636779r779">setq</a></tt> can alter a binding. The lexical closure created for the ﬁrst
lambda-expression does not “snapshot” the value <tt>6</tt> for <tt>x</tt> when the closure is
created. The second function can be used to alter the binding (to <tt>43</tt>, in
the example), and this altered value then becomes accessible to the ﬁrst
function.
<!--l. 240--><p class="indent" >   In situations where a closure of a lambda-expression over the same set of
bindings may be produced more than once, the various resulting closures may or
may not be <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>, at the discretion of the implementation. For example:
<div class="lisp"><div class="tabbing">
(let ((x 5) (funs &#x2019;()))
   <br>                     (dotimes (j 10)<br>                       (push #&#x2019;(lambda (z)<br>
              (if (null z) (setq x 0) (+ x z)))<br>                    funs))<br>
  funs)<br>
<!--l. 251--><p class="noindent" ></div>
<!--l. 251--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4190007.1.1" id="x47-4190007.1.1"></a></span>
<!--l. 251--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4200007.1.1" id="x47-4200007.1.1"></a></span>
</div>
<!--l. 252--><p class="indent" >   The result of the above expression is a list of ten closures. Each logically
requires only the binding of <tt>x</tt>. It is the same binding in each case, so the ten
closures may or may not be the same identical (<tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>) object. On the other hand, the
result of the expression <div class="lisp"><div class="tabbing">
(let ((funs &#x2019;()))
                                                                          

                                                                          
   <br>                                                                          (dotimes (j 10)<br>
    (let ((x 5))<br>                              (push (function (lambda (z)<br>
                        (if (null z) (setq x 0) (+ x z))))<br>
            funs)))<br>                                                funs)<br>
<!--l. 265--><p class="noindent" ></div>
<!--l. 265--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4210007.1.1" id="x47-4210007.1.1"></a></span>
<!--l. 265--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4220007.1.1" id="x47-4220007.1.1"></a></span>
</div>
<!--l. 266--><p class="indent" >   is also a list of ten closures. However, in this case no two of the closures may
be <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>, because each closure is over a distinct binding of <tt>x</tt>, and these bindings can
be behaviorally distinguished because of the use of <tt><a 
href="symbols.html#x187-2636779r779">setq</a></tt>.
<!--l. 271--><p class="indent" >   The question of distinguishable behavior is important; the result of the simpler
expression <div class="lisp"><div class="tabbing">
(let ((funs &#x2019;()))
   <br>                            (dotimes (j 10)<br>                              (let ((x 5))<br>
      (push (function (lambda (z) (+ x z)))<br>                     funs)))<br>
  funs)<br>
<!--l. 280--><p class="noindent" ></div>
<!--l. 280--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4230007.1.1" id="x47-4230007.1.1"></a></span>
<!--l. 280--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4240007.1.1" id="x47-4240007.1.1"></a></span>
</div>
<!--l. 281--><p class="indent" >   is a list of ten closures that <i>may</i> be pairwise <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>. Although one might
think that a diﬀerent binding of <tt>x</tt> is involved for each closure (which is
indeed the case), the bindings cannot be distinguished because their values
are identical and immutable, there being no occurrence of <tt><a 
href="symbols.html#x187-2636779r779">setq</a></tt> on <tt>x</tt>. A
compiler would therefore be justiﬁed in transforming the expression to
<div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(let ((funs &#x2019;()))
   <br>                                                                          (dotimes (j 10)<br>
    (push (function (lambda (z) (+ 5 z)))<br>                         funs))<br>
  funs)<br>
<!--l. 293--><p class="noindent" ></div>
<!--l. 293--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4250007.1.1" id="x47-4250007.1.1"></a></span>
<!--l. 293--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4260007.1.1" id="x47-4260007.1.1"></a></span>
</div>
<!--l. 294--><p class="indent" >   where clearly the closures may be the same after all. The general rule, then, is
that the implementation is free to have two distinct evaluations of the same
<tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> form produce identical (<tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>) closures if it can prove that the two
conceptually distinct resulting closures must in fact be behaviorally identical with
respect to invocation. This is merely a permitted optimization; a perfectly valid
implementation might simply cause every distinct evaluation of a <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> form
to produce a new closure object not <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt> to any other.
<!--l. 304--><p class="indent" >   Frequently a compiler can deduce that a closure in fact does not need
to close over any variable bindings. For example, in the code fragment
<div class="lisp"><div class="tabbing">
(mapcar (function (lambda (x) (+ x 2))) y)
   <br>
<!--l. 309--><p class="noindent" ></div>
<!--l. 309--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4270007.1.1" id="x47-4270007.1.1"></a></span>
<!--l. 309--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4280007.1.1" id="x47-4280007.1.1"></a></span>
</div>
                                                                          

                                                                          
<!--l. 310--><p class="indent" >   the function <tt>(lambda (x) (+ x 2))</tt> contains no references to any outside
entity. In this important special case, the same “closure” may be used as the value
for all evaluations of the <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> special operator. Indeed, this value need not be
a closure object at all; it may be a simple compiled function containing no
environment information. This example is simply a special case of the foregoing
discussion and is included as a hint to implementors familiar with previous
methods of implementing Lisp. The distinction between closures and other kinds
of functions is somewhat pointless, actually, as Common Lisp deﬁnes no particular
representation for closures and no way to distinguish between closures and
non-closure functions. All that matters is that the rules of lexical scoping be
obeyed.
<!--l. 323--><p class="indent" >   Since <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> forms are so frequently useful but somewhat cumbersome to
type, a standard abbreviation is deﬁned for them: any form <i>f </i> preceded by <tt>#&#x2019;</tt> (<tt>#</tt>
followed by an apostrophe) is assumed to have <tt>(function )</tt> wrapped around it to
make <tt>(function <i>f</i>)</tt>. For example, <div class="lisp"><div class="tabbing">
(remove-if #&#x2019;numberp &#x2019;(1 a b 3))
   <br>
<!--l. 330--><p class="noindent" ></div>
<!--l. 330--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4290007.1.1" id="x47-4290007.1.1"></a></span>
<!--l. 330--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4300007.1.1" id="x47-4300007.1.1"></a></span>
</div>
<!--l. 331--><p class="indent" >   is normally interpreted by <tt><a 
href="symbols.html#x187-2636717r717">read</a></tt> to mean <div class="lisp"><div class="tabbing">
(remove-if (function numberp) &#x2019;(1 a b 3))
   <br>
<!--l. 334--><p class="noindent" ></div>
<!--l. 334--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4310007.1.1" id="x47-4310007.1.1"></a></span>
                                                                          

                                                                          
<!--l. 334--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4320007.1.1" id="x47-4320007.1.1"></a></span>
</div>
<!--l. 335--><p class="indent" >   See section <a 
href="clmse112.html#x139-163900022.1.4">22.1.4<!--tex4ht:ref: SHARP-SIGN-MACRO-CHARACTER-SECTION --></a>.
</div>
<div class="defun">
<!--l. 338--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx47-432001"></a><a 
 id="x47-432002r53"></a> <b>symbol-value</b>  <i>symbol</i>
</div>
<tt>
<!--l. 341--><p class="indent" >   <a 
href="symbols.html#x187-2636868r868">symbol-value</a></tt> returns the current value of the dynamic (special) variable
named by <i>symbol</i>. An error occurs if the symbol has no value; see <tt><a 
href="symbols.html#x187-2636147r147">boundp</a></tt>
and <tt><a 
href="symbols.html#x187-2636555r555">makunbound</a></tt>. Note that constant symbols are really variables that
cannot be changed, and so <tt><a 
href="symbols.html#x187-2636868r868">symbol-value</a></tt> may be used to get the value of a
named constant. In particular, <tt><a 
href="symbols.html#x187-2636868r868">symbol-value</a></tt> of a keyword will return that
keyword.
<tt>
<!--l. 350--><p class="indent" >   <a 
href="symbols.html#x187-2636868r868">symbol-value</a></tt> cannot access the value of a lexical variable.
<!--l. 352--><p class="indent" >   This function is particularly useful for implementing interpreters for languages
embedded in Lisp. The corresponding assignment primitive is <tt><a 
href="symbols.html#x187-2636771r771">set</a></tt>; alternatively,
<tt><a 
href="symbols.html#x187-2636868r868">symbol-value</a></tt> may be used with <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt>.
</div>
<div class="defun">
<!--l. 358--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx47-432003"></a><a 
 id="x47-432004r54"></a> <b>symbol-function</b>  <i>symbol</i>
</div>
<tt>
<!--l. 361--><p class="indent" >   <a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> returns the current global function deﬁnition named by
<i>symbol</i>. An error is signalled if the symbol has no function deﬁnition; see <tt><a 
href="symbols.html#x187-2636352r352">fboundp</a></tt>.
Note that the deﬁnition may be a function or may be an object representing a
special operator or macro. In the latter case, however, it is an error to attempt to
invoke the object as a function. If it is desired to process macros, special
operators, and functions equally well, as when writing an interpreter, it is best
ﬁrst to test the symbol with <tt><a 
href="symbols.html#x187-2636529r529">macro-function</a></tt> and <tt><a 
href="symbols.html#x187-2636816r816">special-operator-p</a></tt>
and then to invoke the functional value only if these two tests both yield
false.
<!--l. 374--><p class="indent" >   This function is particularly useful for implementing interpreters for languages
embedded in Lisp.
                                                                          

                                                                          
<tt>
<!--l. 377--><p class="indent" >   <a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> cannot access the value of a lexical function name produced
by <tt><a 
href="symbols.html#x187-2636379r379">flet</a></tt> or <tt><a 
href="symbols.html#x187-2636461r461">labels</a></tt>; it can access only the global function value.
<!--l. 381--><p class="indent" >   The global function deﬁnition of a symbol may be altered by using <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> with
<tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt>. Performing this operation causes the symbol to have <i>only</i> the
speciﬁed deﬁnition as its global function deﬁnition; any previous deﬁnition,
whether as a macro or as a function, is lost. It is an error to attempt to redeﬁne
the name of a special form (see table <a 
href="clmse28.html#x38-2370011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>).
<div class="newer">
<!--l. 390--><p class="indent" >   X3J13 voted in June 1988 <a 
 id="dx47-432005"></a>to clarify the behavior of <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> in the
light of the redeﬁnition of the type <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt>.
      <ul class="itemize1">
      <li class="itemize">It is permissible to call <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> on any symbol for which
      <tt><a 
href="symbols.html#x187-2636352r352">fboundp</a></tt> returns true. Note that <tt><a 
href="symbols.html#x187-2636352r352">fboundp</a></tt> must return true for a symbol
      naming a macro or a special operator.
      </li>
      <li class="itemize">If <tt><a 
href="symbols.html#x187-2636352r352">fboundp</a></tt> returns true for a symbol but the symbol denotes a macro
      or special operator, then the value returned by <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> is
      not well-deﬁned but <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> will not signal an error.
      </li>
      <li class="itemize">When <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> is used with <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> the new value must be of
      type <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt>. It is an error to set the <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> of a symbol
      to a symbol, a list, or the value returned by <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> on the
      name of a macro or a special operator.</li></ul>
</div>
</div>
<div class="defun">
<!--l. 412--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx47-432006"></a><a 
 id="x47-432007r55"></a> <b>fdeﬁnition</b>  <i>function-name</i>
</div>
<!--l. 415--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx47-432008"></a>to add the function <tt><a 
href="symbols.html#x187-2636354r354">fdefinition</a></tt> to the language.
It is exactly like <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> except that its argument may be any
function-name (a symbol or a list whose <i>car</i> is <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt>—see section <a 
href="#x47-4030007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>); it returns
the current global function deﬁnition named by the argument <i>function-name</i>. One
                                                                          

                                                                          
may use <tt><a 
href="symbols.html#x187-2636354r354">fdefinition</a></tt> with <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> to change the current global function deﬁnition
associated with a function-name.
</div>
<div class="defun">
<!--l. 427--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx47-432009"></a><a 
 id="x47-432010r56"></a> <b>boundp</b>  <i>symbol</i>
</div>
<tt>
<!--l. 430--><p class="indent" >   <a 
href="symbols.html#x187-2636147r147">boundp</a></tt> is true if the dynamic (special) variable named by <i>symbol</i> has a value;
otherwise, it returns <tt><a 
href="symbols.html#x187-2636609r609">nil</a></tt>.
<!--l. 433--><p class="indent" >   See also <tt><a 
href="symbols.html#x187-2636771r771">set</a></tt> and <tt><a 
href="symbols.html#x187-2636555r555">makunbound</a></tt>.
</div>
<div class="defun">
<!--l. 436--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx47-432011"></a><a 
 id="x47-432012r57"></a> <b>fboundp</b>  <i>symbol</i>
</div>
<tt>
<!--l. 439--><p class="indent" >   <a 
href="symbols.html#x187-2636352r352">fboundp</a></tt> is true if the symbol has a global function deﬁnition. Note that
<tt><a 
href="symbols.html#x187-2636352r352">fboundp</a></tt> is true when the symbol names a special operator or macro.
<tt><a 
href="symbols.html#x187-2636529r529">macro-function</a></tt> and <tt><a 
href="symbols.html#x187-2636816r816">special-operator-p</a></tt> may be used to test for these
cases.
<!--l. 444--><p class="indent" >   Despite the tightening of the deﬁnition of the type <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt>, <tt><a 
href="symbols.html#x187-2636352r352">fboundp</a></tt> must
return true when the argument names a special operator or macro.
<!--l. 448--><p class="indent" >   See also <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> and <tt><a 
href="symbols.html#x187-2636389r389">fmakunbound</a></tt>.
<tt>
<!--l. 450--><p class="indent" >   <a 
href="symbols.html#x187-2636352r352">fboundp</a></tt> accepts any function-name (a symbol or a list whose <i>car</i> is
<tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt>—see section <a 
href="#x47-4030007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). Thus one may write <tt>(fboundp &#x2019;(setf cadr))</tt> to
determine whether a <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> expansion function has been globally deﬁned for
<tt><a 
href="symbols.html#x187-2636167r167">cadr</a></tt>.
</div>
<div class="defun">
<!--l. 457--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx47-432013"></a><a 
 id="x47-432014r58"></a> <b>special-operator-p</b>  <i>symbol</i>
</div>
<!--l. 460--><p class="indent" >   The function <tt><a 
href="symbols.html#x187-2636816r816">special-operator-p</a></tt> takes a symbol. If the symbol globally
names a special operator, then a non-<tt><a 
href="symbols.html#x187-2636609r609">nil</a></tt> value is returned; otherwise
                                                                          

                                                                          
<tt><a 
href="symbols.html#x187-2636609r609">nil</a></tt> is returned. A returned non-<tt><a 
href="symbols.html#x187-2636609r609">nil</a></tt> value is typically a function of
implementation-dependent nature that can be used to interpret (evaluate) the
special operator.
<!--l. 467--><p class="indent" >   It is possible for <i>both</i> <tt><a 
href="symbols.html#x187-2636816r816">special-operator-p</a></tt> and <tt><a 
href="symbols.html#x187-2636529r529">macro-function</a></tt> to be true of
a symbol. This is possible because an implementation is permitted to implement
any macro also as a special operator for speed. On the other hand, the macro
deﬁnition must be available for use by programs that understand only the
standard special operators listed in table <a 
href="clmse28.html#x38-2370011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>.
</div>
<!--l. 475--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">7.1.2   </span> <a 
href="frontmatter.html#QQ2-47-441" id="x47-4330007.1.2">Assignment</a></h4>
<!--l. 477--><p class="noindent" >The following facilities allow the value of a variable (more speciﬁcally, the value
associated with the current binding of the variable) to be altered. Such alteration
is diﬀerent from establishing a new binding. Constructs for establishing new
bindings of variables are described in section <a 
href="clmse39.html#x51-5550007.5">7.5<!--tex4ht:ref: VAR-BINDING-SECTION --></a>.
<div class="defspec">
<div class="defmacheader">
<!--l. 484--><p class="indent" >   <div class="tabbing">
 <i>[Special operator]</i> <b>setq</b> <a 
 id="dx47-433001"></a><a 
 id="x47-433002r59"></a> {var form}*
   <br>
<!--l. 485--><p class="noindent" ></div>
<!--l. 485--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4340007.1.2" id="x47-4340007.1.2"></a></span>
</div>
<!--l. 486--><p class="indent" >   The special operator <tt>(setq <i>var1</i> <i>form1</i> <i>var2</i> <i>form2</i> ...)</tt> is the “simple
variable assignment statement” of Lisp. First <i>form1</i> is evaluated and the result is
stored in the variable <i>var1</i>, then <i>form2</i> is evaluated and the result stored in <i>var2</i>,
and so forth. The variables are represented as symbols, of course, and are
interpreted as referring to static or dynamic instances according to the usual
rules. Therefore <tt><a 
href="symbols.html#x187-2636779r779">setq</a></tt> may be used for assignment of both lexical and special
variables.
<tt>
<!--l. 496--><p class="indent" >   <a 
href="symbols.html#x187-2636779r779">setq</a></tt> returns the last value assigned, that is, the result of the evaluation of its
                                                                          

                                                                          
last argument. As a boundary case, the form <tt>(setq)</tt> is legal and returns
<tt><a 
href="symbols.html#x187-2636609r609">nil</a></tt>. There must be an even number of argument forms. For example, in
<div class="lisp"><div class="tabbing">
(setq x (+ 3 2 1) y (cons x nil))
   <br>
<!--l. 503--><p class="noindent" ></div>
<!--l. 503--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4350007.1.2" id="x47-4350007.1.2"></a></span>
<!--l. 503--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4360007.1.2" id="x47-4360007.1.2"></a></span>
</div>
<tt>
<!--l. 504--><p class="indent" >   x</tt> is set to <tt>6</tt>, <tt>y</tt> is set to <tt>(6)</tt>, and the <tt><a 
href="symbols.html#x187-2636779r779">setq</a></tt> returns <tt>(6)</tt>. Note that the ﬁrst
assignment is performed before the second form is evaluated, allowing that form
to use the new value of <tt>x</tt>.
<!--l. 509--><p class="indent" >   See also the description of <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt>, the Common Lisp “general assignment
statement” that is capable of assigning to variables, array elements, and other
locations.
<!--l. 513--><p class="indent" >   Some programmers choose to avoid <tt><a 
href="symbols.html#x187-2636779r779">setq</a></tt> as a matter of style, always using
<tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> for any kind of structure modiﬁcation. Others use <tt><a 
href="symbols.html#x187-2636779r779">setq</a></tt> with simple variable
names and <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> with all other generalized variables.
<!--l. 518--><p class="indent" >   If any <i>var</i> refers not to an ordinary variable but to a binding made by
<tt><a 
href="symbols.html#x187-2636864r864">symbol-macrolet</a></tt>, then that <i>var</i> is handled as if <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> had been used instead of
<tt><a 
href="symbols.html#x187-2636779r779">setq</a></tt>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 525--><p class="indent" >   <div class="tabbing">
 <i>[Macro]</i> <b>psetq</b> <a 
 id="dx47-436001"></a><a 
 id="x47-436002r60"></a> {var form}*
   <br>
                                                                          

                                                                          
<!--l. 526--><p class="noindent" ></div>
<!--l. 526--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4370007.1.2" id="x47-4370007.1.2"></a></span>
</div>
<!--l. 527--><p class="indent" >   A <tt><a 
href="symbols.html#x187-2636704r704">psetq</a></tt> form is just like a <tt><a 
href="symbols.html#x187-2636779r779">setq</a></tt> form, except that the assignments happen in
parallel. First all of the forms are evaluated, and then the variables are set to
the resulting values. The value of the <tt><a 
href="symbols.html#x187-2636704r704">psetq</a></tt> form is <tt><a 
href="symbols.html#x187-2636609r609">nil</a></tt>. For example:
<div class="lisp"><div class="tabbing">
(setq a 1)
   <br>                                                                                  (setq b 2)<br>
(psetq a b b a)<br>                                                     a <span class="math"> ⇒</span> 2<br>
b <span class="math"> ⇒</span> 1<br>
<!--l. 538--><p class="noindent" ></div>
<!--l. 538--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4380007.1.2" id="x47-4380007.1.2"></a></span>
<!--l. 538--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4390007.1.2" id="x47-4390007.1.2"></a></span>
</div>
<!--l. 539--><p class="indent" >   In this example, the values of <tt>a</tt> and <tt>b</tt> are exchanged by using parallel
assignment. (If several variables are to be assigned in parallel in the context of a
loop, the <tt><a 
href="symbols.html#x187-2636310r310">do</a></tt> construct may be appropriate.)
<!--l. 544--><p class="indent" >   See also the description of <tt><a 
href="symbols.html#x187-2636703r703">psetf</a></tt>, the Common Lisp “general parallel
assignment statement” that is capable of assigning to variables, array elements,
and other locations.
<!--l. 549--><p class="indent" >   If any <i>var</i> refers not to an ordinary variable but to a binding made by
<tt><a 
href="symbols.html#x187-2636864r864">symbol-macrolet</a></tt>, then that <i>var</i> is handled as if <tt><a 
href="symbols.html#x187-2636703r703">psetf</a></tt> had been used instead of
<tt><a 
href="symbols.html#x187-2636704r704">psetq</a></tt>.
</div>
<div class="defun">
<!--l. 555--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx47-439001"></a><a 
 id="x47-439002r61"></a> <b>set</b>  <i>symbol</i> <i>value</i>
</div>
<tt>
                                                                          

                                                                          
<!--l. 558--><p class="indent" >   <a 
href="symbols.html#x187-2636771r771">set</a></tt> allows alteration of the value of a dynamic (special) variable. <tt><a 
href="symbols.html#x187-2636771r771">set</a></tt>
causes the dynamic variable named by <i>symbol</i> to take on <i>value</i> as its
value.
<!--l. 562--><p class="indent" >   The <i>value</i> may be any Lisp datum whatsoever.
<!--l. 565--><p class="indent" >   Only the value of the current dynamic binding is altered; if there are no
bindings in eﬀect, the most global value is altered. For example, <div class="lisp"><div class="tabbing">
(set (if (eq a b) &#x2019;c &#x2019;d) &#x2019;foo)
   <br>
<!--l. 570--><p class="noindent" ></div>
<!--l. 570--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4400007.1.2" id="x47-4400007.1.2"></a></span>
<!--l. 570--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4410007.1.2" id="x47-4410007.1.2"></a></span>
</div>
<!--l. 571--><p class="indent" >   will either set <tt>c</tt> to <tt>foo</tt> or set <tt>d</tt> to <tt>foo</tt>, depending on the outcome of the test
<tt>(eq a b)</tt>.
<tt>
<!--l. 574--><p class="indent" >   <a 
href="symbols.html#x187-2636771r771">set</a></tt> returns <i>value</i> as its result.
<tt>
<!--l. 576--><p class="indent" >   <a 
href="symbols.html#x187-2636771r771">set</a></tt> cannot alter the value of a local (lexically bound) variable. The special
operator <tt><a 
href="symbols.html#x187-2636779r779">setq</a></tt> is usually used for altering the values of variables (lexical or
dynamic) in programs. <tt><a 
href="symbols.html#x187-2636771r771">set</a></tt> is particularly useful for implementing interpreters for
languages embedded in Lisp. See also <tt><a 
href="symbols.html#x187-2636702r702">progv</a></tt>, a construct that performs binding
rather than assignment of dynamic variables.
</div>
<div class="defun">
<!--l. 587--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx47-441001"></a><a 
 id="x47-441002r62"></a> <b>makunbound</b>  <i>symbol</i><br />
<i>
[Function]</i><a 
 id="dx47-441003"></a><a 
 id="x47-441004r63"></a> <b>fmakunbound</b>  <i>symbol</i>
</div>
<tt>
                                                                          

                                                                          
<!--l. 591--><p class="indent" >   <a 
href="symbols.html#x187-2636555r555">makunbound</a></tt> causes the dynamic (special) variable named by <i>symbol</i>
to become unbound (have no value). <tt><a 
href="symbols.html#x187-2636389r389">fmakunbound</a></tt> does the analogous
thing for the global function deﬁnition named by <i>symbol</i>. For example:
<div class="lisp"><div class="tabbing">
(setq a 1)
   <br>                                                                                      a <span class="math"> ⇒</span> 1<br>
(makunbound &#x2019;a)<br>                                     a <span class="math"> ⇒</span> causes an error<br>
<br>                                                    (defun foo (x) (+ x 1))<br>
(foo 4) <span class="math"> ⇒</span> 5<br>                                          (fmakunbound &#x2019;foo)<br>
(foo 4) <span class="math"> ⇒</span> causes an error<br>
<!--l. 606--><p class="noindent" ></div>
<!--l. 606--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4420007.1.2" id="x47-4420007.1.2"></a></span>
<!--l. 606--><p class="noindent" ><span class="paragraphHead"><a 
href="#x47-4430007.1.2" id="x47-4430007.1.2"></a></span>
</div>
<!--l. 607--><p class="indent" >   Both functions return <i>symbol</i> as the result value.
<tt>
<!--l. 609--><p class="indent" >   <a 
href="symbols.html#x187-2636389r389">fmakunbound</a></tt> accepts any function-name (a symbol or a list whose <i>car</i>
is <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt>—see section <a 
href="#x47-4030007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). Thus one may write <tt>(fmakunbound &#x2019;(setf
cadr))</tt> to remove any global deﬁnition of a <tt><a 
href="symbols.html#x187-2636778r778">setf</a></tt> expansion function for
<tt><a 
href="symbols.html#x187-2636167r167">cadr</a></tt>.
</div>
                                                                          

                                                                          
<!--l. 616--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse36.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html#tailcontrl.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="contrl.html#clmse35.html" >Up</a><tt>&#x003E;</tt></div><a 
 id="tailclmse35.html"></a>   </div> </div> 
</body></html> 
