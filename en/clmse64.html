<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Precision, Contagion, and Coercion</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 16:10:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 56--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse65.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html#tailnumber.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse64.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html#clmse64.html" >Up</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">12.1   </span> <a 
href="clm.html#QQ2-81-966" id="x81-95700012.1">Precision, Contagion, and
Coercion</a></h3>
<!--l. 59--><p class="noindent" >In general, computations with ﬂoating-point numbers are only approximate. The
<i>precision</i> of a ﬂoating-point number is not necessarily correlated at all with the
<i>accuracy</i> of that number. For instance, 3.142857142857142857 is a more precise
approximation to <span class="math">π</span> than 3.14159, but the latter is more accurate. The
precision refers to the number of bits retained in the representation. When an
operation combines a short ﬂoating-point number with a long one, the result
will be a long ﬂoating-point number. This rule is made to ensure that
as much accuracy as possible is preserved; however, it is by no means a
guarantee. Common Lisp numerical routines do assume, however, that the
accuracy of an argument does not exceed its precision. Therefore when two
small ﬂoating-point numbers are combined, the result will always be a
small ﬂoating-point number. This assumption can be overridden by ﬁrst
explicitly converting a small ﬂoating-point number to a larger representation.
(Common Lisp never converts automatically from a larger size to a smaller
one.)
                                                                          

                                                                          
<!--l. 78--><p class="indent" >   Rational computations cannot overﬂow in the usual sense (though of course
there may not be enough storage to represent one), as integers and ratios may in
principle be of any magnitude. Floating-point computations may get exponent
overﬂow or underﬂow; this is an error.
<div class="newer">
<!--l. 85--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx81-957001"></a>to address certain problems relating to ﬂoating-point
overﬂow and underﬂow, but certain parts of the proposed solution were not
adopted, namely to add the macro <tt>without-floating-underflow-traps</tt> to the
language and to require certain behavior of ﬂoating-point overﬂow and underﬂow.
The committee agreed that this area of the language requires more discussion
before a solution is standardized.
<!--l. 93--><p class="indent" >   For the record, the proposal that was considered and rejected (for the nonce)
introduced a macro <tt>without-floating-underflow-traps</tt> that would execute its
body in such a way that, within its dynamic extent, a ﬂoating-point underﬂow
must not signal an error but instead must produce either a denormalized number
or zero as the result. The rejected proposal also speciﬁed the following treatment
of overﬂow and underﬂow:
      <ul class="itemize1">
      <li class="itemize">A ﬂoating-point computation that overﬂows should signal an error of
      type <tt><a 
href="symbols.html#x187-2636385r385">floating-point-overflow</a></tt>.
      </li>
      <li class="itemize">Unless
      the dynamic extent of a use of <tt>without-floating-underflow-traps</tt>,
      a ﬂoating-point computation that underﬂows should signal an error
      of type <tt><a 
href="symbols.html#x187-2636386r386">floating-point-underflow</a></tt>. A result that can be represented
      only  in  denormalized  form  must  be  considered  an  underﬂow  in
      implementations that support denormalized ﬂoating-point numbers.</li></ul>
<!--l. 111--><p class="noindent" >These points refer to conditions <tt><a 
href="symbols.html#x187-2636385r385">floating-point-overflow</a></tt> and
<tt><a 
href="symbols.html#x187-2636386r386">floating-point-underflow</a></tt> that were approved by X3J13 and are described in
section <a 
href="clmse151.html#x184-263100028.5">28.5<!--tex4ht:ref: PREDEFINED-CONDITIONS-SECTION --></a>.
</div>
<!--l. 117--><p class="indent" >   When rational and ﬂoating-point numbers are compared or combined by a
numerical function, the rule of <i>ﬂoating-point contagion</i> is followed: when a
rational meets a ﬂoating-point number, the rational is ﬁrst converted to a
ﬂoating-point number of the same format. For functions such as <tt><a 
href="symbols.html#x187-2636051r51">+</a></tt> that take
more than two arguments, it may be that part of the operation is carried
                                                                          

                                                                          
out exactly using rationals and then the rest is done using ﬂoating-point
arithmetic.
<div class="new">
<!--l. 127--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx81-957002"></a>to apply the rule of ﬂoating-point contagion
stated above to the case of <i>combining</i> rational and ﬂoating-point numbers. For
<i>comparing</i>, the following rule is to be used instead: When a rational number and a
ﬂoating-point number are to be compared by a numerical function, in eﬀect the
ﬂoating-point number is ﬁrst converted to a rational number as if by the function
<tt>rational</tt>, and then an exact comparison of two rational numbers is performed. It
is of course valid to use a more eﬃcient implementation than actually calling the
function <tt>rational</tt>, as long as the result of the comparison is the same. In
the case of complex numbers, the real and imaginary parts are handled
separately.________________________________________________________________<div class="rationale">
<!--l. 142--><p class="noindent" ><b>Rationale:</b> In general, accuracy cannot be preserved in combining operations, but it can
be preserved in comparisons, and preserving it makes that part of Common Lisp
algebraically a bit more tractable. In particular, this change prevents the breakdown of
transitivity. Let <tt>a</tt> be the result of <tt>(/ 10.0 single-float-epsilon)</tt>, and let <tt>j</tt> be the
result of <tt>(floor a)</tt>. (Note that <tt>(= a (+ a 1.0))</tt> is true, by the deﬁnition of
<tt><a 
href="symbols.html#x187-2636800r800">single-float-epsilon</a></tt>.) Under the old rules, all of <tt>(&#x003C;= a j)</tt>, <tt>(&#x003C; j (+ j 1))</tt>, and
<tt>(&#x003C;= (+ j 1) a)</tt> would be true; transitivity would then imply that <tt>(&#x003C; a a)</tt> ought to be
true, but of course it is false, and therefore transitivity fails. Under the new rule,
however, <tt>(&#x003C;= (+ j 1) a)</tt> is false.
</div>___________________________________________________________________________________________________________
</div>
<!--l. 159--><p class="indent" >     For functions that are mathematically associative (and possibly commutative),
a Common Lisp implementation may process the arguments in any manner
consistent with associative (and possibly commutative) rearrangement. This does
not aﬀect the order in which the argument forms are evaluated, of course; that
order is always left to right, as in all Common Lisp function calls. What is left
loose is the order in which the argument values are processed. The point of all this
is that implementations may diﬀer in which automatic coercions are applied
because of diﬀering orders of argument processing. As an example, consider this
expression: <div class="lisp"><div class="tabbing">
(+ 1/3 2/3 1.0D0 1.0 1.0E-15)
     <br>
                                                                          

                                                                          
<!--l. 172--><p class="noindent" ></div>
<!--l. 172--><p class="noindent" ><span class="paragraphHead"><a 
href="#x81-95800012.1" id="x81-95800012.1"></a></span>
<!--l. 172--><p class="noindent" ><span class="paragraphHead"><a 
href="#x81-95900012.1" id="x81-95900012.1"></a></span>
</div>
<!--l. 173--><p class="indent" >   One implementation might process the arguments from left to right, ﬁrst
adding <tt>1/3</tt> and <tt>2/3</tt> to get <tt>1</tt>, then converting that to a double-precision
ﬂoating-point number for combination with <tt>1.0D0</tt>, then successively converting
and adding <tt>1.0</tt> and <tt>1.0E-15</tt>. Another implementation might process the
arguments from right to left, ﬁrst performing a single-precision ﬂoating-point
addition of <tt>1.0</tt> and <tt>1.0E-15</tt> (and probably losing some accuracy in the process!),
then converting the sum to double precision and adding <tt>1.0D0</tt>, then converting
<tt>2/3</tt> to double-precision ﬂoating-point and adding it, and then converting <tt>1/3</tt> and
adding that. A third implementation might ﬁrst scan all the arguments, process
all the rationals ﬁrst to keep that part of the computation exact, then ﬁnd an
argument of the largest ﬂoating-point format among all the arguments and add
that, and then add in all other arguments, converting each in turn (all in a
perhaps misguided attempt to make the computation as accurate as possible). In
any case, all three strategies are legitimate. The user can of course control
the order of processing explicitly by writing several calls; for example:
<div class="lisp"><div class="tabbing">
(+ (+ 1/3 2/3) (+ 1.0D0 1.0E-15) 1.0)
   <br>
<!--l. 193--><p class="noindent" ></div>
<!--l. 193--><p class="noindent" ><span class="paragraphHead"><a 
href="#x81-96000012.1" id="x81-96000012.1"></a></span>
<!--l. 193--><p class="noindent" ><span class="paragraphHead"><a 
href="#x81-96100012.1" id="x81-96100012.1"></a></span>
</div>
<!--l. 194--><p class="indent" >   The user can also control all coercions simply by writing calls to coercion
functions explicitly.
                                                                          

                                                                          
<!--l. 197--><p class="indent" >   In general, then, the type of the result of a numerical function is a
ﬂoating-point number of the largest format among all the ﬂoating-point
arguments to the function; but if the arguments are all rational, then the
result is rational (except for functions that can produce mathematically
irrational results, in which case a single-format ﬂoating-point number may
result).
<!--l. 204--><p class="indent" >   There is a separate rule of complex contagion. As a rule, complex numbers
never result from a numerical function unless one or more of the arguments is
complex. (Exceptions to this rule occur among the irrational and transcendental
functions, speciﬁcally <tt><a 
href="symbols.html#x187-2636350r350">expt</a></tt>, <tt><a 
href="symbols.html#x187-2636502r502">log</a></tt>, <tt><a 
href="symbols.html#x187-2636817r817">sqrt</a></tt>, <tt><a 
href="symbols.html#x187-2636105r105">asin</a></tt>, <tt><a 
href="symbols.html#x187-2636069r69">acos</a></tt>, <tt><a 
href="symbols.html#x187-2636070r70">acosh</a></tt>, and <tt><a 
href="symbols.html#x187-2636112r112">atanh</a></tt>; see
section <a 
href="clmse68.html#x85-99800012.5">12.5<!--tex4ht:ref: TRANSCENDENTAL-SECTION --></a>.) When a non-complex number meets a complex number, the
non-complex number is in eﬀect ﬁrst converted to a complex number by providing
an imaginary part of zero.
<!--l. 216--><p class="indent" >   If any computation produces a result that is a ratio of two integers such that
the denominator evenly divides the numerator, then the result is immediately
converted to the equivalent integer. This is called the rule of <i>rational
canonicalization</i>.
<!--l. 221--><p class="indent" >   If the result of any computation would be a complex rational with a zero
imaginary part, the result is immediately converted to a non-complex
rational number by taking the real part. This is called the rule of <i>complex
canonicalization</i>. Note that this rule does <i>not</i> apply to complex numbers whose
components are ﬂoating-point numbers. Whereas <tt>#C(5 0)</tt> and <tt>5</tt> are not distinct
values in Common Lisp (they are always <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt>), <tt>#C(5.0 0.0)</tt> and <tt>5.0</tt> are always
distinct values in Common Lisp (they are never <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt>, although they are
<tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt>).
                                                                          

                                                                          
<!--l. 231--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse65.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html#tailnumber.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse64.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html#clmse64.html" >Up</a><tt>&#x003E;</tt></div><a 
 id="tailclmse64.html"></a>    </div> </div> 
</body></html> 
