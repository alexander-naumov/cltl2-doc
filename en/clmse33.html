<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Equality Predicates</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 16:10:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 513--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse34.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse33.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="preds.html#clmse33.html" >Up</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
href="clm.html#QQ2-44-388" id="x44-3800006.3">Equality Predicates</a></h3>
<!--l. 515--><p class="noindent" >Common Lisp provides a spectrum of predicates for testing for equality of two
objects: <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt> (the most speciﬁc), <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt>, <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt>, and <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> (the most general). <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>
and <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> have the meanings traditional in Lisp. <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> was added because it is
frequently needed, and <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> was added primarily in order to have a version of
<tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> that would ignore type diﬀerences when comparing numbers and case
diﬀerences when comparing characters. If two objects satisfy any one of
these equality predicates, then they also satisfy all those that are more
general.
<div class="defun">
<!--l. 525--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx44-380001"></a><a 
 id="x44-380002r44"></a> <b>eq</b>  <i>x</i> <i>y</i>
</div>
<tt>
<!--l. 528--><p class="indent" >   (eq <i>x</i> <i>y</i>)</tt> is true if and only if <i>x</i> and <i>y</i> are the same identical object.
(Implementationally, <i>x</i> and <i>y</i> are usually <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt> if and only if they address the same
identical memory location.)
<!--l. 533--><p class="indent" >   It should be noted that things that print the same are not necessarily <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt> to
each other. Symbols with the same print name usually are <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt> to each other
because of the use of the <tt><a 
href="symbols.html#x187-2636451r451">intern</a></tt> function. However, numbers with the same value
need not be <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>, and two similar lists are usually not <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>. For example:
<div class="lisp"><div class="tabbing">
(eq &#x2019;a &#x2019;b) is false.
   <br>                                                                         (eq &#x2019;a &#x2019;a) is true.<br>
(eq 3 3) might be true or false, depending on the implementation.<br>
(eq 3 3.0) is false.<br>(eq 3.0 3.0) might be true or false, depending on the implementation.<br>
(eq #c(3 -4) #c(3 -4))<br>  might be true or false, depending on the implementation.<br>
(eq #c(3 -4.0) #c(3 -4)) is false.<br>       (eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.<br>
(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is false.<br>(eq &#x2019;(a . b) &#x2019;(a . b)) might be true or false.<br>
(progn (setq x (cons &#x2019;a &#x2019;b)) (eq x x)) is true.<br>(progn (setq x &#x2019;(a . b)) (eq x x)) is true.<br>
                                                                          

                                                                          
(eq #\A #\A) might be true or false, depending on the implementation.<br>
(eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) might be true or false.<br>(eq &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is false.<br>
(eq &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is false.<br>
<!--l. 557--><p class="noindent" ></div>
<!--l. 557--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3810006.3" id="x44-3810006.3"></a></span>
<!--l. 557--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3820006.3" id="x44-3820006.3"></a></span>
</div>
<!--l. 559--><p class="indent" >   In Common Lisp, unlike some other Lisp dialects, the implementation
is permitted to make “copies” of characters and numbers at any time.
(This permission is granted because it allows tremendous performance
improvements in many common situations.) The net eﬀect is that Common Lisp
makes no guarantee that <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt> will be true even when both its arguments are
“the same thing” if that thing is a character or number. For example:
<div class="lisp"><div class="tabbing">
(let ((x 5)) (eq x x)) might be true or false.
   <br>
<!--l. 569--><p class="noindent" ></div>
<!--l. 569--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3830006.3" id="x44-3830006.3"></a></span>
<!--l. 569--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3840006.3" id="x44-3840006.3"></a></span>
</div>
<!--l. 571--><p class="indent" >   The predicate <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> is the same as <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>, except that if the arguments are
characters or numbers of the same type then their values are compared. Thus <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt>
tells whether two objects are <i>conceptually</i> the same, whereas <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt> tells whether two
objects are <i>implementationally</i> identical. It is for this reason that <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt>, not <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>, is
the default comparison predicate for the sequence functions deﬁned in
chapter <a 
href="kseque.html#x96-119200014">14<!--tex4ht:ref: KSEQUE --></a>._______________________________________________________________<div class="implementation">
                                                                          

                                                                          
<!--l. 580--><p class="noindent" ><b>Implementation note:</b> <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt> simply compares the two given pointers, so any
kind of object that is represented in an “immediate” fashion will indeed have
like-valued instances satisfy <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>. In some implementations, for example, ﬁxnums and
characters happen to “work.” However, no program should depend on this, as other
implementations of Common Lisp might not use an immediate representation for these
data types.
</div>
__________________________________________________________________________
<div class="obsolete">
<!--l. 592--><p class="indent" >     An additional problem with <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt> is that the implementation is permitted to
“collapse” constants (or portions thereof) appearing in code to be compiled if they
are <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt>. An object is considered to be a constant in code to be compiled if it is
a self-evaluating form or is contained in a <tt><a 
href="symbols.html#x187-2636707r707">quote</a></tt> form. This is why <tt>(eq &#x0022;Foo&#x0022;
&#x0022;Foo&#x0022;)</tt> might be true or false; in interpreted code it would normally be false,
because reading in the form <tt>(eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;)</tt> would construct distinct strings
for the two arguments to <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>, but the compiler might choose to use the same
identical string or two distinct copies as the two arguments in the call to <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>.
Similarly, <tt>(eq &#x2019;(a . b) &#x2019;(a . b))</tt> might be true or false, depending on whether
the constant conses appearing in the <tt><a 
href="symbols.html#x187-2636707r707">quote</a></tt> forms were collapsed by the compiler.
However, <tt>(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b))</tt> is always false, because every
distinct call to the <tt>cons</tt> function necessarily produces a new and distinct
cons.
</div>
<div class="newer">
<!--l. 610--><p class="indent" >     X3J13 voted in March 1989 <a 
 id="dx44-384001"></a>to clarify that <tt><a 
href="symbols.html#x187-2636343r343">eval</a></tt> and <tt><a 
href="symbols.html#x187-2636231r231">compile</a></tt> are not
permitted either to copy or to coalesce (“collapse”) constants (see <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>) appearing in
the code they process; the resulting program behavior must refer to objects
that are <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> to the corresponding objects in the source code. Only the
<tt><a 
href="symbols.html#x187-2636232r232">compile-file</a></tt>/<tt><a 
href="symbols.html#x187-2636498r498">load</a></tt> process is permitted to copy or coalesce constants (see
section <a 
href="clmse122.html#x151-198200024.2">24.2<!--tex4ht:ref: COMPILER-SECTION --></a>).
</div>
</div>
<div class="defun">
<!--l. 621--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx44-384002"></a><a 
 id="x44-384003r45"></a> <b>eql</b>  <i>x</i> <i>y</i>
</div>
<!--l. 624--><p class="indent" >    The <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> predicate is true if its arguments are <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>, or if they are numbers of the
same type with the same value, or if they are character objects that represent the
                                                                          

                                                                          
same character. For example: <div class="lisp"><div class="tabbing">
(eql &#x2019;a &#x2019;b) is false.
   <br>                         (eql &#x2019;a &#x2019;a) is true.<br>                         (eql 3 3) is true.<br>
(eql 3 3.0) is false.<br>                                     (eql 3.0 3.0) is true.<br>
(eql #c(3 -4) #c(3 -4)) is true.<br>            (eql #c(3 -4.0) #c(3 -4)) is false.<br>
(eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.<br>  (eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is false.<br>
(eql &#x2019;(a . b) &#x2019;(a . b)) might be true or false.<br>
(progn (setq x (cons &#x2019;a &#x2019;b)) (eql x x)) is true.<br>
(progn (setq x &#x2019;(a . b)) (eql x x)) is true.<br>
(eql #\A #\A) is true.<br>           (eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) might be true or false.<br>
(eql &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is false.<br>            (eql &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is false.<br>
<!--l. 646--><p class="noindent" ></div>
<!--l. 646--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3850006.3" id="x44-3850006.3"></a></span>
<!--l. 646--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3860006.3" id="x44-3860006.3"></a></span>
</div>
<!--l. 648--><p class="indent" >   Normally <tt>(eql 1.0s0 1.0d0)</tt> would be false, under the assumption that
<tt>1.0s0</tt> and <tt>1.0d0</tt> are of distinct data types. However, implementations
that do not provide four distinct ﬂoating-point formats are permitted to
“collapse” the four formats into some smaller number of them; in such an
implementation <tt>(eql 1.0s0 1.0d0)</tt> might be true. The predicate <tt><a 
href="symbols.html#x187-2636061r61">=</a></tt> will
compare the values of two numbers even if the numbers are of diﬀerent
types.
<!--l. 656--><p class="indent" >   If an implementation supports positive and negative zeros as distinct values
(as in the IEEE proposed standard ﬂoating-point format), then <tt>(eql 0.0 -0.0)</tt>
will be false. Otherwise, when the syntax <tt>-0.0</tt> is read it will be interpreted as the
value <tt>0.0</tt>, and so <tt>(eql 0.0 -0.0)</tt> will be true. The predicate <tt><a 
href="symbols.html#x187-2636061r61">=</a></tt> diﬀers from <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt>
in that <tt>(= 0.0 -0.0)</tt> will always be true, because <tt><a 
href="symbols.html#x187-2636061r61">=</a></tt> compares the mathematical
values of its operands, whereas <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> compares the representational values, so to
speak.
<!--l. 665--><p class="indent" >   Two complex numbers are considered to be <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> if their real parts are <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> and
their imaginary parts are <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt>. For example, <tt>(eql #C(4 5) #C(4 5))</tt> is true and
                                                                          

                                                                          
<tt>(eql #C(4 5) #C(4.0 5.0))</tt> is false. Note that while <tt>(eql #C(5.0 0.0) 5.0)</tt>
is false, <tt>(eql #C(5 0) 5)</tt> is true. In the case of <tt>(eql #C(5.0 0.0) 5.0)</tt> the two
arguments are of diﬀerent types and so cannot satisfy <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt>; that&#x2019;s all there is to it.
In the case of <tt>(eql #C(5 0) 5)</tt>, however, <tt>#C(5 0)</tt> is not a complex number but
is always automatically reduced by the rule of complex canonicalization
to the integer <tt>5</tt>, just as the apparent ratio <tt>20/4</tt> is always simpliﬁed to
<tt>5</tt>.
<!--l. 680--><p class="indent" >   The case of <tt>(eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;)</tt> is discussed above in the description of <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>.
While <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> compares the values of numbers and characters, it does not compare
the contents of strings. To compare the characters of two strings, one should use
<tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt>, <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt>, <tt><a 
href="symbols.html#x187-2636844r844">string=</a></tt>, or <tt><a 
href="symbols.html#x187-2636831r831">string-equal</a></tt>.
</div>
<div class="defun">
<!--l. 687--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx44-386001"></a><a 
 id="x44-386002r46"></a> <b>equal</b>  <i>x</i> <i>y</i>
</div>
<!--l. 690--><p class="indent" >   The <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> predicate is true if its arguments are structurally similar
(isomorphic) objects. A rough rule of thumb is that two objects are <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> if and
only if their printed representations are the same.
<!--l. 694--><p class="indent" >   Numbers and characters are compared as for <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt>. Symbols are compared as for
<tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>. This method of comparing symbols can violate the rule of thumb for <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt>
and printed representations, but only in the infrequently occurring case of two
distinct symbols with the same print name.
<!--l. 701--><p class="indent" >   Certain objects that have components are <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> if they are of the same type
and corresponding components are <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt>. This test is implemented in a recursive
manner and may fail to terminate for circular structures.
<!--l. 706--><p class="indent" >   For conses, <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> is deﬁned recursively as the two <i>car</i>&#x2019;s being <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> and the
two <i>cdr</i>&#x2019;s being <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt>.
<!--l. 710--><p class="indent" >   Two arrays are <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> only if they are <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>, with one exception: strings
and bit-vectors are compared element-by-element. If either argument has
a ﬁll pointer, the ﬁll pointer limits the number of elements examined
by <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt>. Uppercase and lowercase letters in strings are considered by
<tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> to be distinct. (In contrast, <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> ignores case distinctions in
strings.)
<!--l. 719--><p class="indent" >   Two pathname objects are <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> if and only if all the corresponding
components (host, device, and so on) are equivalent. (Whether or not uppercase
and lowercase letters are considered equivalent in strings appearing in components
                                                                          

                                                                          
depends on the ﬁle name conventions of the ﬁle system.) Pathnames that are
<tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> should be functionally equivalent.
<tt>
<!--l. 727--><p class="indent" >   <a 
href="symbols.html#x187-2636339r339">equal</a></tt> never recursively descends any structure or data type other than the
ones explicitly described above: conses, bit-vectors, strings, and pathnames.
Numbers and characters are compared as if by <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt>, and all other data objects are
compared as if by <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>.
<div class="lisp">
<!--l. 733--><p class="indent" >   <div class="tabbing">
(equal &#x2019;a &#x2019;b) is false.
   <br>                                                                     (equal &#x2019;a &#x2019;a) is true.<br>
(equal 3 3) is true.<br>                                    (equal 3 3.0) is false.<br>
(equal 3.0 3.0) is true.<br>                    (equal #c(3 -4) #c(3 -4)) is true.<br>
(equal #c(3 -4.0) #c(3 -4)) is false.<br> (equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.<br>
(equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is true.<br>      (equal &#x2019;(a . b) &#x2019;(a . b)) is true.<br>
(progn (setq x (cons &#x2019;a &#x2019;b)) (equal x x)) is true.<br>
(progn (setq x &#x2019;(a . b)) (equal x x)) is true.<br>       (equal #\A #\A) is true.<br>
(equal &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) is true.<br>        (equal &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is true.<br>
(equal &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is false.<br>
<!--l. 750--><p class="noindent" ></div>
<!--l. 750--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3870006.3" id="x44-3870006.3"></a></span>
<!--l. 750--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3880006.3" id="x44-3880006.3"></a></span>
</div>
<!--l. 751--><p class="indent" >   To compare a tree of conses using <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> (or any other desired predicate) on the
leaves, use <tt><a 
href="symbols.html#x187-2636886r886">tree-equal</a></tt>.
</div>
<div class="defun">
<!--l. 756--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx44-388001"></a><a 
 id="x44-388002r47"></a> <b>equalp</b>  <i>x</i> <i>y</i>
</div>
<!--l. 759--><p class="indent" >   Two objects are <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> if they are <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt>; if they are characters and satisfy
                                                                          

                                                                          
<tt><a 
href="symbols.html#x187-2636199r199">char-equal</a></tt>, which ignores alphabetic case and certain other attributes
of characters; if they are numbers and have the same numerical value,
even if they are of diﬀerent types; or if they have components that are all
<tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt>.
<!--l. 766--><p class="indent" >   Objects that have components are <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> if they are of the same type and
corresponding components are <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt>. This test is implemented in a recursive
manner and may fail to terminate for circular structures. For conses, <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> is
deﬁned recursively as the two <i>car</i>&#x2019;s being <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> and the two <i>cdr</i>&#x2019;s being
<tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt>.
<!--l. 774--><p class="indent" >   Two arrays are <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> if and only if they have the same number of
dimensions, the dimensions match, and the corresponding components are
<tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt>. The specializations need not match; for example, a string and a general
array that happens to contain the same characters will be <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> (though
deﬁnitely not <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt>). If either argument has a ﬁll pointer, the ﬁll pointer limits
the number of elements examined by <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt>. Because <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> performs
element-by-element comparisons of strings and ignores the alphabetic case of
characters, case distinctions are therefore also ignored when <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> compares
strings.
<!--l. 787--><p class="indent" >   Two symbols can be <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> only if they are <tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>, that is, the same identical
object.
<div class="new">
<!--l. 791--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx44-388003"></a>to specify that <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> compares components of
hash tables (see below), and to clarify that otherwise <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> never recursively
descends any structure or data type other than the ones explicitly described
above: conses, arrays (including bit-vectors and strings), and pathnames. Numbers
are compared for numerical equality (see <tt><a 
href="symbols.html#x187-2636061r61">=</a></tt>), characters are compared
as if by <tt><a 
href="symbols.html#x187-2636199r199">char-equal</a></tt>, and all other data objects are compared as if by
<tt><a 
href="symbols.html#x187-2636337r337">eq</a></tt>.
<!--l. 802--><p class="indent" >   Two hash tables are considered the same by <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> if and only if they satisfy
a four-part test:
      <ul class="itemize1">
      <li class="itemize">They must be of the same kind; that is, equivalent <tt>:test</tt> arguments
      were given to <tt><a 
href="symbols.html#x187-2636539r539">make-hash-table</a></tt> when the two hash tables were created.
      </li>
      <li class="itemize">They must have the same number of entries (see <tt><a 
href="symbols.html#x187-2636427r427">hash-table-count</a></tt>).
      </li>
                                                                          

                                                                          
      <li class="itemize">For  every  entry  (<i>key1</i>,  <i>value1</i>)  in  one  hash  table  there  must  be  a
      corresponding entry (<i>key2</i>, <i>value2</i>) in the other, such that <i>key1</i> and
      <i>key2</i> are considered to be the same by the <tt>:test</tt> function associated
      with the hash tables.
      </li>
      <li class="itemize">For every entry (<i>key1</i>, <i>value1</i>) in one hash table and its corresponding
      entry (<i>key2</i>, <i>value2</i>) in the other, such that <i>key1</i> and <i>key2</i> are the
      same, <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> must be true of <i>value1</i> and <i>value2</i>.</li></ul>
<!--l. 821--><p class="noindent" >The four parts of this test are carried out in the order shown, and if some part of
the test fails, <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> returns <tt><a 
href="symbols.html#x187-2636609r609">nil</a></tt> and the other parts of the test are not
attempted.
<!--l. 825--><p class="indent" >   If <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> must compare two structures and the <tt><a 
href="symbols.html#x187-2636289r289">defstruct</a></tt> deﬁnition for
one used the <tt>:type</tt> option and the other did not, then <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> returns
<tt><a 
href="symbols.html#x187-2636609r609">nil</a></tt>.
<!--l. 829--><p class="indent" >   If <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> must compare two structures and neither <tt><a 
href="symbols.html#x187-2636289r289">defstruct</a></tt> deﬁnition used
the <tt>:type</tt> option, then <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> returns <tt><a 
href="symbols.html#x187-2636871r871">t</a></tt> if and only if the structures have the
same type (that is, the same <tt><a 
href="symbols.html#x187-2636289r289">defstruct</a></tt> name) and the values of all corresponding
slots (slots having the same name) are <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt>.
<!--l. 835--><p class="indent" >   As part of the X3J13 discussion of this issue the following observations were
made. Object equality is not a concept for which there is a uniquely determined
correct algorithm. The appropriateness of an equality predicate can be judged
only in the context of the needs of some particular program. Although
these functions take any type of argument and their names sound very
generic, <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> and <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> are not appropriate for every application. Any
decision to use or not use them should be determined by what they are
documented to do rather than by any abstract characterization of their function.
If neither <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> nor <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> is found to be appropriate in a particular
situation, programmers are encouraged to create another operator that is
appropriate rather than blame <tt><a 
href="symbols.html#x187-2636339r339">equal</a></tt> or <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> for “doing the wrong
thing.”
</div>
<div class="new">
<!--l. 852--><p class="indent" >   Note that one consequence of the vote to change the rules of ﬂoating-point
contagion <a 
 id="dx44-388004"></a>(described in section <a 
href="clmse64.html#x81-95700012.1">12.1<!--tex4ht:ref: PRECISION-CONTAGION-COERCION-SECTION --></a>) is to make <tt><a 
href="symbols.html#x187-2636340r340">equalp</a></tt> a true equivalence
relation on numbers.
</div>
                                                                          

                                                                          
<div class="lisp">
<!--l. 861--><p class="indent" >   <div class="tabbing">
(equalp &#x2019;a &#x2019;b) is false.
   <br>                     (equalp &#x2019;a &#x2019;a) is true.<br>                     (equalp 3 3) is true.<br>
(equalp 3 3.0) is true.<br>                              (equalp 3.0 3.0) is true.<br>
(equalp #c(3 -4) #c(3 -4)) is true.<br>     (equalp #c(3 -4.0) #c(3 -4)) is true.<br>
(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.<br>
(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is true.<br>    (equalp &#x2019;(a . b) &#x2019;(a . b)) is true.<br>
(progn (setq x (cons &#x2019;a &#x2019;b)) (equalp x x)) is true.<br>
(progn (setq x &#x2019;(a . b)) (equalp x x)) is true.<br>    (equalp #\A #\A) is true.<br>
(equalp &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) is true.<br>      (equalp &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is true.<br>
(equalp &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is true.<br>
<!--l. 878--><p class="noindent" ></div>
<!--l. 878--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3890006.3" id="x44-3890006.3"></a></span>
<!--l. 878--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-3900006.3" id="x44-3900006.3"></a></span>
</div>
</div>
                                                                          

                                                                          
<!--l. 882--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse34.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="preds.html#clmse33.html" >Up</a><tt>&#x003E;</tt></div><a 
 id="tailclmse33.html"></a>   </div> </div> 
</body></html> 
