<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Declaration Speciﬁers</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:21:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 384--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse53.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse51.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse51.html#tailclmse51.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse52.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="declar.html#clmse52.html" >Up</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">9.2   </span> <a 
href="clm.html#QQ2-66-846" id="x66-8370009.2">Declaration Speciﬁers</a></h3>
<!--l. 387--><p class="noindent" >Here is a list of valid declaration speciﬁers for use in <tt><a 
href="symbols.html#x185-2637271r271">declare</a></tt>. A construct is
said to be “aﬀected” by a declaration if it occurs within the scope of a
declaration.
<div class="flushdesc">
      <ul><li><b>
<tt>special</tt> </b></li><tt>(special <i>var1</i> <i>var2</i> ...)</tt> speciﬁes that all of the variables named are
      to be considered <i>special</i>. This speciﬁer aﬀects variable bindings but also
      pervasively aﬀects references. All variable bindings aﬀected are made to be
      dynamic bindings, and aﬀected variable references refer to the current
      dynamic binding rather than to the current local binding. For example:
      <div class="lisp"><div class="tabbing">
      (defun hack (thing *mod*)       ;The binding of the parameter
      <br>              (declare (special *mod*))     ; <tt>*mod*</tt> is visible to <tt>hack1</tt>,<br>
             (hack1 (car thing)))          ; but not that of <tt>thing</tt><br>
           <br>                                      (defun hack1 (arg)<br>
             (declare (special *mod*))     ;Declare references to <tt>*mod*</tt><br>
                                           ; within <tt>hack1</tt> to be special<br>
             (if (atom arg) *mod*<br>            (cons (hack1 (car arg)) (hack1 (cdr arg)))))<br>
      <!--l. 411--><p class="noindent" ></div>
      <!--l. 411--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8380009.2" id="x66-8380009.2"></a></span>
                                                                          

                                                                          
      <!--l. 411--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8390009.2" id="x66-8390009.2"></a></span>
</div>
      <!--l. 412--><p class="noindent" >Note that it is conventional, though not required, to give special variables
      names that begin and end with an asterisk.
      <!--l. 415--><p class="noindent" >A <tt>special</tt> declaration does <i>not</i> aﬀect bindings pervasively. Inner
      bindings of a variable implicitly shadow a <tt>special</tt> declaration and
      must be explicitly re-declared to be special. (However, a <tt>special</tt>
      proclamation <i>does</i> pervasively aﬀect bindings; this exception is made for
      reasons of convenience and compatibility with MacLisp.) For example:
      <div class="lisp"><div class="tabbing">
      (proclaim &#x2019;(special x))     ;<tt>x</tt> is always special
      <br>                                <br>                                (defun example (x y)<br>
             (declare (special y))<br>                   (let ((y 3) (x (* x 2)))<br>
               (print (+ y (locally (declare (special y)) y)))<br>
               (let ((y 4)) (declare (special y)) (foo x))))<br>
      <!--l. 431--><p class="noindent" ></div>
      <!--l. 431--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8400009.2" id="x66-8400009.2"></a></span>
      <!--l. 431--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8410009.2" id="x66-8410009.2"></a></span>
</div>
      <!--l. 432--><p class="noindent" >In the contorted code above, the outermost and innermost bindings of <tt>y</tt> are
      special and therefore dynamically scoped, but the middle binding is lexically
      scoped. The two arguments to <tt><a 
href="symbols.html#x185-2637051r51">+</a></tt> are diﬀerent, one being the value, which is
      <tt>3</tt>, of the lexically bound variable <tt>y</tt>, and the other being the value of the
      special variable named <tt>y</tt> (a binding of which happens, coincidentally, to
      lexically surround it at an outer level). All the bindings of <tt>x</tt> and references
      to <tt>x</tt> are special, however, because of the proclamation that <tt>x</tt> is always
      <tt>special</tt>.
                                                                          

                                                                          
      <!--l. 442--><p class="noindent" >As a matter of style, use of <tt>special</tt> proclamations should be avoided. The
      <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt> and <tt><a 
href="symbols.html#x185-2637287r287">defparameter</a></tt> macros are the conventional means for
      proclaiming special variables in a program.
      <li><b>
<tt>type</tt> </b></li><tt>(type <i>type</i> <i>var1</i> <i>var2</i> ...)</tt> aﬀects only variable bindings and speciﬁes
      that the variables mentioned will take on values only of the speciﬁed
      type. In particular, values assigned to the variables by <tt><a 
href="symbols.html#x185-2637779r779">setq</a></tt>, as
      well as the initial values of the variables, must be of the speciﬁed
      type.
<div class="new">
      <!--l. 456--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx66-841001"></a>to alter the interpretation of type declarations.
      They are not to be construed to aﬀect “only variable bindings.” The
      new rule for a declaration of a variable to have a speciﬁed type is
      threefold:
           <ul class="itemize1">
           <li class="itemize">It is an error if, during the execution of any reference to that
           variable  within  the  scope  of  the  declaration,  the  value  of  the
           variable is not of the declared type.
           </li>
           <li class="itemize">It is an error if, during the execution of a <tt><a 
href="symbols.html#x185-2637779r779">setq</a></tt> of that variable
           within the scope of the declaration, the new value for the variable
           is not of the declared type.
           </li>
           <li class="itemize">It is an error if, at any moment that execution enters the scope
           of the declaration, the value of the variable is not of the declared
           type.</li></ul>
      <!--l. 473--><p class="noindent" >One may think of a type declaration <tt>(declare (type face bodoni))</tt> as
      implicitly changing every reference to <tt>bodoni</tt> within the scope of the
      declaration to <tt>(the face bodoni)</tt>; changing every expression <i>exp</i> assigned
      to <tt>bodoni</tt> within the scope of the declaration to <tt>(the face <i>exp</i>)</tt>; and
      implicitly executing <tt>(the face bodoni)</tt> every time execution enters the
      scope of the declaration.
      <!--l. 480--><p class="noindent" >These new rules make type declarations much more useful. Under ﬁrst
      edition rules, a type declaration was useless if not associated with a variable
      binding; declarations such as in <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
      (locally
      <br>                                                      (declare (type (byte 8) x y))<br>
             (+ x y))<br>
      <!--l. 487--><p class="noindent" ></div>
      <!--l. 487--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8420009.2" id="x66-8420009.2"></a></span>
      <!--l. 487--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8430009.2" id="x66-8430009.2"></a></span>
</div>
      <!--l. 488--><p class="noindent" >at best had no eﬀect and at worst were erroneous, depending on
      one&#x2019;s interpretation of the ﬁrst edition. Under the interpretation
      approved by X3J13, such declarations have “the obvious natural
      interpretation.”
      <!--l. 492--><p class="noindent" >X3J13 noted that if nested type declarations refer to the same variable, then
      all of them have eﬀect; the value of the variable must be a member of the
      intersection of the declared types.
      <!--l. 496--><p class="noindent" >Nested type declarations could occur as a result of either macro expansion
      or carefully crafted code. There are three cases. First, the inner type might
      be a subtype of the outer one: <div class="lisp"><div class="tabbing">
      (defun compare (apples oranges)
      <br>                                       (declare (type number apples oranges))<br>
             (cond ((typep apples &#x2019;ﬁxnum)<br>               ;; The programmer happens to know that, thanks to<br>
                    ;; constraints imposed by the caller, if APPLES<br>
                    ;; is a ﬁxnum, then ORANGES will be also, and<br>
                    ;; therefore wishes to avoid the unnecessary cost<br>
                    ;; of checking ORANGES.  Nevertheless the compiler<br>
                    ;; should be informed to allow it to optimize code.<br>
                                                                          

                                                                          
                    (locally (declare (type ﬁxnum apples oranges)))<br>
                             ;; Maybe the compiler could have ﬁgured<br>
                             ;; out by ﬂow analysis that APPLES must<br>
                             ;; be a ﬁxnum here, but it doesn&#x2019;t hurt<br>
                             ;; to say it explicitly.<br>
                      (&#x003C; apples oranges)))<br>              ((or (complex apples)<br>
                        (complex oranges))<br>
                    (error &#x0022;Not yet implemented.  Sorry.&#x0022;))<br>
                   ...))<br>
      <!--l. 519--><p class="noindent" ></div>
      <!--l. 519--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8440009.2" id="x66-8440009.2"></a></span>
      <!--l. 519--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8450009.2" id="x66-8450009.2"></a></span>
</div>
      <!--l. 520--><p class="noindent" >This is the case most likely to arise in code written completely by
      hand.
      <!--l. 522--><p class="noindent" >Second, the outer type might be a subtype of the inner one. In this case the
      inner declaration has no additional practical eﬀect, but it is harmless. This
      is likely to occur if code declares a variable to be of a very speciﬁc type and
      then passes it to a macro that then declares it to be of a less speciﬁc
      type.
      <!--l. 529--><p class="noindent" >Third, the inner and outer declarations might be for types that overlap,
      neither being a subtype of the other. This is likely to occur only as a result
      of macro expansion. For example, user code might declare a variable to be of
      type <tt>integer</tt>, and a macro might later declare it to be of type <tt>(or
      fixnum package)</tt>; in this case a compiler could intersect the two
      types to determine that in this instance the variable may hold only
      ﬁxnums.
      <!--l. 537--><p class="noindent" >The reader should note that the following code fragment is, perhaps
      astonishingly, <i>not in error</i> under the interpretation approved by X3J13:
      <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
      (let ((james .007)
      <br>                         (maxwell 86))<br>                     (ﬂet ((spy-swap ()<br>
                      (rotatef james maxwell)))<br>
               (locally (declare (integer maxwell))<br>            (spy-swap)<br>
                 (view-movie &#x0022;The Sound of Music&#x0022;)<br>
                 (spy-swap)<br>                                  maxwell)))<br>
            <span class="math"> ⇒</span> 86  (after a couple of hours of Julie Andrews)<br>
      <!--l. 551--><p class="noindent" ></div>
      <!--l. 551--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8460009.2" id="x66-8460009.2"></a></span>
      <!--l. 551--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8470009.2" id="x66-8470009.2"></a></span>
</div>
      <!--l. 552--><p class="noindent" >The variable <tt>maxwell</tt> is declared to be an integer over the <i>scope</i> of the type
      declaration, not over its <i>extent</i>. Indeed <tt>maxwell</tt> takes on the non-integer
      value <tt>.007</tt> while the Trapp family make their escape, but because no
      reference to <tt>maxwell</tt> within the scope of the declaration ever produces a
      non-integer value, the code is correct.
      <!--l. 560--><p class="noindent" >Now the assignment to <tt>maxwell</tt> during the ﬁrst call to <tt>spy-swap</tt>,
      and the reference to <tt>maxwell</tt> during the second call, <i>do</i> involve
      non-integer values, but they occur within the body of <tt>spy-swap</tt>,
      which is <i>not</i> in the scope of the type declaration! One could put the
      declaration in a diﬀerent place so as to include <tt>spy-swap</tt> in the scope:
      <div class="lisp"><div class="tabbing">
      (let ((james .007)
      <br>              (maxwell 86))<br>          (locally (declare (integer maxwell))<br>
               (ﬂet ((spy-swap ()<br>                   (rotatef james maxwell)))<br>
                                                                          

                                                                          
                 (spy-swap)                                   ;Bug!<br>
                 (view-movie &#x0022;The Sound of Music&#x0022;)<br>
                 (spy-swap)<br>                                  maxwell)))<br>
      <!--l. 576--><p class="noindent" ></div>
      <!--l. 576--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8480009.2" id="x66-8480009.2"></a></span>
      <!--l. 576--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8490009.2" id="x66-8490009.2"></a></span>
</div>
      <!--l. 577--><p class="noindent" >and then the code is indeed in error.
      </div>
<div class="new">
      <!--l. 581--><p class="noindent" >X3J13 also voted in January 1989 <a 
 id="dx66-849001"></a>to alter the meaning of the <tt><a 
href="symbols.html#x185-2637399r399">function</a></tt> type
      speciﬁer when used in <tt>type</tt> declarations (see section <a 
href="clmse22.html#x31-1580004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>).
      </div>
      <li><b>
<i>type</i> </b></li><tt>(<i>type</i> <i>var1</i> <i>var2</i> ...)</tt> is an abbreviation for <tt>(type <i>type</i> <i>var1</i>
      <i>var2</i> ...)</tt>, provided that <i>type</i> is one of the symbols appearing in
      table <a 
href="clmse19.html#x28-1530011">4.1<!--tex4ht:ref: TYPE-SYMBOLS-TABLE --></a>.
<div class="new">
      <!--l. 596--><p class="noindent" >Observe that this covers the particularly common case of declaring numeric
      variables: <div class="lisp"><div class="tabbing">
      (declare (single-ﬂoat mass dx dy dz)
      <br>                                             (double-ﬂoat acceleration sum))<br>
      <!--l. 601--><p class="noindent" ></div>
      <!--l. 601--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8500009.2" id="x66-8500009.2"></a></span>
                                                                          

                                                                          
      <!--l. 601--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8510009.2" id="x66-8510009.2"></a></span>
</div>
      <!--l. 602--><p class="noindent" >In many implementations there is also some advantage to declaring variables
      to have certain specialized vector types such as <tt>base-string</tt>.
      </div>
      <li><b>
<tt>ftype</tt> </b></li><tt>(ftype <i>type</i> <i>function-name-1</i> <i>function-name-2</i> ...)</tt> speciﬁes that
      the named functions will be of the functional type <i>type</i>, an example of which
      follows. For example: <div class="lisp"><div class="tabbing">
      (declare (ftype (function (integer list) t) nth)
      <br>                                 (ftype (function (number) ﬂoat) sin cos))<br>
      <!--l. 614--><p class="noindent" ></div>
      <!--l. 614--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8520009.2" id="x66-8520009.2"></a></span>
      <!--l. 614--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8530009.2" id="x66-8530009.2"></a></span>
</div>
      <!--l. 615--><p class="noindent" >Note that rules of lexical scoping are observed; if one of the functions
      mentioned has a lexically apparent local deﬁnition (as made by <tt><a 
href="symbols.html#x185-2637379r379">flet</a></tt> or
      <tt><a 
href="symbols.html#x185-2637461r461">labels</a></tt>), then the declaration applies to that local deﬁnition and not to the
      global function deﬁnition.
<div class="newer">
      <!--l. 621--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx66-853001"></a>to extend <tt>ftype</tt> declaration speciﬁers to accept
      any function-name (a symbol or a list whose <i>car</i> is <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt>—see section <a 
href="clmse35.html#x47-4030007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>).
      Thus one may write <div class="lisp"><div class="tabbing">
      (declaim (ftype (function (list) t) (setf cadr)))
      <br>
                                                                          

                                                                          
      <!--l. 628--><p class="noindent" ></div>
      <!--l. 628--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8540009.2" id="x66-8540009.2"></a></span>
      <!--l. 628--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8550009.2" id="x66-8550009.2"></a></span>
</div>
      <!--l. 629--><p class="noindent" >to indicate the type of the <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt> expansion function for <tt><a 
href="symbols.html#x185-2637167r167">cadr</a></tt>.
      </div>
<div class="new">
      <!--l. 633--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx66-855001"></a>to alter the meaning of the <tt><a 
href="symbols.html#x185-2637399r399">function</a></tt> type
      speciﬁer when used in <tt>ftype</tt> declarations (see section <a 
href="clmse22.html#x31-1580004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>).
      </div></ul>
</div>
<div class="new">
<!--l. 642--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx66-855002"></a>to remove this interpretation of the <tt><a 
href="symbols.html#x185-2637399r399">function</a></tt>
declaration speciﬁer from the language. Instead, a declaration speciﬁer
<div class="lisp"><div class="tabbing">
(function <i>var1</i> <i>var2</i> ...)
   <br>
<!--l. 649--><p class="noindent" ></div>
<!--l. 649--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8560009.2" id="x66-8560009.2"></a></span>
<!--l. 649--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8570009.2" id="x66-8570009.2"></a></span>
</div>
<!--l. 650--><p class="indent" >   is to be treated simply as an abbreviation for <div class="lisp"><div class="tabbing">
(type function <i>var1</i> <i>var2</i> ...)
   <br>
                                                                          

                                                                          
<!--l. 653--><p class="noindent" ></div>
<!--l. 653--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8580009.2" id="x66-8580009.2"></a></span>
<!--l. 653--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8590009.2" id="x66-8590009.2"></a></span>
</div>
<!--l. 654--><p class="indent" >   just as for all other symbols appearing in table <a 
href="clmse19.html#x28-1530011">4.1<!--tex4ht:ref: TYPE-SYMBOLS-TABLE --></a>.
<!--l. 656--><p class="indent" >   X3J13 noted that although <tt><a 
href="symbols.html#x185-2637399r399">function</a></tt> appears in table <a 
href="clmse19.html#x28-1530011">4.1<!--tex4ht:ref: TYPE-SYMBOLS-TABLE --></a>, the ﬁrst edition
also discussed it explicitly, with a diﬀerent meaning, without noting whether
the diﬀering interpretation was to replace or augment the interpretation
regarding table <a 
href="clmse19.html#x28-1530011">4.1<!--tex4ht:ref: TYPE-SYMBOLS-TABLE --></a>. Unfortunately there is an ambiguous case: the declaration
<div class="lisp"><div class="tabbing">
(declare (function foo nil string))
   <br>
<!--l. 665--><p class="noindent" ></div>
<!--l. 665--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8600009.2" id="x66-8600009.2"></a></span>
<!--l. 665--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8610009.2" id="x66-8610009.2"></a></span>
</div>
<!--l. 666--><p class="indent" >   can be construed to abbreviate either <div class="lisp"><div class="tabbing">
(declare (ftype (function () string) foo))
   <br>
<!--l. 669--><p class="noindent" ></div>
<!--l. 669--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8620009.2" id="x66-8620009.2"></a></span>
                                                                          

                                                                          
<!--l. 669--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8630009.2" id="x66-8630009.2"></a></span>
</div>
<!--l. 670--><p class="indent" >   or <div class="lisp"><div class="tabbing">
(declare (type function foo nil string))
   <br>
<!--l. 673--><p class="noindent" ></div>
<!--l. 673--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8640009.2" id="x66-8640009.2"></a></span>
<!--l. 673--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8650009.2" id="x66-8650009.2"></a></span>
</div>
<!--l. 674--><p class="indent" >   The latter could perhaps be rejected on semantic grounds: it would be an error
to declare <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>, a constant, to be of type <tt><a 
href="symbols.html#x185-2637399r399">function</a></tt>. In any case, X3J13 determined
that the ice was too thin here; the possibility of confusion is not worth the
convenience of an abbreviation for <tt>ftype</tt> declarations. The change also makes the
language more consistent.
</div>
<div class="flushdesc">
      <ul><li><b>
<tt>inline</tt> </b></li><tt>(inline <i>function1</i> <i>function2</i> ...)</tt> speciﬁes that it is desirable
      for the compiler to open-code calls to the speciﬁed functions; that is,
      the code for a speciﬁed function should be integrated into the calling
      routine, appearing in-line in place of a procedure call. This may achieve
      extra speed at the expense of debuggability (calls to functions compiled
      in-line cannot be traced, for example). This declaration is pervasive.
      Remember that a compiler is free to ignore this declaration.
      <!--l. 695--><p class="noindent" >Note that rules of lexical scoping are observed; if one of the functions
      mentioned has a lexically apparent local deﬁnition (as established by
      <tt><a 
href="symbols.html#x185-2637379r379">flet</a></tt> or <tt><a 
href="symbols.html#x185-2637461r461">labels</a></tt>), then the declaration applies to that local deﬁnition
      and not to the global function deﬁnition.
<div class="newer">
                                                                          

                                                                          
      <!--l. 701--><p class="noindent" >X3J13 voted in October 1988 <a 
 id="dx66-865001"></a>to clarify that during compilation the <tt>inline</tt>
      declaration speciﬁer serves two distinct purposes: it indicates not only that
      aﬀected calls to the speciﬁed functions should be expanded in-line, but also
      that aﬀected deﬁnitions of the speciﬁed functions must be recorded for
      possible use in performing such expansions.
      <!--l. 708--><p class="noindent" >Looking at it the other way, the compiler is not required to save function
      deﬁnitions against the possibility of future expansions unless the functions
      have already been proclaimed to be <tt>inline</tt>. If a function is proclaimed (or
      declaimed) <tt>inline</tt> before some call to that function but the current
      deﬁnition of that function was established before the proclamation was
      processed, it is implementation-dependent whether that call will be
      expanded in-line. (Of course, it is implementation-dependent anyway,
      because a compiler is always free to ignore <tt>inline</tt> declaration speciﬁers.
      However, the intent of the committee is clear: for best results, the user is
      advised to put any <tt>inline</tt> proclamation of a function before any deﬁnition
      of or call to that function.)
      <!--l. 722--><p class="noindent" >Consider these examples: <div class="lisp"><div class="tabbing">
      (defun huey (x) (+ x 100))         ;Compiler need not remember this
      <br>                                                     (declaim (inline huey dewey))<br>
           (defun dewey (y) (huey (sqrt y)))  ;Call to <tt>huey</tt> unlikely to be expanded<br>
           (defun louie (z) (dewey (/ z)))    ;Call to <tt>dewey</tt> likely to be expanded<br>
      <!--l. 728--><p class="noindent" ></div>
      <!--l. 728--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8660009.2" id="x66-8660009.2"></a></span>
      <!--l. 728--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8670009.2" id="x66-8670009.2"></a></span>
</div>
                                                                          

                                                                          
      <!--l. 731--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx66-867001"></a>to extend <tt>inline</tt> declaration speciﬁers to
      accept any function-name (a symbol or a list whose <i>car</i> is <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt>—see
      section <a 
href="clmse35.html#x47-4030007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). Thus one may write <tt>(declare (inline (setf cadr)))</tt> to
      indicate that the <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt> expansion function for <tt><a 
href="symbols.html#x185-2637167r167">cadr</a></tt> should be compiled
      in-line.
      </div>
      <li><b>
<tt>notinline</tt> </b></li><tt>(notinline <i>function1</i> <i>function2</i> ...)</tt> speciﬁes that it is
      <i>undesirable</i> to compile the speciﬁed functions in-line. This declaration is
      pervasive. A compiler is <i>not</i> free to ignore this declaration.
      <!--l. 746--><p class="noindent" >Note that rules of lexical scoping are observed; if one of the functions
      mentioned has a lexically apparent local deﬁnition (as made by <tt><a 
href="symbols.html#x185-2637379r379">flet</a></tt> or
      <tt><a 
href="symbols.html#x185-2637461r461">labels</a></tt>), then the declaration applies to that local deﬁnition and not to the
      global function deﬁnition.
<div class="newer">
      <!--l. 752--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx66-867002"></a>to extend <tt>notinline</tt> declaration speciﬁers to
      accept any function-name (a symbol or a list whose <i>car</i> is <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt>—see
      section <a 
href="clmse35.html#x47-4030007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). Thus one may write <tt>(declare (notinline (setf cadr)))</tt> to
      indicate that the <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt> expansion function for <tt><a 
href="symbols.html#x185-2637167r167">cadr</a></tt> should not be compiled
      in-line.
      </div>
<div class="new">
      <!--l. 762--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx66-867003"></a>to clarify that the proper way to deﬁne a
      function <tt>gnards</tt> that is not <tt>inline</tt> by default, but for which a local
      declaration <tt>(declare (inline gnards))</tt> has half a chance of actually
      compiling <tt>gnards</tt> in-line, is as follows: <div class="lisp"><div class="tabbing">
      (declaim (inline gnards))
      <br>                                                                                            <br>
           (defun gnards ...)<br>                                              <br>
           (declaim (notinline gnards))<br>
      <!--l. 774--><p class="noindent" ></div>
                                                                          

                                                                          
      <!--l. 774--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8680009.2" id="x66-8680009.2"></a></span>
      <!--l. 774--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8690009.2" id="x66-8690009.2"></a></span>
</div>
      <!--l. 775--><p class="noindent" >The point is that the ﬁrst declamation informs the compiler that the
      deﬁnition of <tt>gnards</tt> may be needed later for in-line expansion, and the
      second declamation prevents any expansions unless and until it is
      overridden.
      <!--l. 780--><p class="noindent" >While an implementation is never required to perform in-line expansion,
      many implementations that do support such expansion will not process
      <tt>inline</tt> requests successfully unless deﬁnitions are written with these
      proclamations in the manner shown above.
      </div>
      <li><b>
<tt>ignore</tt> </b></li><tt>(ignore <i>var1</i> <i>var2</i> ... <i>varn</i>)</tt> aﬀects only variable bindings and
      speciﬁes that the bindings of the speciﬁed variables are never used. It is
      desirable for a compiler to issue a warning if a variable so declared is ever
      referred to or is also declared special, or if a variable is lexical, never referred
      to, and not declared to be ignored.
      <li><b>
<tt>optimize</tt> </b></li><tt>(optimize (<i>quality1</i> <i>value1</i>) (<i>quality2</i> <i>value2</i>)...)</tt>
      advises the compiler that each <i>quality</i> should be given attention
      according to the speciﬁed corresponding <i>value</i>. A quality is a symbol;
      standard qualities include <tt>speed</tt> (of the object code), <tt>space</tt> (both code
      size and run-time space), <tt>safety</tt> (run-time error checking), and
      <tt>compilation-speed</tt> (speed of the compilation process). <div class="newer"> X3J13
      voted in October 1988 <a 
 id="dx66-869001"></a>to add the standard quality <tt>debug</tt> (ease of
      debugging).
      </div> Other qualities may be recognized by particular implementations. A <i>value</i>
      should be a non-negative integer, normally in the range <tt>0</tt> to <tt>3</tt>. The value
      <tt>0</tt> means that the quality is totally unimportant, and <tt>3</tt> that the
      quality is extremely important; <tt>1</tt> and <tt>2</tt> are intermediate values, with
      <tt>1</tt> the “normal” or “usual” value. One may abbreviate <tt>(<i>quality</i>
      3)</tt> to simply <i>quality</i>. This declaration is pervasive. For example:
                                                                          

                                                                          
      <div class="lisp"><div class="tabbing">
      (defun often-used-subroutine (x y)
      <br>              (declare (optimize (safety 2)))<br>              (error-check x y)<br>
             (hairy-setup x)<br>                             (do ((i 0 (+ i 1))<br>
                  (z x (cdr z)))<br>                               ((null z) i)<br>
               ;; This inner loop really needs to burn.<br>
               (declare (optimize speed))<br>             (declare (ﬁxnum i))<br>
               )))<br>
      <!--l. 827--><p class="noindent" ></div>
      <!--l. 827--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8700009.2" id="x66-8700009.2"></a></span>
      <!--l. 827--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8710009.2" id="x66-8710009.2"></a></span>
</div>
      <li><b>
<tt>declaration</tt> </b></li><tt>(declaration <i>name1</i> <i>name2</i> ...)</tt> advises the compiler that each
      <i>namej</i> is a valid but non-standard declaration name. The purpose of this is
      to tell one compiler not to issue warnings for declarations meant for another
      compiler or other program processor.
      <!--l. 835--><p class="noindent" >The <tt>declaration</tt> declaration speciﬁer may be used with <tt><a 
href="symbols.html#x185-2637269r269">declaim</a></tt> as well as
      <tt><a 
href="symbols.html#x185-2637695r695">proclaim</a></tt>. The preceding examples would be better written using <tt><a 
href="symbols.html#x185-2637269r269">declaim</a></tt>,
      to ensure that the compiler will process them properly.
<div class="lisp">
      <!--l. 839--><p class="noindent" ><div class="tabbing">
      (declaim (declaration author
                                                                          

                                                                          
      <br>                                                           target-language<br>
                                 target-machine))<br>
           <br>                                            (declaim (target-language ada)<br>
                    (target-machine IBM-650))<br>                          <br>
           (defun strangep (x)<br>         (declare (author &#x0022;Harry Tweeker&#x0022;))<br>
             (member x &#x2019;(strange weird odd peculiar)))<br>
      <!--l. 850--><p class="noindent" ></div>
      <!--l. 850--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8720009.2" id="x66-8720009.2"></a></span>
      <!--l. 850--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8730009.2" id="x66-8730009.2"></a></span>
</div>
      <li><b>
<tt>dynamic-extent</tt> </b></li>
<tt>
      <!--l. 854--><p class="noindent" >(dynamic-extent <i>item1</i> <i>item2</i> ... <i>itemn</i>)</tt> declares that certain
      variables or function-names refer to data objects whose extents may be
      regarded as dynamic; that is, the declaration may be construed as a
      guarantee on the part of the programmer that the program will behave
      correctly even if the data objects have only dynamic extent rather than the
      usual indeﬁnite extent.
      <!--l. 860--><p class="noindent" >Each <i>item</i> may be either a variable name or <tt>(function <i>f</i>)</tt> where <i>f </i> is a
      function-name (see section <a 
href="clmse35.html#x47-4030007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). (Of course, <tt>(function <i>f</i>)</tt> may be
      abbreviated in the usual way as <tt>#&#x2019;<i>f</i></tt>.)
      <!--l. 865--><p class="noindent" >It is permissible for an implementation simply to ignore this declaration. In
      implementations that do not ignore it, the compiler (or interpreter) is free to
      make whatever optimizations are appropriate given this information; the
      most common optimization is to stack-allocate the initial value of the
      object. The data types that can be optimized in this manner may vary from
      implementation to implementation.
      <!--l. 872--><p class="noindent" >The meaning of this declaration can be stated more precisely. We say that
      object <i>x</i> is an <i>otherwise inaccessible part</i> of <i>y</i> if and only if making <i>y</i>
                                                                          

                                                                          
      inaccessible would make <i>x</i> inaccessible. (Note that every object is an
      otherwise inaccessible part of itself.) Now suppose that construct <i>c</i> contains
      a <tt>dynamic-extent</tt> declaration for variable (or function) <i>v</i> (which need not
      be bound by <i>c</i>). Consider the values <span class="math"><i>w</i><sub>1</sub>,…,<i>w</i><sub>n</sub></span> taken on by <i>v</i> during
      the course of some execution of <i>c</i>. The declaration asserts that if
      some object <i>x</i> is an otherwise inaccessible part of <span class="math"><i>w</i><sub>j</sub></span> whenever <span class="math"><i>w</i><sub>j</sub></span>
      becomes the value of <i>v</i>, then just after execution of <span class="math">c</span> terminates <i>x</i> will
      be either inaccessible or still an otherwise inaccessible part of the
      value of <i>v</i>. If this assertion is ever violated, the consequences are
      undeﬁned.
      <!--l. 886--><p class="noindent" >In some implementations, it is possible to allocate data structures in a way
      that will make them easier to reclaim than by general-purpose garbage
      collection (for example, on the stack or in some temporary area). The
      <tt>dynamic-extent</tt> declaration is designed to give the implementation the
      information necessary to exploit such techniques.
      <!--l. 892--><p class="noindent" >For example, in the code fragment <div class="lisp"><div class="tabbing">
      (let ((x (list &#x2019;a1 &#x2019;b1 &#x2019;c1))
      <br>                                     (y (cons &#x2019;a2 (cons &#x2019;b2 (cons &#x2019;c2 &#x2019;d2)))))<br>
             (declare (dynamic-extent x y))<br>                            ...)<br>
      <!--l. 895--><p class="noindent" ></div>
      <!--l. 895--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8740009.2" id="x66-8740009.2"></a></span>
      <!--l. 895--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8750009.2" id="x66-8750009.2"></a></span>
</div>
      <!--l. 895--><p class="noindent" >it is not diﬃcult to prove that the otherwise inaccessible parts of <tt>x</tt> include
      the three conses constructed by <tt><a 
href="symbols.html#x185-2637492r492">list</a></tt>, and that the otherwise inaccessible
      parts of <tt>y</tt> include three other conses manufactured by the three calls to
      <tt>cons</tt>. Given the presence of the <tt>dynamic-extent</tt> declaration, a compiler
      would be justiﬁed in stack-allocating these six conses and reclaiming their
      storage on exit from the <tt><a 
href="symbols.html#x185-2637488r488">let</a></tt> form.
                                                                          

                                                                          
      <!--l. 903--><p class="noindent" >Since stack allocation of the initial value entails knowing at the object&#x2019;s
      creation time that the object can be stack-allocated, it is not generally
      useful to declare <tt>dynamic-extent</tt> for variables that have no lexically
      apparent initial value. For example, <div class="lisp"><div class="tabbing">
      (defun f ()
      <br>           (let ((x (list 1 2 3)))<br>             (declare (dynamic-extent x))<br>
               ...))<br>
      <!--l. 909--><p class="noindent" ></div>
      <!--l. 909--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8760009.2" id="x66-8760009.2"></a></span>
      <!--l. 909--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8770009.2" id="x66-8770009.2"></a></span>
</div>
      <!--l. 909--><p class="noindent" >would permit a compiler to stack-allocate the list in <tt>x</tt>. However,
      <div class="lisp"><div class="tabbing">
      (defun g (x) (declare (dynamic-extent x)) ...)
      <br>                                                          (defun f () (g (list 1 2 3)))<br>
      <!--l. 913--><p class="noindent" ></div>
      <!--l. 913--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8780009.2" id="x66-8780009.2"></a></span>
                                                                          

                                                                          
      <!--l. 913--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8790009.2" id="x66-8790009.2"></a></span>
</div>
      <!--l. 913--><p class="noindent" >could not typically permit a similar optimization in <tt><a 
href="symbols.html#x185-2637351r351">f</a></tt> because of the
      possibility of later redeﬁnition of <tt>g</tt>. Only an implementation careful enough
      to recompile <tt><a 
href="symbols.html#x185-2637351r351">f</a></tt> if the deﬁnition of <tt>g</tt> were to change incompatibly could
      stack-allocate the list argument to <tt>g</tt> in <tt><a 
href="symbols.html#x185-2637351r351">f</a></tt>.
      <!--l. 918--><p class="noindent" >Other interesting cases are <div class="lisp"><div class="tabbing">
      (declaim (inline g))
      <br>                                 (defun g (x) (declare (dynamic-extent x)) ...)<br>
           (defun f () (g (list 1 2 3)))<br>
      <!--l. 921--><p class="noindent" ></div>
      <!--l. 921--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8800009.2" id="x66-8800009.2"></a></span>
      <!--l. 921--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8810009.2" id="x66-8810009.2"></a></span>
</div>
      <!--l. 921--><p class="noindent" >and <div class="lisp"><div class="tabbing">
      (defun f ()
      <br>                               (ﬂet ((g (x) (declare (dynamic-extent x)) ...))<br>
               (g (list 1 2 3))))<br>
      <!--l. 924--><p class="noindent" ></div>
      <!--l. 924--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8820009.2" id="x66-8820009.2"></a></span>
                                                                          

                                                                          
      <!--l. 924--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8830009.2" id="x66-8830009.2"></a></span>
</div>
      <!--l. 924--><p class="noindent" >In each case some compilers might realize the optimization is possible and
      others might not.
      <!--l. 927--><p class="noindent" >An interesting variant of this is the so-called <i>stack-allocated rest list</i>, which
      can be achieved (in implementations supporting the optimization) by
      <div class="lisp"><div class="tabbing">
      (defun f (&#x0026;rest x)
      <br>                                                     (declare (dynamic-extent x))<br>
             ...)<br>
      <!--l. 930--><p class="noindent" ></div>
      <!--l. 930--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8840009.2" id="x66-8840009.2"></a></span>
      <!--l. 930--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8850009.2" id="x66-8850009.2"></a></span>
</div>
      <!--l. 930--><p class="noindent" >Note here that although the initial value of <tt>x</tt> is not explicitly present,
      nevertheless in the usual implementation strategy the function <tt><a 
href="symbols.html#x185-2637351r351">f</a></tt> is
      responsible for assembling the list for <tt>x</tt> from the passed arguments, so the <tt><a 
href="symbols.html#x185-2637351r351">f</a></tt>
      function can be optimized by a compiler to construct a stack-allocated list
      instead of a heap-allocated list.
      <!--l. 936--><p class="noindent" >Some Common Lisp functions take other functions as arguments; frequently
      the argument function is a so-called <i>downward funarg</i>, that is, a functional
      argument that is passed only downward and whose extent may therefore be
      dynamic. <div class="lisp"><div class="tabbing">
      (ﬂet ((gd (x) (atan (sinh x))))
                                                                          

                                                                          
      <br>          (declare (dynamic-extent #&#x2019;gd))     ;<tt><a 
href="symbols.html#x185-2637560r560">mapcar</a></tt> won&#x2019;t hang on to <tt>gd</tt><br>
             (mapcar #&#x2019;gd my-list-of-numbers))<br>
      <!--l. 942--><p class="noindent" ></div>
      <!--l. 942--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8860009.2" id="x66-8860009.2"></a></span>
      <!--l. 942--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8870009.2" id="x66-8870009.2"></a></span>
</div>
      <!--l. 945--><p class="noindent" >The following three examples are in error, since in each case the value of <tt>x</tt> is
      used outside of its extent. <div class="lisp"><div class="tabbing">
      (length (let ((x (list 1 2 3)))
      <br>                                                 (declare (dynamic-extent x))<br>
                     x))                                    ;Wrong<br>
      <!--l. 950--><p class="noindent" ></div>
      <!--l. 950--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8880009.2" id="x66-8880009.2"></a></span>
      <!--l. 950--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8890009.2" id="x66-8890009.2"></a></span>
</div>
      <!--l. 950--><p class="noindent" >The preceding code is obviously incorrect, because the cons cells making up
      the list in <tt>x</tt> might be deallocated (thanks to the declaration) before <tt><a 
href="symbols.html#x185-2637487r487">length</a></tt>
      is called. <div class="lisp"><div class="tabbing">
      (length (list (let ((x (list 1 2 3)))
      <br>                                             (declare (dynamic-extent x))<br>
                           x)))                             ;Wrong<br>
                                                                          

                                                                          
      <!--l. 956--><p class="noindent" ></div>
      <!--l. 956--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8900009.2" id="x66-8900009.2"></a></span>
      <!--l. 956--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8910009.2" id="x66-8910009.2"></a></span>
</div>
      <!--l. 956--><p class="noindent" >In this second case it is less obvious that the code is incorrect, because one
      might argue that the cons cells making up the list in <tt>x</tt> have no eﬀect on the
      result to be computed by <tt><a 
href="symbols.html#x185-2637487r487">length</a></tt>. Nevertheless the code brieﬂy violates the
      assertion implied by the declaration and is therefore incorrect. (It is not
      diﬃcult to imagine a perfectly sensible implementation of a garbage
      collector that might become confused by a cons cell containing a dangling
      pointer to a list that was once stack-allocated but then deallocated.)
      <div class="lisp"><div class="tabbing">
      (progn (let ((x (list 1 2 3)))
      <br>                                                 (declare (dynamic-extent x))<br>
                    x)                                      ;Wrong<br>
                  (print &#x0022;Six dollars is your change have a nice day NEXT!&#x0022;))<br>
      <!--l. 967--><p class="noindent" ></div>
      <!--l. 967--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8920009.2" id="x66-8920009.2"></a></span>
      <!--l. 967--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8930009.2" id="x66-8930009.2"></a></span>
</div>
      <!--l. 967--><p class="noindent" >In this third case it is even less obvious that the code is incorrect, because
      the value of <tt>x</tt> returned from the <tt><a 
href="symbols.html#x185-2637488r488">let</a></tt> construct is discarded right away by
      the <tt><a 
href="symbols.html#x185-2637700r700">progn</a></tt>. Indeed it is, but “right away” isn&#x2019;t fast enough. The code brieﬂy
      violates the assertion implied by the declaration and is therefore incorrect.
                                                                          

                                                                          
      (If the code is being interpreted, the interpreter might hang on to
      the value returned by the <tt><a 
href="symbols.html#x185-2637488r488">let</a></tt> for some time before it is eventually
      discarded.)
      <!--l. 975--><p class="noindent" >Here is one last example, one that has little practical import but is
      theoretically quite instructive. <div class="lisp"><div class="tabbing">
      (dotimes (j 10)
      <br>                                                      (declare (dynamic-extent j))<br>
             (setq foo 3)                     ;Correct<br>
             (setq foo j))                    ;Erroneous—but why? (see text)<br>
      <!--l. 980--><p class="noindent" ></div>
      <!--l. 980--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8940009.2" id="x66-8940009.2"></a></span>
      <!--l. 980--><p class="noindent" ><span class="paragraphHead"><a 
href="#x66-8950009.2" id="x66-8950009.2"></a></span>
</div>
      <!--l. 980--><p class="noindent" >Since <tt>j</tt> is an integer by the deﬁnition of <tt><a 
href="symbols.html#x185-2637318r318">dotimes</a></tt>, but <tt><a 
href="symbols.html#x185-2637337r337">eq</a></tt> and <tt><a 
href="symbols.html#x185-2637338r338">eql</a></tt> are not
      necessarily equivalent for integers, what are the otherwise inaccessible parts
      of <tt>j</tt>, which this declaration requires the body of the <tt><a 
href="symbols.html#x185-2637318r318">dotimes</a></tt> not to “save”?
      If the value of <tt>j</tt> is <tt>3</tt>, and the body does <tt>(setq foo 3)</tt>, is that an error?
      The answer is no, but the interesting thing is that it depends on
      the implementation-dependent behavior of <tt><a 
href="symbols.html#x185-2637337r337">eq</a></tt> on numbers. In an
      implementation where <tt><a 
href="symbols.html#x185-2637337r337">eq</a></tt> and <tt><a 
href="symbols.html#x185-2637338r338">eql</a></tt> are equivalent for <tt>3</tt>, then <tt>3</tt> is not an
      otherwise inaccessible part because <tt>(eq j (+ 2 1))</tt> is true, and therefore
      there is another way to access the object besides going through <tt>j</tt>. On
      the other hand, in an implementation where <tt><a 
href="symbols.html#x185-2637337r337">eq</a></tt> and <tt><a 
href="symbols.html#x185-2637338r338">eql</a></tt> are not
      equivalent for <tt>3</tt>, then the particular <tt>3</tt> that is the value of <tt>j</tt> is an
      otherwise inaccessible part, but any other <tt>3</tt> is not. Thus <tt>(setq
      foo 3)</tt> is valid but <tt>(setq foo j)</tt> is erroneous. Since <tt>(setq foo j)</tt> is
      erroneous in some implementations, it is erroneous in all portable
      programs, but some other implementations may not be able to detect the
                                                                          

                                                                          
      error. (If this conclusion seems strange, it may help to replace <tt>3</tt>
      everywhere in the preceding argument with some obvious bignum such as
      <tt>375374638837424898243</tt> and to replace <tt>10</tt> with some even larger
      bignum.)
      <!--l. 1000--><p class="noindent" >The <tt>dynamic-extent</tt> declaration should be used with great care. It makes
      possible great performance improvements in some situations, but if the user
      misdeclares something and consequently the implementation returns a
      pointer into the stack (or stores it in the heap), an undeﬁned situation
      may result and the integrity of the Lisp storage mechanism may be
      compromised. Debugging these situations may be tricky. Users who have
      asked for this feature have indicated a willingness to deal with such
      problems; nevertheless, I do not encourage casual users to use this
      declaration.</ul>
</div>
<!--l. 1010--><p class="indent" >   An implementation is free to support other (implementation-dependent)
declaration speciﬁers as well. On the other hand, a Common Lisp compiler
is free to ignore entire classes of declaration speciﬁers (for example,
implementation-dependent declaration speciﬁers not supported by that compiler&#x2019;s
implementation), except for the <tt>declaration</tt> declaration speciﬁer. Compiler
implementors are encouraged, however, to program the compiler to issue by
default a warning if the compiler ﬁnds a declaration speciﬁer of a kind it never
uses. Such a warning is required in any case if a declaration speciﬁer is not
one of those deﬁned above and has not been declared in a <tt>declaration</tt>
declaration.
                                                                          

                                                                          
<!--l. 1024--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse53.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse51.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse51.html#tailclmse51.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse52.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="declar.html#clmse52.html" >Up</a><tt>&#x003E;</tt></div><a 
 id="tailclmse52.html"></a>  </div> </div> 
</body></html> 
