<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Top-Level Forms</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:21:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 784--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="preds.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse29.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse29.html#tailclmse29.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse30.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html#clmse30.html" >Up</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">5.3   </span> <a 
href="clm.html#QQ2-40-277" id="x40-2690005.3">Top-Level Forms</a></h3>
<!--l. 786--><p class="noindent" >The standard way for the user to interact with a Common Lisp implementation is
via a <i>read-eval-print loop</i>: the system repeatedly reads a form from some input
source (such as a keyboard or a disk ﬁle), evaluates it, and then prints the
value(s) to some output sink (such as a display screen or another disk
ﬁle). Any form (evaluable data object) is acceptable; however, certain
special operators are speciﬁcally designed to be convenient for use as
<i>top-level</i> forms, rather than as forms embedded within other forms in
the way that <tt>(+ 3 4)</tt> is embedded within <tt>(if p (+ 3 4) 6)</tt>. These
top-level special operators may be used to deﬁne globally named functions, to
deﬁne macros, to make declarations, and to deﬁne global values for special
variables.
<!--l. 800--><p class="indent" >   While deﬁning forms normally appear at top level, it is meaningful to place
them in non-top-level contexts. All deﬁning forms that create functional objects
from code appearing as argument forms must ensure that such argument forms
refer to the enclosing lexical environment. Compilers must handle deﬁning forms
properly in all situations, not just top-level contexts. However, certain
compile-time side eﬀects of these deﬁning forms are performed only when the
deﬁning forms occur at top level (see section <a 
href="clmse121.html#x150-198200024.1">24.1<!--tex4ht:ref: COMPILER-SECTION --></a>).
<!--l. 810--><p class="indent" >   Macros are usually deﬁned by using the special operator <tt><a 
href="symbols.html#x185-2637284r284">defmacro</a></tt>. This
facility is fairly complicated; it is described in chapter <a 
href="macro.html#x58-7360008">8<!--tex4ht:ref: MACROS --></a>.
<!--l. 813--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.3.1   </span> <a 
href="frontmatter.html#QQ2-40-278" id="x40-2700005.3.1">Deﬁning Named Functions</a></h4>
<!--l. 815--><p class="noindent" >The <tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt> special operator is the usual means of deﬁning named functions.
<div class="defmac">
<div class="defmacheader">
<!--l. 818--><p class="indent" >   <div class="tabbing">
 <i>[Macro]</i> <b>defun</b> <a 
 id="dx40-270001"></a><a 
 id="x40-270002r13"></a> name lambda-list [[{declaration}* | doc-string]] {form}*
                                                                          

                                                                          
   <br>
<!--l. 819--><p class="noindent" ></div>
<!--l. 819--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2710005.3.1" id="x40-2710005.3.1"></a></span>
</div>
<!--l. 820--><p class="indent" >   Evaluating a <tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt> form causes the symbol <i>name</i> to be a global name for the
function speciﬁed by the lambda-expression <div class="lisp"><div class="tabbing">
(lambda <i>lambda-list</i> {<i><i>declaration</i> | <i>doc-string</i></i>}*  {<i><i>form</i></i>}* )
   <br>
<!--l. 824--><p class="noindent" ></div>
<!--l. 824--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2720005.3.1" id="x40-2720005.3.1"></a></span>
<!--l. 824--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2730005.3.1" id="x40-2730005.3.1"></a></span>
</div>
<!--l. 825--><p class="indent" >   deﬁned in the lexical environment in which the <tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt> form was executed.
Because <tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt> forms normally appear at top level, this is normally the null lexical
environment.
<!--l. 829--><p class="indent" >   While deﬁning forms normally appear at top level, it is meaningful to place
them in non-top-level contexts; <tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt> must deﬁne the function within the
enclosing lexical environment, not within the null lexical environment.
<tt>
<!--l. 835--><p class="indent" >   <a 
href="symbols.html#x185-2637291r291">defun</a></tt> can accept any function-name (a symbol or a list whose <i>car</i> is <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt>—see
section <a 
href="clmse35.html#x47-4030007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>) as a <i>name</i>. Thus one may write <div class="lisp"><div class="tabbing">
(defun (setf cadr) ...)
   <br>
<!--l. 842--><p class="noindent" ></div>
<!--l. 842--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2740005.3.1" id="x40-2740005.3.1"></a></span>
                                                                          

                                                                          
<!--l. 842--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2750005.3.1" id="x40-2750005.3.1"></a></span>
</div>
<!--l. 843--><p class="indent" >   to deﬁne a <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt> expansion function for <tt><a 
href="symbols.html#x185-2637167r167">cadr</a></tt> (although it may be much more
convenient to use <tt><a 
href="symbols.html#x185-2637288r288">defsetf</a></tt> or <tt><a 
href="symbols.html#x185-2637281r281">define-modify-macro</a></tt>).
<!--l. 848--><p class="indent" >   If the optional documentation string <i>doc-string</i> is present, then it is attached
to the <i>name</i> as a documentation string of type <tt><a 
href="symbols.html#x185-2637399r399">function</a></tt>; see <tt><a 
href="symbols.html#x185-2637315r315">documentation</a></tt>. If
<i>doc-string</i> is not followed by a declaration, it may be present only if at least one
<i>form</i> is also speciﬁed, as it is otherwise taken to be a <i>form</i>. It is an error if more
than one <i>doc-string</i> is present.
<!--l. 857--><p class="indent" >   The <i>forms</i> constitute the body of the deﬁned function; they are executed as an
implicit <tt><a 
href="symbols.html#x185-2637700r700">progn</a></tt>.
<!--l. 860--><p class="indent" >   The body of the deﬁned function is implicitly enclosed in a <tt><a 
href="symbols.html#x185-2637128r128">block</a></tt> construct
whose name is the same as the <i>name</i> of the function. Therefore <tt><a 
href="symbols.html#x185-2637752r752">return-from</a></tt> may
be used to exit from the function.
<!--l. 865--><p class="indent" >   Other implementation-dependent bookkeeping actions may be taken as well by
<tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt>. The <i>name</i> is returned as the value of the <tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt> form. For example:
<div class="lisp"><div class="tabbing">
(defun discriminant (a b c)
   <br>                                                              (declare (number a b c))<br>
  &#x0022;Compute the discriminant for a quadratic equation.<br>
   Given a, b, and c, the value b̂2-4*a*c is calculated.<br>
   If the coeﬃcients a, b, and c are all real (that is,<br>
   not complex), then the quadratic equation a*x̂2+b*x+c=0<br>
   has real, multiple, or complex roots depending on<br>
   whether this calculated value is positive, zero, or<br>
   negative, respectively.&#x0022;   (- (* b b) (* 4 a c)))<br>        <span class="math"> ⇒</span> discriminant<br>
   and now (discriminant 1 2/3 -2) <span class="math"> ⇒</span> 76/9<br>
<!--l. 882--><p class="noindent" ></div>
<!--l. 882--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2760005.3.1" id="x40-2760005.3.1"></a></span>
<!--l. 882--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2770005.3.1" id="x40-2770005.3.1"></a></span>
</div>
                                                                          

                                                                          
<!--l. 884--><p class="indent" >   It is permissible to use <tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt> to redeﬁne a function, to install a corrected
version of an incorrect deﬁnition, for example. It is permissible to redeﬁne a macro
as a function. It is an error to attempt to redeﬁne the name of a special form (see
table <a 
href="clmse28.html#x38-2370011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>) as a function.
</div>
<!--l. 891--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.3.2   </span> <a 
href="frontmatter.html#QQ2-40-286" id="x40-2780005.3.2">Declaring Global Variables and Named Constants</a></h4>
<!--l. 893--><p class="noindent" >The <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt> and <tt><a 
href="symbols.html#x185-2637287r287">defparameter</a></tt> special operators are the usual means of
specifying globally deﬁned variables. The <tt><a 
href="symbols.html#x185-2637275r275">defconstant</a></tt> special operator is used for
deﬁning named constants.
<div class="defmac">
<div class="defmacheader">
<!--l. 898--><p class="indent" >   <div class="tabbing">
 <i>[Macro]</i> <b>defvar</b> <a 
 id="dx40-278001"></a><a 
 id="x40-278002r14"></a> name [initial-value [documentation]]
   <br>
<!--l. 898--><p class="noindent" ></div>
<!--l. 898--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2790005.3.2" id="x40-2790005.3.2"></a></span>
</div>
<div class="defmacheader">
<!--l. 898--><p class="indent" >   <div class="tabbing">
 <i>[Macro]</i> <b>defparameter</b> <a 
 id="dx40-279001"></a><a 
 id="x40-279002r15"></a> name initial-value [documentation]
   <br>
<!--l. 899--><p class="noindent" ></div>
<!--l. 899--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2800005.3.2" id="x40-2800005.3.2"></a></span>
</div>
<div class="defmacheader">
<!--l. 899--><p class="indent" >   <div class="tabbing">
                                                                          

                                                                          
 <i>[Macro]</i> <b>defconstant</b> <a 
 id="dx40-280001"></a><a 
 id="x40-280002r16"></a> name initial-value [documentation]
   <br>
<!--l. 901--><p class="noindent" ></div>
<!--l. 901--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2810005.3.2" id="x40-2810005.3.2"></a></span>
</div>
<tt>
<!--l. 902--><p class="indent" >   <a 
href="symbols.html#x185-2637292r292">defvar</a></tt> is the recommended way to declare the use of a special variable in a
program. <div class="lisp"><div class="tabbing">
(defvar <i>variable</i>)
   <br>
<!--l. 906--><p class="noindent" ></div>
<!--l. 906--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2820005.3.2" id="x40-2820005.3.2"></a></span>
<!--l. 906--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2830005.3.2" id="x40-2830005.3.2"></a></span>
</div>
<!--l. 907--><p class="indent" >   proclaims <i>variable</i> to be <tt>special</tt> (see <tt><a 
href="symbols.html#x185-2637695r695">proclaim</a></tt>), and may perform other
system-dependent bookkeeping actions.
<!--l. 910--><p class="indent" >   If no <i>initial-value</i> form is provided, <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt> does not change the value of the
<i>variable</i>; if no <i>initial-value</i> form is provided and the variable has no value, <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt>
does not give it a value.
<!--l. 915--><p class="indent" >   If a second argument form is supplied, <div class="lisp"><div class="tabbing">
(defvar <i>variable</i> <i>initial-value</i>)
   <br>
<!--l. 918--><p class="noindent" ></div>
<!--l. 918--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2840005.3.2" id="x40-2840005.3.2"></a></span>
                                                                          

                                                                          
<!--l. 918--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2850005.3.2" id="x40-2850005.3.2"></a></span>
</div>
<!--l. 919--><p class="indent" >   then <i>variable</i> is initialized to the result of evaluating the form <i>initial-value</i>
unless it already has a value. The <i>initial-value</i> form is not evaluated unless it is
used; this fact is useful if evaluation of the <i>initial-value</i> form does something
expensive like creating a large data structure.
<div class="newer">
<!--l. 926--><p class="indent" >   X3J13 voted in June 1987 <a 
 id="dx40-285001"></a>to clarify that evaluation of the <i>initial-value</i> and the
initialization of the variable occur, if at all, at the time the <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt> form is
executed, and that the <i>initial-value</i> form is evaluated if and only if the <i>variable</i>
does not already have a value.
</div> The initialization is performed by assignment and thus assigns a global value to
the variable unless there are currently special bindings of that variable. Normally
there should not be any such special bindings.
<tt>
<!--l. 937--><p class="indent" >   <a 
href="symbols.html#x185-2637292r292">defvar</a></tt> also provides a good place to put a comment describing the meaning of
the variable, whereas an ordinary <tt>special</tt> proclamation oﬀers the temptation to
declare several variables at once and not have room to describe them all.
<div class="lisp"><div class="tabbing">
(defvar *visible-windows* 0
   <br>             &#x0022;Number of windows at least partially visible on the screen&#x0022;)<br>
<!--l. 945--><p class="noindent" ></div>
<!--l. 945--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2860005.3.2" id="x40-2860005.3.2"></a></span>
<!--l. 945--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2870005.3.2" id="x40-2870005.3.2"></a></span>
</div>
<tt>
<!--l. 947--><p class="indent" >   <a 
href="symbols.html#x185-2637287r287">defparameter</a></tt> is similar to <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt>, but <tt><a 
href="symbols.html#x185-2637287r287">defparameter</a></tt> requires an
<i>initial-value</i> form, always evaluates the form, and assigns the result to the
variable. The semantic distinction is that <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt> is intended to declare a variable
changed by the program, whereas <tt><a 
href="symbols.html#x185-2637287r287">defparameter</a></tt> is intended to declare a variable
that is normally constant but can be changed (possibly at run time), where such a
                                                                          

                                                                          
change is considered a change <i>to</i> the program. <tt><a 
href="symbols.html#x185-2637287r287">defparameter</a></tt> therefore does not
indicate that the quantity <i>never</i> changes; in particular, it does not license
the compiler to build assumptions about the value into programs being
compiled.
<tt>
<!--l. 959--><p class="indent" >   <a 
href="symbols.html#x185-2637275r275">defconstant</a></tt> is like <tt><a 
href="symbols.html#x185-2637287r287">defparameter</a></tt> but <i>does</i> assert that the value of the
variable <i>name</i> is ﬁxed and does license the compiler to build assumptions about
the value into programs being compiled. (However, if the compiler chooses to
replace references to the name of the constant by the value of the constant in
code to be compiled, perhaps in order to allow further optimization, the
compiler must take care that such “copies” appear to be <tt><a 
href="symbols.html#x185-2637338r338">eql</a></tt> to the object
that is the actual value of the constant. For example, the compiler may
freely make copies of numbers but must exercise care when the value is a
list.)
<!--l. 970--><p class="indent" >   It is an error if there are any special bindings of the variable at the time the
<tt><a 
href="symbols.html#x185-2637275r275">defconstant</a></tt> form is executed (but implementations may or may not check for
this).
<!--l. 974--><p class="indent" >   Once a name has been declared by <tt><a 
href="symbols.html#x185-2637275r275">defconstant</a></tt> to be constant, any further
assignment to or binding of that special variable is an error. This is the case for
such system-supplied constants as <tt><a 
href="symbols.html#x185-2637871r871">t</a></tt> and <tt><a 
href="symbols.html#x185-2637589r589">most-positive-fixnum</a></tt>. A compiler may
also choose to issue warnings about bindings of the lexical variable of the same
name.
<div class="new">
<!--l. 982--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx40-287001"></a>to clarify the preceding paragraph by specifying
that it is an error to rebind constant symbols as either lexical or special variables.
Consequently, a valid reference to a symbol declared with <tt><a 
href="symbols.html#x185-2637275r275">defconstant</a></tt> always
refers to its global value. (Unfortunately, this violates the principle of referential
transparency, for one cannot always choose names for lexical variables without
regard to surrounding context.)
</div>
<!--l. 994--><p class="indent" >   For any of these constructs, the documentation should be a string. The string
is attached to the name of the variable, parameter, or constant under the
<tt>variable</tt> documentation type; see the <tt><a 
href="symbols.html#x185-2637315r315">documentation</a></tt> function.
<!--l. 1000--><p class="indent" >   The <i>documentation-string</i> is not evaluated but must appear as a literal string
when the <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt>, <tt><a 
href="symbols.html#x185-2637287r287">defparameter</a></tt>, or <tt><a 
href="symbols.html#x185-2637275r275">defconstant</a></tt> form is evaluated.
<!--l. 1004--><p class="indent" >   For example, the form <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(defvar *avoid-registers* nil &#x0022;Compilation control switch #43&#x0022;)
   <br>
<!--l. 1008--><p class="noindent" ></div>
<!--l. 1008--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2880005.3.2" id="x40-2880005.3.2"></a></span>
<!--l. 1008--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2890005.3.2" id="x40-2890005.3.2"></a></span>
</div>
<!--l. 1009--><p class="indent" >   is legitimate, but <div class="lisp"><div class="tabbing">
(defvar *avoid-registers* nil
   <br>                                 (format nil &#x0022;Compilation control switch #~D&#x0022;<br>
          (incf *compiler-switch-number*)))<br>
<!--l. 1014--><p class="noindent" ></div>
<!--l. 1014--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2900005.3.2" id="x40-2900005.3.2"></a></span>
<!--l. 1014--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2910005.3.2" id="x40-2910005.3.2"></a></span>
</div>
<!--l. 1015--><p class="indent" >   is erroneous because the call to <tt><a 
href="symbols.html#x185-2637392r392">format</a></tt> is not a literal string.
<!--l. 1017--><p class="indent" >   (On the other hand, the form <div class="lisp"><div class="tabbing">
(defvar *avoid-registers* nil
   <br>                             #.(format nil &#x0022;Compilation control switch #~D&#x0022;<br>
            (incf *compiler-switch-number*)))<br>
<!--l. 1022--><p class="noindent" ></div>
<!--l. 1022--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2920005.3.2" id="x40-2920005.3.2"></a></span>
                                                                          

                                                                          
<!--l. 1022--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2930005.3.2" id="x40-2930005.3.2"></a></span>
</div>
<!--l. 1023--><p class="indent" >   might be used to accomplish the same purpose, because the call to
<tt><a 
href="symbols.html#x185-2637392r392">format</a></tt> is evaluated at <tt><a 
href="symbols.html#x185-2637717r717">read</a></tt> time; when the <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt> form is evaluated,
only the result of the call to <tt><a 
href="symbols.html#x185-2637392r392">format</a></tt>, a string, appears in the <tt><a 
href="symbols.html#x185-2637292r292">defvar</a></tt>
form.)
<!--l. 1028--><p class="indent" >   These constructs are normally used only as top-level forms. The value returned
by each of these constructs is the <i>name</i> declared.
</div>
<!--l. 1032--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.3.3   </span> <a 
href="frontmatter.html#QQ2-40-302" id="x40-2940005.3.3">Control of Time of Evaluation</a></h4>
<div class="defspec">
<div class="defmacheader">
<!--l. 1035--><p class="noindent" ><div class="tabbing">
 <i>[Special operator]</i> <b>eval-when</b> <a 
 id="dx40-294001"></a><a 
 id="x40-294002r17"></a> ({situation}*) {form}*
   <br>
<!--l. 1036--><p class="noindent" ></div>
<!--l. 1036--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2950005.3.3" id="x40-2950005.3.3"></a></span>
</div>
<!--l. 1037--><p class="noindent" >The body of an <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> form is processed as an implicit <tt><a 
href="symbols.html#x185-2637700r700">progn</a></tt>, but only in the
situations listed. Each <i>situation</i> must be a symbol, either <tt>:compile-toplevel</tt>,
<tt>:load-toplevel</tt>, or <tt>:execute</tt>.
<!--l. 1042--><p class="indent" >   The use of <tt>:compile-toplevel</tt> and <tt>:load-toplevel</tt> controls whether and
when processing occurs for top-level forms. The use of <tt>:execute</tt> controls whether
processing occurs for non-top-level forms.
<!--l. 1047--><p class="indent" >   The <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> construct may be more precisely understood in terms of a
model of how the ﬁle compiler, <tt><a 
href="symbols.html#x185-2637232r232">compile-file</a></tt>, processes forms in a ﬁle to be
compiled.
<!--l. 1051--><p class="indent" >   Successive forms are read from the ﬁle by the ﬁle compiler using <tt><a 
href="symbols.html#x185-2637717r717">read</a></tt>. These
top-level forms are normally processed in what we call “not-compile-time” mode.
There is one other mode, called “compile-time-too” mode, which can come into
play for top-level forms. The <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> special operator is used to annotate a
                                                                          

                                                                          
program in a way that allows the program doing the processing to select the
appropriate mode.
<!--l. 1059--><p class="indent" >   Processing of top-level forms in the ﬁle compiler works as follows:
      <ul class="itemize1">
      <li class="itemize">If the form is a macro call, it is expanded and the result is processed
      as a top-level form in the same processing mode (compile-time-too or
      not-compile-time).
      </li>
      <li class="itemize">If the form is a <tt><a 
href="symbols.html#x185-2637700r700">progn</a></tt> (or <tt><a 
href="symbols.html#x185-2637501r501">locally</a></tt> <a 
 id="dx40-295001"></a>) form, each of its body forms is
      sequentially processed as top-level forms in the same processing mode.
      </li>
      <li class="itemize">If the form is a <tt>compiler-let</tt>, <tt><a 
href="symbols.html#x185-2637532r532">macrolet</a></tt>, or <tt><a 
href="symbols.html#x185-2637864r864">symbol-macrolet</a></tt>, the ﬁle
      compiler makes the appropriate bindings and recursively processes the
      body forms as an implicit top-level <tt><a 
href="symbols.html#x185-2637700r700">progn</a></tt> with those bindings in eﬀect,
      in the same processing mode.
      </li>
      <li class="itemize">If the form is an <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> form, it is handled according to the following
      table:
      <div class="flushleft" 
>
<!--l. 1079--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" > LT</td><td align="left" >CT</td><td align="left" >EX</td><td align="left" >CTTM</td><td align="left" >Action                                           </td></tr><tr><td align="left" > yes</td> <td align="left" >yes</td> <td align="left" > – </td> <td align="left" > – </td> <td align="left" >process body in compile-time-too mode</td>
</tr><tr><td align="left" > yes</td><td align="left" > no </td><td align="left" >yes</td><td align="left" >   yes   </td><td align="left" >process body in compile-time-too mode</td>
</tr><tr><td align="left" > yes</td><td align="left" > no </td><td align="left" > – </td><td align="left" >   no   </td><td align="left" >process body in not-compile-time mode</td>
</tr><tr><td align="left" > yes</td><td align="left" > no </td><td align="left" > no </td><td align="left" >    –    </td><td align="left" >process body in not-compile-time mode</td>
</tr><tr><td align="left" > no</td><td align="left" >yes</td><td align="left" > – </td><td align="left" >    –    </td><td align="left" >evaluate body                                 </td>
</tr><tr><td align="left" > no</td><td align="left" > no </td><td align="left" >yes</td><td align="left" >   yes   </td><td align="left" >evaluate body                                 </td>
</tr><tr><td align="left" > no</td><td align="left" > no </td><td align="left" > – </td><td align="left" >   no   </td><td align="left" >do nothing                                      </td>
</tr><tr><td align="left" > no</td><td align="left" > no </td><td align="left" > no </td><td align="left" >    –    </td><td align="left" >do nothing                                      </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" >  </td>
</tr></table></div></div>
      <!--l. 1093--><p class="noindent" >In the preceding table the column LT asks whether <tt>:load-toplevel</tt> is one
      of the situations speciﬁed in the <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> form; CT similarly refers to
      <tt>:compile-toplevel</tt> and EX to <tt>:execute</tt>. The column CTTM asks whether
      the <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> form was encountered while in compile-time-too mode. The
      phrase “process body” means to process the body as an implicit top-level
                                                                          

                                                                          
      <tt><a 
href="symbols.html#x185-2637700r700">progn</a></tt> in the indicated mode, and “evaluate body” means to evaluate the
      body forms sequentially as an implicit <tt><a 
href="symbols.html#x185-2637700r700">progn</a></tt> in the dynamic execution
      context of the compiler and in the lexical environment in which the
      <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> appears.
      </li>
      <li class="itemize">Otherwise, the form is a top-level form that is not one of the special cases. If
      in compile-time-too mode, the compiler ﬁrst evaluates the form and then
      performs normal compiler processing on it. If in not-compile-time mode,
      only normal compiler processing is performed (see section <a 
href="clmse121.html#x150-198200024.1">24.1<!--tex4ht:ref: COMPILER-SECTION --></a>). Any
      subforms are treated as non-top-level forms.</li></ul>
<!--l. 1112--><p class="indent" >   Note that top-level forms are guaranteed to be processed in the order in which
they textually appear in the ﬁle, and that each top-level form read by the
compiler is processed before the next is read. However, the order of processing
(including, in particular, macro expansion) of subforms that are not top-level
forms is unspeciﬁed.
<!--l. 1118--><p class="indent" >   For an <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> form that is not a top-level form in the ﬁle compiler (that
is, either in the interpreter, in <tt><a 
href="symbols.html#x185-2637231r231">compile</a></tt>, or in the ﬁle compiler but not at top
level), if the <tt>:execute</tt> situation is speciﬁed, its body is treated as an implicit
<tt><a 
href="symbols.html#x185-2637700r700">progn</a></tt>. Otherwise, the body is ignored and the <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> form has the value
<tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>.
<!--l. 1124--><p class="indent" >   For the sake of backward compatibility, a <i>situation</i> may also be <tt><a 
href="symbols.html#x185-2637231r231">compile</a></tt>,
<tt><a 
href="symbols.html#x185-2637498r498">load</a></tt>, or <tt><a 
href="symbols.html#x185-2637343r343">eval</a></tt>. Within a top-level <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> form these have the same meaning
as <tt>:compile-toplevel</tt>, <tt>:load-toplevel</tt>, and <tt>:execute</tt>, respectively; but their
eﬀect is undeﬁned when used in an <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> form that is not at top
level.
<!--l. 1131--><p class="indent" >   The following eﬀects are logical consequences of the preceding speciﬁcation:
      <ul class="itemize1">
      <li class="itemize">It is never the case that the execution of a single <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> expression
      will execute the body code more than once.
      </li>
      <li class="itemize">The old keyword <tt><a 
href="symbols.html#x185-2637343r343">eval</a></tt> was a misnomer because execution of the body need
      not be done by <tt><a 
href="symbols.html#x185-2637343r343">eval</a></tt>. For example, when the function deﬁnition
      <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
      (defun foo () (eval-when (:execute) (print &#x2019;foo)))
      <br>
      <!--l. 1142--><p class="noindent" ></div>
      <!--l. 1142--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2960005.3.3" id="x40-2960005.3.3"></a></span>
      <!--l. 1142--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2970005.3.3" id="x40-2970005.3.3"></a></span>
</div>
      <!--l. 1143--><p class="noindent" >is compiled the call to <tt><a 
href="symbols.html#x185-2637690r690">print</a></tt> should be compiled, not evaluated at compile
      time.
      </li>
      <li class="itemize">Macros intended for use in top-level forms should arrange for all side-eﬀects
      to be done by the forms in the macro expansion. The macro-expander itself
      should not perform the side-eﬀects.
<div class="lisp">
      <!--l. 1150--><p class="noindent" ><div class="tabbing">
      (defmacro foo ()
      <br>                   (really-foo)                              ;Wrong<br>
             ‘(really-foo))<br>                                                <br>
           (defmacro foo ()<br>                  ‘(eval-when (:compile-toplevel<br>
                          :load-toplevel :execute)     ;Right<br>
               (really-foo)))<br>
      <!--l. 1159--><p class="noindent" ></div>
      <!--l. 1159--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2980005.3.3" id="x40-2980005.3.3"></a></span>
                                                                          

                                                                          
      <!--l. 1159--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-2990005.3.3" id="x40-2990005.3.3"></a></span>
</div>
      <!--l. 1161--><p class="noindent" >Adherence to this convention will mean that such macros will behave
      intuitively when called in non-top-level positions.
      </li>
      <li class="itemize">Placing a variable binding around an <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> reliably captures the
      binding because the “compile-time-too” mode cannot occur (because the
      <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> could not be a top-level form). For example, <div class="lisp"><div class="tabbing">
      (let ((x 3))
      <br>                     (eval-when (:compile-toplevel :load-toplevel :execute)<br>
               (print x)))<br>
      <!--l. 1173--><p class="noindent" ></div>
      <!--l. 1173--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3000005.3.3" id="x40-3000005.3.3"></a></span>
      <!--l. 1173--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3010005.3.3" id="x40-3010005.3.3"></a></span>
</div>
      <!--l. 1174--><p class="noindent" >will print 3 at execution (that is, load) time and will not print anything at
      compile time. This is important so that expansions of <tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt> and <tt><a 
href="symbols.html#x185-2637284r284">defmacro</a></tt>
      can be done in terms of <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> and can correctly capture the lexical
      environment. For example, an implementation might expand a <tt><a 
href="symbols.html#x185-2637291r291">defun</a></tt> form
      such as <div class="lisp"><div class="tabbing">
      (defun bar (x) (defun foo () (+ x 3)))
      <br>
      <!--l. 1182--><p class="noindent" ></div>
                                                                          

                                                                          
      <!--l. 1182--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3020005.3.3" id="x40-3020005.3.3"></a></span>
      <!--l. 1182--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3030005.3.3" id="x40-3030005.3.3"></a></span>
</div>
      <!--l. 1183--><p class="noindent" >into <div class="lisp"><div class="tabbing">
      (progn (eval-when (:compile-toplevel)
      <br>                                       (compiler::notice-function &#x2019;bar &#x2019;(x)))<br>
                  (eval-when (:load-toplevel :execute)<br>
                    (setf (symbol-function &#x2019;bar)<br>
                          #&#x2019;(lambda (x)<br>                         (progn (eval-when (:compile-toplevel)<br>
                                       (compiler::notice-function &#x2019;foo<br>
                                                                  &#x2019;()))<br>
                                     (eval-when (:load-toplevel :execute)<br>
                                       (setf (symbol-function &#x2019;foo)<br>
                                             #&#x2019;(lambda () (+ x 3)))))))))<br>
      <!--l. 1196--><p class="noindent" ></div>
      <!--l. 1196--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3040005.3.3" id="x40-3040005.3.3"></a></span>
      <!--l. 1196--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3050005.3.3" id="x40-3050005.3.3"></a></span>
</div>
      <!--l. 1197--><p class="noindent" >which by the preceding rules would be treated the same as <div class="lisp"><div class="tabbing">
      (progn (eval-when (:compile-toplevel)
                                                                          

                                                                          
      <br>                                       (compiler::notice-function &#x2019;bar &#x2019;(x)))<br>
                  (eval-when (:load-toplevel :execute)<br>
                    (setf (symbol-function &#x2019;bar)<br>
                          #&#x2019;(lambda (x)<br>                         (progn (eval-when (:load-toplevel :execute)<br>
                                       (setf (symbol-function &#x2019;foo)<br>
                                             #&#x2019;(lambda () (+ x 3)))))))))<br>
      <!--l. 1207--><p class="noindent" ></div>
      <!--l. 1207--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3060005.3.3" id="x40-3060005.3.3"></a></span>
      <!--l. 1207--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3070005.3.3" id="x40-3070005.3.3"></a></span>
</div>
      </li></ul>
<!--l. 1211--><p class="indent" >   Here are some additional examples. <div class="lisp"><div class="tabbing">
(let ((x 1))
   <br>                        (eval-when (:execute :load-toplevel :compile-toplevel)<br>
    (setf (symbol-function &#x2019;foo1) #&#x2019;(lambda () x))))<br>
<!--l. 1216--><p class="noindent" ></div>
<!--l. 1216--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3080005.3.3" id="x40-3080005.3.3"></a></span>
<!--l. 1216--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3090005.3.3" id="x40-3090005.3.3"></a></span>
</div>
<!--l. 1217--><p class="indent" >   The <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt> in the preceding expression is not at top level, so
only the <tt>:execute</tt> keyword is considered. At compile time, this has no
eﬀect. At load time (if the <tt><a 
href="symbols.html#x185-2637488r488">let</a></tt> is at top level), or at execution time (if
the <tt><a 
href="symbols.html#x185-2637488r488">let</a></tt> is embedded in some other form which does not execute until
later), this sets <tt>(symbol-function &#x2019;foo1)</tt> to a function that returns <tt>1</tt>.
<div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(eval-when (:execute :load-toplevel :compile-toplevel)
   <br>   (let ((x 2))<br>     (eval-when (:execute :load-toplevel :compile-toplevel)<br>
      (setf (symbol-function &#x2019;foo2) #&#x2019;(lambda () x)))))<br>
<!--l. 1229--><p class="noindent" ></div>
<!--l. 1229--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3100005.3.3" id="x40-3100005.3.3"></a></span>
<!--l. 1229--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3110005.3.3" id="x40-3110005.3.3"></a></span>
</div>
<!--l. 1231--><p class="indent" >   If the preceding expression occurs at the top level of a ﬁle to be compiled, it
has <i>both</i> a compile time <i>and</i> a load-time eﬀect of setting <tt>(symbol-function
&#x2019;foo2)</tt> to a function that returns <tt>2</tt>. <div class="lisp"><div class="tabbing">
(eval-when (:execute :load-toplevel :compile-toplevel)
   <br>                                (setf (symbol-function &#x2019;foo3) #&#x2019;(lambda () 3)))<br>
<!--l. 1237--><p class="noindent" ></div>
<!--l. 1237--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3120005.3.3" id="x40-3120005.3.3"></a></span>
<!--l. 1237--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3130005.3.3" id="x40-3130005.3.3"></a></span>
</div>
<!--l. 1238--><p class="indent" >   If the preceding expression occurs at the top level of a ﬁle to be compiled, it
has <i>both</i> a compile time <i>and</i> a load-time eﬀect of setting the function cell of <tt>foo3</tt>
to a function that returns <tt>3</tt>. <div class="lisp"><div class="tabbing">
(eval-when (:compile-toplevel)
   <br>                                                       (eval-when (:compile-toplevel)<br>
    (print &#x2019;foo4)))<br>
<!--l. 1246--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1246--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3140005.3.3" id="x40-3140005.3.3"></a></span>
<!--l. 1246--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3150005.3.3" id="x40-3150005.3.3"></a></span>
</div>
<!--l. 1247--><p class="indent" >   The preceding expression always does nothing; it simply returns <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>.
<div class="lisp">
<!--l. 1249--><p class="indent" >   <div class="tabbing">
(eval-when (:compile-toplevel)
   <br>                                                                  (eval-when (:execute)<br>
    (print &#x2019;foo5)))<br>
<!--l. 1253--><p class="noindent" ></div>
<!--l. 1253--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3160005.3.3" id="x40-3160005.3.3"></a></span>
<!--l. 1253--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3170005.3.3" id="x40-3170005.3.3"></a></span>
</div>
<!--l. 1254--><p class="indent" >   If the preceding form occurs at the top level of a ﬁle to be compiled, <tt>foo5</tt> is
printed at compile time. If this form occurs in a non-top-level position, nothing is
printed at compile time. Regardless of context, nothing is ever printed at load
time or execution time.
<div class="lisp">
<!--l. 1260--><p class="indent" >   <div class="tabbing">
(eval-when (:execute :load-toplevel)
   <br>                                                       (eval-when (:compile-toplevel)<br>
    (print &#x2019;foo6)))<br>
<!--l. 1264--><p class="noindent" ></div>
<!--l. 1264--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3180005.3.3" id="x40-3180005.3.3"></a></span>
                                                                          

                                                                          
<!--l. 1264--><p class="noindent" ><span class="paragraphHead"><a 
href="#x40-3190005.3.3" id="x40-3190005.3.3"></a></span>
</div>
<!--l. 1266--><p class="indent" >   If the preceding form occurs at the top level of a ﬁle to be compiled, <tt>foo6</tt> is
printed at compile time. If this form occurs in a non-top-level position, nothing is
printed at compile time. Regardless of context, nothing is ever printed at load
time or execution time.
</div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
<!--l. 8--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="preds.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse29.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse29.html#tailclmse29.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse30.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html#clmse30.html" >Up</a><tt>&#x003E;</tt></div><a 
 id="tailclmse30.html"></a>   </div> </div> 
</body></html> 
