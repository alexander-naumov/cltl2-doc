<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Forms</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:21:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 25--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse29.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html#tailprogs.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse28.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html#clmse28.html" >Up</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
href="clm.html#QQ2-38-241" id="x38-2340005.1">Forms</a></h3>
<!--l. 27--><p class="noindent" >The standard unit of interaction with a Common Lisp implementation is the
<i>form</i>, which is simply a data object meant to be <i>evaluated</i> as a program to
produce one or more <i>values</i> (which are also data objects). One may request
evaluation of <i>any</i> data object, but only certain ones are meaningful. For instance,
                                                                          

                                                                          
symbols and lists are meaningful forms, while arrays normally are not. Examples
of meaningful forms are <tt>3</tt>, whose value is <tt>3</tt>, and <tt>(+ 3 4)</tt>, whose value is <tt>7</tt>. We
write <tt>3</tt> <span class="math"> ⇒</span> <tt>3</tt> and <tt>(+ 3 4)</tt> <span class="math"> ⇒</span> <tt>7</tt> to indicate these facts. (<span class="math"> ⇒</span> means “evaluates
to.”)
<!--l. 38--><p class="indent" >   Meaningful forms may be divided into three categories: self-evaluating forms,
such as numbers; symbols, which stand for variables; and lists. The lists in turn
may be divided into three categories: special operators, macro calls, and function
calls.
<i>
<!--l. 43--><p class="indent" >   All</i> standard Common Lisp data objects other than symbols and lists
(including <tt><a 
href="symbols.html#x185-2637289r289">defstruct</a></tt> structures deﬁned without the <tt>:type</tt> option) are
self-evaluating.
<!--l. 47--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.1   </span> <a 
href="frontmatter.html#QQ2-38-242" id="x38-2350005.1.1">Self-Evaluating Forms</a></h4>
<!--l. 49--><p class="noindent" >All numbers, characters, strings, and bit-vectors are <i>self-evaluating</i> forms. When
such an object is evaluated, that object (or possibly a copy in the case of numbers
or characters) is returned as the value of the form. The empty list (), which is also
the false value <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>, is also a self-evaluating form: the value of <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> is <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>.
Keywords (symbols written with a leading colon) also evaluate to themselves: the
value of <tt>:start</tt> is <tt>:start</tt>.
<!--l. 59--><p class="indent" >   It is an error to destructively modify any object that appears as a constant in
executable code, whether as a self-evaluating form or within a <tt><a 
href="symbols.html#x185-2637707r707">quote</a></tt> special
operator.
<!--l. 63--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.2   </span> <a 
href="frontmatter.html#QQ2-38-243" id="x38-2360005.1.2">Variables</a></h4>
<!--l. 65--><p class="noindent" >Symbols are used as names of variables in Common Lisp programs. When
a symbol is evaluated as a form, the value of the variable it names is
produced. For example, after doing <tt>(setq items 3)</tt>, which assigns the
value <tt>3</tt> to the variable named <tt>items</tt>, then <tt>items</tt> <span class="math"> ⇒</span> <tt>3</tt>. Variables can be
<i>assigned</i> to, as by <tt><a 
href="symbols.html#x185-2637779r779">setq</a></tt>, or <i>bound</i>, as by <tt><a 
href="symbols.html#x185-2637488r488">let</a></tt>. Any program construct that
binds a variable eﬀectively saves the old value of the variable and causes
it to have a new value, and on exit from the construct the old value is
reinstated.
                                                                          

                                                                          
<!--l. 75--><p class="indent" >   There are actually two kinds of variables in Common Lisp, called <i>lexical</i> (or
<i>static</i>) variables and <i>special</i> (or <i>dynamic</i>) variables. At any given time
either or both kinds of variable with the same name may have a current
value. Which of the two kinds of variable is referred to when a symbol is
evaluated depends on the context of the evaluation. The general rule is that
if the symbol occurs textually within a program construct that creates
a <i>binding</i> for a variable of the same name, then the reference is to the
variable speciﬁed by the binding; if no such program construct textually
contains the reference, then it is taken to refer to the special variable of that
name.
<!--l. 86--><p class="indent" >   The distinction between the two kinds of variable is one of scope and extent. A
lexically bound variable can be referred to <i>only</i> by forms occurring at any <i>place</i>
textually within the program construct that binds the variable. A dynamically
bound (special) variable can be referred to at any <i>time</i> from the time the binding
is made until the time evaluation of the construct that binds the variable
terminates. Therefore lexical binding of variables imposes a spatial limitation on
occurrences of references (but no temporal limitation, for the binding continues to
exist as long as the possibility of reference remains). Conversely, dynamic binding
of variables imposes a temporal limitation on occurrences of references (but
no spatial limitation). For more information on scope and extent, see
chapter <a 
href="scope.html#x25-1220003">3<!--tex4ht:ref: SCOPE --></a>.
<!--l. 100--><p class="indent" >   The value a special variable has when there are currently no bindings of that
variable is called the <i>global</i> value of the (special) variable. A global value can be
given to a variable only by assignment, because a value given by binding is by
deﬁnition not global.
<!--l. 106--><p class="indent" >   It is possible for a special variable to have no value at all, in which case it is
said to be <i>unbound</i>. By default, every global variable is unbound unless and until
explicitly assigned a value, except for those global variables deﬁned in this book or
by the implementation already to have values when the Lisp system is ﬁrst
started. It is also possible to establish a binding of a special variable and then
cause that binding to be valueless by using the function <tt><a 
href="symbols.html#x185-2637555r555">makunbound</a></tt>. In this
situation the variable is also said to be “unbound,” although this is a misnomer;
precisely speaking, it is bound but valueless. It is an error to refer to a variable
that is unbound.
<!--l. 119--><p class="indent" >   Reading an unbound variable or an undeﬁned function must be detected in the
highest safety setting (see the <tt>safety</tt> quality of the <tt>optimize</tt> declaration
speciﬁer) but the eﬀect is undeﬁned in any other safety setting. That
is, reading an unbound variable should signal an error and reading an
                                                                          

                                                                          
undeﬁned function should signal an error. (“Reading a function” includes both
references to the function using the <tt><a 
href="symbols.html#x185-2637399r399">function</a></tt> special operator, such as <tt><a 
href="symbols.html#x185-2637351r351">f</a></tt>
in <tt>(function f)</tt>, and references to the function in a call, such as <tt><a 
href="symbols.html#x185-2637351r351">f</a></tt> in
<tt>(f x y)</tt>.)
<!--l. 130--><p class="indent" >   For the case of <tt>inline</tt> functions (in implementations where they are
supported), a permitted point of view is that performing the inlining constitutes
the read of the function, so that an <tt><a 
href="symbols.html#x185-2637352r352">fboundp</a></tt> check need not be done at
execution time. Put another way, the eﬀect of the application of <tt><a 
href="symbols.html#x185-2637389r389">fmakunbound</a></tt>
to a function name on potentially inlined references to that function is
undeﬁned.
<!--l. 138--><p class="indent" >   When an unbound variable is detected an error of type <tt><a 
href="symbols.html#x185-2637897r897">unbound-variable</a></tt> is
signaled, and the <tt>name</tt> slot of the <tt><a 
href="symbols.html#x185-2637897r897">unbound-variable</a></tt> condition is initialized to
the name of the oﬀending variable.
<!--l. 144--><p class="indent" >   When an undeﬁned function is detected an error of type <tt><a 
href="symbols.html#x185-2637898r898">undefined-function</a></tt>
is signaled, and the <tt>name</tt> slot of the <tt><a 
href="symbols.html#x185-2637898r898">undefined-function</a></tt> condition is initialized
to the name of the oﬀending function.
<!--l. 150--><p class="indent" >   The condition type <tt>unbound-slot</tt>, which inherits from <tt><a 
href="symbols.html#x185-2637191r191">cell-error</a></tt>, has an
additional slot <tt>instance</tt>, which can be initialized using the <tt>:instance</tt> keyword
to <tt><a 
href="symbols.html#x185-2637536r536">make-condition</a></tt>. The function <tt>unbound-slot-instance</tt> accesses this
slot.
<!--l. 155--><p class="indent" >   The type of error signaled by the default primary method for the CLOS
<tt><a 
href="symbols.html#x185-2637809r809">slot-unbound</a></tt> generic function is <tt>unbound-slot</tt>. The <tt>instance</tt> slot of the
<tt>unbound-slot</tt> condition is initialized to the oﬀending instance and the <tt>name</tt> slot
is initialized to the name of the oﬀending variable.
<!--l. 162--><p class="indent" >   Certain global variables are reserved as “named constants.” They have a global
value and may not be bound or assigned to. For example, the symbols <tt><a 
href="symbols.html#x185-2637871r871">t</a></tt> and <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>
are reserved. One may not assign a value to <tt><a 
href="symbols.html#x185-2637871r871">t</a></tt> or <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>, and one may not bind <tt><a 
href="symbols.html#x185-2637871r871">t</a></tt> or
<tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>. The global value of <tt><a 
href="symbols.html#x185-2637871r871">t</a></tt> is always <tt><a 
href="symbols.html#x185-2637871r871">t</a></tt>, and the global value of <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> is always <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt>.
Constant symbols deﬁned by <tt><a 
href="symbols.html#x185-2637275r275">defconstant</a></tt> also become reserved and may not be
further assigned to or bound (although they may be redeﬁned, if necessary, by
using <tt><a 
href="symbols.html#x185-2637275r275">defconstant</a></tt> again). Keyword symbols, which are notated with a leading
colon, are reserved and may never be assigned to or bound; a keyword always
evaluates to itself.
<!--l. 177--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.3   </span> <a 
href="frontmatter.html#QQ2-38-244" id="x38-2370005.1.3">Special Forms</a></h4>
                                                                          

                                                                          
<!--l. 179--><p class="noindent" >If a list is to be evaluated as a form, the ﬁrst step is to examine the ﬁrst element
of the list. If the ﬁrst element is one of the symbols appearing in table <a 
href="#x38-2370011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>, then
the list is called a <i>special operator</i>. (This use of the word “special” is unrelated to
its use in the phrase “special variable.”)
<!--l. 185--><p class="indent" >   Special forms are generally environment and control constructs. Every special
operator has its own idiosyncratic syntax. An example is the <tt><a 
href="symbols.html#x185-2637435r435">if</a></tt> special operator:
<tt>(if p (+ x 4) 5)</tt> in Common Lisp means what “<b>if</b> <i>p</i> <b>then</b> <i>x</i>+4 <b>else</b> 5” means
in Algol.
<!--l. 192--><p class="indent" >   The evaluation of a special operator normally produces a value or values, but
the evaluation may instead call for a non-local exit; see <tt><a 
href="symbols.html#x185-2637752r752">return-from</a></tt>, <tt><a 
href="symbols.html#x185-2637423r423">go</a></tt>, and
<tt>throw</tt>.
<!--l. 196--><p class="indent" >   The set of special operators is ﬁxed in Common Lisp; no way is provided for
the user to deﬁne more. The user can create new syntactic constructs, however, by
deﬁning macros.
<!--l. 200--><p class="indent" >   The set of special operators in Common Lisp is purposely kept very small
because any program-analyzing program must have special knowledge
about every type of special operator. Such a program needs no special
knowledge about macros because it is simple to expand the macro and
operate on the resulting expansion. (This is not to say that many such
programs, particularly compilers, will not have such special knowledge. A
compiler may be able to produce much better code if it recognizes such
constructs as <tt><a 
href="symbols.html#x185-2637895r895">typecase</a></tt> and <tt><a 
href="symbols.html#x185-2637595r595">multiple-value-bind</a></tt> and gives them customized
treatment.)
   <div class="table">
                                                                          

                                                                          
<!--l. 211--><p class="indent" >   <a 
 id="x38-2370011"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 5.1: </span><span  
class="content">Names of All Common Lisp Special Forms</span></div><!--tex4ht:label?: x38-2370011 -->
<div class="tabular"><table width="100%" class="tabular"><tr><td align="left" > <tt><a 
href="symbols.html#x185-2637128r128">block</a></tt>    </td><td align="left" ><tt><a 
href="symbols.html#x185-2637435r435">if</a></tt>                  </td><td align="left" ><tt><a 
href="symbols.html#x185-2637702r702">progv</a></tt>          </td>
</tr><tr><td align="left" > <tt>catch</tt>    </td><td align="left" ><tt><a 
href="symbols.html#x185-2637461r461">labels</a></tt>              </td><td align="left" ><tt><a 
href="symbols.html#x185-2637707r707">quote</a></tt>          </td>
</tr><tr><td align="left" >               </td><td align="left" ><tt><a 
href="symbols.html#x185-2637488r488">let</a></tt>                 </td><td align="left" ><tt><a 
href="symbols.html#x185-2637752r752">return-from</a></tt>    </td></tr><tr><td align="left" > <tt><a 
href="symbols.html#x185-2637271r271">declare</a></tt> </td><td align="left" ><tt><a 
href="symbols.html#x185-2637489r489">let*</a></tt> </td><td align="left" ><tt><a 
href="symbols.html#x185-2637779r779">setq</a></tt></td>
</tr><tr><td align="left" > <tt><a 
href="symbols.html#x185-2637344r344">eval-when</a></tt></td><td align="left" ><tt><a 
href="symbols.html#x185-2637532r532">macrolet</a></tt>            </td><td align="left" ><tt><a 
href="symbols.html#x185-2637872r872">tagbody</a></tt>        </td>
</tr><tr><td align="left" > <tt><a 
href="symbols.html#x185-2637379r379">flet</a></tt>     </td><td align="left" ><tt><a 
href="symbols.html#x185-2637596r596">multiple-value-call</a></tt> </td><td align="left" ><tt><a 
href="symbols.html#x185-2637878r878">the</a></tt>            </td>
</tr><tr><td align="left" > <tt><a 
href="symbols.html#x185-2637399r399">function</a></tt> </td><td align="left" ><tt><a 
href="symbols.html#x185-2637598r598">multiple-value-prog1</a></tt></td><td align="left" ><tt>throw</tt>          </td>
</tr><tr><td align="left" > <tt><a 
href="symbols.html#x185-2637423r423">go</a></tt>       </td><td align="left" ><tt><a 
href="symbols.html#x185-2637700r700">progn</a></tt>               </td><td align="left" ><tt><a 
href="symbols.html#x185-2637908r908">unwind-protect</a></tt> </td>
</tr><tr><td align="left" >               </td><td align="left" >                        </td><td align="left" ><tt><a 
href="symbols.html#x185-2637864r864">symbol-macrolet</a></tt></td>
</tr><tr><td align="left" >               </td><td align="left" ><tt><a 
href="symbols.html#x185-2637501r501">locally</a></tt>             </td><td align="left" ><tt><a 
href="symbols.html#x185-2637500r500">load-time-value</a></tt></td></tr></table>
</div>
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<!--l. 229--><p class="indent" >   An implementation is free to implement as a macro any construct described
herein as a special operator. Conversely, an implementation is free to implement
as a special operator any construct described herein as a macro if an equivalent
macro deﬁnition is also provided. The practical consequence is that the predicates
<tt><a 
href="symbols.html#x185-2637529r529">macro-function</a></tt> and <tt><a 
href="symbols.html#x185-2637816r816">special-operator-p</a></tt> may both be true of the same symbol.
It is recommended that a program-analyzing program process a form that is a list
whose <i>car</i> is a symbol as follows:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x38-237003x1">If the program has particular knowledge about the symbol, process the
      form using special-purpose code. All of the symbols listed in table <a 
href="#x38-2370011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>
      should fall into this category.
      </li>
      <li 
  class="enumerate" id="x38-237005x2">Otherwise,  if  <tt><a 
href="symbols.html#x185-2637529r529">macro-function</a></tt> is  true  of  the  symbol,  apply  either
      <tt><a 
href="symbols.html#x185-2637530r530">macroexpand</a></tt> or <tt><a 
href="symbols.html#x185-2637531r531">macroexpand-1</a></tt>, as appropriate, to the entire form and
      then start over.
      </li>
      <li 
  class="enumerate" id="x38-237007x3">Otherwise, assume it is a function call.</li></ol>
   <h4 class="subsectionHead"><span class="titlemark">5.1.4   </span> <a 
href="frontmatter.html#QQ2-38-246" id="x38-2380005.1.4">Macros</a></h4>
<!--l. 256--><p class="noindent" >If a form is a list and the ﬁrst element is not the name of a special form, it may be
the name of a <i>macro</i>; if so, the form is said to be a <i>macro call</i>. A macro is
essentially a function from forms to forms that will, given a call to that macro,
compute a new form to be evaluated in place of the macro call. (This computation
is sometimes referred to as <i>macro expansion</i>.) For example, the macro named
<tt><a 
href="symbols.html#x185-2637751r751">return</a></tt> will take a form such as <tt>(return x)</tt> and from that form compute a
new form <tt>(return-from <tt><a 
href="symbols.html#x185-2637609r609">nil</a></tt> x)</tt>. We say that the old form <i>expands</i> into
the new form. The new form is then evaluated in place of the original
form; the value of the new form is returned as the value of the original
form.
<!--l. 269--><p class="indent" >   Macro calls, and subforms of macro calls, need not be proper lists, but that
use of dotted forms requires the macro deﬁnition to use “<tt>. <i>var</i></tt>” or “<tt>&#x0026;rest <i>var</i></tt>”
in order to match them properly. It is then the responsibility of the macro
                                                                          

                                                                          
deﬁnition to recognize and appropriately handle such dotted forms or
subforms.
<!--l. 276--><p class="indent" >   There are a number of standard macros in Common Lisp, and the user can
deﬁne more by using <tt><a 
href="symbols.html#x185-2637284r284">defmacro</a></tt>.
<!--l. 279--><p class="indent" >   Macros provided by a Common Lisp implementation as described herein may
expand into code that is not portable among diﬀering implementations. That is, a
macro call may be implementation-independent because the macro is deﬁned in
this book, but the expansion need not be._________________________________<div class="implementation">
<!--l. 285--><p class="noindent" ><b>Implementation note:</b> Implementors are encouraged to implement the macros deﬁned
in this book, as far as is possible, in such a way that the expansion will not contain any
implementation-dependent special operators, nor contain as forms data objects that are
not considered to be forms in Common Lisp. The purpose of this restriction is to
ensure that the expansion can be processed by a program-analyzing program in
an implementation-independent manner. There is no problem with a macro
expansion containing calls to implementation-dependent functions. This restriction
is not a requirement of Common Lisp; it is recognized that certain complex
macros may be able to expand into signiﬁcantly more eﬃcient code in certain
implementations by using implementation-dependent special operators in the macro
expansion.
</div>___________________________________________________________________________________________________________
<!--l. 303--><p class="noindent" >
     <h4 class="subsectionHead"><span class="titlemark">5.1.5   </span> <a 
href="frontmatter.html#QQ2-38-247" id="x38-2390005.1.5">Function Calls</a></h4>
<!--l. 305--><p class="noindent" >If a list is to be evaluated as a form and the ﬁrst element is not a symbol that
names a special operator or macro, then the list is assumed to be a <i>function call</i>.
The ﬁrst element of the list is taken to name a function. Any and all remaining
elements of the list are forms to be evaluated; one value is obtained from each
form, and these values become the <i>arguments</i> to the function. The function is
then <i>applied</i> to the arguments. The functional computation normally produces a
value, but it may instead call for a non-local exit; see <tt>throw</tt>. A function that does
return may produce no value or several values; see <tt><a 
href="symbols.html#x185-2637917r917">values</a></tt>. If and when the
function returns, whatever values it returns become the values of the function-call
form.
<!--l. 320--><p class="indent" >     For example, consider the evaluation of the form <tt>(+ 3 (* 4 5))</tt>. The symbol
<tt><a 
href="symbols.html#x185-2637051r51">+</a></tt> names the addition function, not a special operator or macro. Therefore the two
forms <tt>3</tt> and <tt>(* 4 5)</tt> are evaluated to produce arguments. The form <tt>3</tt> evaluates
                                                                          

                                                                          
to <tt>3</tt>, and the form <tt>(* 4 5)</tt> is a function call (to the multiplication function).
Therefore the forms <tt>4</tt> and <tt>5</tt> are evaluated, producing arguments <tt>4</tt> and <tt>5</tt> for the
multiplication. The multiplication function calculates the number <tt>20</tt> and returns
it. The values <tt>3</tt> and <tt>20</tt> are then given as arguments to the addition function,
which calculates and returns the number <tt>23</tt>. Therefore we say <tt>(+ 3 (* 4 5))
<span class="math"> ⇒</span> 23</tt>.
<!--l. 331--><p class="indent" >   While the arguments in a function call are always evaluated in strict
left-to-right order, whether the function to be called is determined before or after
argument evaluation is unspeciﬁed. Programs are in error that rely on a particular
order of evaluation of the ﬁrst element of a function call relative to the argument
forms.
                                                                          

                                                                          
<!--l. 339--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse29.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html#tailprogs.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="progs.html#clmse28.html" >Up</a><tt>&#x003E;</tt></div><a 
 id="tailclmse28.html"></a>  </div> </div> 
</body></html> 
