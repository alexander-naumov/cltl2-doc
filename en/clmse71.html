<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Byte Manipulation Functions</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 14:21:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 3202--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse72.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse70.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse70.html#tailclmse70.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse71.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html#clmse71.html" >Up</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">12.8   </span> <a 
href="clm.html#QQ2-88-1155" id="x88-112600012.8">Byte Manipulation Functions</a></h3>
<!--l. 3204--><p class="noindent" >Several functions are provided for dealing with an arbitrary-width ﬁeld of
contiguous bits appearing anywhere in an integer. Such a contiguous set
of bits is called a <i>byte</i>. Here the term <i>byte</i> does not imply some ﬁxed
number of bits (such as eight), rather a ﬁeld of arbitrary and user-speciﬁable
width.
<!--l. 3210--><p class="indent" >   The byte-manipulation functions use objects called <i>byte speciﬁers</i> to designate
a speciﬁc byte position within an integer. The representation of a byte
speciﬁer is implementation-dependent; in particular, it may or may not be a
number. It is suﬃcient to know that the function <tt><a 
href="symbols.html#x185-2637151r151">byte</a></tt> will construct
one, and that the byte-manipulation functions will accept them. The
function <tt><a 
href="symbols.html#x185-2637151r151">byte</a></tt> accepts two integers representing the <i>position</i> and <i>size</i> of
the byte and returns a byte speciﬁer. Such a speciﬁer designates a byte
whose width is <i>size</i> and whose bits have weights <span class="math">2<sup>position+size−1</sup></span> through
<span class="math">2<sup>position</sup></span>.
<div class="defun">
<!--l. 3223--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx88-1126001"></a><a 
 id="x88-1126002r293"></a> <b>byte</b>  <i>size</i> <i>position</i>
</div>
<tt>
<!--l. 3226--><p class="indent" >   <a 
href="symbols.html#x185-2637151r151">byte</a></tt> takes two integers representing the size and position of a byte and
returns a byte speciﬁer suitable for use as an argument to byte-manipulation
functions.
</div>
<div class="defun">
<!--l. 3231--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx88-1126003"></a><a 
 id="x88-1126004r294"></a> <b>byte-size</b>  <i>bytespec</i><br />
<i>
[Function]</i><a 
 id="dx88-1126005"></a><a 
 id="x88-1126006r295"></a> <b>byte-position</b>  <i>bytespec</i>
</div>
<!--l. 3235--><p class="indent" >   Given a byte speciﬁer, <tt><a 
href="symbols.html#x185-2637153r153">byte-size</a></tt> returns the size speciﬁed as an integer;
<tt><a 
href="symbols.html#x185-2637152r152">byte-position</a></tt> similarly returns the position. For example: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(byte-size (byte <i>j</i> <i>k</i>)) <span class="math"> ≡</span> <i>j</i>
   <br>                                                  (byte-position (byte <i>j</i> <i>k</i>)) <span class="math"> ≡</span> <i>k</i><br>
<!--l. 3241--><p class="noindent" ></div>
<!--l. 3241--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-112700012.8" id="x88-112700012.8"></a></span>
<!--l. 3241--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-112800012.8" id="x88-112800012.8"></a></span>
</div>
</div>
<div class="defun">
<!--l. 3244--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx88-1128001"></a><a 
 id="x88-1128002r296"></a> <b>ldb</b>  <i>bytespec</i> <i>integer</i>
</div>
<i>
<!--l. 3247--><p class="indent" >   bytespec</i> speciﬁes a byte of <i>integer</i> to be extracted. The result is returned as a
non-negative integer. For example: <div class="lisp"><div class="tabbing">
(logbitp <i>j</i> (ldb (byte <i>s</i> <i>p</i>) <i>n</i>)) <span class="math"> ≡</span> (and (&#x003C; <i>j</i> <i>s</i>) (logbitp (+ <i>j</i> <i>p</i>) <i>n</i>))
   <br>
<!--l. 3252--><p class="noindent" ></div>
<!--l. 3252--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-112900012.8" id="x88-112900012.8"></a></span>
<!--l. 3252--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-113000012.8" id="x88-113000012.8"></a></span>
</div>
<!--l. 3253--><p class="indent" >   The name of the function <tt><a 
href="symbols.html#x185-2637468r468">ldb</a></tt> means “load byte.”
<!--l. 3255--><p class="indent" >   If the argument <i>integer</i> is speciﬁed by a form that is a <i>place</i> form acceptable
to <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt>, then <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt> may be used with <tt><a 
href="symbols.html#x185-2637468r468">ldb</a></tt> to modify a byte within the integer that
is stored in that <i>place</i>. The eﬀect is to perform a <tt><a 
href="symbols.html#x185-2637321r321">dpb</a></tt> operation and then store the
result back into the <i>place</i>.
</div>
                                                                          

                                                                          
<div class="defun">
<!--l. 3264--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx88-1130001"></a><a 
 id="x88-1130002r297"></a> <b>ldb-test</b>  <i>bytespec</i> <i>integer</i>
</div>
<tt>
<!--l. 3267--><p class="indent" >   <a 
href="symbols.html#x185-2637469r469">ldb-test</a></tt> is a predicate that is true if any of the bits designated by the byte
speciﬁer <i>bytespec</i> are 1&#x2019;s in <i>integer</i>; that is, it is true if the designated ﬁeld is
non-zero. <div class="lisp"><div class="tabbing">
(ldb-test <i>bytespec</i> <i>n</i>) <span class="math"> ≡</span> (not (zerop (ldb <i>bytespec</i> <i>n</i>)))
   <br>
<!--l. 3272--><p class="noindent" ></div>
<!--l. 3272--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-113100012.8" id="x88-113100012.8"></a></span>
<!--l. 3272--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-113200012.8" id="x88-113200012.8"></a></span>
</div>
</div>
<div class="defun">
<!--l. 3275--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx88-1132001"></a><a 
 id="x88-1132002r298"></a> <b>mask-ﬁeld</b>  <i>bytespec</i> <i>integer</i>
</div>
<!--l. 3278--><p class="indent" >   This is similar to <tt><a 
href="symbols.html#x185-2637468r468">ldb</a></tt>; however, the result contains the speciﬁed byte of <i>integer</i>
in the position speciﬁed by <i>bytespec</i>, rather than in position 0 as with <tt><a 
href="symbols.html#x185-2637468r468">ldb</a></tt>. The
result therefore agrees with <i>integer</i> in the byte speciﬁed but has zero-bits
everywhere else. For example: <div class="lisp"><div class="tabbing">
(ldb <i>bs</i> (mask-ﬁeld <i>bs</i> <i>n</i>)) <span class="math"> ≡</span> (ldb <i>bs</i> <i>n</i>)
   <br>                        <br>                        (logbitp <i>j</i> (mask-ﬁeld (byte <i>s</i> <i>p</i>) <i>n</i>))<br>
   <span class="math"> ≡</span> (and (&#x003E;= <i>j</i> <i>p</i>) (&#x003C; <i>j</i> (+ <i>p</i> <i>s</i>)) (logbitp <i>j</i> <i>n</i>))<br>                         <br>
(mask-ﬁeld <i>bs</i> <i>n</i>) <span class="math"> ≡</span> (logand <i>n</i> (dpb -1 <i>bs</i> 0))<br>
<!--l. 3292--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 3292--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-113300012.8" id="x88-113300012.8"></a></span>
<!--l. 3292--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-113400012.8" id="x88-113400012.8"></a></span>
</div>
<!--l. 3294--><p class="indent" >   If the argument <i>integer</i> is speciﬁed by a form that is a <i>place</i> form
acceptable to <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt>, then <tt><a 
href="symbols.html#x185-2637778r778">setf</a></tt> may be used with <tt><a 
href="symbols.html#x185-2637566r566">mask-field</a></tt> to modify
a byte within the integer that is stored in that <i>place</i>. The eﬀect is to
perform a <tt><a 
href="symbols.html#x185-2637300r300">deposit-field</a></tt> operation and then store the result back into the
<i>place</i>.
</div>
<div class="defun">
<!--l. 3303--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx88-1134001"></a><a 
 id="x88-1134002r299"></a> <b>dpb</b>  <i>newbyte</i> <i>bytespec</i> <i>integer</i>
</div>
<!--l. 3306--><p class="indent" >   This returns a number that is the same as <i>integer</i> except in the bits speciﬁed
by <i>bytespec</i>. Let <i>s</i> be the size speciﬁed by <i>bytespec</i>; then the low <i>s</i> bits of <i>newbyte</i>
appear in the result in the byte speciﬁed by <i>bytespec</i>. The integer <i>newbyte</i> is
therefore interpreted as being right-justiﬁed, as if it were the result of <tt><a 
href="symbols.html#x185-2637468r468">ldb</a></tt>. For
example: <div class="lisp"><div class="tabbing">
(logbitp <i>j</i> (dpb <i>m</i> (byte <i>s</i> <i>p</i>) <i>n</i>))
   <br>      <span class="math"> ≡</span> (if (and (&#x003E;= <i>j</i> <i>p</i>) (&#x003C; <i>j</i> (+ <i>p</i> <i>s</i>)))<br>                (logbitp (- <i>j</i> <i>p</i>) <i>m</i>)<br>
         (logbitp <i>j</i> <i>n</i>))<br>
<!--l. 3318--><p class="noindent" ></div>
<!--l. 3318--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-113500012.8" id="x88-113500012.8"></a></span>
<!--l. 3318--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-113600012.8" id="x88-113600012.8"></a></span>
</div>
<!--l. 3319--><p class="indent" >   The name of the function <tt><a 
href="symbols.html#x185-2637321r321">dpb</a></tt> means “deposit byte.”
</div>
<div class="defun">
                                                                          

                                                                          
<!--l. 3322--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx88-1136001"></a><a 
 id="x88-1136002r300"></a> <b>deposit-ﬁeld</b>  <i>newbyte</i> <i>bytespec</i> <i>integer</i>
</div>
<!--l. 3325--><p class="indent" >   This function is to <tt><a 
href="symbols.html#x185-2637566r566">mask-field</a></tt> as <tt><a 
href="symbols.html#x185-2637321r321">dpb</a></tt> is to <tt><a 
href="symbols.html#x185-2637468r468">ldb</a></tt>. The result is an integer that
contains the bits of <i>newbyte</i> within the byte speciﬁed by <i>bytespec</i>, and elsewhere
contains the bits of <i>integer</i>. For example: <div class="lisp"><div class="tabbing">
(logbitp <i>j</i> (deposit-ﬁeld <i>m</i> (byte <i>s</i> <i>p</i>) <i>n</i>))
   <br>         <span class="math"> ≡</span> (if (and (&#x003E;= <i>j</i> <i>p</i>) (&#x003C; <i>j</i> (+ <i>p</i> <i>s</i>)))<br>                   (logbitp <i>j</i> <i>m</i>)<br>
          (logbitp <i>j</i> <i>n</i>))<br>
<!--l. 3335--><p class="noindent" ></div>
<!--l. 3335--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-113700012.8" id="x88-113700012.8"></a></span>
<!--l. 3335--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-113800012.8" id="x88-113800012.8"></a></span>
</div>__________________________________________________________________________<div class="implementation">
<!--l. 3338--><p class="noindent" ><b>Implementation note:</b> If the <i>bytespec</i> is a constant, one may of course construct, at
compile time, an equivalent mask <i>m</i>, for example by computing <tt>(deposit-field -1
<i>bytespec</i> 0)</tt>. Given this mask <i>m</i>, one may then compute <div class="lisp"><div class="tabbing">
(deposit-ﬁeld <i>newbyte</i> <i>bytespec</i> <i>integer</i>)
     <br>
<!--l. 3345--><p class="noindent" ></div>
<!--l. 3345--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-113900012.8" id="x88-113900012.8"></a></span>
<!--l. 3345--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-114000012.8" id="x88-114000012.8"></a></span>
</div>
<!--l. 3346--><p class="indent" >     by computing <div class="lisp"><div class="tabbing">
(logior (logand <i>newbyte</i> <i>m</i>) (logand <i>integer</i> (lognot <i>m</i>)))
     <br>
                                                                          

                                                                          
<!--l. 3349--><p class="noindent" ></div>
<!--l. 3349--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-114100012.8" id="x88-114100012.8"></a></span>
<!--l. 3349--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-114200012.8" id="x88-114200012.8"></a></span>
</div>
<!--l. 3350--><p class="indent" >   where the result of <tt>(lognot <i>m</i>)</tt> can of course also be computed at compile time.
However, the following expression may also be used and may require fewer temporary
registers in some situations: <div class="lisp"><div class="tabbing">
(logxor <i>integer</i> (logand <i>m</i> (logxor <i>integer</i> <i>newbyte</i>)))
   <br>
<!--l. 3356--><p class="noindent" ></div>
<!--l. 3356--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-114300012.8" id="x88-114300012.8"></a></span>
<!--l. 3356--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-114400012.8" id="x88-114400012.8"></a></span>
</div>
<!--l. 3357--><p class="indent" >   A related, though possibly less useful, trick is that <div class="lisp"><div class="tabbing">
(let ((z (logand (logxor x y) m)))
   <br>                                                                           (setq x (logxor z x))<br>
  (setq y (logxor z y)))<br>
<!--l. 3362--><p class="noindent" ></div>
<!--l. 3362--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-114500012.8" id="x88-114500012.8"></a></span>
                                                                          

                                                                          
<!--l. 3362--><p class="noindent" ><span class="paragraphHead"><a 
href="#x88-114600012.8" id="x88-114600012.8"></a></span>
</div>
<!--l. 3363--><p class="indent" >   interchanges those bits of <tt>x</tt> and <tt>y</tt> for which the mask <tt>m</tt> is <tt>1</tt>, and leaves alone those
bits of <tt>x</tt> and <tt>y</tt> for which <tt>m</tt> is <tt>0</tt>.
</div>
__________________________________________________________________________
</div>
                                                                          

                                                                          
<!--l. 3370--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse72.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse70.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse70.html#tailclmse70.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse71.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="number.html#clmse71.html" >Up</a><tt>&#x003E;</tt></div><a 
 id="tailclmse71.html"></a>   </div> </div> 
</body></html> 
