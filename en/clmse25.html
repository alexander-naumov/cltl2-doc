<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Type Conversion Function</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-20 16:10:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
<!--l. 740--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse26.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse24.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse24.html#tailclmse24.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse25.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="dtspec.html#clmse25.html" >Up</a><tt>&#x003E;</tt>&lt;<a href="../index.html">Main Page</a>&gt;</div><h3 class="sectionHead"><span class="titlemark">4.8   </span> <a 
href="clm.html#QQ2-34-223" id="x34-2160004.8">Type Conversion Function</a></h3>
<!--l. 742--><p class="noindent" >The following function may be used to convert an object to an equivalent object
of another type.
<div class="defun">
<!--l. 745--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx34-216001"></a><a 
 id="x34-216002r7"></a> <b>coerce</b>  <i>object</i> <i>result-type</i>
</div>
<!--l. 748--><p class="indent" >   The <i>result-type</i> must be a type speciﬁer; the <i>object</i> is converted to
an “equivalent” object of the speciﬁed type. If the coercion cannot be
performed, then an error is signaled. In particular, <tt>(coerce x &#x2019;nil)</tt> always
signals an error. If <i>object</i> is already of the speciﬁed type, as determined by
<tt><a 
href="symbols.html#x187-2636896r896">typep</a></tt>, then it is simply returned. It is not generally possible to convert
any object to be of any type whatsoever; only certain conversions are
permitted:
      <ul class="itemize1">
      <li class="itemize">Any sequence type may be converted to any other sequence type, provided
      the new sequence can contain all actual elements of the old sequence (it is
      an error if it cannot). If the <i>result-type</i> is speciﬁed as simply <tt>array</tt>, for
      example, then <tt>(array t)</tt> is assumed. A specialized type such as
      <tt><a 
href="symbols.html#x187-2636828r828">string</a></tt> or <tt>(vector (complex short-float))</tt> may be speciﬁed; of
      course, the result may be of either that type or some more general
      type, as determined by the implementation. Elements of the new
      sequence will be <tt><a 
href="symbols.html#x187-2636338r338">eql</a></tt> to corresponding elements of the old sequence. If
      the <i>sequence</i> is already of the speciﬁed type, it may be returned
      without copying it; in this, <tt>(coerce <i>sequence</i> <i>type</i>)</tt> diﬀers from
      <tt>(concatenate <i>type</i> <i>sequence</i>)</tt>, for the latter is required to copy the
      argument <i>sequence</i>. In particular, if one speciﬁes <tt>sequence</tt>, then
      the argument may simply be returned if it already is a <tt>sequence</tt>.
      <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
      (coerce &#x2019;(a b c) &#x2019;vector) <span class="math"> ⇒</span> #(a b c)
      <br>
      <!--l. 777--><p class="noindent" ></div>
      <!--l. 777--><p class="noindent" ><span class="paragraphHead"><a 
href="#x34-2170004.8" id="x34-2170004.8"></a></span>
      <!--l. 777--><p class="noindent" ><span class="paragraphHead"><a 
href="#x34-2180004.8" id="x34-2180004.8"></a></span>
</div>
<tt>
      <!--l. 779--><p class="noindent" ><a 
href="symbols.html#x187-2636227r227">coerce</a></tt> should signal an error if the new sequence type speciﬁes the number
      of elements and the old sequence has a diﬀerent length.
      <!--l. 782--><p class="noindent" >If the <i>result-type</i> is <tt><a 
href="symbols.html#x187-2636828r828">string</a></tt> then it is understood to mean <tt>(vector
      character)</tt>, and <tt>simple-string</tt> is understood to mean <tt>(simple-array
      character (*))</tt>.
      </li>
      <li class="itemize">Any non-complex number can be converted to a <tt>short-float</tt>, <tt>single-float</tt>,
      <tt>double-float</tt>, or <tt>long-float</tt>. If simply <tt><a 
href="symbols.html#x187-2636380r380">float</a></tt> is speciﬁed, and <i>object</i> is
      not already a <tt><a 
href="symbols.html#x187-2636380r380">float</a></tt> of some kind, then the object is converted to a
      <tt>single-float</tt>. <div class="lisp"><div class="tabbing">
      (coerce 0 &#x2019;short-ﬂoat) <span class="math"> ⇒</span> 0.0S0
      <br>                                                    (coerce 3.5L0 &#x2019;ﬂoat) <span class="math"> ⇒</span> 3.5L0<br>
           (coerce 7/2 &#x2019;ﬂoat) <span class="math"> ⇒</span> 3.5<br>
      <!--l. 795--><p class="noindent" ></div>
      <!--l. 795--><p class="noindent" ><span class="paragraphHead"><a 
href="#x34-2190004.8" id="x34-2190004.8"></a></span>
                                                                          

                                                                          
      <!--l. 795--><p class="noindent" ><span class="paragraphHead"><a 
href="#x34-2200004.8" id="x34-2200004.8"></a></span>
</div>
      </li>
      <li class="itemize">Any number can be converted to a complex number. If the number is not
      already complex, then a zero imaginary part is provided by coercing the
      integer zero to the type of the given real part. (If the given real part is
      rational, however, then the rule of canonical representation for complex
      rationals will result in the immediate re-conversion of the result from type
      <tt><a 
href="symbols.html#x187-2636239r239">complex</a></tt> back to type <tt>rational</tt>.)
<div class="lisp">
      <!--l. 806--><p class="noindent" ><div class="tabbing">
      (coerce 4.5s0 &#x2019;complex) <span class="math"> ⇒</span> #C(4.5S0 0.0S0)
      <br>                                                     (coerce 7/2 &#x2019;complex) <span class="math"> ⇒</span> 7/2<br>
           (coerce #C(7/2 0) &#x2019;(complex double-ﬂoat))<br>
              <span class="math"> ⇒</span> #C(3.5D0 0.0D0)<br>
      <!--l. 811--><p class="noindent" ></div>
      <!--l. 811--><p class="noindent" ><span class="paragraphHead"><a 
href="#x34-2210004.8" id="x34-2210004.8"></a></span>
      <!--l. 811--><p class="noindent" ><span class="paragraphHead"><a 
href="#x34-2220004.8" id="x34-2220004.8"></a></span>
</div>
      </li>
      <li class="itemize">Any object may be coerced to type <tt><a 
href="symbols.html#x187-2636871r871">t</a></tt>. <div class="lisp"><div class="tabbing">
      (coerce x &#x2019;t) <span class="math"> ≡</span> (identity x) <span class="math"> ≡</span> x
      <br>
      <!--l. 817--><p class="noindent" ></div>
                                                                          

                                                                          
      <!--l. 817--><p class="noindent" ><span class="paragraphHead"><a 
href="#x34-2230004.8" id="x34-2230004.8"></a></span>
      <!--l. 817--><p class="noindent" ><span class="paragraphHead"><a 
href="#x34-2240004.8" id="x34-2240004.8"></a></span>
</div>
      </li>
      <li class="itemize">A symbol or lambda-expression can be converted to a function. A symbol is
      coerced to type <tt><a 
href="symbols.html#x187-2636399r399">function</a></tt> as if by applying <tt><a 
href="symbols.html#x187-2636863r863">symbol-function</a></tt> to the symbol;
      an error is signaled if the predicate <tt><a 
href="symbols.html#x187-2636352r352">fboundp</a></tt> is not true of the symbol or if
      the symbol names a macro or special operator. A list <i>x</i> whose <i>car</i> is the
      symbol <tt><a 
href="symbols.html#x187-2636462r462">lambda</a></tt> is coerced to a function as if by execution of <tt>(eval ‘#&#x2019;,<i>x</i>)</tt>,
      that is, of <tt>(eval (list &#x2019;function <i>x</i>))</tt>.</li></ul>
<!--l. 830--><p class="indent" >   Coercions from ﬂoating-point numbers to rationals and from ratios to integers
are purposely <i>not</i> provided because of rounding problems. The functions
<tt>rational</tt>, <tt><a 
href="symbols.html#x187-2636715r715">rationalize</a></tt>, <tt><a 
href="symbols.html#x187-2636388r388">floor</a></tt>, <tt><a 
href="symbols.html#x187-2636190r190">ceiling</a></tt>, <tt><a 
href="symbols.html#x187-2636888r888">truncate</a></tt>, and <tt><a 
href="symbols.html#x187-2636757r757">round</a></tt> may be used for
such purposes. Similarly, coercions from characters to integers are purposely not
provided; <tt><a 
href="symbols.html#x187-2636196r196">char-code</a></tt> or <tt><a 
href="symbols.html#x187-2636201r201">char-int</a></tt> may be used explicitly to perform such
conversions.
</div>
                                                                          

                                                                          
<!--l. 839--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse26.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse24.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse24.html#tailclmse24.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse25.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="dtspec.html#clmse25.html" >Up</a><tt>&#x003E;</tt></div><a 
 id="tailclmse25.html"></a>   </div> </div> 
</body></html> 
