<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Top-Level Forms</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 1010--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch6.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse29.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse29.html#tailclmse29.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse30.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse30.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">5.3   </span> <a 
 id="x40-650005.3"></a>Top-Level Forms</h3>
<!--l. 1012--><p class="noindent" >The standard way for the user to interact with a Common Lisp implementation is
via a <i>read-eval-print loop</i>: the system repeatedly reads a form from some input
source (such as a keyboard or a disk ﬁle), evaluates it, and then prints the
value(s) to some output sink (such as a display screen or another disk ﬁle). Any
form (evaluable data object) is acceptable; however, certain special forms are
speciﬁcally designed to be convenient for use as <i>top-level</i> forms, rather than as
forms embedded within other forms in the way that <i>(+ 3 4)</i> is embedded within
<i>(if p (+ 3 4) 6)</i>. These top-level special forms may be used to deﬁne globally
named functions, to deﬁne macros, to make declarations, and to deﬁne global
values for special variables.
<div class=obsolete>
<!--l. 1027--><p class="indent" >   It is not illegal to use these forms at other than top level, but whether it is
meaningful to do so depends on context. Compilers, for example, may
not recognize these forms properly in other than top-level contexts. (As
a special case, however, if a <i>progn</i> form appears at top level, then all
forms within that <i>progn</i> are considered by the compiler to be top-level
forms.)
</div>
<!--l. 1036--><p class="indent" >
                                                                          

                                                                          
<div class=newer>
<!--l. 1039--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that, while deﬁning forms normally
appear at top level, it is meaningful to place them in non-top-level contexts. All
deﬁning forms that create functional objects from code appearing as argument
forms must ensure that such argument forms refer to the enclosing lexical
environment. Compilers must handle deﬁning forms properly in all situations, not
just top-level contexts. However, certain compile-time side eﬀects of these deﬁning
forms are performed only when the deﬁning forms occur at top level (see
section <a 
href="clmse127.html#x157-22400025.1">25.1<!--tex4ht:ref: COMPILER-SECTION --></a>).
</div>
<div class=incompatibility>
<!--l. 1052--><p class="noindent" ><b>Compatibility note:</b> In MacLisp, a top-level <i>progn</i> is considered to contain top-level
forms only if the ﬁrst form is <i>(quote compile)</i>. This odd marker is unnecessary in
Common Lisp.
</div>
<!--l. 1059--><p class="indent" >   Macros are usually deﬁned by using the special form <i>defmacro</i>. This facility is
fairly complicated; it is described in chapter <a 
href="clmch8.html#x58-970008">8<!--tex4ht:ref: MACROS --></a>.
   <h4 class="subsectionHead"><span class="titlemark">5.3.1   </span> <a 
 id="x40-660005.3.1"></a>Deﬁning Named Functions</h4>
<!--l. 1064--><p class="noindent" >The <i>defun</i> special form is the usual means of deﬁning named functions.
<div class=defmac>
<!--l. 1067--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> defun </b> <a 
 id="dx40-66001"></a><a 
 id="x40-66002r14"></a>   name lambda-list  [[ <i> {<i>declaration</i>}∗  | doc-string</div> ]] {<i>form</i>}∗
</td></tr></table>
<!--l. 1068--><p class="indent" >
</div>
   Evaluating a <i>defun</i> form causes the symbol <i>name</i> to be a global name for the
function speciﬁed by the lambda-expression <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(lambda <i>lambda-list</i> {<i><i>declaration</i> |<i>doc-string</i></i>}∗ {<i><i>form</i></i>}∗ )
</td></tr></table>
<!--l. 1073--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 1074--><p class="noindent" >deﬁned in the lexical environment in which the <i>defun</i> form was executed. Because
<i>defun</i> forms normally appear at top level, this is normally the null lexical
environment.
<div class=newer>
<!--l. 1079--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that, while deﬁning forms normally
appear at top level, it is meaningful to place them in non-top-level contexts; <i>defun</i>
must deﬁne the function within the enclosing lexical environment, not within the
null lexical environment.
</div>
<div class=newer>
<!--l. 1088--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to extend <i>defun</i> to accept any function-name
(a symbol or a list whose <i>car</i> is <i>setf </i>—see section <a 
href="clmse35.html#x47-770007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>) as a <i>name</i>. Thus one may
write <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun (setf cadr) ...)
</td></tr></table>
<!--l. 1095--><p class="indent" >
</div>
</div>
<!--l. 1096--><p class="noindent" >to deﬁne a <i>setf </i> expansion function for <i>cadr</i> (although it may be much more
convenient to use <i>defsetf </i> or <i>deﬁne-modify-macro</i>).
</div>
<!--l. 1102--><p class="indent" >
                                                                          

                                                                          
<!--l. 1104--><p class="indent" >   If the optional documentation string <i>doc-string</i> is present, then it is attached
to the <i>name</i> as a documentation string of type <i>function</i>; see <i>documentation</i>. If
<i>doc-string</i> is not followed by a declaration, it may be present only if at least one
<i>form</i> is also speciﬁed, as it is otherwise taken to be a <i>form</i>. It is an error if more
than one <i>doc-string</i> is present.
<!--l. 1113--><p class="indent" >   The <i>forms</i> constitute the body of the deﬁned function; they are executed as an
implicit <i>progn</i>.
<!--l. 1116--><p class="indent" >   The body of the deﬁned function is implicitly enclosed in a <i>block</i> construct
whose name is the same as the <i>name</i> of the function. Therefore <i>return-from</i> may
be used to exit from the function.
<!--l. 1121--><p class="indent" >   Other implementation-dependent bookkeeping actions may be taken as well by
<i>defun</i>. The <i>name</i> is returned as the value of the <i>defun</i> form. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun discriminant (a b c)
</td></tr></table>
<!--l. 1126--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (number a b c))</td></tr></table>
<!--l. 1127--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  &#x0022;Compute the discriminant for a quadratic equation.</td></tr></table>
<!--l. 1128--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   Given a, b, and c, the value b<tt>̂</tt>2-4*a*c is calculated.</td></tr></table>
<!--l. 1129--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   The quadratic equation a*x<tt>̂</tt>2+b*x+c=0 has real, multiple,</td></tr></table>
<!--l. 1130--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   or complex roots depending on whether this calculated</td></tr></table>
<!--l. 1131--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   value is positive, zero, or negative, respectively.&#x0022;</td></tr></table>
<!--l. 1132--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (- (* b b) (* 4 a c)))</td></tr></table>
<!--l. 1133--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ discriminant</td></tr></table>
<!--l. 1134--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   and now (discriminant 1 2/3 -2)  ⇒ 76/9</td></tr></table>
<!--l. 1136--><p class="indent" >
</div>
</div>
<div class=new>
<!--l. 1138--><p class="noindent" >The documentation string in this example neglects to mention that the coeﬃcients <i>a</i>,
<i>b</i>, and <i>c</i> must be real for the discrimination criterion to hold. Here is an improved
version: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  &#x0022;Compute the discriminant for a quadratic equation.
</td></tr></table>
<!--l. 1143--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   Given a, b, and c, the value b<tt>̂</tt>2-4*a*c is calculated.</td></tr></table>
                                                                          

                                                                          
<!--l. 1144--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   If the coeﬃcients a, b, and c are all real (that is,</td></tr></table>
<!--l. 1145--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   not complex), then the quadratic equation a*x<tt>̂</tt>2+b*x+c=0</td></tr></table>
<!--l. 1146--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   has real, multiple, or complex roots depending on</td></tr></table>
<!--l. 1147--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   whether this calculated value is positive, zero, or</td></tr></table>
<!--l. 1148--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   negative, respectively.&#x0022;</td></tr></table>
<!--l. 1150--><p class="indent" >
</div>
</div>
</div>
<!--l. 1153--><p class="indent" >   It is permissible to use <i>defun</i> to redeﬁne a function, to install a corrected
version of an incorrect deﬁnition, for example. It is permissible to redeﬁne a macro
as a function. It is an error to attempt to redeﬁne the name of a special form (see
table <a 
href="clmse28.html#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>) as a function.
   <h4 class="subsectionHead"><span class="titlemark">5.3.2   </span> <a 
 id="x40-670005.3.2"></a>Declaring Global Variables and Named Constants</h4>
<!--l. 1162--><p class="noindent" >The <i>defvar</i> and <i>defparameter</i> special forms are the usual means of specifying
globally deﬁned variables. The <i>defconstant</i> special form is used for deﬁning named
constants.
<div class=defmac>
<!--l. 1167--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> defvar </b> <a 
 id="dx40-67001"></a><a 
 id="x40-67002r15"></a>   name  [ <i>initial-value [ <i>documentation</i>] </i>]     <i>[Macro]</i><b> defparameter </b> <a 
 id="dx40-67003"></a><a 
 id="x40-67004r16"></a>   name initial-value  [ <i>documentation</i>]     <i>[Macro]</i><b> defconstant </b> <a 
 id="dx40-67005"></a><a 
 id="x40-67006r17"></a>   name initial-value  [ <i>documentation</i>]
</td></tr></table>
<!--l. 1170--><p class="indent" >
</div>
   <i>defvar</i> is the recommended way to declare the use of a special variable in a
program. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defvar <i>variable</i>)
</td></tr></table>
<!--l. 1175--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 1176--><p class="noindent" >proclaims <i>variable</i> to be <i>special</i> (see <i>proclaim</i>), and may perform other
system-dependent bookkeeping actions. <div class=newer> X3J13 voted in June 1987 ⟨<b>?</b>⟩ to clarify
that if no <i>initial-value</i> form is provided, <i>defvar</i> does not change the value of the
<i>variable</i>; if no <i>initial-value</i> form is provided and the variable has no value, <i>defvar</i>
does not give it a value.
</div> If a second argument form is supplied, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defvar <i>variable</i> <i>initial-value</i>)
</td></tr></table>
<!--l. 1188--><p class="indent" >
</div>
</div>
<!--l. 1189--><p class="noindent" >then <i>variable</i> is initialized to the result of evaluating the form <i>initial-value</i> unless it
already has a value. The <i>initial-value</i> form is not evaluated unless it is used; this
fact is useful if evaluation of the <i>initial-value</i> form does something expensive like
creating a large data structure. <div class=newer> X3J13 voted in June 1987 ⟨<b>?</b>⟩ to clarify
that evaluation of the <i>initial-value</i> and the initialization of the variable
occur, if at all, at the time the <i>defvar</i> form is executed, and that the
<i>initial-value</i> form is evaluated if and only if the <i>variable</i> does not already have a
value.
</div> The initialization is performed by assignment and thus assigns a global value to
the variable unless there are currently special bindings of that variable. Normally
there should not be any such special bindings.
<i>
<!--l. 1206--><p class="indent" >   defvar</i> also provides a good place to put a comment describing the meaning of
the variable, whereas an ordinary <i>special</i> proclamation oﬀers the temptation to
declare several variables at once and not have room to describe them all. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defvar *visible-windows* 0
</td></tr></table>
<!--l. 1212--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  &#x0022;Number of windows at least partially visible on the screen&#x0022;)</td></tr></table>
<!--l. 1214--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<i>
<!--l. 1216--><p class="indent" >   defparameter</i> is similar to <i>defvar</i>, but <i>defparameter</i> requires an <i>initial-value</i>
form, always evaluates the form, and assigns the result to the variable. The
semantic distinction is that <i>defvar</i> is intended to declare a variable changed by
the program, whereas <i>defparameter</i> is intended to declare a variable that is
normally constant but can be changed (possibly at run time), where such a
change is considered a change <i>to</i> the program. <i>defparameter</i> therefore does not
indicate that the quantity <i>never</i> changes; in particular, it does not license
the compiler to build assumptions about the value into programs being
compiled.
<i>
<!--l. 1228--><p class="indent" >   defconstant</i> is like <i>defparameter</i> but <i>does</i> assert that the value of the variable
<i>name</i> is ﬁxed and does license the compiler to build assumptions about the value
into programs being compiled. (However, if the compiler chooses to replace
references to the name of the constant by the value of the constant in
code to be compiled, perhaps in order to allow further optimization, the
compiler must take care that such “copies” appear to be <i>eql</i> to the object
that is the actual value of the constant. For example, the compiler may
freely make copies of numbers but must exercise care when the value is a
list.)
<!--l. 1239--><p class="indent" >   It is an error if there are any special bindings of the variable at the time the
<i>defconstant</i> form is executed (but implementations may or may not check for
this).
<!--l. 1243--><p class="indent" >   Once a name has been declared by <i>defconstant</i> to be constant, any further
assignment to or binding of that special variable is an error. This is the case for
such system-supplied constants as <i>t</i> and <i>most-positive-ﬁxnum</i>. A compiler may
also choose to issue warnings about bindings of the lexical variable of the same
name.
<div class=new>
<!--l. 1251--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to clarify the preceding paragraph by
specifying that it is an error to rebind constant symbols as either lexical or special
variables. Consequently, a valid reference to a symbol declared with <i>defconstant</i>
always refers to its global value. (Unfortunately, this violates the principle of
referential transparency, for one cannot always choose names for lexical variables
without regard to surrounding context.)
</div>
<!--l. 1263--><p class="indent" >   For any of these constructs, the documentation should be a string. The string
is attached to the name of the variable, parameter, or constant under the <i>variable</i>
                                                                          

                                                                          
documentation type; see the <i>documentation</i> function.
<div class=new>
<!--l. 1270--><p class="indent" >   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to clarify that the <i>documentation-string</i> is not
evaluated but must appear as a literal string when the <i>defvar</i>, <i>defparameter</i>, or
<i>defconstant</i> form is evaluated.
<!--l. 1276--><p class="indent" >   For example, the form <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defvar *avoid-registers* nil &#x0022;Compilation control switch #43&#x0022;)
</td></tr></table>
<!--l. 1280--><p class="indent" >
</div>
</div>
<!--l. 1281--><p class="noindent" >is legitimate, but <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defvar *avoid-registers* nil
</td></tr></table>
<!--l. 1283--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (format nil &#x0022;Compilation control switch #<tt>~</tt>D&#x0022;</td></tr></table>
<!--l. 1284--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (incf *compiler-switch-number*)))</td></tr></table>
<!--l. 1286--><p class="indent" >
</div>
</div>
<!--l. 1287--><p class="noindent" >is erroneous because the call to <i>format</i> is not a literal string.
<!--l. 1289--><p class="indent" >   (On the other hand, the form <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defvar *avoid-registers* nil
</td></tr></table>
<!--l. 1291--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  #.(format nil &#x0022;Compilation control switch #<tt>~</tt>D&#x0022;</td></tr></table>
<!--l. 1292--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            (incf *compiler-switch-number*)))</td></tr></table>
<!--l. 1294--><p class="indent" >
</div>
</div>
<!--l. 1295--><p class="noindent" >might be used to accomplish the same purpose, because the call to <i>format</i> is
evaluated at <i>read</i> time; when the <i>defvar</i> form is evaluated, only the result of the
call to <i>format</i>, a string, appears in the <i>defvar</i> form.)
</div>
                                                                          

                                                                          
<!--l. 1301--><p class="indent" >   These constructs are normally used only as top-level forms. The value returned
by each of these constructs is the <i>name</i> declared.
</div>
<!--l. 1305--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.3.3   </span> <a 
 id="x40-680005.3.3"></a>Control of Time of Evaluation</h4>
<div class=obsolete>
<!--l. 1308--><p class="noindent" >The <i>eval-when</i> special form allows pieces of code to be executed only at compile
time, only at load time, or when interpreted but not compiled. Its uses are
relatively esoteric.
<div class=defspec>
<!--l. 1313--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> eval-when </b> <a 
 id="dx40-68001"></a><a 
 id="x40-68002r18"></a>   ( {<i>situation</i>}∗ )  {<i>form</i>}∗
</td></tr></table>
<!--l. 1314--><p class="indent" >
</div>
   The body of an <i>eval-when</i> form is processed as an implicit <i>progn</i>, but only in
the situations listed. Each <i>situation</i> must be a symbol, either <i>compile</i>, <i>load</i>, or
<i>eval</i>.
<i>
   eval</i> speciﬁes that the interpreter should process the body. <i>compile</i> speciﬁes
that the compiler should evaluate the body at compile time in the compilation
context. <i>load</i> speciﬁes that the compiler should arrange to evaluate the
forms in the body when the compiled ﬁle containing the <i>eval-when</i> form is
loaded.
   The <i>eval-when</i> construct may be more precisely understood in terms of a
model of how the compiler processes forms in a ﬁle to be compiled. Successive
forms are read from the ﬁle using the function <i>read</i>. These top-level forms are
normally processed in what we shall call <i>not-compile-time</i> mode. There is another
mode called <i>compile-time-too</i> mode. The <i>eval-when</i> special form controls which of
these two modes to use.
   Every form is processed as follows:
      <ul class="itemize1">
      <li class="itemize">If the form is an <i>eval-when</i> form:
                                                                          

                                                                          
           <ul class="itemize2">
           <li class="itemize">If the situation <i>load</i> is speciﬁed:
               <ul class="itemize3">
               <li class="itemize">If  the  situation  <i>compile</i>  is  speciﬁed,  <i>or</i>  if  the  current
               processing mode is <i>compile-time-too</i> and the situation <i>eval</i>
               is speciﬁed, then process each of the forms in the body in
               <i>compile-time-too</i> mode.
               </li>
               <li class="itemize">Otherwise,  process  each  of  the  forms  in  the  body  in
               <i>not-compile-time</i> mode.</li></ul>
           </li>
           <li class="itemize">If the situation <i>load</i> is not speciﬁed:
               <ul class="itemize3">
               <li class="itemize">If  the  situation  <i>compile</i>  is  speciﬁed,  <i>or</i>  if  the  current
               processing mode is <i>compile-time-too</i> and the situation <i>eval</i> is
               speciﬁed, then evaluate each of the forms in the body in the
               compiler&#x2019;s executing environment.
               </li>
               <li class="itemize">Otherwise, ignore the <i>eval-when</i> form entirely.</li></ul>
           </li></ul>
      </li>
      <li class="itemize">If the form is not an <i>eval-when</i> form, then do two things. First, if the
      current processing mode is <i>compile-time-too</i> mode, evaluate the form in the
      compiler&#x2019;s executing environment. Second, perform normal compiler
      processing of the form (compiling functions deﬁned by <i>defun</i> forms, and so
      on).</li></ul>
<!--l. 1375--><p class="noindent" >One example of the use of <i>eval-when</i> is that if the compiler is to be able to
properly read a ﬁle that uses user-deﬁned reader macro characters, it is necessary
to write <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eval-when (compile load eval)
</td></tr></table>
<!--l. 1380--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (set-macro-character #<tt>\</tt>$ #&#x2019;(lambda (stream char)</td></tr></table>
<!--l. 1381--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                               (declare (ignore char))</td></tr></table>
                                                                          

                                                                          
<!--l. 1382--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                               (list &#x2019;dollar (read stream)))))</td></tr></table>
<!--l. 1384--><p class="indent" >
</div>
</div>
<!--l. 1385--><p class="noindent" >This causes the call to <i>set-macro-character</i> to be executed in the compiler&#x2019;s execution
environment, thereby modifying its reader syntax table.
</div>
</div>
<div class=newer>
<!--l. 1392--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to completely redesign the <i>eval-when</i> construct to
solve some problems concerning its treatment in other than top-level contexts.
The new deﬁnition is upward compatible with the old deﬁnition, but the old
keywords are deprecated.
<div class=defspec>
<!--l. 1399--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> eval-when </b> <a 
 id="dx40-68003"></a><a 
 id="x40-68004r19"></a>   ( {<i>situation</i>}∗ )  {<i>form</i>}∗
</td></tr></table>
<!--l. 1400--><p class="indent" >
</div>
   The body of an <i>eval-when</i> form is processed as an implicit <i>progn</i>, but only in
the situations listed. Each <i>situation</i> must be a symbol, either <i>:compile-toplevel</i>,
<i>:load-toplevel</i>, or <i>:execute</i>.
   The use of <i>:compile-toplevel</i> and <i>:load-toplevel</i> controls whether and when
processing occurs for top-level forms. The use of <i>:execute</i> controls whether
processing occurs for non-top-level forms.
   The <i>eval-when</i> construct may be more precisely understood in terms of a
model of how the ﬁle compiler, <i>compile-ﬁle</i>, processes forms in a ﬁle to be
compiled.
   Successive forms are read from the ﬁle by the ﬁle compiler using <i>read</i>. These
top-level forms are normally processed in what we call “not-compile-time” mode.
There is one other mode, called “compile-time-too” mode, which can come into
play for top-level forms. The <i>eval-when</i> special form is used to annotate a program
in a way that allows the program doing the processing to select the appropriate
mode.
   Processing of top-level forms in the ﬁle compiler works as follows:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">If the form is a macro call, it is expanded and the result is processed
      as a top-level form in the same processing mode (compile-time-too or
      not-compile-time).
      </li>
      <li class="itemize">If the form is a <i>progn</i> (or <i>locally</i> ⟨<b>?</b>⟩) form, each of its body forms is
      sequentially processed as top-level forms in the same processing mode.
      </li>
      <li class="itemize">If the form is a <i>compiler-let</i>, <i>macrolet</i>, or <i>symbol-macrolet</i>, the ﬁle
      compiler makes the appropriate bindings and recursively processes the
      body forms as an implicit top-level <i>progn</i> with those bindings in eﬀect,
      in the same processing mode.
      </li>
      <li class="itemize">If the form is an <i>eval-when</i> form, it is handled according to the following
      table:
      <div class="flushleft" 
>
<!--l. 1443--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" > LT</td><td align="left" >CT</td><td align="left" >EX</td><td align="left" >CTTM</td><td align="left" >Action                                           </td></tr><tr><td align="left" > yes</td> <td align="left" >yes</td> <td align="left" > – </td> <td align="left" > – </td> <td align="left" >process body in compile-time-too mode</td>
</tr><tr><td align="left" > yes</td><td align="left" > no </td><td align="left" >yes</td><td align="left" >   yes   </td><td align="left" >process body in compile-time-too mode</td>
</tr><tr><td align="left" > yes</td><td align="left" > no </td><td align="left" > – </td><td align="left" >   no   </td><td align="left" >process body in not-compile-time mode</td>
</tr><tr><td align="left" > yes</td><td align="left" > no </td><td align="left" > no </td><td align="left" >    –    </td><td align="left" >process body in not-compile-time mode</td>
</tr><tr><td align="left" > no</td><td align="left" >yes</td><td align="left" > – </td><td align="left" >    –    </td><td align="left" >evaluate body                                 </td>
</tr><tr><td align="left" > no</td><td align="left" > no </td><td align="left" >yes</td><td align="left" >   yes   </td><td align="left" >evaluate body                                 </td>
</tr><tr><td align="left" > no</td><td align="left" > no </td><td align="left" > – </td><td align="left" >   no   </td><td align="left" >do nothing                                      </td>
</tr><tr><td align="left" > no</td><td align="left" > no </td><td align="left" > no </td><td align="left" >    –    </td><td align="left" >do nothing                                      </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" >  </td>
</tr></table></div></div>
      <!--l. 1457--><p class="noindent" >In the preceding table the column LT asks whether <i>:load-toplevel</i> is one of
      the situations speciﬁed in the <i>eval-when</i> form; CT similarly refers to
      <i>:compile-toplevel</i> and EX to <i>:execute</i>. The column CTTM asks whether the
      <i>eval-when</i> form was encountered while in compile-time-too mode. The
      phrase “process body” means to process the body as an implicit top-level
      <i>progn</i> in the indicated mode, and “evaluate body” means to evaluate the
      body forms sequentially as an implicit <i>progn</i> in the dynamic execution
      context of the compiler and in the lexical environment in which the
      <i>eval-when</i> appears.
                                                                          

                                                                          
      </li>
      <li class="itemize">Otherwise, the form is a top-level form that is not one of the special cases. If
      in compile-time-too mode, the compiler ﬁrst evaluates the form and then
      performs normal compiler processing on it. If in not-compile-time mode,
      only normal compiler processing is performed (see section <a 
href="clmse127.html#x157-22400025.1">25.1<!--tex4ht:ref: COMPILER-SECTION --></a>). Any
      subforms are treated as non-top-level forms.</li></ul>
<!--l. 1476--><p class="noindent" >Note that top-level forms are guaranteed to be processed in the order in which
they textually appear in the ﬁle, and that each top-level form read by the
compiler is processed before the next is read. However, the order of processing
(including, in particular, macro expansion) of subforms that are not top-level
forms is unspeciﬁed.
<!--l. 1482--><p class="indent" >   For an <i>eval-when</i> form that is not a top-level form in the ﬁle compiler (that is,
either in the interpreter, in <i>compile</i>, or in the ﬁle compiler but not at top level), if
the <i>:execute</i> situation is speciﬁed, its body is treated as an implicit <i>progn</i>.
Otherwise, the body is ignored and the <i>eval-when</i> form has the value
<i>nil</i>.
<!--l. 1488--><p class="indent" >   For the sake of backward compatibility, a <i>situation</i> may also be <i>compile</i>, <i>load</i>,
or <i>eval</i>. Within a top-level <i>eval-when</i> form these have the same meaning
as <i>:compile-toplevel</i>, <i>:load-toplevel</i>, and <i>:execute</i>, respectively; but their
eﬀect is undeﬁned when used in an <i>eval-when</i> form that is not at top
level.
<!--l. 1495--><p class="indent" >   The following eﬀects are logical consequences of the preceding speciﬁcation:
      <ul class="itemize1">
      <li class="itemize">It is never the case that the execution of a single <i>eval-when</i> expression
      will execute the body code more than once.
      </li>
      <li class="itemize">The old keyword <i>eval</i> was a misnomer because execution of the body need
      not be done by <i>eval</i>. For example, when the function deﬁnition <div class=lisp>
      <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(defun foo () (eval-when (:execute) (print &#x2019;foo)))
</td></tr></table>
      <!--l. 1505--><p class="noindent" >
                                                                          

                                                                          
</div>
</div>
      <!--l. 1506--><p class="noindent" >is compiled the call to <i>print</i> should be compiled, not evaluated at compile
      time.
      </li>
      <li class="itemize">Macros intended for use in top-level forms should arrange for all side-eﬀects
      to be done by the forms in the macro expansion. The macro-expander itself
      should not perform the side-eﬀects. <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(defmacro foo ()
</td></tr></table>
      <!--l. 1513--><p class="noindent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">  (really-foo)                              ;Wrong</td></tr></table>
      <!--l. 1514--><p class="noindent" >                                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">  <tt>‘</tt>(really-foo))</td></tr></table>
      <!--l. 1515--><p class="noindent" >                                                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing"></td></tr></table>
      <!--l. 1516--><p class="noindent" >                                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(defmacro foo ()</td></tr></table>
      <!--l. 1517--><p class="noindent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">  <tt>‘</tt>(eval-when (:compile-toplevel</td></tr></table>
      <!--l. 1518--><p class="noindent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">               :load-toplevel :execute)     ;Right</td></tr></table>
      <!--l. 1519--><p class="noindent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">    (really-foo)))</td></tr></table>
      <!--l. 1521--><p class="noindent" >
</div>
</div>
      <!--l. 1522--><p class="noindent" >Adherence to this convention will mean that such macros will behave
      intuitively when called in non-top-level positions.
      </li>
      <li class="itemize">Placing a variable binding around an <i>eval-when</i> reliably captures the
      binding because the “compile-time-too” mode cannot occur (because the
      <i>eval-when</i> could not be a top-level form). For example, <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(let ((x 3))
</td></tr></table>
                                                                          

                                                                          
      <!--l. 1531--><p class="noindent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">  (eval-when (:compile-toplevel :load-toplevel :execute)</td></tr></table>
      <!--l. 1532--><p class="noindent" >                                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">    (print x)))</td></tr></table>
      <!--l. 1534--><p class="noindent" >
</div>
</div>
      <!--l. 1535--><p class="noindent" >will print 3 at execution (that is, load) time and will not print anything at
      compile time. This is important so that expansions of <i>defun</i> and <i>defmacro</i>
      can be done in terms of <i>eval-when</i> and can correctly capture the lexical
      environment. For example, an implementation might expand a <i>defun</i> form
      such as <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(defun bar (x) (defun foo () (+ x 3)))
</td></tr></table>
      <!--l. 1543--><p class="noindent" >
</div>
</div>
      <!--l. 1544--><p class="noindent" >into <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(progn (eval-when (:compile-toplevel)
</td></tr></table>
      <!--l. 1546--><p class="noindent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">         (compiler::notice-function &#x2019;bar &#x2019;(x)))</td></tr></table>
      <!--l. 1547--><p class="noindent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">       (eval-when (:load-toplevel :execute)</td></tr></table>
      <!--l. 1548--><p class="noindent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">         (setf (symbol-function &#x2019;bar)</td></tr></table>
      <!--l. 1549--><p class="noindent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">               #&#x2019;(lambda (x)</td></tr></table>
      <!--l. 1550--><p class="noindent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">                   (progn (eval-when (:compile-toplevel)</td></tr></table>
      <!--l. 1551--><p class="noindent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">                            (compiler::notice-function &#x2019;foo</td></tr></table>
      <!--l. 1552--><p class="noindent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">                                                       &#x2019;()))</td></tr></table>
      <!--l. 1553--><p class="noindent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">                          (eval-when (:load-toplevel :execute)</td></tr></table>
      <!--l. 1554--><p class="noindent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">                            (setf (symbol-function &#x2019;foo)</td></tr></table>
                                                                          

                                                                          
      <!--l. 1555--><p class="noindent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">                                  #&#x2019;(lambda () (+ x 3)))))))))</td></tr></table>
      <!--l. 1557--><p class="noindent" >
</div>
</div>
      <!--l. 1558--><p class="noindent" >which by the preceding rules would be treated the same as <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(progn (eval-when (:compile-toplevel)
</td></tr></table>
      <!--l. 1560--><p class="noindent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">         (compiler::notice-function &#x2019;bar &#x2019;(x)))</td></tr></table>
      <!--l. 1561--><p class="noindent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">       (eval-when (:load-toplevel :execute)</td></tr></table>
      <!--l. 1562--><p class="noindent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">         (setf (symbol-function &#x2019;bar)</td></tr></table>
      <!--l. 1563--><p class="noindent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">               #&#x2019;(lambda (x)</td></tr></table>
      <!--l. 1564--><p class="noindent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">                   (progn (eval-when (:load-toplevel :execute)</td></tr></table>
      <!--l. 1565--><p class="noindent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">                            (setf (symbol-function &#x2019;foo)</td></tr></table>
      <!--l. 1566--><p class="noindent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">                                  #&#x2019;(lambda () (+ x 3)))))))))</td></tr></table>
      <!--l. 1568--><p class="noindent" >
</div>
</div>
      </li></ul>
<!--l. 1571--><p class="indent" >   Here are some additional examples. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((x 1))
</td></tr></table>
<!--l. 1573--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (eval-when (:execute :load-toplevel :compile-toplevel)</td></tr></table>
<!--l. 1574--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (setf (symbol-function &#x2019;foo1) #&#x2019;(lambda () x))))</td></tr></table>
<!--l. 1576--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 1577--><p class="noindent" >The <i>eval-when</i> in the preceding expression is not at top level, so only the <i>:execute</i>
keyword is considered. At compile time, this has no eﬀect. At load time (if the <i>let</i>
is at top level), or at execution time (if the <i>let</i> is embedded in some other form
which does not execute until later), this sets <i>(symbol-function &#x2019;foo1)</i> to a function
that returns <i>1</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eval-when (:execute :load-toplevel :compile-toplevel)
</td></tr></table>
<!--l. 1585--><p class="indent" >                                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((x 2))</td></tr></table>
<!--l. 1586--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (eval-when (:execute :load-toplevel :compile-toplevel)</td></tr></table>
<!--l. 1587--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (setf (symbol-function &#x2019;foo2) #&#x2019;(lambda () x)))))</td></tr></table>
<!--l. 1589--><p class="indent" >
</div>
</div>
<!--l. 1590--><p class="noindent" >If the preceding expression occurs at the top level of a ﬁle to be compiled, it has <i>both</i>
a compile time <i>and</i> a load-time eﬀect of setting <i>(symbol-function &#x2019;foo2)</i> to a
function that returns <i>2</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eval-when (:execute :load-toplevel :compile-toplevel)
</td></tr></table>
<!--l. 1594--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf (symbol-function &#x2019;foo3) #&#x2019;(lambda () 3)))</td></tr></table>
<!--l. 1596--><p class="indent" >
</div>
</div>
<!--l. 1597--><p class="noindent" >If the preceding expression occurs at the top level of a ﬁle to be compiled, it has <i>both</i>
a compile time <i>and</i> a load-time eﬀect of setting the function cell of <i>foo3</i> to a
function that returns <i>3</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eval-when (:compile-toplevel)
</td></tr></table>
<!--l. 1602--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (eval-when (:compile-toplevel)</td></tr></table>
<!--l. 1603--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (print &#x2019;foo4)))</td></tr></table>
<!--l. 1605--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1606--><p class="noindent" >The preceding expression always does nothing; it simply returns <i>nil</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eval-when (:compile-toplevel)
</td></tr></table>
<!--l. 1608--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (eval-when (:execute)</td></tr></table>
<!--l. 1609--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (print &#x2019;foo5)))</td></tr></table>
<!--l. 1611--><p class="indent" >
</div>
</div>
<!--l. 1612--><p class="noindent" >If the preceding form occurs at the top level of a ﬁle to be compiled, <i>foo5</i> is printed
at compile time. If this form occurs in a non-top-level position, nothing is printed
at compile time. Regardless of context, nothing is ever printed at load time or
execution time.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eval-when (:execute :load-toplevel)
</td></tr></table>
<!--l. 1619--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (eval-when (:compile-toplevel)</td></tr></table>
<!--l. 1620--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (print &#x2019;foo6)))</td></tr></table>
<!--l. 1622--><p class="indent" >
</div>
</div>
<!--l. 1624--><p class="indent" >   If the preceding form occurs at the top level of a ﬁle to be compiled, <i>foo6</i> is
printed at compile time. If this form occurs in a non-top-level position, nothing is
printed at compile time. Regardless of context, nothing is ever printed at load
time or execution time.
</div>
</div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
   <!--l. 6--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch6.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse29.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse29.html#tailclmse29.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse30.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse30.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 6--><p class="indent" >   <a 
 id="tailclmse30.html"></a>  
</body></html> 
