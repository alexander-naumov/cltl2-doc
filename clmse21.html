<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Type Speciﬁers That Combine Комбинированные спецификаторы
типов</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 210--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse22.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse20.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse20.html#tailclmse20.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse21.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch4.html#clmse21.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">4.4   </span> <a 
 id="x30-480004.4"></a>Type Speciﬁers That Combine Комбинированные спецификаторы
типов</h3>
<!--l. 212--><p class="noindent" >The following type speciﬁer lists deﬁne a type in terms of other types or
objects.
<!--l. 215--><p class="indent" >   Следущие списки специфкаторы типов, определяют новый тип в терминах
других типов или объектов.
<div class=flushdesc>
<!--l. 219--><p class="indent" >
  <div><br /><b>
<i>(member <i>object1</i> <i>object2</i> ...)</i>                                               </b>
This denotes the set containing precisely those objects named. An object is
of this type if and only if it is <i>eql</i> to one of the speciﬁed objects.
<!--l. 224--><p class="indent" >  Такая                                запись                                обозначает
тип, как множество содержащее определенный набор объектов. Объект
принадлежит данному типу тогда и только тогда, когда он равен <i>eql</i>
одному из заданных объектов. FIXME.
<div class=incompatibility>
<!--l. 229--><p class="noindent" ><b>Compatibility note:</b> This is roughly equivalent to the Interlisp DECL package&#x2019;s
<i>memq</i>.
</div>
  </div>
</div>
<div class=newer>
<div class=flushdesc>
<!--l. 238--><p class="indent" >
  <div><br /><b>
<i>(eql <i>object</i>)</i>                                                                </b>
                                                                          

                                                                          
X3J13  voted  in  June  1988  ⟨<b>?</b>⟩ to  add  the  <i>eql</i> type  speciﬁer.  It  may  be
used as a parameter specializer for CLOS methods (see section <a 
href="clmse150.html#x183-27900028.1.6">28.1.6<!--tex4ht:ref: Introduction-to-Methods-SECTION --></a> and
<i>ﬁnd-method</i>). It denotes the set of the one object named; an object is of this
type if and only if it is <i>eql</i> to <i>object</i>. While <i>(eql <i>object</i>)</i> denotes the same
type as <i>(member <i>object</i>)</i>, only <i>(eql <i>object</i>)</i> may be used as a CLOS parameter
specializer.
<!--l. 248--><p class="indent" >  Такой специализатор может быть использован для определения CLOS
методов. Смотрите раздел <a 
href="clmse150.html#x183-27900028.1.6">28.1.6<!--tex4ht:ref: Introduction-to-Methods-SECTION --></a> и <i>ﬁnd-method</i>. Он задает множество
из одного объекта. Объект принадлежит такому типу тогда и только
тогда, когда он <i>eql</i> для первого <i>объекта</i>. Несмотря на то, что <i>(eql <i>объект</i>)</i>
обозначает то же, что и <i>(member <i>объект</i>)</i>, только <i>(eql <i>объект</i>)</i> может
быть использован для определения CLOS метода.</div>
</div>
</div>
<div class=flushdesc>
<!--l. 259--><p class="indent" >
  <div><br /><b>
<i>(not <i>type</i>)</i>                                                                 </b>
This denotes the set of all those objects that are <i>not</i> of the speciﬁed type.
<!--l. 263--><p class="indent" >  Такая запись задает тип множества объектов, которые <i>не</i> являются
типом type.
  <br /><b>
<i>(and <i>type1</i> <i>type2</i> ...)</i>                                                      </b>
This denotes the intersection of the speciﬁed types.
<!--l. 270--><p class="indent" >  Такая запись задает пересечение указанных типов.
<div class=incompatibility>
<!--l. 273--><p class="noindent" ><b>Compatibility note:</b> This is roughly equivalent to the Interlisp DECL package&#x2019;s
<i>allof </i>.
</div>
<!--l. 279--><p class="indent" >  When <i>typep</i> processes an <i>and</i> type speciﬁer, it always tests each of the
component types in order from left to right and stops processing as soon as one
component of the intersection has been found to which the object in question does
not belong. In this respect an <i>and</i> type speciﬁer is similar to an executable <i>and</i>
form. The purpose of this similarity is to allow a <i>satisﬁes</i> type speciﬁer to depend
on ﬁltering by previous type speciﬁers. For example, suppose there were a
                                                                          

                                                                          
function <i>primep</i> that takes an integer and says whether it is prime. Suppose also
that it is an error to give any object other than an integer to <i>primep</i>. Then the
type speciﬁer
<!--l. 291--><p class="indent" >  Когда <i>typep</i> обрабатывает спецификатор типа <i>and</i>, она производит
проверку на принадлежность к каждому подтипу слева направо и
моментально останавливает проверку, в случае первого случившегося
отрицательного результата. Таким образом, спецификатор <i>and</i> ведет себя
подобно форме <i>and</i>. Цель такого сходства — позволить спецификатору типа
<i>satisﬁes</i> зависеть от фильтрации предыдущим спецификатором типа.
Например, предположим, что есть функция <i>primep</i>, что принимает целое и
возвращает <i>t</i>, если оно простое. Также предположим, что является
ошибочным передавать любой объект, не являющийся целым, в <i>primep</i>. Тогда
спецификатор будет выглядеть так:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(and integer (satisﬁes primep))
</td></tr></table>
<!--l. 303--><p class="indent" >
</div>
</div>
<!--l. 304--><p class="noindent" >is guaranteed never to result in an error because the function <i>primep</i> will not be
invoked unless the object in question has already been determined to be an
integer.
<!--l. 308--><p class="indent" >  никогда не вызовет ошибку, так как функция <i>primep</i> никогда не будет
вызвана с объектом, который не удовлетворяет предыдущему типу
integer.
  <br /><b>
<i>(or <i>type1</i> <i>type2</i> ...)</i>                                                        </b>This
denotes the union of the speciﬁed types. For example, the type <i>list</i> by deﬁnition is
the same as <i>(or null cons)</i>. Also, the value returned by the function <i>position</i>
is always of type <i>(or null (integer 0 *))</i> (either <i>nil</i> or a non-negative
integer).
<!--l. 318--><p class="indent" >  Такая запись обозначает объединение типов. Например, тип <i>list</i> совпадает
                                                                          

                                                                          
с <i>(or null cons)</i>. Также, значение, возвращаемое функцией <i>position</i> всегда
принадлежит типу <i>(or null (integer 0 *))</i> (или <i>nil</i> или неотрицательное
число).
<div class=incompatibility>
<!--l. 323--><p class="noindent" ><b>Compatibility note:</b> This is roughly equivalent to the Interlisp DECL package&#x2019;s
<i>oneof </i>.
</div>
<!--l. 329--><p class="indent" >  As for <i>and</i>, when <i>typep</i> processes an <i>or</i> type speciﬁer, it always tests each of
the component types in order from left to right and stops processing as soon as
one component of the union has been found to which the object in question
belongs.
<!--l. 335--><p class="indent" >  Также как и для <i>and</i>, когда <i>typep</i> обрабатывает спецификатор типа <i>or</i>, она
поочередно проверяет каждый подтип объедиения слева направо и завершает
обработку, как только принадлежность подтипу установлена.</div>
</div>
                                                                          

                                                                          
   <!--l. 340--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse22.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse20.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse20.html#tailclmse20.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse21.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch4.html#clmse21.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 340--><p class="indent" >   <a 
 id="tailclmse21.html"></a>  
</body></html> 
