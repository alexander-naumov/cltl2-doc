<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Random Numbers</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-19 00:40:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 3890--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse70.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html#tailclmse68.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse69.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse69.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">12.9   </span> <a 
 id="x86-18700012.9"></a>Random Numbers</h3>
<!--l. 3893--><p class="noindent" >The Common Lisp facility for generating pseudo-random numbers has been
carefully deﬁned to make its use reasonably portable. While two implementations
may produce diﬀerent series of pseudo-random numbers, the distribution of values
should be relatively independent of such machine-dependent aspects as word
size.
<div class=defun>
<!--l. 3900--><p class="noindent" ><i>[Function]</i><a 
 id="dx86-187001"></a><a 
 id="x86-187002r280"></a><b> random</b>  <i>number</i> &#x0026;optional  <i>state</i>
<!--l. 3902--><p class="noindent" >(random <i>n</i>) accepts a positive number <i>n</i> and returns a number of the same kind
between zero (inclusive) and <i>n</i> (exclusive). The number <i>n</i> may be an integer or a
ﬂoating-point number. An approximately uniform choice distribution is used. If
<i>n</i> is an integer, each of the possible results occurs with (approximate)
probability 1/<i>n</i>. (The qualiﬁer “approximate” is used because of implementation
considerations; in practice, the deviation from uniformity should be quite
small.)
<!--l. 3913--><p class="indent" >   The argument <i>state</i> must be an object of type random-state; it defaults to the
value of the variable *random-state*. This object is used to maintain the state of
the pseudo-random-number generator and is altered as a side eﬀect of the <a 
href="#x86-187002r280">random</a>
operation.
<div class=incompatibility>
<!--l. 3919--><p class="noindent" ><b>Compatibility note:</b> <a 
href="#x86-187002r280">random</a> of zero arguments as deﬁned in MacLisp has been
omitted because its value is too implementation-dependent (limited by ﬁxnum
range).
</div>
<div class=implementation>
<!--l. 3925--><p class="noindent" ><b>Implementation note:</b> In general, even if <a 
href="#x86-187002r280">random</a> of zero arguments were deﬁned as in
MacLisp, it is not adequate to deﬁne (random <i>n</i>) for integral <i>n</i> to be simply (mod
(random) <i>n</i>); this fails to be uniformly distributed if <i>n</i> is larger than the largest number
produced by <a 
href="#x86-187002r280">random</a>, or even if <i>n</i> merely approaches this number. This is another reason
for omitting <a 
href="#x86-187002r280">random</a> of zero arguments in Common Lisp. Assuming that the underlying
mechanism produces “random bits” (possibly in chunks such as ﬁxnums), the best
                                                                          

                                                                          
approach is to produce enough random bits to construct an integer <i>k</i> some
number <i>d</i> of bits larger than (integer-length <i>n</i>) (see <a 
href="clmse67.html#x84-185067r271">integer-length</a>), and then
compute (mod <i>k</i> <i>n</i>). The quantity <i>d</i> should be at least 7, and preferably 10 or
more.
<!--l. 3940--><p class="indent" >   To produce random ﬂoating-point numbers in the half-open range <span class="math">[<i>A</i>,<i>B</i>)</span>, accepted
practice (as determined by a look through the <i>Collected Algorithms from the ACM</i>,
particularly algorithms 133, 266, 294, and 370) is to compute <span class="math"><i>X</i> ⋅ (<i>B</i> −<i>A</i>) + <i>A</i></span>,
where <i>X</i> is a ﬂoating-point number uniformly distributed over <span class="math">[0.0,1.0)</span> and
computed by calculating a random integer <span class="math"><i>N</i></span> in the range <span class="math">[0,<i>M</i>)</span> (typically by a
multiplicative-congruential or linear-congruential method mod <span class="math"><i>M</i></span>) and then setting
<span class="math"><i>X</i> = <i>N</i>∕<i>M</i></span>. See also <span class="cite">[<a 
href="clmli5.html#XKNUTH-VOLUME-2">27</a>]</span>. If one takes <span class="math"><i>M</i> = 2<sup>f</sup></span>, where <span class="math"><i>f</i></span> is the length of the signiﬁcand of a
ﬂoating-point number (and it is in fact common to choose <span class="math"><i>M</i></span> to be a power of
2), then this method is equivalent to the following assembly-language-level
procedure. Assume the representation has no hidden bit. Take a ﬂoating-point 0.5,
and clobber its entire signiﬁcand with random bits. Normalize the result if
necessary.
<!--l. 3959--><p class="indent" >   For example, on the DEC PDP-10, assume that accumulator T is completely random
(all 36 bits are random). Then the code sequence <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">LSH T,-9                 ;Clear high 9 bits; low 27 are random
</td></tr></table>
<!--l. 3962--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">FSC T,128.               ;Install exponent and normalize</td></tr></table>
<!--l. 3964--><p class="indent" >
</div>
</div>
<!--l. 3965--><p class="noindent" >will produce in T a random ﬂoating-point number uniformly distributed over <span class="math">[0.0,1.0)</span>.
(Instead of the LSH instruction, one could do <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">TLZ T,777000             ;That&#x2019;s 777000 octal
</td></tr></table>
<!--l. 3970--><p class="indent" >
</div>
</div>
<!--l. 3971--><p class="noindent" >but if the 36 random bits came from a congruential random-number generator, the
high-order bits tend to be “more random” than the low-order ones, and so the LSH
would be better for uniform distribution. Ideally all the bits would be the result of
high-quality randomness.)
                                                                          

                                                                          
<!--l. 3976--><p class="indent" >   With a hidden-bit representation, normalization is not a problem, but dealing with
the hidden bit is. The method can be adapted as follows. Take a ﬂoating-point 1.0 and
clobber the explicit signiﬁcand bits with random bits; this produces a random
ﬂoating-point number in the range <span class="math">[1.0,2.0)</span>. Then simply subtract 1.0. In eﬀect, we let
the hidden bit creep in and then subtract it away again.
<!--l. 3983--><p class="indent" >   For example, on the DEC VAX, assume that register T is completely random (but a
little less random than on the PDP-10, as it has only 32 random bits). Then the code
sequence <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">INSV #̂X81,#7,#9,T     ;Install correct sign bit and exponent
</td></tr></table>
<!--l. 3987--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">SUBF #̂F1.0,T          ;Subtract 1.0</td></tr></table>
<!--l. 3989--><p class="indent" >
</div>
</div>
<!--l. 3990--><p class="noindent" >will produce in T a random ﬂoating-point number uniformly distributed over <span class="math">[0.0,1.0)</span>.
Again, if the low-order bits are not random enough, then the instruction <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">ROTL #7,T
</td></tr></table>
<!--l. 3995--><p class="indent" >
</div>
</div>
<!--l. 3996--><p class="noindent" >should be performed ﬁrst.
<!--l. 3998--><p class="indent" >   Implementors may wish to consult reference <span class="cite">[<a 
href="clmli5.html#XADDITIVE-RANDOMS">41</a>]</span> for a discussion of some eﬃcient
methods of generating pseudo-random numbers.
</div>
</div>
<div class=defun>
<!--l. 4004--><p class="noindent" ><i>[Variable]</i><a 
 id="dx86-187003"></a><a 
 id="x86-187004r281"></a><b> *random-state*</b>
<!--l. 4006--><p class="noindent" >This variable holds a data structure, an object of type random-state, that encodes
the internal state of the random-number generator that <a 
href="#x86-187002r280">random</a> uses by default.
The nature of this data structure is implementation-dependent. It may be printed
out and successfully read back in, but may or may not function correctly as a
random-number state object in another implementation. A call to <a 
href="#x86-187002r280">random</a> will
perform a side eﬀect on this data structure. Lambda-binding this variable to a
diﬀerent random-number state object will correctly save and restore the old state
object.
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 4019--><p class="noindent" ><i>[Function]</i><a 
 id="dx86-187005"></a><a 
 id="x86-187006r282"></a><b> make-random-state</b>  &#x0026;optional  <i>state</i>
<!--l. 4021--><p class="noindent" >This function returns a new object of type random-state, suitable for use as the
value of the variable *random-state*. If <i>state</i> is <a 
href="clmse31.html#x42-74002r18">nil</a> or omitted, <a 
href="#x86-187006r282">make-random-state</a>
returns a <i>copy</i> of the current random-number state object (the value of the
variable *random-state*). If <i>state</i> is a state object, a copy of that state object
is returned. If <i>state</i> is <a 
href="clmse31.html#x42-74004r19">t</a>, then a new state object is returned that has
been “randomly” initialized by some means (such as by a time-of-day
clock).
<div class=rationale>
<!--l. 4032--><p class="noindent" ><b>Rationale:</b> Common Lisp purposely provides no way to initialize a random-state object
from a user-speciﬁed “seed.” The reason for this is that the number of bits of state
information in a random-state object may vary widely from one implementation
to another, and there is no simple way to guarantee that any user-speciﬁed
seed value will be “random enough.” Instead, the initialization of random-state
objects is left to the implementor in the case where the argument <a 
href="clmse31.html#x42-74004r19">t</a> is given to
<a 
href="#x86-187006r282">make-random-state</a>.
<!--l. 4042--><p class="indent" >   To handle the common situation of executing the same program many times in a
reproducible manner, where that program uses <a 
href="#x86-187002r280">random</a>, the following procedure may be
used:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x86-187008x1">Evaluate (make-random-state t) to create a random-state object.
      </li>
      <li 
  class="enumerate" id="x86-187010x2">Write that object to a ﬁle, using <a 
href="clmse112.html#x139-260010r670">print</a>, for later use.
      </li>
      <li 
  class="enumerate" id="x86-187012x3">Whenever the program is to be run, ﬁrst use <a 
href="clmse111.html#x138-257003r653">read</a> to create a copy of the
      random-state object from the printed representation in the ﬁle. Then use
      the random-state object newly created by the <a 
href="clmse111.html#x138-257003r653">read</a> operation to initialize the
      random-number generator for the program.</li></ol>
<!--l. 4059--><p class="noindent" >It is for the sake of this procedure for reproducible execution that implementations are
required to provide a read/print syntax for objects of type random-state.
<!--l. 4063--><p class="indent" >   It is also possible to make copies of a random-state object directly without going
through the print/read process, simply by using the <a 
href="#x86-187006r282">make-random-state</a> function to copy
the object; this allows the same sequence of random numbers to be generated many
times within a single program.
</div>
                                                                          

                                                                          
<div class=implementation>
<!--l. 4070--><p class="noindent" ><b>Implementation note:</b> A recommended way to implement the type random-state is
eﬀectively to use the machinery for <a 
href="clmse99.html#x123-227002r580">defstruct</a>. The usual structure syntax may
then be used for printing random-state objects; one might look something like
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#S(RANDOM-STATE DATA #(14 49 98436589 786345 8734658324 ...))
</td></tr></table>
<!--l. 4077--><p class="indent" >
</div>
</div>
<!--l. 4078--><p class="noindent" >where the components are of course completely implementation-dependent.
</div>
</div>
<div class=defun>
<!--l. 4083--><p class="noindent" ><i>[Function]</i><a 
 id="dx86-187013"></a><a 
 id="x86-187014r283"></a><b> random-state-p</b>  <i>object</i>
<!--l. 4085--><p class="noindent" ><a 
href="#x86-187014r283">random-state-p</a> is true if its argument is a random-state object, and otherwise is
false. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(random-state-p <i>x</i>) <span class="math"> ≡</span> (typep <i>x</i> &#x2019;random-state)
</td></tr></table>
<!--l. 4090--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
   <!--l. 4093--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse70.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html#tailclmse68.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse69.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse69.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 4093--><p class="indent" >   <a 
 id="tailclmse69.html"></a>  
</body></html> 
