<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Приведение типов и доступ к компонентам чисел</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 23:44:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 6169--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse70.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html#tailclmse68.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse69.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse69.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">12.6   </span> <a 
href="clm.html#QQ2-86-1206" id="x86-117700012.6">Приведение типов
и доступ к компонентам чисел</a></h3>
<!--l. 6171--><p class="noindent" >Тогда как большинство арифметических функций будут оперировать любым
типом чисел, выполняя при необходимости приведения, следующие функции
позволяют явно преобразовывать типы данных.
<div class="defun">
<!--l. 6175--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1177001"></a><a 
 id="x86-1177002r233"></a><b> ﬂoat</b>  <i>number</i> &#x0026;optional  <i>other</i>
</div>
<!--l. 6177--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-117800012.6" id="x86-117800012.6"></a></span>
   Преобразует любое некомплексное число в число с плавающей точкой.
При отсутствии необязательного параметра, если <i>number</i> уже является
числом с плавающей точкой, то оно и будет возвращено, иначе число будет
преобразовано в <tt>single-float</tt>. Если аргумент <i>other</i> указан, тогда он должен
быть числом с плавающей точкой, и <i>number</i> будет конвертирован в такой же
формат как у <i>other</i>.
<!--l. 6186--><p class="indent" >   Смотрите также <tt><a 
href="clmli7.html#x196-3479238r238">coerce</a></tt>.
</div>
<div class="defun">
<!--l. 6189--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1178001"></a><a 
 id="x86-1178002r234"></a><b> rational</b>  <i>number</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1178003"></a><a 
 id="x86-1178004r235"></a><b> rationalize</b>  <i>number</i>
</div>
<!--l. 6192--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-117900012.6" id="x86-117900012.6"></a></span>
   Каждая из этих функций преобразует любое некомплексное число в
рациональное. Если аргумент уже является рациональным, он возвращается
как есть. Две функции различаются в том, как они обрабатывают числа с
плавающей точкой.
<tt>
<!--l. 6197--><p class="indent" >   rational</tt> предполагает, что число с плавающей точкой совершенно точно,
и возвращает рациональное число математически эквивалентное значению
числа с плавающей точкой.
<tt>
                                                                          

                                                                          
<!--l. 6201--><p class="indent" >   <a 
href="clmli7.html#x196-3479761r761">rationalize</a></tt> предполагает, что число с плавающей точкой приближенное,
и может возвращать любое рациональное число, для которого исходное число
является наилучшим приближением. Функция пытается сохранить числитель
и знаменатель наименьшими насколько это возможно.
<!--l. 6206--><p class="indent" >   Следующие тождества всегда справедливы <div class="lisp"><div class="tabbing">
(ﬂoat (rational <i>x</i>) <i>x</i>) <span class="math"> ≡</span> <i>x</i>
   <br>
<!--l. 6209--><p class="noindent" ></div>
<!--l. 6209--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-118000012.6" id="x86-118000012.6"></a></span>
<!--l. 6209--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-118100012.6" id="x86-118100012.6"></a></span>
</div>
<!--l. 6210--><p class="indent" >   и <div class="lisp"><div class="tabbing">
(ﬂoat (rationalize <i>x</i>) <i>x</i>) <span class="math"> ≡</span> <i>x</i>
   <br>
<!--l. 6213--><p class="noindent" ></div>
<!--l. 6213--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-118200012.6" id="x86-118200012.6"></a></span>
<!--l. 6213--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-118300012.6" id="x86-118300012.6"></a></span>
</div>
<!--l. 6214--><p class="indent" >   То есть, преобразование числа с плавающей точкой любым из методов
туда и обратно даёт исходное число. Различие в том, что <tt>rational</tt> обычно
имеет более простую недорогую реализацию, тогда как <tt><a 
href="clmli7.html#x196-3479761r761">rationalize</a></tt>
представляет более «красивое» число.
</div>
<div class="defun">
                                                                          

                                                                          
<!--l. 6220--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1183001"></a><a 
 id="x86-1183002r236"></a><b> numerator</b>  <i>rational</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1183003"></a><a 
 id="x86-1183004r237"></a><b> denominator</b>  <i>rational</i>
</div>
<!--l. 6223--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-118400012.6" id="x86-118400012.6"></a></span>
   Эти функции принимают рациональное число (целое или дробное) и
возвращают в качестве целого числа числитель или знаменатель дроби,
приведённое к каноническому виду. Числитель целого числа и является
этим числом. Знаменатель целого числа <tt>1</tt>. Следует отметить, что
<div class="lisp"><div class="tabbing">
(gcd (numerator <i>x</i>) (denominator <i>x</i>)) <span class="math"> ⇒</span> 1
   <br>
<!--l. 6230--><p class="noindent" ></div>
<!--l. 6230--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-118500012.6" id="x86-118500012.6"></a></span>
<!--l. 6230--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-118600012.6" id="x86-118600012.6"></a></span>
</div>
<!--l. 6231--><p class="indent" >   Знаменатель будет всегда строго положительным числом. Числитель
может быть любым целым числом. Например: <div class="lisp"><div class="tabbing">
(numerator (/ 8 -6)) <span class="math"> ⇒</span> -4
   <br>                                                         (denominator (/ 8 -6)) <span class="math"> ⇒</span> 3<br>
<!--l. 6237--><p class="noindent" ></div>
<!--l. 6237--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-118700012.6" id="x86-118700012.6"></a></span>
                                                                          

                                                                          
<!--l. 6237--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-118800012.6" id="x86-118800012.6"></a></span>
</div>
</div>
<!--l. 6240--><p class="indent" >   В Common Lisp&#x2019;е нет функции <tt>fix</tt>, потому что есть несколько интересных
способов преобразовать нецелое число к целому. Эти способы представлены
функциями ниже, которые выполняются не только преобразование типа, но
также некоторые нетривиальные вычисления.
<div class="defun">
<!--l. 6245--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1188001"></a><a 
 id="x86-1188002r238"></a><b> ﬂoor</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1188003"></a><a 
 id="x86-1188004r239"></a><b> ceiling</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1188005"></a><a 
 id="x86-1188006r240"></a><b> truncate</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1188007"></a><a 
 id="x86-1188008r241"></a><b> round</b>  <i>number</i> &#x0026;optional  <i>divisor</i>
</div>
<!--l. 6250--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-118900012.6" id="x86-118900012.6"></a></span>
   При вызове с одним аргументом, каждая из этих функций преобразует
аргумент <i>number</i> (который не может быть комплексным числом) в целое
число. Если аргумент уже является целым числом, то он немедленно
возвращается в качестве результата. Если аргумент дробь или число с
плавающей точкой, для конвертации функции используют различные
алгоритмы.
<tt>
<!--l. 6258--><p class="indent" >   <a 
href="clmli7.html#x196-3479419r419">floor</a></tt> преобразовывает аргумент путём отсечения к отрицательной
бесконечности, то есть, результатом является наибольшее целое число,
которое не больше чем аргумент.
<tt>
<!--l. 6262--><p class="indent" >   <a 
href="clmli7.html#x196-3479198r198">ceiling</a></tt> преобразовывает аргумент путём отсечения к положительной
бесконечности, то есть, результатом является наименьшее целое число,
которое не меньше чем аргумент.
<tt>
<!--l. 6266--><p class="indent" >   <a 
href="clmli7.html#x196-3479198r198">ceiling</a></tt> преобразовывает аргумент путём отсечения к нулю, то есть,
результатом является целое число с таким же знаком, которое имеет
наибольшую целую величину, но не большую чем аргумент.
<!--l. 6270--><p class="indent" >   Следующая таблица содержит то, что возвращают четыре функции для
разных аргументов.
<div class="flushleft" 
>
                                                                          

                                                                          
<!--l. 6273--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Аргумент</td><td align="left" >ﬂoor</td><td align="left" >ceiling</td><td align="left" >truncate</td><td align="left" >round</td>
</tr><tr><td align="left" >     2.6    </td><td align="left" >  2 </td><td align="left" >    3   </td><td align="left" >     2    </td><td align="left" >   3  </td></tr><tr><td align="left" >  2.5 </td> <td align="left" >  2 </td> <td align="left" >  3 </td> <td align="left" >  2 </td> <td align="left" >  2</td>
</tr><tr><td align="left" >     2.4    </td><td align="left" >  2 </td><td align="left" >    3   </td><td align="left" >     2    </td><td align="left" >   2  </td></tr><tr><td align="left" >  0.7 </td> <td align="left" >  0 </td> <td align="left" >  1 </td> <td align="left" >  0 </td> <td align="left" >  1</td>
</tr><tr><td align="left" >     0.3    </td><td align="left" >  0 </td><td align="left" >    1   </td><td align="left" >     0    </td><td align="left" >   0  </td></tr><tr><td align="left" > -0.3 </td> <td align="left" > -1 </td> <td align="left" >  0 </td> <td align="left" >  0 </td> <td align="left" >  0</td>
</tr><tr><td align="left" >    -0.7    </td><td align="left" >  -1  </td><td align="left" >    0   </td><td align="left" >     0    </td><td align="left" >   -1   </td></tr><tr><td align="left" > -2.4 </td> <td align="left" > -3 </td> <td align="left" > -2 </td> <td align="left" > -2 </td> <td align="left" > -2</td>
</tr><tr><td align="left" >    -2.5    </td><td align="left" >  -3  </td><td align="left" >   -2   </td><td align="left" >    -2    </td><td align="left" >   -2   </td></tr><tr><td align="left" > -2.6 </td> <td align="left" > -3 </td> <td align="left" > -2 </td> <td align="left" > -2 </td> <td align="left" > -3</td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
<!--l. 6292--><p class="indent" >   Если указан второй аргумент <i>divisor</i>, тогда аргумент <i>number</i> будет
разделен на <i>divisor</i>, а затем уже будут проведены вышеописанные действия.
Например, <tt>(floor 5 2)</tt> <span class="math"> ≡</span> <tt>(values (floor (/ 5 2)))</tt>, но первый вариант
потенциально эффективнее.
<div class="new">
<!--l. 6298--><p class="indent" >   This statement is not entirely accurate; one should instead say that <tt>(values
(floor 5 2))</tt> <span class="math"> ≡</span> <tt>(values (floor (/ 5 2)))</tt>, because there is a second value
to consider, as discussed below. In other words, the ﬁrst values returned by the
two forms will be the same, but in general the second values will diﬀer. Indeed, we
have <div class="lisp"><div class="tabbing">
(ﬂoor 5 2) <span class="math"> ⇒</span> 2 and 1
   <br>                                                          (ﬂoor (/ 5 2)) <span class="math"> ⇒</span> 2 and 1/2<br>
<!--l. 6306--><p class="noindent" ></div>
<!--l. 6306--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-119000012.6" id="x86-119000012.6"></a></span>
<!--l. 6306--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-119100012.6" id="x86-119100012.6"></a></span>
</div>
<!--l. 6307--><p class="indent" >   for this example.
</div>
<i>
<!--l. 6310--><p class="indent" >   divisor</i> может любым числом, кроме комплексного. <i>divisor</i> не может
равняться нулю. Случай вызова функции с одним аргументом эквивалентен
вызову с двумя аргументами, последний из которых равен <tt>1</tt>.
<div class="newer">
                                                                          

                                                                          
<!--l. 6316--><p class="indent" >   In other words, the one-argument case returns an integer and fractional part
for the <i>number</i>: <tt>(truncate 5.3) <span class="math"> ⇒</span> 5.0 and  0.3</tt>, for example.
</div>
<!--l. 6320--><p class="indent" >   Каждая из функций возвращает <i>два</i> значения. Второе значение является
остатком и может быть получено с помощью <tt><a 
href="clmli7.html#x196-3479634r634">multiple-value-bind</a></tt> или
другими подобными конструкциями. Если любая из этих функций получает
два аргумента <i>x</i> и <i>y</i> и возвращает <i>q</i> и <i>r</i>, тогда <span class="math"><i>q</i> ⋅<i>y</i> + <i>r</i> = <i>x</i></span>. Первое
значение результата <i>q</i> всегда целочисленное. Остаток <i>r</i> целочисленный,
если оба аргумента были целочисленными, и рациональное, если оба
аргумента были рациональными, и с плавающей точкой, если один из
аргументов был с плавающей точкой. Если при вызове был указан
один аргумент, то тип данных остатка всегда такой же как и этот
аргумент.
<!--l. 6333--><p class="indent" >   Когда указывается только один аргумент, сумма двух значений
результата точно равняется переданному в параметре значению.
</div>
<div class="defun">
<!--l. 6337--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1191001"></a><a 
 id="x86-1191002r242"></a><b> mod</b>  <i>number</i> <i>divisor</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1191003"></a><a 
 id="x86-1191004r243"></a><b> rem</b>  <i>number</i> <i>divisor</i>
</div>
<!--l. 6340--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-119200012.6" id="x86-119200012.6"></a></span>
<tt>
   <a 
href="clmli7.html#x196-3479621r621">mod</a></tt> выполняет операцию <tt><a 
href="clmli7.html#x196-3479419r419">floor</a></tt> для двух аргументов и возвращает <i>второй</i>
результат <tt><a 
href="clmli7.html#x196-3479419r419">floor</a></tt>. Таким же образом, <tt><a 
href="clmli7.html#x196-3479779r779">rem</a></tt> выполняет операцию <tt><a 
href="clmli7.html#x196-3479954r954">truncate</a></tt> для
двух аргументов и возвращает <i>второй</i> результат <tt><a 
href="clmli7.html#x196-3479954r954">truncate</a></tt>.
<!--l. 6346--><p class="indent" >   Таким образом <tt><a 
href="clmli7.html#x196-3479621r621">mod</a></tt> и <tt><a 
href="clmli7.html#x196-3479779r779">rem</a></tt> являются обычными функциями вычисления
остатка от деления двух чисел. Аргументы могут быть также числами с
плавающей точкой. <div class="lisp"><div class="tabbing">
(mod 13 4) <span class="math"> ⇒</span> 1                           (rem 13 4) <span class="math"> ⇒</span> 1
   <br>                     (mod -13 4) <span class="math"> ⇒</span> 3                          (rem -13 4) <span class="math"> ⇒</span> -1<br>
(mod 13 -4) <span class="math"> ⇒</span> -3                         (rem 13 -4) <span class="math"> ⇒</span> 1<br>
(mod -13 -4) <span class="math"> ⇒</span> -1                        (rem -13 -4) <span class="math"> ⇒</span> -1<br>
(mod 13.4 1) <span class="math"> ⇒</span> 0.4                       (rem 13.4 1) <span class="math"> ⇒</span> 0.4<br>
(mod -13.4 1) <span class="math"> ⇒</span> 0.6                      (rem -13.4 1) <span class="math"> ⇒</span> -0.4<br>
                                                                          

                                                                          
<!--l. 6357--><p class="noindent" ></div>
<!--l. 6357--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-119300012.6" id="x86-119300012.6"></a></span>
<!--l. 6357--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-119400012.6" id="x86-119400012.6"></a></span>
</div>
</div>
<div class="defun">
<!--l. 6360--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1194001"></a><a 
 id="x86-1194002r244"></a><b> ﬄoor</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1194003"></a><a 
 id="x86-1194004r245"></a><b> fceiling</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1194005"></a><a 
 id="x86-1194006r246"></a><b> ftruncate</b>  <i>number</i> &#x0026;optional  <i>divisor</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1194007"></a><a 
 id="x86-1194008r247"></a><b> fround</b>  <i>number</i> &#x0026;optional  <i>divisor</i>
</div>
<!--l. 6365--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-119500012.6" id="x86-119500012.6"></a></span>
   Эти функции похожи на <tt><a 
href="clmli7.html#x196-3479419r419">floor</a></tt>, <tt><a 
href="clmli7.html#x196-3479198r198">ceiling</a></tt>, <tt><a 
href="clmli7.html#x196-3479954r954">truncate</a></tt> и <tt><a 
href="clmli7.html#x196-3479804r804">round</a></tt> за исключением
того, что результат (первый из двух) всегда целое число, а не число
с плавающей точкой. Это примерно, как если бы <tt><a 
href="clmli7.html#x196-3479386r386">ffloor</a></tt> передала
аргументы в <tt><a 
href="clmli7.html#x196-3479419r419">floor</a></tt>, а затем применила к первому результату <tt><a 
href="clmli7.html#x196-3479411r411">float</a></tt> и
вернула полученную пару значений. Однако, на практике <tt><a 
href="clmli7.html#x196-3479386r386">ffloor</a></tt> может
быть реализована более эффективно. Такое же описание подходит к
остальным трём функциям. Если первый аргумент является числом с
плавающей точкой, и второй аргумент не точнее типа первого, тогда первый
результат будет такого же типа как первый аргумент. Например:
<div class="lisp"><div class="tabbing">
(ﬄoor -4.7) <span class="math"> ⇒</span> -5.0 and 0.3
   <br>                                                   (ﬄoor 3.5d0) <span class="math"> ⇒</span> 3.0d0 and 0.5d0<br>
<!--l. 6379--><p class="noindent" ></div>
<!--l. 6379--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-119600012.6" id="x86-119600012.6"></a></span>
                                                                          

                                                                          
<!--l. 6379--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-119700012.6" id="x86-119700012.6"></a></span>
</div>
</div>
<div class="defun">
<!--l. 6382--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1197001"></a><a 
 id="x86-1197002r248"></a><b> decode-ﬂoat</b>  <i>ﬂoat</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1197003"></a><a 
 id="x86-1197004r249"></a><b> scale-ﬂoat</b>  <i>ﬂoat</i> <i>integer</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1197005"></a><a 
 id="x86-1197006r250"></a><b> ﬂoat-radix</b>  <i>ﬂoat</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1197007"></a><a 
 id="x86-1197008r251"></a><b> ﬂoat-sign</b>  <i>ﬂoat1</i> &#x0026;optional  <i>ﬂoat2</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1197009"></a><a 
 id="x86-1197010r252"></a><b> ﬂoat-digits</b>  <i>ﬂoat</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1197011"></a><a 
 id="x86-1197012r253"></a><b> ﬂoat-precision</b>  <i>ﬂoat</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1197013"></a><a 
 id="x86-1197014r254"></a><b> integer-decode-ﬂoat</b>  <i>ﬂoat</i>
</div>
<!--l. 6390--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-119800012.6" id="x86-119800012.6"></a></span>
   Функция <tt><a 
href="clmli7.html#x196-3479301r301">decode-float</a></tt> принимает числа с плавающей точкой и
возвращает три значения.
<!--l. 6394--><p class="indent" >   Первое значение является мантиссой и числом того же типа, что
и аргумент. Второе значение является целочисленной экспонентой.
Третье значение отображает знак аргумента (-1.0 или 1.0) и является и
числом того же типа, что и аргумент . Пусть <i>b</i> есть система счисления
для отображения чисел с плавающей точкой, тогда <tt><a 
href="clmli7.html#x196-3479301r301">decode-float</a></tt>
делит аргумент на <i>b</i> в некоторой степени, чтобы привести значение
в промежуток включая 1/<i>b</i> и не включая 1 и возвращает частное
в качестве первого значения FIXME. Однако, если аргумент равен
нулю результат равен абсолютному значению аргумента (то есть, если
существует отрицательный ноль, то для него возвращается положительный
ноль).
<!--l. 6405--><p class="indent" >   Второе значение <tt><a 
href="clmli7.html#x196-3479301r301">decode-float</a></tt> является целочисленным экспонентой <i>e</i>,
которая равняется степени, в которую было возведено <i>b</i>. Если аргумент
равен нулю, то может быть возвращено любое целое число, при условии, что
тожество, описанное ниже для <tt>scale-format</tt>, имеет место быть.
<!--l. 6410--><p class="indent" >   Третье значение <tt><a 
href="clmli7.html#x196-3479301r301">decode-float</a></tt> является числом с плавающей точкой в
том же формате, что и аргумент, абсолютное значение которого равно 1, и
знак совпадает со знаком аргумента.
<!--l. 6414--><p class="indent" >   Функция <tt><a 
href="clmli7.html#x196-3479813r813">scale-float</a></tt> принимает число с плавающей точкой <i>f </i> (не
обязательно между 1/<i>b</i> и 1) и целое число <i>k</i>, и возвращает <tt>(* <i>f</i> (expt
(float <i>b</i> <i>f</i>) <i>k</i>))</tt>. (Использование <tt><a 
href="clmli7.html#x196-3479813r813">scale-float</a></tt> может быть более
                                                                          

                                                                          
эффективным, чем использование возведения в степень или умножения и
позволяет избежать переполнений).
<!--l. 6420--><p class="indent" >   Следует отметить, что <div class="lisp"><div class="tabbing">
(multiple-value-bind (signif expon sign)
   <br>                       (decode-ﬂoat <i>f </i>)<br>    (scale-ﬂoat signif expon))<br>
<span class="math"> ≡</span> (abs <i>f </i>)<br>
<!--l. 6426--><p class="noindent" ></div>
<!--l. 6426--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-119900012.6" id="x86-119900012.6"></a></span>
<!--l. 6426--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-120000012.6" id="x86-120000012.6"></a></span>
</div>
<!--l. 6427--><p class="indent" >   и <div class="lisp"><div class="tabbing">
(multiple-value-bind (signif expon sign)
   <br>                                                              (decode-ﬂoat <i>f </i>)<br>
  (* (scale-ﬂoat signif expon) sign))<br>                                  <span class="math"> ≡</span> <i>f </i><br>
<!--l. 6433--><p class="noindent" ></div>
<!--l. 6433--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-120100012.6" id="x86-120100012.6"></a></span>
<!--l. 6433--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-120200012.6" id="x86-120200012.6"></a></span>
</div>
<!--l. 6435--><p class="indent" >   Функция <tt><a 
href="clmli7.html#x196-3479414r414">float-radix</a></tt> возвращает (в качестве целого числа) основание <i>b</i>
для числа с плавающей точкой.
<!--l. 6438--><p class="indent" >   Функция <tt><a 
href="clmli7.html#x196-3479415r415">float-sign</a></tt> возвращает такое число с плавающей точкой <i>z</i>,
что <i>z</i> и <i>ﬂoat1</i> имеют одинаковый знак, и <i>z</i> и <i>ﬂoat2</i> имеют равное
абсолютное значение. Аргумент <i>ﬂoat2</i> по-умолчанию имеет значение <tt>(float
1 <i>float1</i>)</tt>. Таким образом <tt>(float-sign x)</tt> всегда возвращает <tt>1.0</tt>
                                                                          

                                                                          
или <tt>-1.0</tt> в таком же формате и с тем же знаком, что и <i>x</i>. (Следует
отметить, что если реализация содержит различные представления для
отрицательного и положительного нулей, тогда <tt>(float-sign -0.0)</tt>
<span class="math"> ⇒</span> <tt>-1.0</tt>.)
<!--l. 6447--><p class="indent" >   Функция <tt><a 
href="clmli7.html#x196-3479412r412">float-digits</a></tt> возвращает целочисленное количество цифр
используемых в представлении аргумента. Функция <tt><a 
href="clmli7.html#x196-3479413r413">float-precision</a></tt>
возвращает целочисленное количество цифр в мантиссе аргумента.
Если аргумент равен нулю, то результатом также будет ноль. Для
нормализованных чисел с плавающей точкой, результаты <tt><a 
href="clmli7.html#x196-3479412r412">float-digits</a></tt> и
<tt><a 
href="clmli7.html#x196-3479413r413">float-precision</a></tt> будут такими же. Но в случае с денормализованными
числами или нулём точность будет меньше чем количество цифр в
представлении.
<!--l. 6455--><p class="indent" >   Функция <tt><a 
href="clmli7.html#x196-3479481r481">integer-decode-float</a></tt> похожа на <tt><a 
href="clmli7.html#x196-3479301r301">decode-float</a></tt>, но в качестве
первого значение возвращает масштабированную целочисленную мантиссу.
Для аргумента <i>f </i>, это число будет строго меньше чем <div class="lisp"><div class="tabbing">
<tt>(expt <i>b</i> (float-precision <i>f</i>))</tt>
   <br>
<!--l. 6460--><p class="noindent" ></div>
<!--l. 6460--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-120300012.6" id="x86-120300012.6"></a></span>
<!--l. 6460--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-120400012.6" id="x86-120400012.6"></a></span>
</div>
<!--l. 6461--><p class="indent" >   на не менее чем <div class="lisp"><div class="tabbing">
<tt>(expt <i>b</i> (- (float-precision <i>f</i>) 1))</tt>
   <br>
<!--l. 6464--><p class="noindent" ></div>
<!--l. 6464--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-120500012.6" id="x86-120500012.6"></a></span>
                                                                          

                                                                          
<!--l. 6464--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-120600012.6" id="x86-120600012.6"></a></span>
</div>
<!--l. 6465--><p class="indent" >   за исключением того, что если <i>f </i> равно нулю, тогда целочисленное
значение также будет равно нулю.
<!--l. 6468--><p class="indent" >   Второе значение имеет такую же связь с первым значением, как и для
<tt><a 
href="clmli7.html#x196-3479301r301">decode-float</a></tt>: <div class="lisp"><div class="tabbing">
(multiple-value-bind (signif expon sign)
   <br>                                                    (integer-decode-ﬂoat <i>f </i>)<br>
  (scale-ﬂoat (ﬂoat signif <i>f </i>) expon))<br>                            <span class="math"> ≡</span> (abs <i>f </i>)<br>
<!--l. 6475--><p class="noindent" ></div>
<!--l. 6475--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-120700012.6" id="x86-120700012.6"></a></span>
<!--l. 6475--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-120800012.6" id="x86-120800012.6"></a></span>
</div>
<!--l. 6477--><p class="indent" >   Третье значение <tt><a 
href="clmli7.html#x196-3479481r481">integer-decode-float</a></tt> будет <tt>1</tt> или <tt>-1</tt>.
<div class="rationale">
<!--l. 6480--><p class="noindent" ><b>Обоснование:</b> Эти функции позволяют писать машиннонезависиммые или как
минимум машиннопараметризированные приложения с вычислениями чисел с
плавающими точками с необходимой эффективностью.
</div>
</div>
<div class="defun">
<!--l. 6488--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1208001"></a><a 
 id="x86-1208002r255"></a><b> complex</b>  <i>realpart</i> &#x0026;optional  <i>imagpart</i>
</div>
<!--l. 6490--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-120900012.6" id="x86-120900012.6"></a></span>
   Аргументы должны быть некомплексными числами. Результатом
является число, которое имеет действительную часть <i>realpart</i> и мнимую
<i>imagpart</i>, возможно конвертированные к одному типу. Если <i>imagpart</i> не
указаны, тогда используется <tt>(coerce 0 (type-of <i>realpart</i>))</tt>. Необходимо
отметить, что если обе части комплексного число рациональны, и мнимая
часть равна нуля, то результатом будет только действительная часть <i>realpart</i>
                                                                          

                                                                          
так как в силу вступят правила канонизации. Таким образом результат
<tt><a 
href="clmli7.html#x196-3479267r267">complex</a></tt> не всегда является комплексным числом. Он может быть просто
рациональным числом (<tt>rational</tt>).
</div>
<div class="defun">
<!--l. 6503--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1209001"></a><a 
 id="x86-1209002r256"></a><b> realpart</b>  <i>number</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1209003"></a><a 
 id="x86-1209004r257"></a><b> imagpart</b>  <i>number</i>
</div>
<!--l. 6506--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-121000012.6" id="x86-121000012.6"></a></span>
   Эти функции возвращают действительную и мнимую части комплексного
числа. Если <i>number</i> не является комплексным числом, тогда <tt><a 
href="clmli7.html#x196-3479776r776">realpart</a></tt>
возвращает это число, а <tt><a 
href="clmli7.html#x196-3479471r471">imagpart</a></tt> возвращает <tt>(* 0 <i>number</i>)</tt>, другими
словами, <tt>0</tt> того типа, каким был аргумент.
<div class="newer">
<!--l. 6513--><p class="indent" >   A clever way to multiply a complex number <i>z</i> by <i>i</i> is to write <div class="lisp"><div class="tabbing">
(complex (- (imagpart <i>z</i>)) (realpart <i>z</i>))
   <br>
<!--l. 6516--><p class="noindent" ></div>
<!--l. 6516--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-121100012.6" id="x86-121100012.6"></a></span>
<!--l. 6516--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-121200012.6" id="x86-121200012.6"></a></span>
</div>
<!--l. 6517--><p class="indent" >   instead of <tt>(* <i>z</i> #c(0 1))</tt>. This cleverness is not always gratuitous; it may be
of particular importance in the presence of minus zero. For example, if we are
using IEEE standard ﬂoating-point arithmetic and <span class="math">z = 4 + 0<i>i</i></span>, the result of the
clever expression is <span class="math"> − 0 + 4<i>i</i></span>, a true <span class="math">90<sup>∘</sup></span> rotation of <span class="math"><i>z</i></span>, whereas the result of <tt>(* <i>z</i>
#c(0 1))</tt> is likely to be <div class="tabbing">
<span class="math">(4 + 0<i>i</i>)(+0 + <i>i</i>) = ((4)(+0) − (+0)(1)) + ((4)(1) + (+0)(+0))<i>i</i></span>
   <br>                                   <span class="math"> = ((+0) − (+0)) + ((4) + (+0))<i>i</i> = +0 + 4<i>i</i></span><br>
                                                                          

                                                                          
<!--l. 6526--><p class="noindent" ></div>
<!--l. 6526--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-121300012.6" id="x86-121300012.6"></a></span>
   which could land on the wrong side of a branch cut, for example.
</div>
</div>
                                                                          

                                                                          
<!--l. 6532--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse70.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html#tailclmse68.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse69.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse69.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse69.html"></a>   </div> </div> 
</body></html> 
