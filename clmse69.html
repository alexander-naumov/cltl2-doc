<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Логические операции над числами</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 4909--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse70.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html#tailclmse68.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse69.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse69.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">12.7   </span> <a 
href="clm.html#QQ2-86-1079" id="x86-107100012.7">Логические
операции над числами</a></h3>
<!--l. 4911--><p class="noindent" >Логические операции в данном разделе в качестве аргументов требуют целых
чисел. Передача числа любого другого формата является ошибкой. Функции
обрабатывают целые числа, как если бы они были представлены в двух
системах счисления. FIXME
<div class="implementation">
<!--l. 4917--><p class="noindent" ><b>Заметка для реализации:</b> Внутренне, конечно, реализация Common Lisp&#x2019;а может
использовать и может и нет представление числа с дополнительным кодом. Все,
что необходимо это чтобы логические операции выполняли вычисление так, как
описано в разделе.
</div>
<!--l. 4924--><p class="indent" >   Логические операции предоставляют удобный способ для представления
бесконечного вектора битов. Пусть такой концептуальный вектор будет
индексироваться с помощью неотрицательного целого. Тогда биту <span class="math">j</span>
присваивается «вес (weight)» <span class="math">2<sup>j</sup></span>. Предположим, что лишь конечное число
битов являются 1 или только конечное число битов являются 0. Вектор, у
которого конечное число битов 1, представлен как сумма всех весов этих
битов, и является положительным числом. Вектор, у которого конечное
число битов 0, представлен как <tt>-1</tt> минус сумма всех весов этих битов, и
является отрицательным числом. FIXME
<!--l. 4934--><p class="indent" >   Данный метод использования целых чисел для представления битовых
векторов может в свою очередь использоваться для представления множеств.
Предположим, что некоторая (возможно бесконечная) совокупность
рассуждений для множеств отображается в неотрицательные целые числа.
FIXME Тогда множество может быть представлено как битовый вектор.
Элемент принадлежит множеству, если бит, индекс которого соответствует
элементу, является 1. Таким образом все конечные множества могут быть
представлены с помощью положительных целых, и множества, дополнения
которых конечны, с помощью отрицательных чисел. Функции <tt><a 
href="#x86-1071002r256">logior</a></tt>, <tt><a 
href="#x86-1073002r258">logand</a></tt>
и <tt><a 
href="#x86-1072002r257">logxor</a></tt>, определённые ниже, вычисляют объединение, пересечение и
симметричную разность для таких множеств.
<div class="defun">
                                                                          

                                                                          
<!--l. 4946--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1071001"></a><a 
 id="x86-1071002r256"></a><b> logior</b>  &#x0026;rest  <i>integers</i>
</div>
<!--l. 4948--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-107200012.7" id="x86-107200012.7"></a></span>
   Функция возвращает побитовое логическое <i>или</i> для аргументов. Если не
задан ни один аргумент, возвращается ноль.
</div>
<div class="defun">
<!--l. 4953--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1072001"></a><a 
 id="x86-1072002r257"></a><b> logxor</b>  &#x0026;rest  <i>integers</i>
</div>
<!--l. 4955--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-107300012.7" id="x86-107300012.7"></a></span>
   Функция возвращает побитовое логическое <i>исключающее или</i> для
аргументов. Если не задан ни один аргумент, возвращается ноль.
</div>
<div class="defun">
<!--l. 4960--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1073001"></a><a 
 id="x86-1073002r258"></a><b> logand</b>  &#x0026;rest  <i>integers</i>
</div>
<!--l. 4962--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-107400012.7" id="x86-107400012.7"></a></span>
   Функция возвращает побитовое логическое <i>и</i> для аргументов. Если ни
один аргумент не задан, возвращается ноль.
</div>
<div class="defun">
<!--l. 4967--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1074001"></a><a 
 id="x86-1074002r259"></a><b> logeqv</b>  &#x0026;rest  <i>integers</i>
</div>
<!--l. 4969--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-107500012.7" id="x86-107500012.7"></a></span>
   Функция возвращает побитовую логическую <i>эквивалентность</i> (также
известную как <i>исключающее отрицающее или</i> для аргументов. Если не задан
ни один аргумент, возвращается ноль.
</div>
<div class="defun">
<!--l. 4975--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1075001"></a><a 
 id="x86-1075002r260"></a><b> lognand</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1075003"></a><a 
 id="x86-1075004r261"></a><b> lognor</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1075005"></a><a 
 id="x86-1075006r262"></a><b> logandc1</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1075007"></a><a 
 id="x86-1075008r263"></a><b> logandc2</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1075009"></a><a 
 id="x86-1075010r264"></a><b> logorc1</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx86-1075011"></a><a 
 id="x86-1075012r265"></a><b> logorc2</b>  <i>integer1</i> <i>integer2</i>
</div>
<!--l. 4982--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-107600012.7" id="x86-107600012.7"></a></span>
   Данные функции служат для шести нетривиальные битовый логический
операций для двух аргументов. Так как они не ассоциативны, они принимают
только два аргумента. <div class="lisp"><div class="tabbing">
(lognand <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (lognot (logand <i>n1</i> <i>n2</i>))
   <br>
(lognor <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (lognot (logior <i>n1</i> <i>n2</i>))
   <br>
(logandc1 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logand (lognot <i>n1</i>) <i>n2</i>)
   <br>
(logandc2 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logand <i>n1</i> (lognot <i>n2</i>))
   <br>
(logorc1 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logior (lognot <i>n1</i>) <i>n2</i>)
   <br>
(logorc2 <i>n1</i> <i>n2</i>) <span class="math"> ≡</span> (logior <i>n1</i> (lognot <i>n2</i>))
   <br>
<!--l. 4993--><p class="noindent" ></div>
<!--l. 4993--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-107700012.7" id="x86-107700012.7"></a></span>
<!--l. 4993--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-107800012.7" id="x86-107800012.7"></a></span>
</div>
</div>
<!--l. 4996--><p class="indent" >   В следующей таблице перечислены десять битовых логических операций
для двух целых чисел.
<div class="flushleft" 
>
                                                                          

                                                                          
<!--l. 4998--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" > <i>integer1</i></td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td>
</tr><tr><td align="left" > <i>integer2</i></td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >Имя операции                                                 </td>
</tr><tr><td align="left" >logand  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >и                                                                   </td>
</tr><tr><td align="left" > logior  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >или                                                                </td>
</tr><tr><td align="left" > logxor  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >исключающее или                                            </td>
</tr><tr><td align="left" >logeqv  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >эквивалентность (исключающее отрицающее или)</td>
</tr><tr><td align="left" >lognand </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >не и                                                               </td>
</tr><tr><td align="left" > lognor  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >не или                                                            </td>
</tr><tr><td align="left" >logandc1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >не <i>integer1</i> и <i>integer2</i>                                     </td>
</tr><tr><td align="left" >logandc2</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" ><i>integer1</i> и не <i>integer2</i>                                     </td>
</tr><tr><td align="left" > logorc1 </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >не <i>integer1</i> или <i>integer2</i>                                  </td>
</tr><tr><td align="left" > logorc2 </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" ><i>integer1</i> или не <i>integer2</i>                                  </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table></div></div>
<div class="defun">
<!--l. 5018--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1078001"></a><a 
 id="x86-1078002r266"></a><b> boole</b>  <i>op</i> <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078003"></a><a 
 id="x86-1078004r267"></a><b> boole-clr</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078005"></a><a 
 id="x86-1078006r268"></a><b> boole-set</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078007"></a><a 
 id="x86-1078008r269"></a><b> boole-1</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078009"></a><a 
 id="x86-1078010r270"></a><b> boole-2</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078011"></a><a 
 id="x86-1078012r271"></a><b> boole-c1</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078013"></a><a 
 id="x86-1078014r272"></a><b> boole-c2</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078015"></a><a 
 id="x86-1078016r273"></a><b> boole-and</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078017"></a><a 
 id="x86-1078018r274"></a><b> boole-ior</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078019"></a><a 
 id="x86-1078020r275"></a><b> boole-xor</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078021"></a><a 
 id="x86-1078022r276"></a><b> boole-eqv</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078023"></a><a 
 id="x86-1078024r277"></a><b> boole-nand</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078025"></a><a 
 id="x86-1078026r278"></a><b> boole-nor</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078027"></a><a 
 id="x86-1078028r279"></a><b> boole-andc1</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078029"></a><a 
 id="x86-1078030r280"></a><b> boole-andc2</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078031"></a><a 
 id="x86-1078032r281"></a><b> boole-orc1</b> <br 
class="newline" /><i>[Константа]</i><a 
 id="dx86-1078033"></a><a 
 id="x86-1078034r282"></a><b> boole-orc2</b>
</div>
<!--l. 5036--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-107900012.7" id="x86-107900012.7"></a></span>
   Функция <tt><a 
href="#x86-1078002r266">boole</a></tt> принимает операцию <i>op</i> и два целых числа, и возвращает
целое число полученное применением операции <i>op</i> к этим двум числам.
Точные значения шестнадцати констант зависят от реализации, но
они подходят для использования в качестве первого аргумента для
<tt><a 
href="#x86-1078002r266">boole</a></tt>:
<div class="flushleft" 
>
                                                                          

                                                                          
<!--l. 5041--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >     <i>integer1</i></td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td>
</tr><tr><td align="left" >     <i>integer2</i></td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >Выполняемая операция                                        </td>
</tr><tr><td align="left" >  boole-clr  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >всегда 0                                                             </td>
</tr><tr><td align="left" > boole-set  </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >всегда 1                                                             </td>
</tr><tr><td align="left" >boole-1    </td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" ><i>integer1</i>                                                         </td>
</tr><tr><td align="left" >boole-2    </td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" ><i>integer2</i>                                                         </td>
</tr><tr><td align="left" > boole-c1   </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >дополнение <i>integer1</i>                                          </td>
</tr><tr><td align="left" > boole-c2   </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >дополнение <i>integer2</i>                                          </td>
</tr><tr><td align="left" >boole-and  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >и                                                                       </td></tr><tr><td align="left" > boole-ior  </td> <td align="left" >0</td> <td align="left" >1</td> <td align="left" >1</td> <td align="left" >1</td> <td align="left" >или</td>
</tr><tr><td align="left" > boole-xor  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >исключающее или                                               </td>
</tr><tr><td align="left" >boole-eqv  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >эквивалентность (исключительное отрицающее или)</td>
</tr><tr><td align="left" >boole-nand </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >не и                                                                   </td></tr><tr><td align="left" > boole-nor  </td> <td align="left" >1</td> <td align="left" >0</td> <td align="left" >0</td> <td align="left" >0</td> <td align="left" >не или</td>
</tr><tr><td align="left" >boole-andc1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >не <i>integer1</i> и <i>integer2</i>                                        </td>
</tr><tr><td align="left" >boole-andc2</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" ><i>integer1</i> и не <i>integer2</i>                                        </td>
</tr><tr><td align="left" > boole-orc1 </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >не <i>integer1</i> или <i>integer2</i>                                     </td>
</tr><tr><td align="left" > boole-orc2 </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" ><i>integer1</i> или не <i>integer2</i>                                     </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table></div></div>
<!--l. 5067--><p class="indent" >   Таким образом <tt><a 
href="#x86-1078002r266">boole</a></tt> может вычислять все шестнадцать логических
функций для двух аргументов. В целом, <div class="lisp"><div class="tabbing">
(boole boole-and x y) <span class="math"> ≡</span> (logand x y)
   <br>
<!--l. 5071--><p class="noindent" ></div>
<!--l. 5071--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-108000012.7" id="x86-108000012.7"></a></span>
<!--l. 5071--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-108100012.7" id="x86-108100012.7"></a></span>
</div>
<!--l. 5072--><p class="indent" >   и далее по аналогии. <tt><a 
href="#x86-1078002r266">boole</a></tt> полезна, когда необходимо параметризировать
процедуру так, что они может использовать одну из нескольких логических
операций.
</div>
<div class="defun">
<!--l. 5077--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1081001"></a><a 
 id="x86-1081002r283"></a><b> lognot</b>  <i>integer</i>
</div>
                                                                          

                                                                          
<!--l. 5079--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-108200012.7" id="x86-108200012.7"></a></span>
   Функция возвращает битовое логическое <i>отрицание</i> аргумента. Каждый
бит результата является дополнение соответствующего исходного бита
аргумента. <div class="lisp"><div class="tabbing">
(logbitp <i>j</i> (lognot <i>x</i>)) <span class="math"> ≡</span> (not (logbitp <i>j</i> <i>x</i>))
   <br>
<!--l. 5085--><p class="noindent" ></div>
<!--l. 5085--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-108300012.7" id="x86-108300012.7"></a></span>
<!--l. 5085--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-108400012.7" id="x86-108400012.7"></a></span>
</div>
</div>
<div class="defun">
<!--l. 5088--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1084001"></a><a 
 id="x86-1084002r284"></a><b> logtest</b>  <i>integer1</i> <i>integer2</i>
</div>
<!--l. 5090--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-108500012.7" id="x86-108500012.7"></a></span>
<tt>
   <a 
href="#x86-1084002r284">logtest</a></tt> является предикатом, который истинен, если любой бит
определённый как 1 в <i>integer1</i> также является соответствующим битом 1 в
<i>integer2</i>. <div class="lisp"><div class="tabbing">
(logtest <i>x</i> <i>y</i>) <span class="math"> ≡</span> (not (zerop (logand <i>x</i> <i>y</i>)))
   <br>
<!--l. 5096--><p class="noindent" ></div>
<!--l. 5096--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-108600012.7" id="x86-108600012.7"></a></span>
                                                                          

                                                                          
<!--l. 5096--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-108700012.7" id="x86-108700012.7"></a></span>
</div>
</div>
<div class="defun">
<!--l. 5099--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1087001"></a><a 
 id="x86-1087002r285"></a><b> logbitp</b>  <i>index</i> <i>integer</i>
</div>
<!--l. 5101--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-108800012.7" id="x86-108800012.7"></a></span>
   Предикат <tt><a 
href="#x86-1087002r285">logbitp</a></tt> является истиной, если бит в позиции <i>index</i> в целом
числе <i>integer</i> (то есть, его вес <span class="math">2<sup>index</sup></span>), является 1, иначе предикат ложен.
Например: <div class="lisp"><div class="tabbing">
(logbitp 2 6) is true
   <br>                                                                     (logbitp 0 6) is false<br>
(logbitp <i>k</i> <i>n</i>) <span class="math"> ≡</span> (ldb-test (byte 1 <i>k</i>) <i>n</i>)<br>
<!--l. 5110--><p class="noindent" ></div>
<!--l. 5110--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-108900012.7" id="x86-108900012.7"></a></span>
<!--l. 5110--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-109000012.7" id="x86-109000012.7"></a></span>
</div>
<i>
<!--l. 5112--><p class="indent" >   index</i> должен быть неотрицательным целым числом.
</div>
<div class="defun">
<!--l. 5115--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1090001"></a><a 
 id="x86-1090002r286"></a><b> ash</b>  <i>integer</i> <i>count</i>
</div>
<!--l. 5117--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-109100012.7" id="x86-109100012.7"></a></span>
   Если <i>count</i> положительное число, данная функция арифметически
сдвигает число <i>integer</i> влево на количество бит <i>count</i>. Если <i>count</i>
отрицательное число, функция сдвигает число <i>integer</i> вправо. Знак
результата всегда такое же как и исходного числа <i>integer</i>.
                                                                          

                                                                          
<!--l. 5123--><p class="indent" >   Говоря математически, эта операция выполняет вычисления
<span class="math"><i>ﬂoor</i>(<i>integer</i> ⋅ 2<sup>count</sup></span>).
<!--l. 5126--><p class="indent" >   Логически, функция перемещает все биты числа <i>integer</i> влево, добавляя
нулевые биты в конец, или вправо отбрасывая биты в конце числа. (В этом
контексте вопрос о том, что сдвигается налево, не относится к делу. Целые
числа, рассматриваемые как строки битов, являются «полубесконечными», то
есть концептуально расширяются бесконечно влево FIXME.) Например:
<div class="lisp"><div class="tabbing">
(logbitp <i>j</i> (ash <i>n</i> <i>k</i>)) <span class="math"> ≡</span> (and (&#x003E;= <i>j</i> <i>k</i>) (logbitp (- <i>j</i> <i>k</i>) <i>n</i>))
   <br>
<!--l. 5134--><p class="noindent" ></div>
<!--l. 5134--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-109200012.7" id="x86-109200012.7"></a></span>
<!--l. 5134--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-109300012.7" id="x86-109300012.7"></a></span>
</div>
</div>
<div class="defun">
<!--l. 5137--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1093001"></a><a 
 id="x86-1093002r287"></a><b> logcount</b>  <i>integer</i>
</div>
<!--l. 5139--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-109400012.7" id="x86-109400012.7"></a></span>
   Функция возвращает количество бит в числе <i>integer</i>. Если <i>integer</i>
положительное число, тогда подсчитаны будут биты <tt>1</tt>. Если число <i>integer</i>
отрицательно, то в два раза дополненной (two&#x2019;s-complement) бинарной
форме будут подсчитаны биты <tt>0</tt>. FIXME Результатом всегда является
неотрицательное целое число. Например: <div class="lisp"><div class="tabbing">
(logcount 13) <span class="math"> ⇒</span> 3      ;Бинарное представление ...0001101
   <br>            (logcount -13) <span class="math"> ⇒</span> 2     ;Бинарное представление ...1110011<br>
(logcount 30) <span class="math"> ⇒</span> 4      ;Бинарное представление ...0011110<br>
(logcount -30) <span class="math"> ⇒</span> 4     ;Бинарное представление ...1100010<br>
                                                                          

                                                                          
<!--l. 5152--><p class="noindent" ></div>
<!--l. 5152--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-109500012.7" id="x86-109500012.7"></a></span>
<!--l. 5152--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-109600012.7" id="x86-109600012.7"></a></span>
</div>
<!--l. 5153--><p class="indent" >   Следующее тождество всегда верно: <div class="lisp"><div class="tabbing">
(logcount x) <span class="math"> ≡</span> (logcount (- (+ x 1)))
   <br>                                                       <span class="math"> ≡</span> (logcount (lognot x))<br>
<!--l. 5157--><p class="noindent" ></div>
<!--l. 5157--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-109700012.7" id="x86-109700012.7"></a></span>
<!--l. 5157--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-109800012.7" id="x86-109800012.7"></a></span>
</div>
</div>
<div class="defun">
<!--l. 5160--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx86-1098001"></a><a 
 id="x86-1098002r288"></a><b> integer-length</b>  <i>integer</i>
</div>
<!--l. 5162--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-109900012.7" id="x86-109900012.7"></a></span>
   Данная функция выполняет следующие вычисления <div class="tabbing">
<span class="math"><i>ceiling</i>(log <sub>2</sub>(if <i>integer</i> &#x003C; 0 then −<i>integer</i> else <i>integer</i> + 1))</span>
   <br>
<!--l. 5167--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 5167--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-110000012.7" id="x86-110000012.7"></a></span>
   Эта функция полезна в двух случаях. Первое, если целое число <i>integer</i> не
отрицательно, тогда его значение может быть представлено в беззнаковой
бинарной форме в поле, ширина которого в битах не меньше чем
<tt>(integer-length <i>integer</i>)</tt>. Второе, независимо от знака числа <i>integer</i>, его
значение может быть представлено как знаковая бинарная два раза
дополненная (two&#x2019;s-complement) форма в поле, ширина которого в битах не
меньше чем <tt>(+ (integer-length <i>integer</i>) 1)</tt>. FIXME Например:
<div class="lisp"><div class="tabbing">
(integer-length 0) <span class="math"> ⇒</span> 0
   <br>                                                                (integer-length 1) <span class="math"> ⇒</span> 1<br>
(integer-length 3) <span class="math"> ⇒</span> 2<br>                            (integer-length 4) <span class="math"> ⇒</span> 3<br>
(integer-length 7) <span class="math"> ⇒</span> 3<br>                           (integer-length -1) <span class="math"> ⇒</span> 0<br>
(integer-length -4) <span class="math"> ⇒</span> 2<br>                           (integer-length -7) <span class="math"> ⇒</span> 3<br>
(integer-length -8) <span class="math"> ⇒</span> 3<br>
<!--l. 5187--><p class="noindent" ></div>
<!--l. 5187--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-110100012.7" id="x86-110100012.7"></a></span>
<!--l. 5187--><p class="noindent" ><span class="paragraphHead"><a 
href="#x86-110200012.7" id="x86-110200012.7"></a></span>
</div>
</div>
                                                                          

                                                                          
<!--l. 5191--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse70.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html#tailclmse68.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse69.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse69.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse69.html"></a>  </div> </div> 
</body></html> 
