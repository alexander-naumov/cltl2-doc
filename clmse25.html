<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Type Conversion Function Функция преобразования</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-08 00:30:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 1305--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse26.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse24.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse24.html#tailclmse24.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse25.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch4.html#clmse25.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">4.8   </span> <a 
 id="x34-550004.8"></a>Type Conversion Function Функция преобразования</h3>
<!--l. 1307--><p class="noindent" >The following function may be used to convert an object to an equivalent object
of another type.
<!--l. 1310--><p class="indent" >   Следующие функции могут быть использованы для преобразования
объекта в эквивалентный объект другого типа.
<div class=defun>
<!--l. 1313--><p class="noindent" ><i>[Function]</i><a 
 id="dx34-55001"></a><a 
 id="x34-55002r7"></a><b> coerce</b>  <i>object</i> <i>result-type</i>
<!--l. 1315--><p class="noindent" >The <i>result-type</i> must be a type speciﬁer; the <i>object</i> is converted to an “equivalent”
object of the speciﬁed type. If the coercion cannot be performed, then an error is
signaled. In particular, (coerce x &#x2019;nil) always signals an error. If <i>object</i> is already
of the speciﬁed type, as determined by <a 
href="clmse32.html#x43-79002r21">typep</a>, then it is simply returned. It is not
generally possible to convert any object to be of any type whatsoever; only certain
conversions are permitted:
<i>
<!--l. 1326--><p class="indent" >   result-type</i> должен быть спецификатором типа; <i>object</i> будет сконверитрован в
«эквивалентный» объект заданного типа. Если преобразование не может
быть осуществлено, будет сгенерирована ошибка. В частности, (coerce x &#x2019;nil)
всегда сигнализирует ошибку. Если <i>object</i> уже принадлежит заданному
типу, это проверяется предикатом <a 
href="clmse32.html#x43-79002r21">typep</a>, тогда даный объект будет
возвращен. В общем случае невозможно преобразовать любой объект
в в объекто любого другого типа. Допускаются только следующие
преобразования.
      <ul class="itemize1">
      <li class="itemize">Any sequence type may be converted to any other sequence type, provided
      the new sequence can contain all actual elements of the old sequence (it is
      an error if it cannot). If the <i>result-type</i> is speciﬁed as simply array, for
      example, then (array t) is assumed. A specialized type such as <a 
href="clmse102.html#x125-247028r618">string</a> or
      (vector (complex short-ﬂoat)) may be speciﬁed; of course, the result may be
      of either that type or some more general type, as determined by the
      implementation. Elements of the new sequence will be <a 
href="clmse33.html#x44-81005r47">eql</a> to corresponding
                                                                          

                                                                          
      elements of the old sequence. If the <i>sequence</i> is already of the speciﬁed type,
      it may be returned without copying it; in this, (coerce <i>sequence</i> <i>type</i>) diﬀers
      from (concatenate <i>type</i> <i>sequence</i>), for the latter is required to copy the
      argument <i>sequence</i>. In particular, if one speciﬁes sequence, then
      the argument may simply be returned if it already is a sequence. <div class=lisp>
      <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce &#x2019;(a b c) &#x2019;vector)  ⇒ #(a b c)
</td></tr></table>
      <!--l. 1354--><p class="noindent" >
</div>
</div>
      </li>
      <li class="itemize">Любой тип последовательности может быть сконвертирован в другой
      тип последовательности. Новый тип последовательности будет
      содержать все объекты из старой последовательности (если это
      невозможно, тогда возникнет ошибка). Если result-type задан как array,
      тогда будет использоваться (array t). Также может использоваться
      специализированный тип такой, как <a 
href="clmse102.html#x125-247028r618">string</a> или (vector (complex
      short-ﬂoat)); конечно, результат может быть более общим типом, в
      зависимости от реализации. Элементы новой последовательности
      будут эквивалентны <a 
href="clmse33.html#x44-81005r47">eql</a> соответствующим элементам старой
      последовательности. Если последовательность уже принадлежит
      заданному типу, она может быть просто возвращена без копирования. В
      таком случае (coerce <i>последовательность</i> <i>тип</i>) отлчается от
      (concatenate <i>тип</i> <i>последовательность</i>), так как последняя требует
      копирования аргумента <i>последовательность</i>.
<div class=lisp>
<div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce &#x2019;(a b c) &#x2019;vector)  ⇒ #(a b c)
</td></tr></table>
      <!--l. 1374--><p class="noindent" >
                                                                          

                                                                          
</div>
</div>
      </li></ul>
<div class=newer>
<!--l. 1379--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx34-55003"></a>to specify that <a 
href="#x34-55002r7">coerce</a> should signal an error if the
new sequence type speciﬁes the number of elements and the old sequence has a
diﬀerent length.
</div>
<div class=newer>
<!--l. 1385--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx34-55004"></a>to specify that if the <i>result-type</i> is <a 
href="clmse102.html#x125-247028r618">string</a> then it is
understood to mean (vector character), and simple-string is understood to mean
(simple-array character (*)).
</div>
<div class=obsolete>
      <ul class="itemize1">
      <li class="itemize">Some strings, symbols, and integers may be converted to characters. If
      <i>object</i> is a string of length 1, then the sole element of the string is returned.
      If <i>object</i> is a symbol whose print name is of length 1, then the sole element
      of the print name is returned. If <i>object</i> is an integer <i>n</i>, then (int-char <i>n</i>) is
      returned. See <a 
href="clmse79.html#x97-215002r384">character</a>. <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce &#x0022;a&#x0022; &#x2019;character)  ⇒ #\a
</td></tr></table>
      <!--l. 1402--><p class="noindent" >
</div>
</div>
      </li></ul>
</div>
<div class=newer>
<!--l. 1407--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx34-55005"></a>to eliminate <a 
href="clmse79.html#x97-215014r389">int-char</a> from Common Lisp.
Presumably this eliminates the possibility of coercing an integer to a character,
although the vote did not address this question directly.
</div>
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">Any non-complex number can be converted to a short-ﬂoat, single-ﬂoat,
      double-ﬂoat, or long-ﬂoat. If simply <a 
href="clmse71.html#x88-206002r251">ﬂoat</a> is speciﬁed, and <i>object</i> is not
      already a <a 
href="clmse71.html#x88-206002r251">ﬂoat</a> of some kind, then the object is converted to a single-ﬂoat. <div class=lisp>
      <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce 0 &#x2019;short-ﬂoat)  ⇒ 0.0S0
</td></tr></table>
      <!--l. 1421--><p class="noindent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce 3.5L0 &#x2019;ﬂoat)  ⇒ 3.5L0</td></tr></table>
      <!--l. 1422--><p class="noindent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce 7/2 &#x2019;ﬂoat)  ⇒ 3.5</td></tr></table>
      <!--l. 1424--><p class="noindent" >
</div>
</div>
      </li>
      <li class="itemize">Любое некомплексное число может быть приведено к short-ﬂoat,
      single-ﬂoat, double-ﬂoat или long-ﬂoat. Если тип указан с плавающей
      точкой и <i>объект</i> не является числом с плавающей точкой, тогда объект
      преобразовывается в single-ﬂoat.
<div class=lisp>
<div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce 0 &#x2019;short-ﬂoat)  ⇒ 0.0S0
</td></tr></table>
      <!--l. 1433--><p class="noindent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce 3.5L0 &#x2019;ﬂoat)  ⇒ 3.5L0</td></tr></table>
      <!--l. 1434--><p class="noindent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce 7/2 &#x2019;ﬂoat)  ⇒ 3.5</td></tr></table>
      <!--l. 1436--><p class="noindent" >
</div>
</div>
                                                                          

                                                                          
      </li>
      <li class="itemize">Any number can be converted to a complex number. If the number is not
      already complex, then a zero imaginary part is provided by coercing the
      integer zero to the type of the given real part. (If the given real part is
      rational, however, then the rule of canonical representation for complex
      rationals will result in the immediate re-conversion of the result from type
      <a 
href="clmse71.html#x88-206046r273">complex</a> back to type <a 
href="clmse71.html#x88-206004r252">rational</a>.)
<div class=lisp>
<div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce 4.5s0 &#x2019;complex)  ⇒ #C(4.5S0 0.0S0)
</td></tr></table>
      <!--l. 1448--><p class="noindent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce 7/2 &#x2019;complex)  ⇒ 7/2</td></tr></table>
      <!--l. 1449--><p class="noindent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce #C(7/2 0) &#x2019;(complex double-ﬂoat))</td></tr></table>
      <!--l. 1450--><p class="noindent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">    ⇒ #C(3.5D0 0.0D0)</td></tr></table>
      <!--l. 1452--><p class="noindent" >
</div>
</div>
      </li>
      <li class="itemize">Любое число может быть приведено к комплексному. Если число
      еще не является комплексным, тогда мнимая часть будет равна
      нулю, который будет преобразован в тип, соответствующий типу
      действительной части. (Если полученная действительная часть является
      рациональным числом, тогда результат немедленно будет преобразован
      из комплексного обратно в рациональный.)
<div class=lisp>
<div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce 4.5s0 &#x2019;complex)  ⇒ #C(4.5S0 0.0S0)
</td></tr></table>
                                                                          

                                                                          
      <!--l. 1462--><p class="noindent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce 7/2 &#x2019;complex)  ⇒ 7/2</td></tr></table>
      <!--l. 1463--><p class="noindent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce #C(7/2 0) &#x2019;(complex double-ﬂoat))</td></tr></table>
      <!--l. 1464--><p class="noindent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">    ⇒ #C(3.5D0 0.0D0)</td></tr></table>
      <!--l. 1466--><p class="noindent" >
</div>
</div>
      </li>
      <li class="itemize">Any object may be coerced to type <a 
href="clmse31.html#x42-77004r20">t</a>. <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce x &#x2019;t)  ≡ (identity x)  ≡ x
</td></tr></table>
      <!--l. 1472--><p class="noindent" >
</div>
</div>
      </li>
      <li class="itemize">Любой объект может быть приведен к типу <a 
href="clmse31.html#x42-77004r20">t</a>. <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(coerce x &#x2019;t)  ≡ (identity x)  ≡ x
</td></tr></table>
      <!--l. 1478--><p class="noindent" >
</div>
</div>
      </li></ul>
<div class=newer>
<!--l. 1483--><p class="indent" >   X3J13 voted in June 1988 <a 
 id="dx34-55006"></a>to allow coercion of certain objects to the type
<a 
href="clmse35.html#x47-88006r54">function</a>:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">A  symbol  or  lambda-expression  can  be  converted  to  a  function.  A
      symbol is coerced to type <a 
href="clmse35.html#x47-88006r54">function</a> as if by applying <a 
href="clmse35.html#x47-89007r56">symbol-function</a>
      to the symbol; an error is signaled if the predicate <a 
href="clmse35.html#x47-89015r59">fboundp</a> is not true
      of the symbol or if the symbol names a macro or special form. A list
      <i>x</i> whose <i>car</i> is the symbol lambda is coerced to a function as if by
      execution of (eval ‘#&#x2019;,<i>x</i>), that is, of (eval (list &#x2019;function <i>x</i>)).
      <!--l. 1496--><p class="noindent" >Символ  или  лямбда-выражение  может  быть  преобразовано  к
      функции. Символ приводится к типу <a 
href="clmse35.html#x47-88006r54">function</a>, как если бы к нему
      была применена функция <a 
href="clmse35.html#x47-89007r56">symbol-function</a>. Если символ не связан
      (<a 
href="clmse35.html#x47-89015r59">fboundp</a>  symbol  -&#x003E;  false),  или  символ  связан  с  макросом  или
      специальной формой сигнализируется ошибка. Список <i>x</i>, чей <i>car</i>
      является  символом  lambda  приводится  к  функции,  как  если  бы
      было вычислено выражение (eval ‘#&#x2019;,<i>x</i>), или (eval (list &#x2019;function <i>x</i>)).</li></ul>
</div>
<!--l. 1507--><p class="indent" >   Coercions from ﬂoating-point numbers to rationals and from ratios to integers
are purposely <i>not</i> provided because of rounding problems. The functions
<a 
href="clmse71.html#x88-206004r252">rational</a>, <a 
href="clmse71.html#x88-206006r253">rationalize</a>, <a 
href="clmse71.html#x88-206012r256">ﬂoor</a>, <a 
href="clmse71.html#x88-206014r257">ceiling</a>, <a 
href="clmse71.html#x88-206016r258">truncate</a>, and <a 
href="clmse71.html#x88-206018r259">round</a> may be used for such
purposes. Similarly, coercions from characters to integers are purposely not
provided; <a 
href="clmse78.html#x96-214002r379">char-code</a> or <a 
href="clmse79.html#x97-215012r388">char-int</a> may be used explicitly to perform such
conversions.
<!--l. 1515--><p class="indent" >   Приведение чисел с плавающей точкой к рациональным и рациональныхк
целым <i>не</i> предоставляется в связи с проблемами округления. Для этого
могут использоваться функции <a 
href="clmse71.html#x88-206004r252">rational</a>, <a 
href="clmse71.html#x88-206006r253">rationalize</a>, <a 
href="clmse71.html#x88-206012r256">ﬂoor</a>, <a 
href="clmse71.html#x88-206014r257">ceiling</a>, <a 
href="clmse71.html#x88-206016r258">truncate</a> и
<a 
href="clmse71.html#x88-206018r259">round</a>. Также не предоставляется приведение строковых символов
к целым числам. В этих целях можно использовать <a 
href="clmse78.html#x96-214002r379">char-code</a> или
<a 
href="clmse79.html#x97-215012r388">char-int</a>.
</div>
                                                                          

                                                                          
   <!--l. 1523--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse26.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse24.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse24.html#tailclmse24.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse25.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch4.html#clmse25.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 1523--><p class="indent" >   <a 
 id="tailclmse25.html"></a>  
</body></html> 
