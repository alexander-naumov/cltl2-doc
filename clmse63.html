<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Точность, неявное приведение и явное приведение</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 3744--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse64.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#tailclmch12.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse63.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse63.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">12.1   </span> <a 
href="clm.html#QQ2-80-948" id="x80-94000012.1">Точность, неявное
приведение и явное приведение</a></h3>
<!--l. 3747--><p class="noindent" >Вычисления с числами с плавающей точкой являются приблизительными.
<i>Точность</i> чисел с плавающей точкой не обязательно коррелирует с
<i>«аккуратностью»</i> числа. Например, 3.142857142857142857 имеет более точное
приближение к <span class="math">pi</span> чем 3.14159, но последнее число более «аккуратно».
Точность указывает на количество бит используемых при представлении
числа. Если операция объединяла числа с плавающей точкой короткого
формата и длинного, то результат будет иметь длинный формат. Это
правило создано для уверенности, что при вычислениях аккуратности
будет как можно больше. Однако это не гарантированно. Однако,
численные процедуры Common Lisp&#x2019;а предполагают, что аккуратность
аргумента не превышает его точность. Поэтому, когда объединяются
два числа с плавающей точкой небольшой точности, результатом
всегда будет число с плавающей точкой небольшой точности. Это
предположение может быть изменено первым же явным преобразованием
число с плавающей точкой в более точное представление. (Common
Lisp никогда не преобразует числа из более точного формата в менее
точный.)
<!--l. 3765--><p class="indent" >   Вычисления рациональных чисел не может вызвать переполнения в
обычном смысле этого слова (хотя, конечно, может быть возникнуть
недостаток места для представления), целые и дробные числа в принципе
могут быть любой величины. Вычисления с плавающей точкой могут вызвать
переполнение экспоненты. Это является ошибкой.
<!--l. 3771--><p class="indent" >   Когда числовой функцией между собой сравниваются или объединяются
рациональное и число с плавающей точкой, то вступает в силу правило
<i>неявного приведения к плавающей точке</i>. Когда рациональное встречает
                                                                          

                                                                          
число с плавающей точкой, то рациональное преобразуется в тот же
формат второго числа. Для функций, например <tt><a 
href="clmse107.html#x132-1644002r586">+</a></tt>, которые принимает
более двух аргументов, может быть, что все рациональные будут
вычислены и результат будет преобразован в число с плавающей
точкой.
<!--l. 3780--><p class="indent" >   Для функций, которые математически ассоциативны (и возможно
коммутативны), реализация Common Lisp&#x2019;а может обрабатывать аргументы
любым подходящим методом с ассоциативной (и возможно коммутативной)
перестановкой. Это конечно не влияет на порядок вычисления форм, данный
порядок всегда слева направо, как и во всех Common Lisp&#x2019;овых вызовах
функций. Порядок, который может быть изменён, это обработка значений
аргументов. Смысл всего этого в том, что реализация может отличаться
в том, какие автоматические приведения типов и в каком порядке
производятся. Например, рассмотрим выражение: <div class="lisp"><div class="tabbing">
(+ 1/3 2/3 1.0D0 1.0 1.0E-15)
   <br>
<!--l. 3791--><p class="noindent" ></div>
<!--l. 3791--><p class="noindent" ><span class="paragraphHead"><a 
href="#x80-94100012.1" id="x80-94100012.1"></a></span>
<!--l. 3791--><p class="noindent" ><span class="paragraphHead"><a 
href="#x80-94200012.1" id="x80-94200012.1"></a></span>
</div>
<!--l. 3792--><p class="indent" >   Одна реализация может обрабатывать аргументы слева направо,
складывая сначала <tt>1/3</tt> и <tt>2/3</tt> для получения <tt>1</tt>, затем преобразовывая
результат в число с плавающей точкой двойной точности для сложения с
<tt>1.0D0</tt>, затем преобразовывая и добавляя <tt>1.0</tt> и <tt>1.0E-15</tt>. Другая реализация
может обрабатывать значения аргументов справа налево, сначала выполняя
сложение чисел с плавающей точкой <tt>1.0</tt> и <tt>1.0E-15</tt> (и возможно теряя
аккуратность в процессе!), затем преобразовывая результат в число двойной
точности и прибавляя <tt>1.0D0</tt>, затем преобразовывая <tt>2/3</tt> к числу с
плавающей точкой двойной точности, и затем преобразовывая <tt>1/3</tt>
и добавляя его. Третья реализация может сначала просканировать
все аргументы, и сгруппировав их по типам, выполнить сложения
                                                                          

                                                                          
сначала одинаковых типов, затем преобразовать результаты к наиболее
точному типу и сложить их. В этом случае все три стратегии являются
допустимыми. Пользователь конечно может контролировать порядок
обработки аргументов явно задавая вызовы вычислений, например:
<div class="lisp"><div class="tabbing">
(+ (+ 1/3 2/3) (+ 1.0D0 1.0E-15) 1.0)
   <br>
<!--l. 3808--><p class="noindent" ></div>
<!--l. 3808--><p class="noindent" ><span class="paragraphHead"><a 
href="#x80-94300012.1" id="x80-94300012.1"></a></span>
<!--l. 3808--><p class="noindent" ><span class="paragraphHead"><a 
href="#x80-94400012.1" id="x80-94400012.1"></a></span>
</div>
<!--l. 3809--><p class="indent" >   Пользователь может также контролировать приведения, явно используя
для этого функцию.
<!--l. 3812--><p class="indent" >   В целом, тип результата числовой функции является числом с плавающей
точкой наиболее точного формата, который был в аргументах данной
функции. Но если все аргументы были рационального типа, тогда результат
будет рациональным (за исключением функций, который математически
возвращают иррациональные результаты, в случае который используется
одинарная точность с плавающей точкой)
<!--l. 3819--><p class="indent" >   Другое правило для комплексных чисел. Комплексные числа никогда не
возвращаются из числовых функций, если только в аргументах не было
использовано хоть одно комплексное число. (Исключением из этого правила
являются иррациональные и трансцендентальные функции, в частности
<tt><a 
href="clmse67.html#x84-998002r210">expt</a></tt>, <tt><a 
href="clmse67.html#x84-1001002r211">log</a></tt>, <tt><a 
href="clmse67.html#x84-1006002r212">sqrt</a></tt>, <tt><a 
href="clmse67.html#x84-1028002r221">asin</a></tt>, <tt><a 
href="clmse67.html#x84-1028004r222">acos</a></tt>, <tt><a 
href="clmse67.html#x84-1035010r229">acosh</a></tt> и <tt><a 
href="clmse67.html#x84-1035012r230">atanh</a></tt>. Смотрите раздел <a 
href="clmse67.html#x84-99600012.5">12.5<!--tex4ht:ref: TRANSCENDENTAL-SECTION --></a>.)
Когда некомплексное число встречает комплексно, то первое сначала
конвертируется во второе с нулевой мнимой частью, а потом вычисляется
результат.
<!--l. 3828--><p class="indent" >   Если любое вычисление привело к дробному результату, в котором
числитель нацело делится на знаменатель, то результат немедленно
преобразуется к эквивалентному целому числу. Это правило называется
<i>канонизацией дробей</i>.
                                                                          

                                                                          
<!--l. 3832--><p class="indent" >   Если результат любого вычисления должен быть комплексным числом с
рациональными частями и нулевой мнимой частью, то результат немедленно
преобразуется в некомплексное рациональное число и равен действительной
части исходного. Это называется правилом <i>канонизации комплексного числа</i>.
Следует отметить, что это правило <i>не</i> применяется к комплексным числам
с компонентами из чисел с плавающими точками. Таким образом
<tt>#C(5 0)</tt> и <tt>5</tt> равны <tt><a 
href="clmse33.html#x44-402003r45">eql</a></tt>, а <tt>#C(5.0 0.0)</tt> и <tt>5.0</tt> не равны <tt><a 
href="clmse33.html#x44-402003r45">eql</a></tt>, но равны
<tt><a 
href="clmse33.html#x44-408002r47">equalp</a></tt>.
                                                                          

                                                                          
<!--l. 3841--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse64.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#tailclmch12.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse63.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse63.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse63.html"></a>    </div> </div> 
</body></html> 
