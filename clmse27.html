<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Формы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-11 09:24:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1367--><p class="noindent" > <div id="main_container"> <div id="content"> <!--l. 1367--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse28.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#tailclmch5.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse27.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse27.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
href="clm.html#QQ2-37-63" id="x37-560005.1">Формы</a></h3>
<!--l. 1369--><p class="noindent" >Стандартной единицей взаимодействия с реализацией Common Lisp&#x2019;а
                                                                          

                                                                          
является <i>форма</i>, которая является объектом данных, который выполняется
как программа для вычисления одного или более <i>значений</i> (которые также
являются объектами данных). Запросить выполнение можно для <i>любого</i>
объекта данных, но не для всех это имеет смысл. Например, символы и
списки имеет смысл выполнять, тогда как массивы обычно нет. Примеры
содержательных форм: <tt>3</tt>, значение которой <tt>3</tt>, и <tt>(+ 3 4)</tt>, значение которой <tt>7</tt>.
Для обозначения этих фактов мы пишем <tt>3</tt> <span class="math"> ⇒</span> <tt>3</tt> и <tt>(+ 3 4)</tt> <span class="math"> ⇒</span> <tt>7</tt>.
(<span class="math"> ⇒</span> означает «вычисляется в»)
<!--l. 1379--><p class="indent" >   Содержательные формы могут быть разделены на три категории:
самовычисляемые формы, такие как числа, символы, которые используются
для переменных, и списки. Списки в свою очередь могут быть разделены
на три категории: специальные формы, вызовы макросов, вызовы
функций.
<!--l. 1387--><p class="indent" >   Все стандартные объекты данных Common Lisp, не являющиеся
символами и списками (включая <tt><a 
href="clmse97.html#x121-225002r561">defstruct</a></tt> структуры, определённые без
опции <tt>:type</tt>) являются самовычисляемыми.
<!--l. 1391--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.1   </span> <a 
href="clmli1.html#QQ2-37-64" id="x37-570005.1.1">Самовычисляемые формы</a></h4>
<!--l. 1393--><p class="noindent" >Все числа, строковые символы, строки и битовые векторы являются
<i>самовычисляемыми</i> формами. Когда данный объект вычисляется, тогда
объект (или возможно копия в случае с числами и строковыми символами)
возвращается в качестве значения данной формы. Пустой список (), который
также является значением ложь (<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>), также является самовычисляемой
формой: значение <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> является <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. Ключевые символы (примечание
переводчика: не путать с ключевыми словами в других языках, в Common
Lisp&#x2019;е это вид символов) также вычисляются сами в себя: значение <tt>:start</tt>
является <tt>:start</tt>.
<!--l. 1404--><p class="indent" >   Деструктивная модификация любого объекта, представленного как
константа с помощью самовычисляемой формы или специальной формы
<tt><a 
href="clmse34.html#x46-83002r51">quote</a></tt>, является ошибкой.
<!--l. 1408--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.2   </span> <a 
href="clmli1.html#QQ2-37-65" id="x37-580005.1.2">Переменные</a></h4>
<!--l. 1410--><p class="noindent" >В Common Lisp программах символы используются в качестве имён
                                                                          

                                                                          
переменных. Когда символ вычисляется как форма, то в качестве результата
возвращается значение переменной, которую данный символ именовал.
Например, после выполнения <tt>(setq items 3)</tt>, которая присвоила значение <tt>3</tt>
переменой именованной символом <tt>items</tt>, форма <tt>items</tt> выполнится
в <tt>3</tt> (<tt>items</tt> <span class="math"> ⇒</span> <tt>3</tt>). Переменные могут быть <i>назначены</i> с помощью
<tt><a 
href="clmse34.html#x46-86002r59">setq</a></tt> или <i>связаны</i> с помощью <tt><a 
href="clmse38.html#x50-99002r74">let</a></tt>. Любая программная конструкция,
которая связывает переменную, сохраняет старое значение переменной, и
назначает новое, и при выходе из конструкции восстанавливается старое
значение.
<!--l. 1422--><p class="indent" >   В Common Lisp&#x2019;е есть два вида переменных. Они называются <tt>лексические</tt>
(или <i>статические</i>) и <i>специальные</i> (или <i>динамические</i>). В одно время каждая
из них или обе переменные с одинаковым именем могут иметь некоторое
значение. На какую переменную ссылается символ при его вычислении,
зависит от контекста выполнения. Главное правило заключается в
том, что если символ вычисляется по тексту в конструкции, которая
создала <i>связывание</i> для переменной с одинаковым именем, то символ
ссылается на переменную, обозначенную в этом связывании, если же по
тексту такой конструкции нет, то символ ссылается на специальную
переменную.
<!--l. 1432--><p class="indent" >   Различие между двумя видами переменных заключается в области
видимости и продолжительности видимости. Лексически связанная
переменная может быть использована <i>только</i> по тексту в форме, которая
установила связывание. Динамически связанная (специальная) переменная
может быть использована в любое <i>время</i> между установкой связи и до
выполнения конструкции, которая упраздняет связывание. Таким образом
лексическое связывание переменных накладывает ограничение на
использование переменной только в некоторой текстовой области (но не на
временные ограничения, так связывание продолжает существовать, пока
возможно существование ссылки на переменную). И наоборот, динамическое
связывание переменных накладывает ограничение на временные рамки
использования переменной (но не на текстовую область). Для более
подробной информации смотрите главу <a 
href="clmch3.html#x24-420003">3<!--tex4ht:ref: SCOPE --></a>.
<!--l. 1445--><p class="indent" >   Когда нет связываний, значение, которое имеет специальная переменная,
называется <i>глобальным</i> значением (специальной) переменной. Глобальное
значение может быть задано переменной только с помощью назначения,
потому что значение заданное связыванием по определению не глобально.
<!--l. 1450--><p class="indent" >   Специальная переменная может вообще не иметь значения, в таком
случае, говориться, что она <i>несвязанная</i>. По умолчанию, каждая глобальная
                                                                          

                                                                          
переменная является несвязанной, пока значение не будет назначено явно, за
исключением переменных определённых в этой книге или реализацией,
которые уже имеют значения сразу после первого запуска Lisp машины.
Кроме того, существует возможность установки связывания специальной
переменной и затем упразднения этого связывания с помощью функции
<tt><a 
href="clmse34.html#x46-88004r62">makunbound</a></tt>. В такой ситуации переменная также называется «несвязанной»,
хотя это и неправильно, если быть точнее, переменная связана, но
без значения FIXME. Ссылка на несвязанную переменную является
ошибкой.
<!--l. 1461--><p class="indent" >   Некоторые глобальные переменные зарезервированы в качестве
«именованных констант». Они имеют глобальное значение и не могут быть
связаны или переназначены. Например символы <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> и <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> зарезервированы. Этим
символам невозможно назначить значение. Также и невозможно связать эти
символы с другими значениями. Символы констант определённых с помощью
<tt><a 
href="clmse29.html#x39-68006r16">defconstant</a></tt> также становятся зарезервированными и не могут быть
переназначены или связаны (но они могут быть переопределены с
помощью вызова <tt><a 
href="clmse29.html#x39-68006r16">defconstant</a></tt>). Ключевые символы также не могут быть
переназначены или связаны, ключевые символы всегда вычисляются сами в
себя.
<!--l. 1472--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.3   </span> <a 
href="clmli1.html#QQ2-37-66" id="x37-590005.1.3">Специальные формы</a></h4>
<!--l. 1474--><p class="noindent" >Если список выполняется в качестве формы, первым шагом является
определение первого элемента списка. Если первый элемент списка
является одним из символов, перечисленных в таблице <a 
href="#x37-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>, тогда список
называется <i>специальной формой</i>. (Использование слова «специальный»
никак не связано с использованием этого слова в фразе «специальная
переменная».)
<!--l. 1480--><p class="indent" >   Специальные формы обычно являются окружениями и управляющими
конструкциями. Каждая специальная форма имеет свой идиосинкразический
синтаксис. Например специальная форма <tt><a 
href="clmse130.html#x160-327002r793">if</a></tt>: <tt>(if p (+ x 4) 5)</tt> в
Common Lisp&#x2019;е означает то же, что и «<b>if</b> <i>p</i> <b>then</b> <i>x</i>+4 <b>else</b> 5» означает в
Algol&#x2019;е.
<!--l. 1487--><p class="indent" >   Выполнение специальной формы обычно возвращает значение или
значения, но выполнение может и вызвать нелокальный выход; смотрите
<tt><a 
href="clmse40.html#x52-113002r88">return-from</a></tt>, <tt><a 
href="clmse41.html#x53-127002r104">go</a></tt> и <tt><a 
href="clmse43.html#x55-140002r116">throw</a></tt>.
                                                                          

                                                                          
<!--l. 1491--><p class="indent" >   Множество специальных форм в Common Lisp&#x2019;е фиксировано. Создание
пользовательских специальных форм невозможно. Однако пользователь
может создавать новые синтаксические конструкции с помощью определения
макросов.
<!--l. 1495--><p class="indent" >   Множество специальных форм в Common Lisp&#x2019;е специально держится
малым, потому что любая программа, анализирующая программы, должна
содержать специальные знания о каждом типе специальной формы. Такие
программы не нуждаются в специальных знаниях о макросах, так как
раскрытие макроса просто, и далее остаётся только оперирование с
результатом раскрытия. (Это не значит, что программы, в частности,
компиляторы, не будут иметь специальных знаний о макросах. Компилятор
может генерировать боле эффективный код, если он распознает такие
конструкции, как <tt><a 
href="clmse39.html#x51-110002r86">typecase</a></tt> и <tt><a 
href="clmse42.html#x54-133002r111">multiple-value-bind</a></tt> и будет по-особому с
ними обращаться.)
   <div class="table">
                                                                          

                                                                          
<!--l. 1505--><p class="indent" >   <a 
 id="x37-590011"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 5.1: </span><span  
class="content">Имена всех специальных форм</span></div><!--tex4ht:label?: x37-590011 -->
<div class="tabular"><table width="100%"><tr><td align="left" > <tt><a 
href="clmse40.html#x52-112002r87">block</a></tt>             </td><td align="left" ><tt><a 
href="clmse130.html#x160-327002r793">if</a></tt>                  </td><td align="left" ><tt><a 
href="clmse38.html#x50-101002r76">progv</a></tt>          </td>
</tr><tr><td align="left" > <tt><a 
href="clmse43.html#x55-138006r114">catch</a></tt>             </td><td align="left" ><tt><a 
href="clmse38.html#x50-102004r78">labels</a></tt>              </td><td align="left" ><tt><a 
href="clmse34.html#x46-83002r51">quote</a></tt>          </td>
</tr><tr><td align="left" >                             </td><td align="left" ><tt><a 
href="clmse38.html#x50-99002r74">let</a></tt>                 </td><td align="left" ><tt><a 
href="clmse40.html#x52-113002r88">return-from</a></tt>    </td></tr><tr><td align="left" > <tt><a 
href="clmse47.html#x61-149003r123">declare</a></tt> </td><td align="left" ><tt><a 
href="clmse38.html#x50-100002r75">let*</a></tt> </td><td align="left" ><tt><a 
href="clmse34.html#x46-86002r59">setq</a></tt></td>
</tr><tr><td align="left" > <tt><a 
href="clmse29.html#x39-70002r17">eval-when</a></tt>         </td><td align="left" ><tt><a 
href="clmse38.html#x50-102006r79">macrolet</a></tt>            </td><td align="left" ><tt><a 
href="clmse41.html#x53-125002r101">tagbody</a></tt>        </td>
</tr><tr><td align="left" > <tt><a 
href="clmse38.html#x50-102002r77">flet</a></tt>              </td><td align="left" ><tt><a 
href="clmse42.html#x54-131002r109">multiple-value-call</a></tt> </td><td align="left" ><tt><a 
href="clmse49.html#x63-153002r126">the</a></tt>            </td>
</tr><tr><td align="left" > <tt><a 
href="clmse34.html#x46-84002r52">function</a></tt>          </td><td align="left" ><tt><a 
href="clmse42.html#x54-132002r110">multiple-value-prog1</a></tt></td><td align="left" ><tt><a 
href="clmse43.html#x55-140002r116">throw</a></tt>          </td>
</tr><tr><td align="left" > <tt><a 
href="clmse41.html#x53-127002r104">go</a></tt>                </td><td align="left" ><tt><a 
href="clmse37.html#x49-95002r71">progn</a></tt>               </td><td align="left" ><tt><a 
href="clmse43.html#x55-139004r115">unwind-protect</a></tt> </td>
</tr><tr><td align="left" > <tt><a 
href="clmse140.html#x172-404048r862">generic-flet</a></tt>      </td><td align="left" ><tt><a 
href="clmse140.html#x172-406002r864">generic-labels</a></tt>      </td><td align="left" ><tt><a 
href="clmse38.html#x50-103002r80">symbol-macrolet</a></tt></td>
</tr><tr><td align="left" > <tt><a 
href="clmse140.html#x172-408004r903">with-added-methods</a></tt></td><td align="left" ><tt>locally</tt>             </td><td align="left" ><tt>load-time-eval</tt> </td></tr></table>
</div>
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<!--l. 1523--><p class="indent" >   Реализация может исполнять в виде макроса любую конструкцию
описанную здесь как специальную форму. И наоборот, реализация может
выполнять в виде специальной формы любую конструкцию описанную здесь
как макрос, при условии, что также предоставляется эквивалентное
определение макроса. Практическое значение заключается в том, что
предикаты <tt><a 
href="clmse44.html#x57-143002r117">macro-function</a></tt> и <tt><a 
href="clmse34.html#x46-85015r58">special-operator-p</a></tt> могут оба возвращать true
принимая один и тот же символ. Рекомендуется, чтобы программа для
анализа других программ обрабатывала форму являющуюся списком с
символом в первой позиции следующим образом:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x37-59003x1">Если программа имеет подробные знания о символе, обрабатывать
      форму  необходимо  с  помощью  специализированного  кода.  Все
      символы,  перечисленные  в  таблице <a 
href="#x37-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>  должны  попадать  под
      данную категорию.
      </li>
      <li 
  class="enumerate" id="x37-59005x2">В  противном  случае,  если  для  этого  символа  <tt><a 
href="clmse44.html#x57-143002r117">macro-function</a></tt>
      вычисляется  в  true,  необходимо  применить  <tt><a 
href="clmse45.html#x58-145002r119">macroexpand</a></tt> или
      <tt><a 
href="clmse45.html#x58-145004r120">macroexpand-1</a></tt>  для   раскрытия   формы,   и   результат   вновь
      анализировать.
      </li>
      <li 
  class="enumerate" id="x37-59007x3">В  противном  случае,  необходимо  расценивать  форму  как  вызов
      функции.</li></ol>
   <h4 class="subsectionHead"><span class="titlemark">5.1.4   </span> <a 
href="clmli1.html#QQ2-37-68" id="x37-600005.1.4">Макросы</a></h4>
<!--l. 1549--><p class="noindent" >Если форма является списком и первый элемент не обозначает специальную
форму, возможно он является именем <i>макроса</i>. Если так, то форма
называется <i>макровызовом или вызовом макроса (macrocall)</i>. Макрос это
функция, которая принимает формы и возвращает формы. Возвращённые
формы подставляются в то место, где происходил макровызов, и затем
выполняются. (Этот процесс иногда называется <i>раскрытием макроса</i>.)
Например, макрос с именем <tt><a 
href="clmse131.html#x161-330002r798">return</a></tt> принимает форму, вот так: <tt>(return x)</tt>, и
полученная в результате раскрытия форма такая: <tt>(return-from <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> x)</tt>. Мы
                                                                          

                                                                          
говорим: старая форма раскрылась в новую. Новая форма будет вычислена
на месте оригинальной формы. Значение новой формы будет возвращено, как
значение оригинальной формы.
<!--l. 1561--><p class="indent" >   В Common Lisp&#x2019;е существует некоторое количество стандартных
макросов, и пользователь может определять свои макросы используя
<tt><a 
href="clmse44.html#x57-143004r118">defmacro</a></tt>.
<!--l. 1564--><p class="indent" >   Макросы, предоставляемые реализацией Common Lisp&#x2019;а и описанные
здесь, могут раскрываться в код, который не будет являться переносимым
между реализациями. Вызов макроса является портабельным, в то время как
результат раскрытия нет.
<!--l. 1568--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.5   </span> <a 
href="clmli1.html#QQ2-37-69" id="x37-610005.1.5">Вызовы функций</a></h4>
<!--l. 1570--><p class="noindent" >Если список выполняется как форма, и первый элемент не является символом,
обозначающим специальную форму или макрос, тогда предполагается, что
список является <i>вызовом функции</i>. Первый элемент списка является именем
функции. Все следующие элементы списка будут вычислены. Одно значение
каждого вычисленного элемента будет является <i>аргументом</i> для
вызываемой функции. Затем функция будет <i>применена</i> к аргументам.
Вычисление функции обычно возвращает значение, однако вместо этого
может быть выполнен нелокальный выход, смотрите <tt><a 
href="clmse43.html#x55-140002r116">throw</a></tt>. Функция может
возвращать 0 и более значений, смотрите <tt><a 
href="clmse42.html#x54-130002r105">values</a></tt>. Если и когда функция
возвращает значения, они становятся значениями вычисления формы вызова
функции.
<!--l. 1583--><p class="indent" >   Например, рассмотрим вычисление формы: <tt>(+ (* 4 5))</tt>. Символ <tt><a 
href="clmse104.html#x129-237002r568">+</a></tt>
обозначает функцию сложения, а не специальную форму или макрос.
Таким образом две формы <tt>3</tt> и <tt>(* 4 5)</tt> вычисляются для аргументов.
Форма <tt>3</tt> вычисляется в <tt>3</tt>, а форма <tt>(* 4 5)</tt> является вызовом функции
(умножения). Таким образом формы <tt>4</tt> и <tt>5</tt> вычисляются сами в себя, тем
самым предоставляя аргументы для функции умножения. Функция
умножения вычисляет результат <tt>20</tt> и возвращает его. Значения <tt>3</tt> и <tt>20</tt>
становятся аргументами функции сложения, которая вычисляет и
возвращает результат <tt>23</tt>. Таким образом мы говорим <tt>(+3 (* 4 5))
<span class="math"> ⇒</span> 23</tt>.
                                                                          

                                                                          
   <!--l. 1593--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse28.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#tailclmch5.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse27.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse27.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 1593--><p class="indent" >   <a 
 id="tailclmse27.html"></a>  </div> </div> 
</body></html> 
