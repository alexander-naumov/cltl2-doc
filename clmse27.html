<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Type Upgrading</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 1691--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch5.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html#tailclmse26.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse27.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch4.html#clmse27.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">4.10   </span> <a 
 id="x36-540004.10"></a>Type Upgrading</h3>
<!--l. 1693--><p class="noindent" >X3J13 voted in January 1989 ⟨<b>?</b>⟩ to add new functions by which a program can
determine, in a given Common Lisp implementation, how that implementation
will <i>upgrade</i> a type when constructing an array specialized to contain elements
of that type, or a complex number specialized to contain parts of that
type.
<div class=defun>
<!--l. 1702--><p class="noindent" > <i>[Function]</i>   <b>upgraded-array-element-type</b> <a 
 id="dx36-54001"></a><a 
 id="x36-54002r10"></a>   <i>type</i>
<!--l. 1704--><p class="noindent" >A type speciﬁer is returned, indicating the element type of the most specialized
array representation capable of holding items of the speciﬁed argument <i>type</i>. The
result is necessarily a supertype of the given <i>type</i>. Furthermore, if a type <i>A</i> is a
subtype of type <i>B</i>, then <i>(upgraded-array-element-type <i>A</i>)</i> is a subtype of
<i>(upgraded-array-element-type <i>B</i>)</i>.
<!--l. 1713--><p class="indent" >   The manner in which an array element type is upgraded depends only on
the element type as such and not on any other property of the array
such as size, rank, adjustability, presence or absence of a ﬁll pointer, or
displacement.
<div class=rationale>
<!--l. 1719--><p class="noindent" ><b>Rationale:</b> If upgrading were allowed to depend on any of these properties, all of which
can be referred to, directly or indirectly, in the language of type speciﬁers, then it would
not be possible to displace an array in a consistent and dependable manner to another
array created with the same <i>:element-type</i> argument but diﬀering in one of these
properties.
</div>
<!--l. 1729--><p class="indent" >   Note that <i>upgraded-array-element-type</i> could be deﬁned as <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun upgraded-array-element-type (type)
</td></tr></table>
<!--l. 1731--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (array-element-type (make-array 0 :element-type type)))</td></tr></table>
<!--l. 1733--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1734--><p class="noindent" >but this deﬁnition has the disadvantage of allocating an array and then immediately
discarding it. The clever implementor surely can conjure up a more practical
approach.
</div>
<div class=defun>
<!--l. 1740--><p class="noindent" > <i>[Function]</i>   <b>upgraded-complex-part-type</b> <a 
 id="dx36-54003"></a><a 
 id="x36-54004r11"></a>   <i>type</i>
<!--l. 1742--><p class="noindent" >A type speciﬁer is returned, indicating the element type of the most specialized
complex number representation capable of having parts of the speciﬁed argument
<i>type</i>. The result is necessarily a supertype of the given <i>type</i>. Furthermore, if a
type <i>A</i> is a subtype of type <i>B</i>, then <i>(upgraded-complex-part-type <i>A</i>)</i> is a subtype
of <i>(upgraded-complex-part-type <i>B</i>)</i>.
</div>
</div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
   <!--l. 7--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch5.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html#tailclmse26.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse27.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch4.html#clmse27.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 7--><p class="indent" >   <a 
 id="tailclmse27.html"></a>  
</body></html> 
