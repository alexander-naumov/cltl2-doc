<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Type Upgrading</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-06 23:16:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 1691--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch5.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html#tailclmse26.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse27.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch4.html#clmse27.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">4.10   </span> <a 
 id="x36-1020004.10"></a>Type Upgrading</h3>
<!--l. 1693--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx36-102001"></a>to add new functions by which a program can
determine, in a given Common Lisp implementation, how that implementation
will <i>upgrade</i> a type when constructing an array specialized to contain elements
of that type, or a complex number specialized to contain parts of that
type.
<div class=defun>
<!--l. 1702--><p class="noindent" ><i>[Function]</i><a 
 id="dx36-102002"></a><a 
 id="x36-102003r9"></a><b> upgraded-array-element-type</b>  <i>type</i>
<!--l. 1704--><p class="noindent" ><span class="paragraphHead"><a 
 id="x36-1030009"></a></span>
   A type speciﬁer is returned, indicating the element type of the most
specialized array representation capable of holding items of the speciﬁed argument
<i>type</i>. The result is necessarily a supertype of the given <i>type</i>. Furthermore, if a
type <i>A</i> is a subtype of type <i>B</i>, then (upgraded-array-element-type <i>A</i>) is a subtype
of (upgraded-array-element-type <i>B</i>).
<!--l. 1713--><p class="indent" >   The manner in which an array element type is upgraded depends only on
the element type as such and not on any other property of the array
such as size, rank, adjustability, presence or absence of a ﬁll pointer, or
displacement.
<div class=rationale>
<!--l. 1719--><p class="noindent" ><span class="paragraphHead"><a 
 id="x36-1040004.10"></a></span>
   <b>Rationale:</b> If upgrading were allowed to depend on any of these properties, all
of which can be referred to, directly or indirectly, in the language of type
speciﬁers, then it would not be possible to displace an array in a consistent and
dependable manner to another array created with the same :element-type
argument but diﬀering in one of these properties.
<!--l. 1726--><p class="noindent" ><span class="paragraphHead"><a 
 id="x36-1050004.10"></a>
                                                                          

                                                                          
<!--l. 1726--><p class="indent" >   </span>
   rationale
</div>
<!--l. 1729--><p class="indent" >   Note that <a 
href="#x36-62003r9">upgraded-array-element-type</a> could be deﬁned as <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun upgraded-array-element-type (type)
</td></tr></table>
<!--l. 1731--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (array-element-type (make-array 0 :element-type type)))</td></tr></table>
<!--l. 1733--><p class="indent" >
</div>
</div>
<!--l. 1734--><p class="noindent" >but this deﬁnition has the disadvantage of allocating an array and then immediately
discarding it. The clever implementor surely can conjure up a more practical
approach.
</div>
<div class=defun>
<!--l. 1740--><p class="noindent" ><i>[Function]</i><a 
 id="dx36-105001"></a><a 
 id="x36-105002r10"></a><b> upgraded-complex-part-type</b>  <i>type</i>
<!--l. 1742--><p class="noindent" ><span class="paragraphHead"><a 
 id="x36-10600010"></a></span>
   A type speciﬁer is returned, indicating the element type of the most
specialized complex number representation capable of having parts of
the speciﬁed argument <i>type</i>. The result is necessarily a supertype of the
given <i>type</i>. Furthermore, if a type <i>A</i> is a subtype of type <i>B</i>, then
(upgraded-complex-part-type <i>A</i>) is a subtype of (upgraded-complex-part-type
<i>B</i>).
</div>
</div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
   <!--l. 7--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmch5.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse26.html#tailclmse26.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse27.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch4.html#clmse27.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 7--><p class="indent" >   <a 
 id="tailclmse27.html"></a>  
</body></html> 
