<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Иррациональные и трансцендентные функции</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 23:44:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 4285--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse69.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse67.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse67.html#tailclmse67.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse68.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse68.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">12.5   </span> <a 
href="clm.html#QQ2-85-1094" id="x85-108500012.5">Иррациональные и
трансцендентные функции</a></h3>
<!--l. 4288--><p class="noindent" >Common Lisp не содержит тип данных, который точно отображает
иррациональные числовые значения. В данном разделе функции описаны
так, как если бы результаты были математически точными, но фактически
все они возвращают число с плавающей точкой приблизительно равное
настоящему математическому значению. В некоторых местах изложены
математические тождества, связанные со значениями функций, однако, два
математически идентичных выражения могут быть различными по причине
ошибок процесса аппроксимации при вычислениях чисел с плавающей
точкой.
<!--l. 4298--><p class="indent" >   Когда все аргументы для функции данного раздела являются
рациональными и Ъ математический результат также является
(математически) рациональным, тогда, если не указано иное, реализация может
вернуть или точный результат типа <tt>rational</tt> или приближенное значение с
плавающей точкой одинарной точности. Если все аргументы рациональны, но
результат не может быть рациональным, тогда возвращается число с
плавающей точкой одинарной точности.
<!--l. 4305--><p class="indent" >   Если все переданные в функцию аргументы принадлежат типу
<tt>(or rational (complex rational))</tt> и Ъ математический результат является
(математически) комплексным числом с рациональными действительной и
мнимой частями, тогда, если не указано иное, реализация может вернуть
или точный результат типа <tt>(or rational (complex rational))</tt> или
приближенный типа с плавающей точкой с одинарной точностью
<tt>single-float</tt> (только если мнимая часть равна нулю) или <tt>(complex
single-float)</tt>. Если все аргументы типа <tt>(or rational (complex
rational))</tt>, но результат не может быть выражен рациональными или
комплексным рациональным числом, тогда он будет принадлежать типу
<tt>single-float</tt> (только если мнимая часть равна нулю) или <tt>(complex
single-float)</tt>.
<!--l. 4317--><p class="indent" >   Все функции за исключением <tt><a 
href="clmli7.html#x196-3479381r381">expt</a></tt> подчиняются правилам неявного
приведения плавающей точки или комплексного числа. Когда, возможно
после приведения типов, все аргументы становятся с плавающей точкой или
                                                                          

                                                                          
комплексным числом с плавающей точкой, тогда результат будет такого же
типа, что и аргумента, если не указано иное.
<div class="implementation">
<!--l. 4324--><p class="noindent" ><b>Заметка для реализации:</b> Для понимания работы функций из данного раздела
может быть полезной «поваренная книга чисел с плавающей точкой» от Cody и
Waite <span class="cite">[<a 
href="clmli5.html#XCODY-AND-WAITE">14</a>]</span>.
</div>
<!--l. 4330--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">12.5.1   </span> <a 
href="clmli1.html#QQ2-85-1095" id="x85-108600012.5.1">Экспоненциальные и логарифмические функции</a></h4>
<!--l. 4332--><p class="noindent" >Наряду с обычными одно-аргументными и двух-аргументными
экспоненциальными и логарифмическими функциями, <tt><a 
href="clmli7.html#x196-3479880r880">sqrt</a></tt> рассматривается
как экспоненциальная функция, потому что она возводит число в степень
1/2.
<div class="defun">
<!--l. 4336--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1086001"></a><a 
 id="x85-1086002r211"></a><b> exp</b>  <i>number</i>
</div>
<!--l. 4338--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-108700012.5.1" id="x85-108700012.5.1"></a></span>
   Возвращает <i>е</i>, возведённое в степень <i>number</i>, где <i>е</i> является основанием
натурального логарифма.
</div>
<div class="defun">
<!--l. 4343--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1087001"></a><a 
 id="x85-1087002r212"></a><b> expt</b>  <i>base-number</i> <i>power-number</i>
</div>
<!--l. 4345--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-108800012.5.1" id="x85-108800012.5.1"></a></span>
   Возвращает <i>base-number</i>, возведённый в степень <i>power-number</i>. Если
<i>base-number</i> принадлежит типу <tt>rational</tt> и <i>power-number</i> — <tt>integer</tt>,
тогда результат вычислений будет принадлежать типу <tt>rational</tt>, в
противном случае результат будет приближенным числом с плавающей
точкой.
<div class="newer">
<!--l. 4353--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx85-1088001"></a>to clarify that provisions similar to those of the
previous paragraph apply to complex numbers. If the <i>base-number</i> is of type
<tt>(complex rational)</tt> and the <i>power-number</i> is an <tt>integer</tt>, the calculation will
                                                                          

                                                                          
also be exact and the result will be of type <tt>(or rational (complex rational))</tt>;
otherwise a ﬂoating-point or complex ﬂoating-point approximation may
result.
</div>
<!--l. 4364--><p class="indent" >   Если <i>power-number</i> равен <tt>0</tt> (ноль целочисленного типа), тогда результат
всегда будет значение 1, такого же типа что и <i>base-number</i>, даже если
<i>base-number</i> равен нулю (любого типа). То есть: <div class="lisp"><div class="tabbing">
(expt <i>x</i> 0) <span class="math"> ≡</span> (coerce 1 (type-of <i>x</i>))
   <br>
<!--l. 4369--><p class="noindent" ></div>
<!--l. 4369--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-108900012.5.1" id="x85-108900012.5.1"></a></span>
<!--l. 4369--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-109000012.5.1" id="x85-109000012.5.1"></a></span>
</div>
<!--l. 4370--><p class="indent" >   Если <i>power-number</i> является нулём любого другого типа данных, тогда
результат также равен 1 такого же типа, что и аргументы после применения
правил приведения числовых типов, с одним условием: если <i>base-number</i>
равен нулю, когда <i>power-number</i> является нецелочисленным нулём, то это
является ошибкой.
<!--l. 4376--><p class="indent" >   Реализация <tt><a 
href="clmli7.html#x196-3479381r381">expt</a></tt> может использовать различные алгоритмы для случаев с
рациональным и с плавающей точкой аргументом <i>power-number</i>. Суть в том,
что в большинстве случаев боле аккуратный результат может быть
достигнут для рационального <i>power-number</i>. Например, <tt>(expt pi 16)</tt> и
<tt>(expt pi 16.0)</tt> могут вернуть слегка разные результаты, если в первом
случае алгоритм «повторных квадратов», а во втором использование
логарифмов.
<!--l. 4384--><p class="indent" >   Результатом <tt><a 
href="clmli7.html#x196-3479381r381">expt</a></tt> может быть комплексное число, даже если ни один
аргумент не был комплексным. Такой результат получается если <i>base-number</i>
отрицательное число и <i>power-number</i> не является целочисленным.
Следует отметить, что <tt>(expt -8 1/3)</tt> не может вернуть <tt>-2</tt>, хотя
и <tt>-2</tt> несомненно является одним из кубических корней для <tt>-8</tt>, но
основным корнем является аппроксимированное комплексное число <tt>#C(1.0
                                                                          

                                                                          
1.73205)</tt>.
</div>
<div class="defun">
<!--l. 4392--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1090001"></a><a 
 id="x85-1090002r213"></a><b> log</b>  <i>number</i> &#x0026;optional  <i>base</i>
</div>
<!--l. 4394--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-109100012.5.1" id="x85-109100012.5.1"></a></span>
   Функция возвращает логарифм числа <i>number</i> c основанием <i>base</i>, которое
по умолчанию равно <i>e</i> (эпсилон, основание для натурального логарифма).
Например: <div class="lisp"><div class="tabbing">
(log 8.0 2) <span class="math"> ⇒</span> 3.0
   <br>                                                                   (log 100.0 10) <span class="math"> ⇒</span> 2.0<br>
<!--l. 4402--><p class="noindent" ></div>
<!--l. 4402--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-109200012.5.1" id="x85-109200012.5.1"></a></span>
<!--l. 4402--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-109300012.5.1" id="x85-109300012.5.1"></a></span>
</div>
<!--l. 4403--><p class="indent" >   В зависимости от реализации, результатом <tt>(log 8 2)</tt> может быть как <tt>3</tt>,
так и <tt>3.0</tt>. Например: <div class="lisp"><div class="tabbing">
(log -1.0) <span class="math"> ≡</span> (complex 0.0 (ﬂoat pi 0.0))
   <br>
<!--l. 4408--><p class="noindent" ></div>
<!--l. 4408--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-109400012.5.1" id="x85-109400012.5.1"></a></span>
                                                                          

                                                                          
<!--l. 4408--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-109500012.5.1" id="x85-109500012.5.1"></a></span>
</div>
<div class="new">
<!--l. 4411--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx85-1095001"></a>to specify certain ﬂoating-point behavior when
minus zero is supported. As a part of that vote it approved a mathematical
deﬁnition of complex logarithm in terms of real logarithm, absolute value, arc
tangent of two real arguments, and the phase function as <div class="tabbing">
Logarithm                 <span class="math"> log <img 
src="clm0x.png" alt="|z|"  class="left" align="middle"> + <i>i</i> phase <i>z</i></span>
   <br>
<!--l. 4420--><p class="noindent" ></div>
<!--l. 4420--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-109600012.5.1" id="x85-109600012.5.1"></a></span>
   This speciﬁes the branch cuts precisely whether minus zero is supported or
not; see <tt><a 
href="clmli7.html#x196-3479710r710">phase</a></tt> and <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt>.
</div>
</div>
<div class="defun">
<!--l. 4426--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1096001"></a><a 
 id="x85-1096002r214"></a><b> sqrt</b>  <i>number</i>
</div>
<!--l. 4428--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-109700012.5.1" id="x85-109700012.5.1"></a></span>
   Функция возвращает квадратный корень числа <i>number</i>. Если <i>number</i> не
является комплексным числом и отрицательно, тогда результат будет
комплексным числом. Например: <div class="lisp"><div class="tabbing">
(sqrt 9.0) <span class="math"> ⇒</span> 3.0
   <br>                                                            (sqrt -9.0) <span class="math"> ⇒</span> #c(0.0 3.0)<br>
<!--l. 4436--><p class="noindent" ></div>
<!--l. 4436--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-109800012.5.1" id="x85-109800012.5.1"></a></span>
                                                                          

                                                                          
<!--l. 4436--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-109900012.5.1" id="x85-109900012.5.1"></a></span>
</div>
<!--l. 4437--><p class="indent" >   В зависимости от реализации результат <tt>(sqrt 9)</tt> может быть как <tt>3</tt>,
так и <tt>3.0</tt>. Результат <tt>(sqrt -9)</tt> может быть как <tt>#(0 3)</tt> или <tt>#c(0.0
3.0)</tt>.
<div class="new">
<!--l. 4442--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx85-1099001"></a>to specify certain ﬂoating-point behavior when
minus zero is supported. As a part of that vote it approved a mathematical
deﬁnition of complex square root in terms of complex logarithm and exponential
functions as <div class="tabbing">
Square root               <span class="math"><i>e</i><sup>(log z)∕2</sup></span>
   <br>
<!--l. 4450--><p class="noindent" ></div>
<!--l. 4450--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-110000012.5.1" id="x85-110000012.5.1"></a></span>
   This speciﬁes the branch cuts precisely whether minus zero is supported or
not; see <tt><a 
href="clmli7.html#x196-3479710r710">phase</a></tt> and <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt>.
</div>
</div>
<div class="defun">
<!--l. 4456--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1100001"></a><a 
 id="x85-1100002r215"></a><b> isqrt</b>  <i>integer</i>
</div>
<!--l. 4458--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-110100012.5.1" id="x85-110100012.5.1"></a></span>
   Целочисленный квадратный корень: аргумент должен быть
неотрицательным целым, и результат является наибольшим целым числом,
которое меньше или равно точному положительному квадратному корню
аргумента. <div class="lisp"><div class="tabbing">
(isqrt 9) <span class="math"> ⇒</span> 3
   <br>                          (isqrt 12) <span class="math"> ⇒</span> 3<br>                          (isqrt 300) <span class="math"> ⇒</span> 17<br>
(isqrt 325) <span class="math"> ⇒</span> 18<br>
<!--l. 4467--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 4467--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-110200012.5.1" id="x85-110200012.5.1"></a></span>
<!--l. 4467--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-110300012.5.1" id="x85-110300012.5.1"></a></span>
</div>
</div>
<!--l. 4470--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">12.5.2   </span> <a 
href="clmli1.html#QQ2-85-1113" id="x85-110400012.5.2">Тригонометрические и связанные с ними функции</a></h4>
<!--l. 4472--><p class="noindent" >Некоторые из функций в данном разделе, такие как <tt><a 
href="clmli7.html#x196-3479073r73">abs</a></tt> и <tt><a 
href="clmli7.html#x196-3479851r851">signum</a></tt>,
несомненно не относятся к тригонометрическим функциям, когда
рассматриваются как функции только для действительных чисел.
Однако, путь, с помощью которого они расширены для операций на
комплексных числах, делает их связь с тригонометрическими функциями
явной.
<div class="defun">
<!--l. 4478--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1104001"></a><a 
 id="x85-1104002r216"></a><b> abs</b>  <i>number</i>
</div>
<!--l. 4480--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-110500012.5.2" id="x85-110500012.5.2"></a></span>
   Возвращает абсолютное значение аргумента. Для некомплексных чисел <i>x</i>,
<div class="lisp"><div class="tabbing">
(abs <i>x</i>) <span class="math"> ≡</span> (if (minusp <i>x</i>) (- <i>x</i>) <i>x</i>)
   <br>
<!--l. 4484--><p class="noindent" ></div>
<!--l. 4484--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-110600012.5.2" id="x85-110600012.5.2"></a></span>
<!--l. 4484--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-110700012.5.2" id="x85-110700012.5.2"></a></span>
</div>
<!--l. 4485--><p class="indent" >   и результат всегда имеет тот же тип, что и аргумент.
                                                                          

                                                                          
<!--l. 4487--><p class="indent" >   Для комплексных чисел <i>z</i>, абсолютное значение может быть вычислено
как <div class="lisp"><div class="tabbing">
(sqrt (+ (expt (realpart <i>z</i>) 2) (expt (imagpart <i>z</i>) 2)))
   <br>
<!--l. 4490--><p class="noindent" ></div>
<!--l. 4490--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-110800012.5.2" id="x85-110800012.5.2"></a></span>
<!--l. 4490--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-110900012.5.2" id="x85-110900012.5.2"></a></span>
</div>
<div class="implementation">
<!--l. 4493--><p class="noindent" ><b>Заметка для реализации:</b> Аккуратные разработчики не будут напрямую
использовать эту формулу для всех комплексных чисел. Очень большие и очень
маленькие части комплексных чисел будут обрабатываться специализированно для
избежания выходов за верхние и нижние границы значений.
</div>
<!--l. 4501--><p class="indent" >   Например: <div class="lisp"><div class="tabbing">
(abs #c(3.0 -4.0)) <span class="math"> ⇒</span> 5.0
   <br>
<!--l. 4504--><p class="noindent" ></div>
<!--l. 4504--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-111000012.5.2" id="x85-111000012.5.2"></a></span>
<!--l. 4504--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-111100012.5.2" id="x85-111100012.5.2"></a></span>
</div>
<!--l. 4505--><p class="indent" >   Результатом <tt>(abs #(3 4))</tt> может быть или <tt>5</tt> или <tt>5.0</tt>, в зависимости от
реализации.
</div>
<div class="defun">
                                                                          

                                                                          
<!--l. 4509--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1111001"></a><a 
 id="x85-1111002r217"></a><b> phase</b>  <i>number</i>
</div>
<!--l. 4511--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-111200012.5.2" id="x85-111200012.5.2"></a></span>
   Аргументом (так называется функция phase) числа z (arg(z) <span class="math"> ≡</span>(phase z))
является угол <span class="math">φ</span> (в радианах) радиус-вектора точки, соответствующей
комплексному числу z.
<div class="new">
<!--l. 4517--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx85-1112001"></a>to specify certain ﬂoating-point behavior when
minus zero is supported; <tt><a 
href="clmli7.html#x196-3479710r710">phase</a></tt> is still deﬁned in terms of <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt> as above, but
thanks to a change in <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt> the range of <tt><a 
href="clmli7.html#x196-3479710r710">phase</a></tt> becomes <span class="math"> − π</span> <i>inclusive</i> to <span class="math">π</span>
inclusive. The value <span class="math"> − π</span> results from an argument whose real part is
                                                                          

                                                                          
negative and whose imaginary part is minus zero. The <tt><a 
href="clmli7.html#x196-3479710r710">phase</a></tt> function
therefore has a branch cut along the negative real axis. The phase of
<span class="math"> + 0 + 0<i>i</i></span> is <span class="math"> + 0</span>, of <span class="math"> + 0 − 0<i>i</i></span> is <span class="math"> − 0</span>, of <span class="math"> − 0 + 0<i>i</i></span> is <span class="math"> + π</span>, and of <span class="math"> − 0 − 0<i>i</i></span> is
<span class="math"> − π</span>.
</div>
<!--l. 4530--><p class="indent" >   Если аргумент является комплексным числом с частями из чисел с
плавающей точкой, то результатом является число с плавающей точкой того
же типа. Если аргумент является числом с плавающей точкой, то
результатом является число с плавающей точкой того же типа. Если
аргумент является комплексным числом с частями из рациональных
чисел, то результатом является число с плавающей точкой одинарного
типа.
</div>
<div class="defun">
<!--l. 4538--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1112002"></a><a 
 id="x85-1112003r218"></a><b> signum</b>  <i>number</i>
</div>
<!--l. 4540--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-111300012.5.2" id="x85-111300012.5.2"></a></span>
   По определению, <div class="lisp"><div class="tabbing">
(signum <i>x</i>) <span class="math"> ≡</span> (if (zerop <i>x</i>) <i>x</i> (/ <i>x</i> (abs <i>x</i>)))
   <br>
<!--l. 4544--><p class="noindent" ></div>
<!--l. 4544--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-111400012.5.2" id="x85-111400012.5.2"></a></span>
<!--l. 4544--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-111500012.5.2" id="x85-111500012.5.2"></a></span>
</div>
<!--l. 4545--><p class="indent" >   Для рационального числа, <tt><a 
href="clmli7.html#x196-3479851r851">signum</a></tt> будет возвращать один из вариантов:
<tt>-1</tt>, <tt>0</tt> или <tt>1</tt>, в соответствии с тем, является ли число отрицательным, нулём
или положительным. Для числа с плавающей точкой, результатом будет
число с плавающей точкой того же типа и значением: <span class="math"> − 1</span>, <span class="math">0</span> или <span class="math">1</span>. Для
комплексного числа <i>z</i>, <tt>(signum <i>z</i>)</tt> является комплексным числом с таким
же аргументом (phase), но с единичным модулем. Но если <i>z</i> равен
                                                                          

                                                                          
комплексному нулю, результатом является само число <i>z</i>. Например:
<div class="lisp"><div class="tabbing">
(signum 0) <span class="math"> ⇒</span> 0
   <br>                                                            (signum -3.7L5) <span class="math"> ⇒</span> -1.0L0<br>
(signum 4/5) <span class="math"> ⇒</span> 1<br>                 (signum #C(7.5 10.0)) <span class="math"> ⇒</span> #C(0.6 0.8)<br>
(signum #C(0.0 -14.7)) <span class="math"> ⇒</span> #C(0.0 -1.0)<br>
<!--l. 4560--><p class="noindent" ></div>
<!--l. 4560--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-111600012.5.2" id="x85-111600012.5.2"></a></span>
<!--l. 4560--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-111700012.5.2" id="x85-111700012.5.2"></a></span>
</div>
<!--l. 4561--><p class="indent" >   Для некомплексных рациональных чисел <tt><a 
href="clmli7.html#x196-3479851r851">signum</a></tt> является рациональной
функцией, но для комплексных чисел может быть иррациональной.
</div>
<div class="defun">
<!--l. 4565--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1117001"></a><a 
 id="x85-1117002r219"></a><b> sin</b>  <i>radians</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx85-1117003"></a><a 
 id="x85-1117004r220"></a><b> cos</b>  <i>radians</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx85-1117005"></a><a 
 id="x85-1117006r221"></a><b> tan</b>  <i>radians</i>
</div>
<!--l. 4569--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-111800012.5.2" id="x85-111800012.5.2"></a></span>
<tt>
   <a 
href="clmli7.html#x196-3479861r861">sin</a></tt> возвращает синус аргумента, <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt> — косинус, <tt><a 
href="clmli7.html#x196-3479938r938">tan</a></tt> — тангенс. Аргумент
рассматривается как угол в радианах. Аргумент может быть комплексным
числом.
</div>
<div class="defun">
<!--l. 4575--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1118001"></a><a 
 id="x85-1118002r222"></a><b> cis</b>  <i>radians</i>
</div>
                                                                          

                                                                          
<!--l. 4577--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-111900012.5.2" id="x85-111900012.5.2"></a></span>
   Функция вычисляет <span class="math"><i>e</i><sup>i⋅radians</sup></span>. Имя <tt><a 
href="clmli7.html#x196-3479228r228">cis</a></tt> обозначает «cos + <i>i</i> sin», потому
что <span class="math"><i>e</i><sup>i𝜃</sup> = cos 𝜃 + <i>i</i> sin 𝜃</span>. Аргумент рассматривается как угол в радианах и
может быть любым некомплексным числом. Результатом является
комплексное число, у которого действительная часть это косинус аргумента,
и мнимая — синус аргумента. Другими словами, результат это комплексное
число, у которого аргумент (фаза) равна (mod <span class="math">2∕pi</span>) и модуль равен
единице.
<div class="implementation">
<!--l. 4588--><p class="noindent" ><b>Заметка для реализации:</b> Чаще всего дешевле вычислить синус и косинус угла
вместе, чем выполнять два раздельных вычисления.
</div>
</div>
<div class="defun">
<!--l. 4595--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1119001"></a><a 
 id="x85-1119002r223"></a><b> asin</b>  <i>number</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx85-1119003"></a><a 
 id="x85-1119004r224"></a><b> acos</b>  <i>number</i>
</div>
<!--l. 4598--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-112000012.5.2" id="x85-112000012.5.2"></a></span>
<tt>
   <a 
href="clmli7.html#x196-3479112r112">asin</a></tt> возвращаем арксинус аргумента, и <tt><a 
href="clmli7.html#x196-3479075r75">acos</a></tt> — арккосинус аргумента.
Результат будет в радианах. Аргумент может быть комплексным
числом.
<!--l. 4602--><p class="indent" >   Функции арксинус и арккосинус могут быть математически определены
для аргумента <i>z</i> следующим образом: <div class="tabbing">
Арксинус                 <span class="math"> −<i>i</i> log <img 
src="clm1x.png" alt="(            )
 iz + √1--−-z2"  class="left" align="middle"></span>
   <br>
Арккосинус              <span class="math"> −<i>i</i> log <img 
src="clm2x.png" alt="(    √ ------)
 z + i 1 − z2"  class="left" align="middle"></span>
   <br>
<!--l. 4608--><p class="noindent" ></div>
<!--l. 4608--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-112100012.5.2" id="x85-112100012.5.2"></a></span>
   Следует отметить, что результат <tt><a 
href="clmli7.html#x196-3479112r112">asin</a></tt> или <tt>acos</tt> может быть комплексным
числом, даже если аргумент не являлся комплексным. Такое происходит,
когда абсолютное значение аргумента превышает 1.
                                                                          

                                                                          
<div class="newer">
<!--l. 4614--><p class="indent" >   Kahan <span class="cite">[<a 
href="clmli5.html#XKAHAN-COMPLEX-FNS">25</a>]</span> suggests for <tt><a 
href="clmli7.html#x196-3479075r75">acos</a></tt> the deﬁning formula <div class="tabbing">
Arc cosine                 <span class="math">2 log <img 
src="clm3x.png" alt="( ∘ ----  ∘ ----)
    1+z+  i  1−-z
     2        2"  class="left" align="middle"> 
        i            </span>
   <br>
<!--l. 4619--><p class="noindent" ></div>
<!--l. 4619--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-112200012.5.2" id="x85-112200012.5.2"></a></span>
   or even the much simpler <span class="math">(π∕2) − arcsin <i>z</i></span>. Both equations are mathematically
equivalent to the formula shown above.
</div>
<div class="implementation">
<!--l. 4625--><p class="noindent" ><b>Заметка для реализации:</b> These formulae are mathematically correct, assuming
completely accurate computation. They may be terrible methods for ﬂoating-point
computation. Implementors should consult a good text on numerical analysis. The
formulae given above are not necessarily the simplest ones for real-valued computations,
either; they are chosen to deﬁne the branch cuts in desirable ways for the complex
case.
</div>
</div>
<div class="defun">
<!--l. 4636--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1122001"></a><a 
 id="x85-1122002r225"></a><b> atan</b>  <i>y</i> &#x0026;optional  <i>x</i>
</div>
<!--l. 4638--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-112300012.5.2" id="x85-112300012.5.2"></a></span>
   Функция вычисляет арктангенс и возвращает результат в радианах.
<!--l. 4641--><p class="indent" >   Ни один из двух аргументов <i>y</i> и <i>x</i> не может быть комплексным. Знаки <i>y</i> и
<i>x</i> используются для определения квадранта. <i>x</i> может быть нулём при
условии, что <i>y</i> не ноль. Значение <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt> лежит между <span class="math"> −pi</span> (невключительно) и
<span class="math">pi</span> (включительно). Следующая таблица описывает различные специальные
случаи.
<div class="flushleft" 
>
                                                                          

                                                                          
<!--l. 4647--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" colspan="2">     <div class="multicolumn"  style="white-space:nowrap; text-align:center;">Условие</div>     </td><td align="left" >Декартово местоположение         </td><td align="left" >Промежуток результата</td>
</tr><tr><td align="left" ><span class="math">y = +0</span> </td><td align="left" ><span class="math">x &#x003E; 0</span>  </td><td align="left" >Точно выше положительной оси x</td><td align="left" >              <span class="math"> + 0</span>              </td>
</tr><tr><td align="left" ><span class="math">y &#x003E; 0</span>   </td><td align="left" ><span class="math">x &#x003E; 0</span>  </td><td align="left" >Квадрант I                                </td><td align="left" >    <span class="math"> + 0 &#x003C; result &#x003C; π∕2</span>    </td>
</tr><tr><td align="left" ><span class="math">y &#x003E; 0</span>   </td><td align="left" ><span class="math">x = ±0</span></td><td align="left" >Положительная ось y                 </td><td align="left" >              <span class="math">π∕2</span>              </td>
</tr><tr><td align="left" ><span class="math">y &#x003E; 0</span>   </td><td align="left" ><span class="math">x &#x003C; 0</span>  </td><td align="left" >Квадрант II                               </td><td align="left" >     <span class="math">π∕2 &#x003C; result &#x003C; π</span>     </td>
</tr><tr><td align="left" ><span class="math">y = +0</span> </td><td align="left" ><span class="math">x &#x003C; 0</span>  </td><td align="left" >Точно ниже негативной оси x      </td><td align="left" >                <span class="math">π</span>             </td>
</tr><tr><td align="left" ><span class="math">y = −0</span> </td><td align="left" ><span class="math">x &#x003C; 0</span>  </td><td align="left" >Точно выше отрицательной оси x </td><td align="left" >                <span class="math">π</span>             </td>
</tr><tr><td align="left" ><span class="math">y &#x003C; 0</span>   </td><td align="left" ><span class="math">x &#x003C; 0</span>  </td><td align="left" >Квадрант III                              </td><td align="left" >  <span class="math"> − π &#x003C; result &#x003C; −π∕2</span>  </td>
</tr><tr><td align="left" ><span class="math">y &#x003C; 0</span>   </td><td align="left" ><span class="math">x = ±0</span></td><td align="left" >Отрицательная ось y                  </td><td align="left" >             <span class="math"> − π∕2</span>             </td>
</tr><tr><td align="left" ><span class="math">y &#x003C; 0</span>   </td><td align="left" ><span class="math">x &#x003E; 0</span>  </td><td align="left" >Квадрант IV                              </td><td align="left" >   <span class="math"> − π∕2 &#x003C; result &#x003C; −0</span>   </td>
</tr><tr><td align="left" ><span class="math">y = −0</span> </td><td align="left" ><span class="math">x &#x003E; 0</span>  </td><td align="left" >Точно ниже положительной оси x</td><td align="left" >              <span class="math"> − 0</span>              </td>
</tr><tr><td align="left" ><span class="math">y = +0</span> </td><td align="left" ><span class="math">x = +0</span></td><td align="left" >Рядом с центром                        </td><td align="left" >              <span class="math"> + 0</span>              </td>
</tr><tr><td align="left" ><span class="math">y = −0</span> </td><td align="left" ><span class="math">x = +0</span></td><td align="left" >Рядом с центром                        </td><td align="left" >              <span class="math"> − 0</span>              </td>
</tr><tr><td align="left" ><span class="math">y = +0</span> </td><td align="left" ><span class="math">x = −0</span></td><td align="left" >Рядом с центром                        </td><td align="left" >                <span class="math">π</span>             </td>
</tr><tr><td align="left" ><span class="math">y = −0</span> </td><td align="left" ><span class="math">x = −0</span></td><td align="left" >Рядом с центром                        </td><td align="left" >              <span class="math"> − π</span>            </td></tr><tr><td align="left" >  </td></tr></table>
</div></div>
<!--l. 4667--><p class="indent" >   Следует отметить, что случай <span class="math">y = 0,x = 0</span> при отсутствии минус ноля
является ошибкой, но четыре случая <span class="math">y = ±0,x = ±0</span> определены при условии
существования минус ноля.
<!--l. 4671--><p class="indent" >   Если не указывать <i>x</i>, <i>y</i> может быть комплексным. Результатом функции
является арктангенс <i>y</i>, который может быть определён следующей
формулой: <div class="tabbing">
Арктангенс               <span class="math"> log(1+<i>i</i><i>y</i>)−log(1−<i>i</i><i>y</i>) 
             2<i>i</i>         </span>
   <br>
<!--l. 4677--><p class="noindent" ></div>
<!--l. 4677--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-112400012.5.2" id="x85-112400012.5.2"></a></span>
<div class="implementation">
   <b>Заметка для реализации:</b> This formula is mathematically correct, assuming
completely accurate computation. It may be a terrible method for ﬂoating-point
computation. Implementors should consult a good text on numerical analysis. The
formula given above is not necessarily the simplest one for real-valued computations,
either; it is chosen to deﬁne the branch cuts in desirable ways for the complex
case.
</div>
   Для некомплексного аргумента <i>y</i>, результат будет некомплексным и
будет лежать между <span class="math"> − π∕2</span> и <span class="math">π∕2</span> (оба невключительно).
</div>
                                                                          

                                                                          
<div class="defun">
<!--l. 4694--><p class="noindent" ><div class="defunheader"> <i>[Константа]</i><a 
 id="dx85-1124001"></a><a 
 id="x85-1124002r226"></a><b> pi</b>
</div>
<!--l. 4696--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-112500012.5.2" id="x85-112500012.5.2"></a></span>
   Данная глобальная переменная содержит значение наиболее
приближенное к <span class="math">pi</span> в <i>длинном</i> формате числа с плавающей точкой.
Например: <div class="lisp"><div class="tabbing">
(defun sind (x)     ;Аргумент в градусах
   <br>                                                      (sin (* x (/ (ﬂoat pi x) 180))))<br>
<!--l. 4703--><p class="noindent" ></div>
<!--l. 4703--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-112600012.5.2" id="x85-112600012.5.2"></a></span>
<!--l. 4703--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-112700012.5.2" id="x85-112700012.5.2"></a></span>
</div>
<!--l. 4704--><p class="indent" >   Приближение к <span class="math">pi</span> с другими точностями может быть выполнено с
помощью <tt>(float pi <i>x</i>)</tt>, где <i>x</i> является числом с плавающей точкой
необходимой точности, или с помощью <tt>(coerce pi <i>type</i>)</tt>, где <i>type</i> является
именем необходимого типа, как например <tt>short-float</tt>.
</div>
<div class="defun">
<!--l. 4710--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx85-1127001"></a><a 
 id="x85-1127002r227"></a><b> sinh</b>  <i>number</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx85-1127003"></a><a 
 id="x85-1127004r228"></a><b> cosh</b>  <i>number</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx85-1127005"></a><a 
 id="x85-1127006r229"></a><b> tanh</b>  <i>number</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx85-1127007"></a><a 
 id="x85-1127008r230"></a><b> asinh</b>  <i>number</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx85-1127009"></a><a 
 id="x85-1127010r231"></a><b> acosh</b>  <i>number</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx85-1127011"></a><a 
 id="x85-1127012r232"></a><b> atanh</b>  <i>number</i>
</div>
<!--l. 4717--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-112800012.5.2" id="x85-112800012.5.2"></a></span>
   Данные функции вычисляют гиперболический синус, косинус, тангенс,
арксинус, арккосинус и арктангенс, которые для аргумента <i>z</i> математически
определены следующим образом: <div class="tabbing">
                                                                          

                                                                          
Гиперболический синус  <span class="math">(<i>e </i> <sup>z </sup> −<i>e</i><sup>−z</sup>)∕2</span>
   <br>                                                 Гиперболический косинус  <span class="math">(<i>e </i> <sup>z </sup> + <i> e</i><sup>−z</sup>)∕2</span><br>
Гиперболический тангенс  <span class="math">(<i>e </i> <sup>z </sup> − <i> e</i><sup>−z</sup>)∕(<i>e</i><sup>z</sup> + <i>e</i><sup>−z</sup>)</span><br>
Гиперболический арксинус  <span class="math">log<img 
src="clm4x.png" alt="(    √ -----2)
 z +   1 + z"  class="left" align="middle"></span>
   <br>
Гиперболический арккосинус  <span class="math">log<img 
src="clm5x.png" alt="(          ∘ ---------------)
 z + (z + 1 ) (z − 1)∕(z + 1)"  class="left" align="middle"></span>
   <br>
Гиперболический арктангенс  <span class="math">log<img 
src="clm6x.png" alt="(       ∘ ---------)
 (1 + z)  1∕(1 − z2)"  class="left" align="middle"></span>
   <br>
<!--l. 4729--><p class="noindent" ></div>
<!--l. 4729--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-112900012.5.2" id="x85-112900012.5.2"></a></span>
   Следует отметить, что результат <tt><a 
href="clmli7.html#x196-3479076r76">acosh</a></tt> может быть комплексным, даже
если аргумент комплексным числом не был. Это происходит если аргумент
меньше 1. Также результат <tt><a 
href="clmli7.html#x196-3479119r119">atanh</a></tt> может быть комплексным, даже если
аргумент не был комплексным. Это происходит если абсолютное значение
аргумента было больше 1.
<div class="implementation">
<!--l. 4737--><p class="noindent" ><b>Заметка для реализации:</b> These formulae are mathematically correct, assuming
completely accurate computation. They may be terrible methods for ﬂoating-point
computation. Implementors should consult a good text on numerical analysis. The
formulae given above are not necessarily the simplest ones for real-valued computations,
either; they are chosen to deﬁne the branch cuts in desirable ways for the complex
case.
</div>
</div>
<!--l. 4748--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">12.5.3   </span> <a 
href="clmli1.html#QQ2-85-1139" id="x85-113000012.5.3">Точки ветвления, главные значения и краевые условия на
комплексной плоскости</a></h4>
<!--l. 4751--><p class="noindent" >Многие иррациональные и трансцендентные функции на комплексной
плоскости многозначны. Например, в общем случае, логарифмическая
функция имеет бесконечное количество комплексных значений. В
                                                                          

                                                                          
каждом таком случае для возврата должно быть выбрано одно главное
значение.
<!--l. 4756--><p class="indent" >   Common Lisp определяет точки ветвления, главные значения и краевые
условия для комплексных функции в соотвествие с предложениями для
комплексных функций в APL <span class="cite">[<a 
href="clmli5.html#XAPL-BRANCH-CUTS">36</a>]</span>. Содержимое раздела по большей части
скопировано из этих предложений.
<div class="new">
<!--l. 4762--><p class="indent" >   Indeed, X3J13 voted in January 1989 <a 
 id="dx85-1130001"></a>to alter the direction of continuity for
the branch cuts of <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt>, and also <a 
 id="dx85-1130002"></a>to address the treatment of branch cuts in
implementations that have a distinct ﬂoating-point minus zero.
<!--l. 4770--><p class="indent" >   The treatment of minus zero centers in two-argument <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt>. If there is no
minus zero, then the branch cut runs just below the negative real axis as before,
and the range of two-argument <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt> is <span class="math">(−π,π]</span>. If there is a minus zero, however,
then the branch cut runs precisely on the negative real axis, skittering between
pairs of numbers of the form <span class="math"> −<i>x</i> ± 0<i>i</i></span>, and the range of two-argument <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt> is
<span class="math">[−π,π]</span>.
<!--l. 4777--><p class="indent" >   The treatment of minus zero by all other irrational and transcendental
functions is then speciﬁed by deﬁning those functions in terms of two-argument
<tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt>. First, <tt><a 
href="clmli7.html#x196-3479710r710">phase</a></tt> is deﬁned in terms of two-argument <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt>, and complex <tt><a 
href="clmli7.html#x196-3479073r73">abs</a></tt> in
terms of real <tt><a 
href="clmli7.html#x196-3479880r880">sqrt</a></tt>; then complex <tt><a 
href="clmli7.html#x196-3479538r538">log</a></tt> is deﬁned in terms of <tt><a 
href="clmli7.html#x196-3479710r710">phase</a></tt>, <tt><a 
href="clmli7.html#x196-3479073r73">abs</a></tt>, and real
<tt><a 
href="clmli7.html#x196-3479538r538">log</a></tt>; then complex <tt><a 
href="clmli7.html#x196-3479880r880">sqrt</a></tt> in terms of complex <tt><a 
href="clmli7.html#x196-3479538r538">log</a></tt>; and ﬁnally all others are deﬁned
in terms of these.
<!--l. 4785--><p class="indent" >   Kahan <span class="cite">[<a 
href="clmli5.html#XKAHAN-COMPLEX-FNS">25</a>]</span> treats these matters in some detail and also suggests speciﬁc
algorithms for implementing irrational and transcendental functions in IEEE
standard ﬂoating-point arithmetic <span class="cite">[<a 
href="clmli5.html#XIEEE-PROPOSED-FLOATING-POINT-STANDARD">23</a>]</span>.
<!--l. 4789--><p class="indent" >   Remarks in the ﬁrst edition about the direction of the continuity of branch
cuts continue to hold in the absence of minus zero and may be ignored if minus
zero is supported; since all branch cuts happen to run along the principal axes,
they run <i>between</i> plus zero and minus zero, and so each sort of zero is associated
with the obvious quadrant.
</div>
<div class="flushdesc">
<!--l. 4797--><p class="indent" >
      <ul><li><b>
<tt><a 
href="clmli7.html#x196-3479880r880">sqrt</a></tt> </b></li>The  branch  cut  for  square  root  lies  along  the  negative  real  axis,
      continuous with quadrant II. The range consists of the right half-plane,
      including the non-negative imaginary axis and excluding the negative
                                                                          

                                                                          
      imaginary axis.
<div class="new">
      <!--l. 4804--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx85-1130003"></a>to specify certain ﬂoating-point behavior when
      minus zero is supported. As a part of that vote it approved a mathematical
      deﬁnition of complex square root: <div class="tabbing">
      <span class="math"><img 
src="clm7x.png" alt="√z-"  class="sqrt" > = <i>e</i><sup>(log z)∕2
           </sup></span>
      <br>
      <!--l. 4810--><p class="noindent" ></div>
      <!--l. 4810--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-113100012.5.3" id="x85-113100012.5.3"></a></span>
      This deﬁnes the branch cuts precisely, whether minus zero is supported or
      not.
      </div>
      <li><b>
<tt><a 
href="clmli7.html#x196-3479710r710">phase</a></tt> </b></li>The branch cut for the phase function lies along the negative real axis,
      continuous with quadrant II. The range consists of that portion of the real
      axis between <span class="math"> − π</span> (exclusive) and <span class="math">π</span> (inclusive).
<div class="new">
      <!--l. 4820--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx85-1131001"></a>to specify certain ﬂoating-point behavior when
      minus zero is supported. As a part of that vote it approved a mathematical
      deﬁnition of phase: <div class="tabbing">
      <span class="math"> phase <i>z</i> = arctan(ℑ<i>z</i>,ℜ<i>z</i>)</span>
      <br>
      <!--l. 4826--><p class="noindent" ></div>
                                                                          

                                                                          
      <!--l. 4826--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-113200012.5.3" id="x85-113200012.5.3"></a></span>
      where <span class="math">ℑ<i>z</i></span> is the imaginary part of <span class="math"><i>z</i></span> and <span class="math">ℜ<i>z</i></span> the real part of <span class="math"><i>z</i></span>. This
      deﬁnes the branch cuts precisely, whether minus zero is supported or
      not.
      </div>
      <li><b>
 <tt><a 
href="clmli7.html#x196-3479538r538">log</a></tt> </b></li>The branch cut for the logarithm function of one argument (natural
      logarithm) lies along the negative real axis, continuous with quadrant II.
      The domain excludes the origin. For a complex number <span class="math"><i>z</i></span>, <span class="math"> log <i>z</i></span> is deﬁned to
      be <div class="tabbing">
      <span class="math"> log <i>z</i> = <img 
src="clm8x.png" alt="(log |z|)"  class="left" align="middle"> + <i>i</i>(phase <i>z</i>)</span>
      <br>
      <!--l. 4838--><p class="noindent" ></div>
      <!--l. 4838--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-113300012.5.3" id="x85-113300012.5.3"></a></span>
      Therefore the range of the one-argument logarithm function is that strip of
      the complex plane containing numbers with imaginary parts between <span class="math"> − π</span>
      (exclusive) and <span class="math">π</span> (inclusive).
<div class="new">
      <!--l. 4844--><p class="noindent" >The X3J13 vote on minus zero <a 
 id="dx85-1133001"></a>would alter that exclusive bound of <span class="math"> − π</span> to
      be inclusive if minus zero is supported.
      </div>
      <!--l. 4849--><p class="noindent" >The two-argument logarithm function is deﬁned as <span class="math"> log <sub>b</sub><i>z</i> = (log <i>z</i>)∕(log <i>b</i>)</span>.
      This deﬁnes the principal values precisely. The range of the two-argument
      logarithm function is the entire complex plane. It is an error if <span class="math"><i>z</i></span> is
      zero. If <span class="math"><i>z</i></span> is non-zero and <span class="math"><i>b</i></span> is zero, the logarithm is taken to be
      zero.
      <li><b>
 <tt><a 
href="clmli7.html#x196-3479378r378">exp</a></tt> </b></li>The simple exponential function has no branch cut.
                                                                          

                                                                          
      <li><b>
<tt><a 
href="clmli7.html#x196-3479381r381">expt</a></tt> </b></li>The two-argument exponential function is deﬁned as <span class="math"><i>b</i><sup>x</sup> = <i>e</i><sup>x log b</sup></span>. This
      deﬁnes the principal values precisely. The range of the two-argument
      exponential function is the entire complex plane. Regarded as a
      function of <span class="math"><i>x</i></span>, with <span class="math"><i>b</i></span> ﬁxed, there is no branch cut. Regarded as a
      function of <i>b</i>, with <span class="math"><i>x</i></span> ﬁxed, there is in general a branch cut along the
      negative real axis, continuous with quadrant II. The domain excludes
      the origin. By deﬁnition, <span class="math">0<sup>0</sup> = 1</span>. If <span class="math"><i>b</i> = 0</span> and the real part of <span class="math"><i>x</i></span>
      is strictly positive, then <span class="math"><i>b</i><sup>x</sup> = 0</span>. For all other values of <span class="math"><i>x</i></span>, <span class="math">0<sup>x</sup></span> is an
      error.
      <li><b>
<tt><a 
href="clmli7.html#x196-3479112r112">asin</a></tt> </b></li>The following deﬁnition for arc sine determines the range and branch cuts:
      <div class="tabbing">
      <span class="math"> arcsin <i>z</i> = −<i>i</i> log <img 
src="clm9x.png" alt="(    √ ------)
 iz +  1 − z2"  class="left" align="middle"></span>
      <br>
      <!--l. 4877--><p class="noindent" ></div>
      <!--l. 4877--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-113400012.5.3" id="x85-113400012.5.3"></a></span>
<div class="newer">
      This is equivalent to the formula <div class="tabbing">
      <span class="math"> arcsin <i>z</i> = arcsinh <i>i</i><i>z</i> 
     <i>i</i>     </span>
      <br>
      <!--l. 4883--><p class="noindent" ></div>
                                                                          

                                                                          
      <!--l. 4883--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-113500012.5.3" id="x85-113500012.5.3"></a></span>
      recommended by Kahan <span class="cite">[<a 
href="clmli5.html#XKAHAN-COMPLEX-FNS">25</a>]</span>.
      </div>
      The branch cut for the arc sine function is in two pieces: one along the
      negative real axis to the left of <span class="math"> − 1</span> (inclusive), continuous with quadrant II,
      and one along the positive real axis to the right of 1 (inclusive),
      continuous with quadrant IV. The range is that strip of the complex
      plane containing numbers whose real part is between <span class="math"> − π∕2</span> and
      <span class="math">π∕2</span>. A number with real part equal to <span class="math"> − π∕2</span> is in the range if
      and only if its imaginary part is non-negative; a number with real
      part equal to <span class="math">π∕2</span> is in the range if and only if its imaginary part is
      non-positive.
      <li><b>
<tt><a 
href="clmli7.html#x196-3479075r75">acos</a></tt> </b></li>The following deﬁnition for arc cosine determines the range and branch
      cuts: <div class="tabbing">
      <span class="math"> arccos <i>z</i> = −<i>i</i> log <img 
src="clm10x.png" alt="(     √------)
 z + i 1 − z2"  class="left" align="middle"></span>
      <br>
      <!--l. 4902--><p class="noindent" ></div>
      <!--l. 4902--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-113600012.5.3" id="x85-113600012.5.3"></a></span>
      or, which is equivalent, <div class="tabbing">
      <span class="math"> arccos <i>z</i> = π 
2  − arcsin <i>z</i></span>
      <br>
      <!--l. 4906--><p class="noindent" ></div>
                                                                          

                                                                          
      <!--l. 4906--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-113700012.5.3" id="x85-113700012.5.3"></a></span>
      The branch cut for the arc cosine function is in two pieces: one along the
      negative real axis to the left of <span class="math"> − 1</span> (inclusive), continuous with quadrant II,
      and one along the positive real axis to the right of 1 (inclusive), continuous
      with quadrant IV. This is the same branch cut as for arc sine. The range is
      that strip of the complex plane containing numbers whose real part is
      between zero and <span class="math">π</span>. A number with real part equal to zero is in the range if
      and only if its imaginary part is non-negative; a number with real
      part equal to <span class="math">π</span> is in the range if and only if its imaginary part is
      non-positive.
      <li><b>
<tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt> </b></li>The following deﬁnition for (one-argument) arc tangent determines the
      range and branch cuts:
<div class="new">
      <!--l. 4923--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx85-1137001"></a>to replace the formula shown above with the
      formula <div class="tabbing">
      <span class="math"> arctan <i>z</i> = log(1 + <i>i</i><i>z</i>) − log(1 −<i>i</i><i>z</i>) 
              2<i>i</i>              </span>
      <br>
      <!--l. 4928--><p class="noindent" ></div>
      <!--l. 4928--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-113800012.5.3" id="x85-113800012.5.3"></a></span>
      This is equivalent to the formula <div class="tabbing">
      <span class="math"> arctan <i>z</i> = arctanh <i>i</i><i>z</i> 
     <i>i</i>      </span>
      <br>
      <!--l. 4932--><p class="noindent" ></div>
                                                                          

                                                                          
      <!--l. 4932--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-113900012.5.3" id="x85-113900012.5.3"></a></span>
      recommended by Kahan <span class="cite">[<a 
href="clmli5.html#XKAHAN-COMPLEX-FNS">25</a>]</span>. It causes the upper branch cut to be
      continuous with quadrant I rather than quadrant II, and the lower branch
      cut to be continuous with quadrant III rather than quadrant IV; otherwise
      it agrees with the formula of the ﬁrst edition. Therefore this change alters
      the result returned by <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt> only for arguments on the positive imaginary
      axis that are of magnitude greater than 1. The full description for this new
      formula is as follows.
      <!--l. 4941--><p class="noindent" >The branch cut for the arc tangent function is in two pieces: one along the
      positive imaginary axis above <i>i</i> (exclusive), continuous with quadrant I, and
      one along the negative imaginary axis below <span class="math"> −<i>i</i></span> (exclusive), continuous
      with quadrant III. The points <i>i</i> and <span class="math"> −<i>i</i></span> are excluded from the domain. The
      range is that strip of the complex plane containing numbers whose real
      part is between <span class="math"> − π∕2</span> and <span class="math">π∕2</span>. A number with real part equal to
      <span class="math"> − π∕2</span> is in the range if and only if its imaginary part is strictly
      negative; a number with real part equal to <span class="math">π∕2</span> is in the range if
      and only if its imaginary part is strictly positive. Thus the range
      of the arc tangent function is <i>not</i> identical to that of the arc sine
      function.
      </div>
      <li><b>
<tt><a 
href="clmli7.html#x196-3479113r113">asinh</a></tt> </b></li>The following deﬁnition for the inverse hyperbolic sine determines the
      range and branch cuts: <div class="tabbing">
      <span class="math"> arcsinh <i>z</i> = log <img 
src="clm11x.png" alt="(    √ ------)
 z +   1 + z2"  class="left" align="middle"></span>
      <br>
      <!--l. 4959--><p class="noindent" ></div>
      <!--l. 4959--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-114000012.5.3" id="x85-114000012.5.3"></a></span>
      The branch cut for the inverse hyperbolic sine function is in two pieces: one
      along the positive imaginary axis above <i>i</i> (inclusive), continuous with
      quadrant I, and one along the negative imaginary axis below <span class="math"> −<i>i</i></span> (inclusive),
                                                                          

                                                                          
      continuous with quadrant III. The range is that strip of the complex
      plane containing numbers whose imaginary part is between <span class="math"> − π∕2</span>
      and <span class="math">π∕2</span>. A number with imaginary part equal to <span class="math"> − π∕2</span> is in the
      range if and only if its real part is non-positive; a number with
      imaginary part equal to <span class="math">π∕2</span> is in the range if and only if its real part is
      non-negative.
      <li><b>
<tt><a 
href="clmli7.html#x196-3479076r76">acosh</a></tt> </b></li>The following deﬁnition for the inverse hyperbolic cosine determines the
      range and branch cuts: <div class="tabbing">
      <span class="math"> arccosh <i>z</i> = log <img 
src="clm12x.png" alt="(           ∘ --------------)
  z + (z + 1) (z − 1)∕(z + 1)"  class="left" align="middle"></span>
      <br>
      <!--l. 4975--><p class="noindent" ></div>
      <!--l. 4975--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-114100012.5.3" id="x85-114100012.5.3"></a></span>
<div class="newer">
      Kahan <span class="cite">[<a 
href="clmli5.html#XKAHAN-COMPLEX-FNS">25</a>]</span> suggests the formula <div class="tabbing">
      <span class="math"> arccosh <i>z</i> = 2 log <img 
src="clm13x.png" alt="(∘ ---------  ∘ ---------)
   (z + 1 )∕2 +  (z − 1)∕2"  class="left" align="middle"></span>
      <br>
      <!--l. 4981--><p class="noindent" ></div>
      <!--l. 4981--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-114200012.5.3" id="x85-114200012.5.3"></a></span>
      pointing out that it yields the same principal value but eliminates a
      gratuitous removable singularity at <span class="math"><i>z</i> = −1</span>. A proposal was submitted to
      X3J13 in September 1989 to replace the formula <tt><a 
href="clmli7.html#x196-3479076r76">acosh</a></tt> with that
      recommended by Kahan. There is a good possibility that it will be
      adopted.
      </div>
                                                                          

                                                                          
      The branch cut for the inverse hyperbolic cosine function lies along the real
      axis to the left of 1 (inclusive), extending indeﬁnitely along the negative real
      axis, continuous with quadrant II and (between 0 and 1) with quadrant I.
      The range is that half-strip of the complex plane containing numbers whose
      real part is non-negative and whose imaginary part is between <span class="math"> − π</span>
      (exclusive) and <span class="math">π</span> (inclusive). A number with real part zero is in
      the range if its imaginary part is between zero (inclusive) and <span class="math">π</span>
      (inclusive).
      <li><b>
<tt><a 
href="clmli7.html#x196-3479119r119">atanh</a></tt> </b></li>The following deﬁnition for the inverse hyperbolic tangent determines the
      range and branch cuts:
<div class="newer">
      <!--l. 5004--><p class="noindent" >WARNING! <i>The formula shown above for hyperbolic arc tangent is
      incorrect.</i> It is not a matter of incorrect branch cuts; it simply does not
      compute anything like a hyperbolic arc tangent. This unfortunate error in
      the ﬁrst edition was the result of mistranscribing a (correct) APL formula
      from Penﬁeld&#x2019;s paper <span class="cite">[<a 
href="clmli5.html#XAPL-BRANCH-CUTS">36</a>]</span>. The formula should have been transcribed as
      <div class="tabbing">
      <span class="math"> arctanh <i>z</i> = log <img 
src="clm14x.png" alt="(      ∘ --------2-)
 (1 + z)  1∕(1 − z )"  class="left" align="middle"></span>
      <br>
      <!--l. 5011--><p class="noindent" ></div>
      <!--l. 5011--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-114300012.5.3" id="x85-114300012.5.3"></a></span>
</div>
<div class="newer">
      <!--l. 5015--><p class="noindent" >A proposal was submitted to X3J13 in September 1989 to replace the
      formula <tt><a 
href="clmli7.html#x196-3479119r119">atanh</a></tt> with that recommended by Kahan <span class="cite">[<a 
href="clmli5.html#XKAHAN-COMPLEX-FNS">25</a>]</span>: <div class="tabbing">
      <span class="math"> arctanh <i>z</i> = <img 
src="clm15x.png" alt="(log(1 + z) − log (1 − z))"  class="left" align="middle"> 
               2                </span>
      <br>
                                                                          

                                                                          
      <!--l. 5019--><p class="noindent" ></div>
      <!--l. 5019--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-114400012.5.3" id="x85-114400012.5.3"></a></span>
      There is a good possibility that it will be adopted. If it is, the complete
      description of the branch cuts of <tt><a 
href="clmli7.html#x196-3479119r119">atanh</a></tt> will then be as follows.
      <!--l. 5023--><p class="noindent" >The branch cut for the inverse hyperbolic tangent function is in two pieces:
      one along the negative real axis to the left of <span class="math"> − 1</span> (inclusive), continuous
      with quadrant II, and one along the positive real axis to the right of 1
      (inclusive), continuous with quadrant IV. The points <span class="math"> − 1</span> and 1 are
      excluded from the domain. The range is that strip of the complex
      plane containing numbers whose imaginary part is between <span class="math"> − π∕2</span>
      and <span class="math">π∕2</span>. A number with imaginary part equal to <span class="math"> − π∕2</span> is in the
      range if and only if its real part is strictly positive; a number with
      imaginary part equal to <span class="math">π∕2</span> is in the range if and only if its real
      part is strictly negative. Thus the range of the inverse hyperbolic
      tangent function is <i>not</i> the same as that of the inverse hyperbolic sine
      function.
      </div></ul>
</div>
<!--l. 5040--><p class="indent" >   With these deﬁnitions, the following useful identities are obeyed throughout
the applicable portion of the complex domain, even on the branch cuts:
<div class="flushleft" 
>
<!--l. 5045--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" ><span class="math"> sin <i>i</i><i>z</i> = <i>i</i> sinh <i>z</i></span>  </td><td align="left" ><span class="math"> sinh <i>i</i><i>z</i> = <i>i</i> sin <i>z</i></span>       </td><td align="left" ><span class="math"> arctan <i>i</i><i>z</i> = <i>i</i> arctanh <i>z</i></span></td></tr><tr><td align="left" ><span class="math"> cos <i> i </i> <i> z </i> = cosh <i> z </i> </span>  </td> <td align="left" ><span class="math"> cosh <i> i </i> <i> z </i> = cos <i> z </i> </span> </td> <td align="left" ><span class="math"> arcsinh <i> i </i> <i> z </i> = <i> i </i> arcsin <i> z </i> </span></td>
</tr><tr><td align="left" ><span class="math"> tan <i>i</i><i>z</i> = <i>i</i> tanh <i>z</i></span> </td><td align="left" ><span class="math"> arcsin <i>i</i><i>z</i> = <i>i</i> arcsinh <i>z</i></span></td><td align="left" ><span class="math"> arctanh <i>i</i><i>z</i> = <i>i</i> arctan <i>z</i></span></td></tr></table>
</div></div>
<div class="new">
<!--l. 5054--><p class="indent" >   I thought it would be useful to provide some graphs illustrating the behavior
of the irrational and transcendental functions in the complex plane. It also
provides an opportunity to show oﬀ the Common Lisp code that was used to
generate them.
<!--l. 5059--><p class="indent" >   Imagine the complex plane to be decorated as follows. The real and imaginary
axes are painted with thick lines. Parallels from the axes on both sides at
distances of 1, 2, and 3 are painted with thin lines; these parallels are doubly
inﬁnite lines, as are the axes. Four annuli (rings) are painted in gradated shades of
                                                                          

                                                                          
gray. Ring 1, the inner ring, consists of points whose radial distances
from the origin lie in the range <span class="math">[1∕4, 1∕2]</span>; ring 2 is in the radial range
<span class="math">[3∕4, 1]</span>; ring 3, in the range <span class="math">[π∕2, 2]</span>; and ring 4, in the range <span class="math">[3,π]</span>. Ring <i>j</i> is
divided into <span class="math">2<sup>j+1</sup></span> equal sectors, with each sector painted a diﬀerent shade of
gray, darkening as one proceeds counterclockwise from the positive real
axis.
<!--l. 5072--><p class="indent" >   We can illustrate the behavior of a numerical function <span class="math"><i>f</i></span> by considering how it
maps the complex plane to itself. More speciﬁcally, consider each point <span class="math"><i>z</i></span> of the
decorated plane. We decorate a new plane by coloring the point <span class="math"><i>f</i>(<i>z</i>)</span> with the same
color that point <span class="math"><i>z</i></span> had in the original decorated plane. In other words, the newly
decorated plane illustrates how the <span class="math"><i>f</i></span> maps the axes, other horizontal and vertical
lines, and annuli.
<!--l. 5079--><p class="indent" >   In each ﬁgure we will show only a fragment of the complex plane, with the real
axis horizontal in the usual manner (<span class="math"> −∞</span> to the left, <span class="math"> + ∞</span> to the right) and the
imaginary axis vertical (<span class="math"> −∞<i>i</i></span> below, <span class="math"> + ∞<i>i</i></span> above). Each fragment shows a region
containing points whose real and imaginary parts are in the range <span class="math">[−4.1, 4.1]</span>. The
axes of the new plane are shown as very thin lines, with large tick marks
at integer coordinates and somewhat smaller tick marks at multiples of
<span class="math">π∕2</span>.
<!--l. 5087--><p class="indent" >   Figure <a 
href="#x85-11460011">12.1<!--tex4ht:ref: IDENTITY-PLOT --></a> shows the result of plotting the <tt><a 
href="clmli7.html#x196-3479468r468">identity</a></tt> function (quite
literally); the graph exhibits the decoration of the original plane.
<!--l. 5090--><p class="indent" >   Figures <a 
href="#x85-11460022">12.2<!--tex4ht:ref: SECOND-PLOT --></a> through <a 
href="#x85-114602020">12.20<!--tex4ht:ref: LAST-PLOT --></a> show the graphs for the functions <tt><a 
href="clmli7.html#x196-3479880r880">sqrt</a></tt>, <tt><a 
href="clmli7.html#x196-3479378r378">exp</a></tt>, <tt><a 
href="clmli7.html#x196-3479538r538">log</a></tt>,
<tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt>, <tt><a 
href="clmli7.html#x196-3479112r112">asin</a></tt>, <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt>, <tt><a 
href="clmli7.html#x196-3479075r75">acos</a></tt>, <tt><a 
href="clmli7.html#x196-3479938r938">tan</a></tt>, <tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt>, <tt><a 
href="clmli7.html#x196-3479864r864">sinh</a></tt>, <tt><a 
href="clmli7.html#x196-3479113r113">asinh</a></tt>, <tt><a 
href="clmli7.html#x196-3479290r290">cosh</a></tt>, <tt><a 
href="clmli7.html#x196-3479076r76">acosh</a></tt>, <tt><a 
href="clmli7.html#x196-3479939r939">tanh</a></tt>, and <tt><a 
href="clmli7.html#x196-3479119r119">atanh</a></tt>, and
as a bonus, the graphs for the functions <span class="math"><img 
src="clm16x.png" alt="√ ------
  1 − z2"  class="sqrt" ></span>, <span class="math"><img 
src="clm17x.png" alt="√ ------
  1 + z2"  class="sqrt" ></span>, <span class="math">(<i>z</i> − 1)∕(<i>z</i> + 1)</span>, and
<span class="math">(1 + <i>z</i>)∕(1 −<i>z</i>)</span>. All of these are related to the trigonometric functions in various
ways. For example, if <span class="math"><i>f</i>(<i>z</i>) = (<i>z</i> − 1)∕(<i>z</i> + 1)</span>, then <span class="math"> tanh <i>z</i> = <i>f</i>(<i>e</i><sup>2z</sup>)</span>, and if
<span class="math"><i>g</i>(<i>z</i>) = <img 
src="clm18x.png" alt="√ -----2
  1 − z"  class="sqrt" ></span>, then <span class="math"> cos <i>z</i> = <i>g</i>(sin <i>z</i>)</span>. It is instructive to examine the graph for
<span class="math"><img 
src="clm19x.png" alt="√ ------
  1 − z2"  class="sqrt" ></span> and try to visualize how it transforms the graph for <tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt> into the graph
for <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt>.
<!--l. 5100--><p class="indent" >   Each ﬁgure is accompanied by a commentary on what maps to what and other
interesting features. None of this material is terribly new; much of it may be found
in any good textbook on complex analysis. I believe that the particular form
in which the graphs are presented is novel, as well as the fact that the
graphs have been generated as PostScript <span class="cite">[<a 
href="clmli5.html#XADOBE-POSTSCRIPT">1</a>]</span> code by Common Lisp code.
This PostScript code was then fed directly to the typesetting equipment
that set the pages for this book. Samples of this PostScript code follow
the ﬁgures themselves, after which the code for the entire program is
presented.
                                                                          

                                                                          
<!--l. 5109--><p class="indent" >   In the commentaries that accompany the ﬁgures I sometimes speak of mapping
the points <span class="math"> ±∞</span> or <span class="math"> ±∞i</span>. When I say that function <span class="math">f</span> maps <span class="math"> + ∞</span> to a certain
point <span class="math">z</span>, I mean that <div class="tabbing">
<span class="math">z = lim <sub>x→+∞</sub>f(x + 0 i)</span>
   <br>
<!--l. 5114--><p class="noindent" ></div>
<!--l. 5114--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-114500012.5.3" id="x85-114500012.5.3"></a></span>
   Similarly, when I say that <span class="math">f</span> maps <span class="math"> −∞i</span> to <span class="math">z</span>, I mean that <div class="tabbing">
<span class="math">z = lim <sub>y→−∞</sub>f(0 + yi)</span>
   <br>
<!--l. 5119--><p class="noindent" ></div>
<!--l. 5119--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-114600012.5.3" id="x85-114600012.5.3"></a></span>
   In other words, I am considering a limit as one travels out along one of the
main axes. I also speak in a similar manner of mapping <i>to</i> one of these
inﬁnities.
</div>
                                                                          

                                                                          
   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-11460011"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.1:  </span><span  
class="content">Initial  Decoration  of  the  Complex  Plane  (Identity
Function)</span></div><!--tex4ht:label?: x85-11460011 -->
<!--l. 5144--><p class="noindent" ><img 
src="identity-plot.png" alt="PIC"  
><br 
class="newline" />This ﬁgure was produced in exactly the same manner as succeeding ﬁgures, simply by
plotting the function <tt><a 
href="clmli7.html#x196-3479468r468">identity</a></tt> instead of a numerical function. Thus the ﬁrst of these
ﬁgures was produced by the last function of the ﬁrst edition. I knew it would come in
handy someday!
                                                                          

                                                                          
   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5155--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-11460022"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.2: </span><span  
class="content">Illustration of the Range of the Square Root Function</span></div><!--tex4ht:label?: x85-11460022 -->
<!--l. 5158--><p class="noindent" ><img 
src="sqrt-plot.png" alt="PIC"  
><br 
class="newline" />The <tt><a 
href="clmli7.html#x196-3479880r880">sqrt</a></tt> function maps the complex plane into the right half of the plane by slitting it
along the negative real axis and then sweeping it around as if half-closing a folding fan.
The fan also shrinks, as if it were made of cotton and had gotten wetter at the
periphery than at the center. The positive real axis is mapped onto itself. The
negative real axis is mapped onto the positive imaginary axis (but if minus zero is
supported, then <span class="math"> −<i>x</i> + 0<i>i</i></span> is mapped onto the positive imaginary axis and <span class="math"> −<i>x</i> − 0<i>i</i></span>
onto the negative imaginary axis, assuming <span class="math"><i>x</i> &#x003E; 0</span>). The positive imaginary
axis is mapped onto the northeast diagonal, and the negative imaginary axis
onto the southeast diagonal. More generally, lines are mapped to rectangular
hyperbolas (or fragments thereof) centered on the origin; lines through the
origin are mapped to degenerate hyperbolas (perpendicular lines through the
origin).
                                                                          

                                                                          
<!--l. 5174--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5178--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-11460033"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.3: </span><span  
class="content">Illustration of the Range of the Exponential Function</span></div><!--tex4ht:label?: x85-11460033 -->
<!--l. 5180--><p class="noindent" ><img 
src="exp-plot.png" alt="PIC"  
><br 
class="newline" />The <tt><a 
href="clmli7.html#x196-3479378r378">exp</a></tt> function maps horizontal lines to radii and maps vertical lines to circles
centered at the origin. The origin is mapped to 1. (It is instructive to compare this graph
with those of other functions that map the origin to 1, for example <span class="math">(1 + <i>z</i>)∕(1 −<i>z</i>)</span>, <span class="math"> cos<i>z</i></span>,
and <span class="math"><img 
src="clm20x.png" alt="√1--−-z2-"  class="sqrt" ></span>.) The entire real axis is mapped to the positive real axis, with <span class="math"> −∞</span>
mapping to the origin and <span class="math"> + ∞</span> to itself. The imaginary axis is mapped to
the unit circle with inﬁnite multiplicity (period <span class="math">2π</span>); therefore the mapping of
the imaginary inﬁnities <span class="math"> ±∞<i>i</i></span> is indeterminate. It follows that the entire left
half-plane is mapped to the interior of the unit circle, and the right half-plane
is mapped to the exterior of the unit circle. A line at any angle other than
horizontal or vertical is mapped to a logarithmic spiral (but this is not illustrated
here).
                                                                          

                                                                          
<!--l. 5195--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5199--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-11460044"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.4:  </span><span  
class="content">Illustration  of  the  Range  of  the  Natural  Logarithm
Function</span></div><!--tex4ht:label?: x85-11460044 -->
<!--l. 5201--><p class="noindent" ><img 
src="log-plot.png" alt="PIC"  
><br 
class="newline" />The <tt><a 
href="clmli7.html#x196-3479538r538">log</a></tt> function, which is the inverse of <tt><a 
href="clmli7.html#x196-3479378r378">exp</a></tt>, naturally maps radial lines to horizontal
lines and circles centered at the origin to vertical lines. The interior of the unit circle is
thus mapped to the entire left half-plane, and the exterior of the unit circle is mapped to
the right half-plane. The positive real axis is mapped to the entire real axis, and the
negative real axis to a horizontal line of height <span class="math">π</span>. The positive and negative imaginary
axes are mapped to horizontal lines of height <span class="math"> ± π∕2</span>. The origin is mapped to
<span class="math"> −∞</span>.
                                                                          

                                                                          
<!--l. 5211--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5215--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-11460055"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.5: </span><span  
class="content">Illustration of the Range of the Function <span class="math">(<i>z</i>−1)∕(<i>z</i>+1)</span></span></div><!--tex4ht:label?: x85-11460055 -->
<!--l. 5217--><p class="noindent" ><img 
src="minus-over-plus-plot.png" alt="PIC"  
><br 
class="newline" />A line is a degenerate circle with inﬁnite radius; when I say “circles” here I also mean
lines. Then <span class="math">(<i>z</i> − 1)∕(<i>z</i> + 1)</span> maps circles into circles. All circles through <span class="math"> − 1</span> become lines;
all lines become circles through <span class="math">1</span>. The real axis is mapped onto itself: 1 to the origin,
the origin to <span class="math"> − 1</span>, <span class="math"> − 1</span> to inﬁnity, and inﬁnity to 1. The imaginary axis becomes the unit
circle; <i>i</i> is mapped to itself, as is <span class="math"> −<i>i</i></span>. Thus the entire right half-plane is mapped to the
interior of the unit circle, the unit circle interior to the left half-plane, the left
half-plane to the unit circle exterior, and the unit circle exterior to the right
half-plane. Imagine the complex plane to be a vast sea. The Colossus of Rhodes
straddles the origin, its left foot on <i>i</i> and its right foot on <span class="math"> −<i>i</i></span>. It bends down
and brieﬂy paddles water between its legs so furiously that the water directly
beneath is pushed out into the entire area behind it; much that was behind swirls
forward to either side; and all that was before is sucked in to lie between its
feet.
                                                                          

                                                                          
<!--l. 5236--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5240--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-11460066"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.6: </span><span  
class="content">Illustration of the Range of the Function <span class="math">(1+<i>z</i>)∕(1−<i>z</i>)</span></span></div><!--tex4ht:label?: x85-11460066 -->
<!--l. 5242--><p class="noindent" ><img 
src="plus-over-minus-plot.png" alt="PIC"  
><br 
class="newline" />The function <span class="math"><i>h</i>(<i>z</i>) = (1 + <i>z</i>)∕(1 −<i>z</i>)</span> is the inverse of <span class="math"><i>f</i>(<i>z</i>) = (<i>z</i> − 1)∕(<i>z</i> + 1)</span>; that is,
<span class="math"><i>h</i>(<i>f</i>(<i>z</i>)) = <i>f</i>(<i>h</i>(<i>z</i>)) = <i>z</i></span>. At ﬁrst glance, the graph of <span class="math"><i>h</i></span> appears to be that of <span class="math"><i>f</i></span> ﬂipped
left-to-right, or perhaps reﬂected in the origin, but careful consideration of the shaded
annuli reveals that this is not so; something more subtle is going on. Note that
<span class="math"><i>f</i>(<i>f</i>(<i>z</i>)) = <i>h</i>(<i>h</i>(<i>z</i>)) = <i>g</i>(<i>z</i>) = −1∕<i>z</i></span>. The functions <span class="math"><i>f</i></span>, <span class="math"><i>g</i></span>, <span class="math"><i>h</i></span>, and the identity function thus form
a group under composition, isomorphic to the group of the cyclic permutations of the
points <span class="math"> − 1</span>, <span class="math">0</span>, <span class="math">1</span>, and <span class="math">∞</span>, as indeed these functions accomplish the four possible cyclic
permutations on those points. This function group is a subset of the group of bilinear
transformations <span class="math">(<i>a</i><i>z</i> + <i>b</i>)∕(<i>c</i><i>z</i> + <i>d</i>)</span>, all of which are conformal (angle-preserving) and map
circles onto circles. Now, doesn&#x2019;t that tangle of circles through <span class="math"> − 1</span> look like something
the cat got into?
                                                                          

                                                                          
<!--l. 5261--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5265--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-11460077"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.7: </span><span  
class="content">Illustration of the Range of the Sine Function</span></div><!--tex4ht:label?: x85-11460077 -->
<!--l. 5267--><p class="noindent" ><img 
src="sin-plot.png" alt="PIC"  
><br 
class="newline" />We are used to seeing <tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt> looking like a wiggly ocean wave, graphed vertically as a
function of the real axis only. Here is a diﬀerent view. The entire real axis is mapped to
the segment <span class="math">[−1,1]</span> of the real axis with inﬁnite multiplicity (period <span class="math">2π</span>). The imaginary
axis is mapped to itself as if by <tt><a 
href="clmli7.html#x196-3479864r864">sinh</a></tt> considered as a real function. The origin is mapped
to itself. Horizontal lines are mapped to ellipses with foci at <span class="math"> ± 1</span> (note that two
horizontal lines equidistant from the real axis will map onto the same ellipse). Vertical
lines are mapped to hyperbolas with the same foci. There is a curious accident: the
ellipse for horizontal lines at distance <span class="math"> ± 1</span> from the real axis appears to intercept the
real axis at <span class="math"> ± π∕2 ≈±1.57…</span> but this is not so; the intercepts are actually at
<span class="math"> ± (<i>e</i> + 1∕<i>e</i>)∕2 ≈±1.54…</span>.
                                                                          

                                                                          
<!--l. 5281--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5285--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-11460088"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.8: </span><span  
class="content">Illustration of the Range of the Arc Sine Function</span></div><!--tex4ht:label?: x85-11460088 -->
<!--l. 5287--><p class="noindent" ><img 
src="asin-plot.png" alt="PIC"  
><br 
class="newline" />Just as <tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt> grabs horizontal lines and bends them into elliptical loops around the origin,
so its inverse <tt><a 
href="clmli7.html#x196-3479112r112">asin</a></tt> takes annuli and yanks them more or less horizontally straight.
Because sine is not injective, its inverse as a function cannot be surjective. This is just a
highfalutin way of saying that the range of the <tt><a 
href="clmli7.html#x196-3479112r112">asin</a></tt> function doesn&#x2019;t cover the
entire plane but only a strip <span class="math">π</span> wide; arc sine as a one-to-many relation would
cover the plane with an inﬁnite number of copies of this strip side by side,
looking for all the world like the tail of a peacock with an inﬁnite number of
feathers. The imaginary axis is mapped to itself as if by <tt><a 
href="clmli7.html#x196-3479113r113">asinh</a></tt> considered as a real
function. The real axis is mapped to a bent path, turning corners at <span class="math"> ± π∕2</span> (the
points to which <span class="math"> ± 1</span> are mapped); <span class="math"> + ∞</span> is mapped to <span class="math">π∕2 −∞<i>i</i></span>, and <span class="math"> −∞</span> to
<span class="math"> − π∕2 + ∞<i>i</i></span>.
                                                                          

                                                                          
<!--l. 5301--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5305--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-11460099"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.9: </span><span  
class="content">Illustration of the Range of the Cosine Function</span></div><!--tex4ht:label?: x85-11460099 -->
<!--l. 5307--><p class="noindent" ><img 
src="cos-plot.png" alt="PIC"  
><br 
class="newline" />We are used to seeing <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt> looking exactly like <tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt>, a wiggly ocean wave, only displaced.
Indeed the complex mapping of <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt> is also similar to that of <tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt>, with horizontal and
vertical lines mapping to the same ellipses and hyperbolas with foci at <span class="math"> ± 1</span>, although
mapping to them in a diﬀerent manner, to be sure. The entire real axis is again mapped
to the segment <span class="math">[−1,1]</span> of the real axis, but each half of the imaginary axis is
mapped to the real axis to the right of 1 (as if by <tt><a 
href="clmli7.html#x196-3479290r290">cosh</a></tt> considered as a real
function). Therefore <span class="math"> ±∞<i>i</i></span> both map to <span class="math"> + ∞</span>. The origin is mapped to 1. Whereas
<tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt> is an odd function, <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt> is an even function; as a result <i>two</i> points in each
annulus, one the negative of the other, are mapped to the same shaded point in
this graph; the shading shown here is taken from points in the original upper
half-plane.
                                                                          

                                                                          
<!--l. 5322--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5326--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114601010"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.10: </span><span  
class="content">Illustration of the Range of the Arc Cosine Function</span></div><!--tex4ht:label?: x85-114601010 -->
<!--l. 5328--><p class="noindent" ><img 
src="acos-plot.png" alt="PIC"  
><br 
class="newline" />The graph of <tt><a 
href="clmli7.html#x196-3479075r75">acos</a></tt> is very much like that of <tt><a 
href="clmli7.html#x196-3479112r112">asin</a></tt>. One might think that our nervous
peacock has shuﬄed half a step to the right, but the shading on the annuli shows that
we have instead caught the bird exactly in mid-ﬂight while doing a cartwheel. This is
easily understood if we recall that <span class="math"> arccos<i>z</i> = (π∕2) − arcsin<i>z</i></span>; negating <span class="math"> arcsin<i>z</i></span> rotates it
upside down, and adding the result to <span class="math">π∕2</span> translates it <span class="math">π∕2</span> to the right. The imaginary
axis is mapped upside down to the vertical line at <span class="math">π∕2</span>. The point <span class="math"> + 1</span> is mapped to the
origin, and <span class="math"> − 1</span> to <span class="math">π</span>. The image of the real axis is again cranky; <span class="math"> + ∞</span> is mapped to
<span class="math"> + ∞<i>i</i></span>, and <span class="math"> −∞</span> to <span class="math">π −∞<i>i</i></span>.
                                                                          

                                                                          
<!--l. 5341--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5345--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114601111"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.11: </span><span  
class="content">Illustration of the Range of the Tangent Function</span></div><!--tex4ht:label?: x85-114601111 -->
<!--l. 5347--><p class="noindent" ><img 
src="tan-plot.png" alt="PIC"  
><br 
class="newline" />The usual graph of <tt><a 
href="clmli7.html#x196-3479938r938">tan</a></tt> as a real function looks like an inﬁnite chorus line of disco
dancers, left hands pointed skyward and right hands to the ﬂoor. The <tt><a 
href="clmli7.html#x196-3479938r938">tan</a></tt> function is the
quotient of <tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt> and <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt> but it doesn&#x2019;t much look like either except for having period <span class="math">2π</span>.
This goes for the complex plane as well, although the swoopy loops produced
from the annulus between <span class="math">π∕2</span> and <span class="math">2</span> look vaguely like those from the graph of
<tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt> inside out. The real axis is mapped onto itself with inﬁnite multiplicity
(period <span class="math">2π</span>). The imaginary axis is mapped backwards onto <span class="math">[−<i>i</i>,<i>i</i>]</span>: <span class="math"> + ∞<i>i</i></span> is
mapped to <span class="math"> −<i>i</i></span> and <span class="math"> −∞<i>i</i></span> to <span class="math"> + <i>i</i></span>. Horizontal lines below or above the real axis
become circles surrounding <span class="math"> + <i>i</i></span> or <span class="math"> −<i>i</i></span>, respectively. Vertical lines become circular
arcs from <span class="math"> + <i>i</i></span> to <span class="math"> −<i>i</i></span>; two vertical lines separated by <span class="math">(2<i>k</i> + 1)π</span> for integer <span class="math"><i>k</i></span>
together become a complete circle. It seems that two arcs shown hit the real
axis at <span class="math"> ± π∕2 = ±1.57…</span> but that is a coincidence; they really hit the axis at
<span class="math"> ± tan1 = 1.55…</span>.
                                                                          

                                                                          
<!--l. 5366--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5370--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114601212"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.12: </span><span  
class="content">Illustration of the Range of the Arc Tangent Function</span></div><!--tex4ht:label?: x85-114601212 -->
<!--l. 5372--><p class="noindent" ><img 
src="xatan-plot.png" alt="PIC"  
><br 
class="newline" />All I can say is that this peacock is a horse of another color. At ﬁrst glance, the
axes seem to map in the same way as for <tt><a 
href="clmli7.html#x196-3479112r112">asin</a></tt> and <tt><a 
href="clmli7.html#x196-3479075r75">acos</a></tt>, but look again: this
time it&#x2019;s the imaginary axis doing weird things. All inﬁnities map multiply to
the points <span class="math">(2<i>k</i> + 1)π∕2</span>; within the strip of principal values we may say that
the real axis is mapped to the interval <span class="math">[−π∕2,+π∕2]</span> and therefore <span class="math"> −∞</span> is
mapped to <span class="math"> − π∕2</span> and <span class="math"> + ∞</span> to <span class="math"> + π∕2</span>. The point <span class="math"> + <i>i</i></span> is mapped to <span class="math"> + ∞<i>i</i></span>,
and <span class="math"> −<i>i</i></span> to <span class="math"> −∞<i>i</i></span>, and so the imaginary axis is mapped into three pieces: the
segment <span class="math">[−∞<i>i</i>,−<i>i</i>]</span> is mapped to <span class="math">[π∕2,π∕2 −∞<i>i</i>]</span>; the segment <span class="math">[−<i>i</i>,<i>i</i>]</span> is mapped
to the imaginary axis <span class="math">[−∞<i>i</i>,+∞<i>i</i>]</span>; and the segment <span class="math">[+<i>i</i>,+∞<i>i</i>]</span> is mapped to
<span class="math">[−π∕2 + ∞<i>i</i>,−π∕2]</span>.
                                                                          

                                                                          
<!--l. 5386--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5390--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114601313"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.13:  </span><span  
class="content">Illustration  of  the  Range  of  the  Hyperbolic  Sine
Function</span></div><!--tex4ht:label?: x85-114601313 -->
<!--l. 5392--><p class="noindent" ><img 
src="sinh-plot.png" alt="PIC"  
><br 
class="newline" />It would seem that the graph of <tt><a 
href="clmli7.html#x196-3479864r864">sinh</a></tt> is merely that of <tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt> rotated 90 degrees. If
that were so, then we would have <span class="math"> sinh<i>z</i> = <i>i</i>sin<i>z</i></span>. Careful inspection of the
shading, however, reveals that this is not quite the case; in both graphs the
lightest and darkest shades, which initially are adjacent to the positive real axis,
remain adjacent to the positive real axis in both cases. To derive the graph
of <tt><a 
href="clmli7.html#x196-3479864r864">sinh</a></tt> from <tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt> we must therefore ﬁrst rotate the complex plane by <span class="math"> − 90</span>
degrees, then apply <tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt>, then rotate the result by 90 degrees. In other words,
<span class="math"> sinh<i>z</i> = <i>i</i>sin(−<i>i</i>)<i>z</i></span>; consistently replacing <span class="math"><i>z</i></span> with <span class="math"><i>i</i><i>z</i></span> in this formula yields the familiar
identity <span class="math"> sinh<i>i</i><i>z</i> = <i>i</i>sin<i>z</i></span>.
                                                                          

                                                                          
<!--l. 5404--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5408--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114601414"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.14: </span><span  
class="content">Illustration of the Range of the Hyperbolic Arc Sine
Function</span></div><!--tex4ht:label?: x85-114601414 -->
<!--l. 5410--><p class="noindent" ><img 
src="asinh-plot.png" alt="PIC"  
><br 
class="newline" />The peacock sleeps. Because <span class="math"> arcsinh <i>i</i><i>z</i> = <i>i</i>arcsin<i>z</i></span>, the graph of <tt><a 
href="clmli7.html#x196-3479113r113">asinh</a></tt> is related to that
of <tt><a 
href="clmli7.html#x196-3479112r112">asin</a></tt> by pre- and post-rotations of the complex plane in the same way as for <tt><a 
href="clmli7.html#x196-3479864r864">sinh</a></tt> and
<tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt>.
                                                                          

                                                                          
<!--l. 5416--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5420--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114601515"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.15: </span><span  
class="content">Illustration of the Range of the Hyperbolic Cosine
Function</span></div><!--tex4ht:label?: x85-114601515 -->
<!--l. 5422--><p class="noindent" ><img 
src="cosh-plot.png" alt="PIC"  
><br 
class="newline" />The graph of <tt><a 
href="clmli7.html#x196-3479290r290">cosh</a></tt> does <i>not</i> look like that of <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt> rotated 90 degrees; instead it looks like
that of <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt> unrotated. That is because <span class="math"> cosh<i>i</i><i>z</i></span> is not equal to <span class="math"><i>i</i>cos<i>z</i></span>; rather,
<span class="math"> cosh<i>i</i><i>z</i> = cos<i>z</i></span>. Interpreted, that means that the shading is pre-rotated but there is no
post-rotation.
                                                                          

                                                                          
<!--l. 5430--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5434--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114601616"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.16: </span><span  
class="content">Illustration of the Range of the Hyperbolic Arc Cosine
Function</span></div><!--tex4ht:label?: x85-114601616 -->
<!--l. 5436--><p class="noindent" ><img 
src="acosh-plot.png" alt="PIC"  
><br 
class="newline" />Hmm—I&#x2019;d rather not say what happened to this peacock. This feather looks a bit
mangled. Actually it is all right—the principal value for <tt><a 
href="clmli7.html#x196-3479076r76">acosh</a></tt> is so chosen that its graph
does not look simply like a rotated version of the graph of <tt><a 
href="clmli7.html#x196-3479075r75">acos</a></tt>, but if all values were
shown, the two graphs would ﬁll the plane in repeating patterns related by a
rotation.
                                                                          

                                                                          
<!--l. 5444--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5448--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114601717"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.17: </span><span  
class="content">Illustration of the Range of the Hyperbolic Tangent
Function</span></div><!--tex4ht:label?: x85-114601717 -->
<!--l. 5450--><p class="noindent" ><img 
src="tanh-plot.png" alt="PIC"  
><br 
class="newline" />The diagram for <tt><a 
href="clmli7.html#x196-3479939r939">tanh</a></tt> is simply that of <tt><a 
href="clmli7.html#x196-3479938r938">tan</a></tt> turned on its ear: <span class="math"><i>i</i>tan<i>z</i> = tanh<i>i</i><i>z</i></span>. The
imaginary axis is mapped onto itself with inﬁnite multiplicity (period <span class="math">2π</span>), and the real
axis is mapped onto the segment <span class="math">[−1,+1]</span>: <span class="math"> + ∞</span> is mapped to <span class="math"> + 1</span>, and <span class="math"> −∞</span> to <span class="math"> − 1</span>.
Vertical lines to the left or right of the real axis are mapped to circles surrounding
<span class="math"> − 1</span> or <span class="math">1</span>, respectively. Horizontal lines are mapped to circular arcs anchored
at <span class="math"> − 1</span> and <span class="math"> + 1</span>; two horizontal lines separated by a distance <span class="math">(2<i>k</i> + 1)π</span> for
integer <span class="math"><i>k</i></span> are together mapped into a complete circle. How do we know these
really are circles? Well, <span class="math"> tanh<i>z</i> = ((exp2<i>z</i>) − 1)∕((exp2<i>z</i>) + 1)</span>, which is the
composition of the bilinear transform <span class="math">(<i>z</i> − 1)∕(<i>z</i> + 1)</span>, the exponential <span class="math"> exp<i>z</i></span>, and
the magniﬁcation <span class="math">2<i>z</i></span>. Magniﬁcation maps lines to lines of the same slope; the
exponential maps horizontal lines to circles and vertical lines to radial lines; and a
bilinear transform maps generalized circles (including lines) to generalized circles.
Q.E.D.
                                                                          

                                                                          
<!--l. 5469--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5473--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114601818"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.18:  </span><span  
class="content">Illustration  of  the  Range  of  the  Hyperbolic  Arc
Tangent Function</span></div><!--tex4ht:label?: x85-114601818 -->
<!--l. 5476--><p class="noindent" ><img 
src="really-good-atanh-plot.png" alt="PIC"  
><br 
class="newline" />A sleeping peacock of another color: <span class="math"> arctanh <i>i</i><i>z</i> = <i>i</i>arctan<i>z</i></span>.
                                                                          

                                                                          
<!--l. 5479--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5483--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114601919"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.19: </span><span  
class="content">Illustration of the Range of the Function <span class="math"><img 
src="clm21x.png" alt="  ------
√ 1 − z2"  class="sqrt" ></span></span></div><!--tex4ht:label?: x85-114601919 -->
<!--l. 5485--><p class="noindent" ><img 
src="sqrt-one-minus-sq-plot.png" alt="PIC"  
><br 
class="newline" />Here is a curious graph indeed for so simple a function! The origin is mapped to 1. The
real axis segment <span class="math">[0,1]</span> is mapped backwards (and non-linearly) into itself; the segment
<span class="math">[1,+∞]</span> is mapped non-linearly onto the positive imaginary axis. The negative real axis
is mapped to the same points as the positive real axis. Both halves of the imaginary axis
are mapped into <span class="math">[1,+∞]</span> on the real axis. Horizontal lines become vaguely vertical, and
vertical lines become vaguely horizontal. Circles centered at the origin are transformed
into Cassinian (half-)ovals; the unit circle is mapped to a (half-)lemniscate of Bernoulli.
The outermost annulus appears to have its <i>inner</i> edge at <span class="math">π</span> on the real axis
and its <i>outer</i> edge at 3 on the imaginary axis, but this is another accident;
the intercept on the real axis, for example, is not really at <span class="math">π ≈ 3.14…</span> but at
<span class="math"><img 
src="clm22x.png" alt="∘ ---------
  1 − (3i)2"  class="sqrt" > = <img 
src="clm23x.png" alt="√ ---
  10"  class="sqrt" > ≈ 3.16…</span>.
                                                                          

                                                                          
<!--l. 5501--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<!--l. 5505--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x85-114602020"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 12.20: </span><span  
class="content">Illustration of the Range of the Function <span class="math"><img 
src="clm24x.png" alt="  ------
√ 1 + z2"  class="sqrt" ></span></span></div><!--tex4ht:label?: x85-114602020 -->
<!--l. 5508--><p class="noindent" ><img 
src="sqrt-one-plus-sq-plot.png" alt="PIC"  
><br 
class="newline" />The graph of <span class="math"><i>q</i>(<i>z</i>) = <img 
src="clm25x.png" alt="√ ----2-
  1+ z"  class="sqrt" ></span> looks like that of <span class="math"><i>p</i>(<i>z</i>) = <img 
src="clm26x.png" alt="√ ----2-
  1− z"  class="sqrt" ></span> except for the shading.
You might not expect <span class="math"><i>p</i></span> and <span class="math"><i>q</i></span> to be related in the same way that <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt> and <tt><a 
href="clmli7.html#x196-3479290r290">cosh</a></tt> are,
but after a little reﬂection (or perhaps I should say, after turning it around in
one&#x2019;s mind) one can see that <span class="math"><i>q</i>(<i>i</i><i>z</i>) = <i>p</i>(<i>z</i>)</span>. This formula is indeed of exactly
the same form as <span class="math"> cosh<i>i</i><i>z</i> = cos<i>z</i></span>. The function <span class="math"><img 
src="clm27x.png" alt="√ -----2
  1 + z"  class="sqrt" ></span> maps both halves of
the real axis into <span class="math">[1,+∞]</span> on the real axis. The segments <span class="math">[0,<i>i</i>]</span> and <span class="math">[0,−<i>i</i>]</span> of
the imaginary axis are each mapped backwards onto segment <span class="math">[0,1]</span> of the real
axis; <span class="math">[<i>i</i>,+∞<i>i</i>]</span> and <span class="math">[−<i>,</i> −∞<i>i</i>]</span> are each mapped onto the positive imaginary axis
(but if minus zero is supported then opposite sides of the imaginary axis map
to opposite halves of the imaginary axis—for example, <span class="math">q(+0 + 2<i>i</i>) = <img 
src="clm28x.png" alt="√ --
  5"  class="sqrt" ><i>i</i></span> but
<span class="math">q(−0 + 2<i>i</i>) = −<img 
src="clm29x.png" alt="√ --
  5"  class="sqrt" ><i>i</i></span>).
                                                                          

                                                                          
<!--l. 5524--><p class="indent" >   </div><hr class="endfigure">
                                                                          

                                                                          
<div class="new">
<!--l. 5529--><p class="indent" >   Here is a sample of the PostScript code that generated ﬁgure <a 
href="#x85-11460011">12.1<!--tex4ht:ref: IDENTITY-PLOT --></a>, showing
the initial scaling, translation, and clipping parameters; the code for one sector of
the innermost annulus; and the code for the negative imaginary axis. Comment
lines indicate how path or boundary segments were generated separately and then
spliced (in order to allow for the places that a singularity might lurk, in which
case the generating code can “inch up” to the problematical argument
value).
<!--l. 5539--><p class="indent" >   The size of the entire PostScript ﬁle for the <tt><a 
href="clmli7.html#x196-3479468r468">identity</a></tt> function was about 68
kilobytes (2757 lines, including comments). The smallest ﬁles were the plots for
<tt><a 
href="clmli7.html#x196-3479118r118">atan</a></tt> and <tt><a 
href="clmli7.html#x196-3479119r119">atanh</a></tt>, about 65 kilobytes apiece; the largest were the plots for <tt><a 
href="clmli7.html#x196-3479861r861">sin</a></tt>, <tt><a 
href="clmli7.html#x196-3479289r289">cos</a></tt>,
<tt><a 
href="clmli7.html#x196-3479864r864">sinh</a></tt>, and <tt><a 
href="clmli7.html#x196-3479290r290">cosh</a></tt>, about 138 kilobytes apiece.
<div class="lisp">
<!--l. 5547--><p class="indent" >   <div class="tabbing">
   <br>                                    % PostScript ﬁle for plot of function IDENTITY<br>
% Plot is to ﬁt in a region 4.666666666666667 inches square<br>
%  showing axes extending 4.1 units from the origin.<br>                          <br>
40.97560975609756 40.97560975609756 scale<br>                    4.1 4.1 translate<br>
newpath<br>                                                    -4.1 -4.1 moveto<br>
  4.1 -4.1 lineto<br>                                                4.1 4.1 lineto<br>
  -4.1 4.1 lineto<br>                                                   closepath<br>
clip<br>                                     % Moby grid for function IDENTITY<br>
% Annulus 0.25 0.5 4 0.97 0.45<br>      % Sector from 4.7124 to 6.2832 (quadrant 3)<br>
newpath<br>                                                   0.0 -0.25 moveto<br>
  0.0 -0.375 lineto<br>                                            %middle radial<br>
  0.0 -0.375 lineto<br>                                             0.0 -0.5 lineto<br>
  %end radial<br>                                                 0.0 -0.5 lineto<br>
  0.092 -0.4915 lineto<br>                                    0.1843 -0.4648 lineto<br>
  0.273 -0.4189 lineto<br>                                    0.3536 -0.3536 lineto<br>
  %middle circumferential<br>                               0.3536 -0.3536 lineto<br>
  0.413 -0.2818 lineto<br>                                    0.4594 -0.1974 lineto<br>
  0.4894 -0.1024 lineto<br>                                         0.5 0.0 lineto<br>
  %end circumferential<br>                                         0.5 0.0 lineto<br>
  0.375 0.0 lineto<br>                                            %middle radial<br>
  0.375 0.0 lineto<br>                                             0.25 0.0 lineto<br>
  %end radial<br>                                                0.25 0.0 lineto<br>
                                                                          

                                                                          
  0.2297 -0.0987 lineto<br>                                   0.1768 -0.1768 lineto<br>
  %middle circumferential<br>                               0.1768 -0.1768 lineto<br>
  0.0922 -0.2324 lineto<br>                                        0.0 -0.25 lineto<br>
  %end circumferential<br>                                            closepath<br>
currentgray   0.45 setgray   ﬁll   setgray<br>
<!--l. 5600--><p class="noindent" ></div>
<!--l. 5600--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-114700012.5.3" id="x85-114700012.5.3"></a></span>
<!--l. 5600--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-114800012.5.3" id="x85-114800012.5.3"></a></span>
</div>
<!--l. 5601--><p class="indent" >   [2598 lines omitted] <div class="lisp"><div class="tabbing">
% Vertical line from (0.0, -0.5) to (0.0, 0.0)
   <br>                                  newpath<br>                                    0.0 -0.5 moveto<br>
  0.0 0.0 lineto<br>                       0.05 setlinewidth   1 setlinecap  stroke<br>
% Vertical line from (0.0, -0.5) to (0.0, -1.0)<br>     newpath<br>       0.0 -0.5 moveto<br>
  0.0 -1.0 lineto<br>                       0.05 setlinewidth   1 setlinecap  stroke<br>
% Vertical line from (0.0, -2.0) to (0.0, -1.0)<br>     newpath<br>       0.0 -2.0 moveto<br>
  0.0 -1.0 lineto<br>                       0.05 setlinewidth   1 setlinecap  stroke<br>
% Vertical line from (0.0, -2.0) to (0.0, -1.1579208923731617E77)<br>        newpath<br>
  0.0 -2.0 moveto<br>        0.0 -6.3553 lineto<br>        0.0 -6.378103166302659 lineto<br>
  0.0 -6.378103166302659 lineto<br>                  0.0 -6.378103166302659 lineto<br>
0.05 setlinewidth 1 setlinecap stroke<br>
<!--l. 5626--><p class="noindent" ></div>
<!--l. 5626--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-114900012.5.3" id="x85-114900012.5.3"></a></span>
<!--l. 5626--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-115000012.5.3" id="x85-115000012.5.3"></a></span>
</div>
<!--l. 5627--><p class="indent" >   [84 lines omitted] <div class="lisp"><div class="tabbing">
% End of PostScript ﬁle for plot of function IDENTITY
   <br>
<!--l. 5630--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 5630--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-115100012.5.3" id="x85-115100012.5.3"></a></span>
<!--l. 5630--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-115200012.5.3" id="x85-115200012.5.3"></a></span>
</div>
<!--l. 5633--><p class="indent" >   Here is the program that generated the PostScript code for the graphs shown
in ﬁgures <a 
href="#x85-11460011">12.1<!--tex4ht:ref: IDENTITY-PLOT --></a> through <a 
href="#x85-114602020">12.20<!--tex4ht:ref: LAST-PLOT --></a>. It contains a mixture of fairly general mechanisms
and <i>ad hoc</i> kludges for plotting functions of a single complex argument while
gracefully handling extremely large and small values, branch cuts, singularities,
and periodic behavior. The aim was to provide a simple user interface that
would not require the caller to provide special advice for each function to
be plotted. The ﬁle for ﬁgure <a 
href="#x85-11460011">12.1<!--tex4ht:ref: IDENTITY-PLOT --></a>, for example, was generated by the
call <tt>(picture &#x2019;identity)</tt>, which resulted in the writing of a ﬁle named
<tt>identity-plot.ps</tt>.
<!--l. 5646--><p class="indent" >   The program assumes that any periodic behavior will have a period that is a
multiple of <span class="math">2π</span>; that branch cuts will fall along the real or imaginary axis;
and that singularities or very large or small values will occur only at the
origin, at <span class="math"> ± 1</span> or <span class="math"> ±<i>i</i></span>, or on the boundaries of the annuli (particularly
those with radius <span class="math">π∕2</span> or <span class="math">π</span>). The central function is <tt>parametric-path</tt>,
which accepts four arguments: two real numbers that are the endpoints
of an interval of real numbers, a function that maps this interval into
a path in the complex plane, and the function to be plotted; the task
of <tt>parametric-path</tt> is to generate PostScript code (a series of <tt>lineto</tt>
operations) that will plot an approximation to the image of the parametric
path as transformed by the function to be plotted. Each of the functions
<tt>hline</tt>, <tt>vline</tt>, <tt>-hline</tt>, <tt>-vline</tt>, <tt>radial</tt>, and <tt>circumferential</tt> takes
appropriate parameters and returns a function suitable for use as the third
argument to <tt>parametric-path</tt>. There is some code that defends against
errors (by using <tt><a 
href="clmli7.html#x196-3479470r470">ignore-errors</a></tt>) and against certain peculiarities of IEEE
ﬂoating-point arithmetic (the code that checks for not-a-number (NaN)
results).
<!--l. 5666--><p class="indent" >   The program is oﬀered here without further comment or apology.
<div class="lisp">
<!--l. 5672--><p class="indent" >   <div class="tabbing">
   <br>                                                       (defparameter units-to-show 4.1)<br>
(defparameter text-width-in-picas 28.0)<br> (defparameter device-pixels-per-inch 300)<br>
                                                                          

                                                                          
(defparameter pixels-per-unit<br>                    (* (/ (/ text-width-in-picas 6)<br>
        (* units-to-show 2))<br>                          device-pixels-per-inch))<br>
<br>                      (defparameter big (sqrt (sqrt most-positive-single-ﬂoat)))<br>
(defparameter tiny (sqrt (sqrt least-positive-single-ﬂoat)))<br>
<br>                                      (defparameter path-really-losing 1000.0)<br>
(defparameter path-outer-limit (* units-to-show (sqrt 2) 1.1))<br>
(defparameter path-minimal-delta (/ 10 pixels-per-unit))<br>
(defparameter path-outer-delta (* path-outer-limit 0.3))<br>
(defparameter path-relative-closeness 0.00001)<br>
(defparameter back-oﬀ-delta 0.0005)<br>
<!--l. 5691--><p class="noindent" ></div>
<!--l. 5691--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-115300012.5.3" id="x85-115300012.5.3"></a></span>
<!--l. 5691--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-115400012.5.3" id="x85-115400012.5.3"></a></span>
</div>
<!--l. 5692--><p class="indent" >
                                                                          

                                                                          
<div class="lisp">
<!--l. 5693--><p class="indent" >   <div class="tabbing">
(defun comment-line (stream &#x0026;rest stuﬀ)
   <br>              (format stream &#x0022;~%% &#x0022;)<br>              (apply #&#x2019;format stream stuﬀ)<br>
  (format t &#x0022;~%% &#x0022;)<br>                                (apply #&#x2019;format t stuﬀ))<br>
<br>                              (defun parametric-path (from to paramfn plotfn)<br>
  (assert (and (plusp from) (plusp to)))<br>  (ﬂet ((domainval (x) (funcall paramfn x))<br>
         (rangeval (x) (funcall plotfn (funcall paramfn x)))<br>
         (losing (x) (or (null x)<br>                         (/= (realpart x) (realpart x))  ;NaN?<br>
                         (/= (imagpart x) (imagpart x))  ;NaN?<br>
                         (&#x003E; (abs (realpart x)) path-really-losing)<br>
                         (&#x003E; (abs (imagpart x)) path-really-losing))))<br>
    (when (&#x003E; to 1000.0)<br>                            (let ((f0 (rangeval from))<br>
            (f1 (rangeval (+ from 1)))<br>            (f2 (rangeval (+ from (* 2 pi))))<br>
            (f3 (rangeval (+ from 1 (* 2 pi))))<br>            (f4 (rangeval (+ from (* 4 pi)))))<br>
        (ﬂet ((close (x y)<br>                 (or (&#x003C; (careful-abs (- x y)) path-minimal-delta)<br>
                     (&#x003C; (careful-abs (- x y))<br>                        (* (+ (careful-abs x) (careful-abs y))<br>
                           path-relative-closeness)))))<br>
          (when (and (close f0 f2)<br>                             (close f2 f4)<br>
                     (close f1 f3)<br>                     (or (and (close f0 f1)<br>
                              (close f2 f3))<br>                         (and (not (close f0 f1))<br>
                              (not (close f2 f3)))))<br>
            (format t &#x0022;~&#x0026;Periodicity detected.&#x0022;)<br>
            (setq to (+ from (* (signum (- to from)) 2 pi)))))))<br>
     (let ((fromrange (ignore-errors (rangeval from)))<br>
          (torange (ignore-errors (rangeval to))))<br>        (if (losing fromrange)<br>
          (if (losing torange)<br>                                           &#x2019;()<br>
              (parametric-path (back-oﬀ from to) to paramfn plotfn))<br>
          (if (losing torange)<br>              (parametric-path from (back-oﬀ to from) paramfn plotfn)<br>
              (expand-path (reﬁne-path (list from to) #&#x2019;rangeval)<br>
                           #&#x2019;rangeval))))))<br>
<!--l. 5739--><p class="noindent" ></div>
<!--l. 5739--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-115500012.5.3" id="x85-115500012.5.3"></a></span>
                                                                          

                                                                          
<!--l. 5739--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-115600012.5.3" id="x85-115600012.5.3"></a></span>
</div>
<!--l. 5740--><p class="indent" >
                                                                          

                                                                          
<div class="lisp">
<!--l. 5741--><p class="indent" >   <div class="tabbing">
(defun back-oﬀ (point other)
   <br>         (if (or (&#x003E; point 10.0) (&#x003C; point 0.1))<br>             (let ((sp (sqrt point)))<br>
        (if (or (&#x003E; point sp other) (&#x003C; point sp other))<br>
            sp<br>                                        (* sp (sqrt other))))<br>
      (+ point (* (signum (- other point)) back-oﬀ-delta))))<br>                   <br>
(defun careful-abs (z)<br>                           (cond ((or (&#x003E; (realpart z) big)<br>
             (&#x003C; (realpart z) (- big))<br>                   (&#x003E; (imagpart z) big)<br>
             (&#x003C; (imagpart z) (- big)))<br>                                 big)<br>
        ((complexp z) (abs z))<br>           ((minusp z) (- z))<br>           (t z)))<br>
<br>
<!--l. 5759--><p class="noindent" ></div>
<!--l. 5759--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-115700012.5.3" id="x85-115700012.5.3"></a></span>
<!--l. 5759--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-115800012.5.3" id="x85-115800012.5.3"></a></span>
</div>
<div class="lisp">
<!--l. 5760--><p class="indent" >   <div class="tabbing">
(defparameter max-reﬁnements 5000)
   <br>                      <br>                      (defun reﬁne-path (original-path rangevalfn)<br>
  (ﬂet ((rangeval (x) (funcall rangevalfn x)))<br>         (let ((path original-path))<br>
      (do ((j 0 (+ j 1)))<br>                                 ((null (rest path)))<br>
        (when (zerop (mod (+ j 1) max-reﬁnements))<br>
              (break &#x0022;Runaway path&#x0022;))<br>             (let* ((from (ﬁrst path))<br>
               (to (second path))<br>               (fromrange (rangeval from))<br>
               (torange (rangeval to))<br>               (dist (careful-abs (- torange fromrange)))<br>
               (mid (* (sqrt from) (sqrt to)))<br>               (midrange (rangeval mid)))<br>
          (cond ((or (and (far-out fromrange) (far-out torange))<br>
                     (and (&#x003C; dist path-minimal-delta)<br>
                          (&#x003C; (abs (- midrange fromrange))<br>
                             path-minimal-delta)<br>
                          ;; Next test is intentionally asymmetric to<br>
                          ;;  avoid problems with periodic functions.<br>
                                                                          

                                                                          
                          (&#x003C; (abs (- (rangeval (/ (+ to (* from 1.5))<br>
                                                  2.5))<br>
                                     fromrange))<br>
                             path-minimal-delta)))<br>
                 (pop path))<br>                   ((= mid from) (pop path))<br>
                ((= mid to) (pop path))<br>                (t (setf (rest path) (cons mid (rest path)))))))))<br>
  original-path)<br>             <br>                  (defun expand-path (path rangevalfn)<br>
  (ﬂet ((rangeval (x) (funcall rangevalfn x)))<br>    (let ((ﬁnal-path (list (rangeval (ﬁrst path)))))<br>
      (do ((p (rest path) (cdr p)))<br>                                  ((null p)<br>
           (unless (rest ﬁnal-path)<br>                (break &#x0022;Singleton path&#x0022;))<br>
           (reverse ﬁnal-path))<br>                  (let ((v (rangeval (car p))))<br>
          (cond ((and (rest ﬁnal-path)<br>                      (not (far-out v))<br>
                      (not (far-out (ﬁrst ﬁnal-path)))<br>
                      (between v (ﬁrst ﬁnal-path)<br>
                                 (second ﬁnal-path)))<br>
                 (setf (ﬁrst ﬁnal-path) v))<br>                ((null (rest p))   ;Mustn&#x2019;t omit last point<br>
                 (push v ﬁnal-path))<br>                ((&#x003C; (abs (- v (ﬁrst ﬁnal-path))) path-minimal-delta))<br>
                ((far-out v)<br>                 (unless (and (far-out (ﬁrst ﬁnal-path))<br>
                              (&#x003C; (abs (- v (ﬁrst ﬁnal-path)))<br>
                                 path-outer-delta))<br>
                   (push (* 1.01 path-outer-limit (signum v))<br>
                         ﬁnal-path)))<br>                (t (push v ﬁnal-path))))))))<br>
<br>                                                          (defun far-out (x)<br>
  (&#x003E; (careful-abs x) path-outer-limit))<br>                                       <br>
(defparameter between-tolerance 0.000001)<br>                                   <br>
(defun between (p q r)<br>                 (let ((px (realpart p)) (py (imagpart p))<br>
        (qx (realpart q)) (qy (imagpart q))<br>        (rx (realpart r)) (ry (imagpart r)))<br>
    (and (or (&#x003C;= px qx rx) (&#x003E;= px qx rx))<br>         (or (&#x003C;= py qy ry) (&#x003E;= py qy ry))<br>
         (&#x003C; (abs (- (* (- qx px) (- ry qy))<br>                    (* (- rx qx) (- qy py))))<br>
            between-tolerance))))<br>
<!--l. 5833--><p class="noindent" ></div>
<!--l. 5833--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-115900012.5.3" id="x85-115900012.5.3"></a></span>
<!--l. 5833--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-116000012.5.3" id="x85-116000012.5.3"></a></span>
</div>
<!--l. 5834--><p class="indent" >
                                                                          

                                                                          
<div class="lisp">
<!--l. 5835--><p class="indent" >   <div class="tabbing">
(defun circle (radius)
   <br>                                              #&#x2019;(lambda (angle) (* radius (cis angle))))<br>
<br>                                                         (defun hline (imag)<br>
  #&#x2019;(lambda (real) (complex real imag)))<br>                                    <br>
(defun vline (real)<br>                     #&#x2019;(lambda (imag) (complex real imag)))<br>
<br>                                                        (defun -hline (imag)<br>
  #&#x2019;(lambda (real) (complex (- real) imag)))<br>                                 <br>
(defun -vline (real)<br>                 #&#x2019;(lambda (imag) (complex real (- imag))))<br>
<br>                                                 (defun radial (phi quadrant)<br>
  #&#x2019;(lambda (rho) (repair-quadrant (* rho (cis phi)) quadrant)))<br>
<br>                                        (defun circumferential (rho quadrant)<br>
  #&#x2019;(lambda (phi) (repair-quadrant (* rho (cis phi)) quadrant)))<br>               <br>
;;; Quadrant is 0, 1, 2, or 3, meaning I, II, III, or IV.<br>                          <br>
(defun repair-quadrant (z quadrant)<br>      (complex (* (+ (abs (realpart z)) tiny)<br>
              (case quadrant (0 1.0) (1 -1.0) (2 -1.0) (3 1.0)))<br>
           (* (+ (abs (imagpart z)) tiny)<br>
              (case quadrant (0 1.0) (1 1.0) (2 -1.0) (3 -1.0)))))<br>              <br>
(defun clamp-real (x)<br>     (if (far-out x)<br>         (* (signum x) path-outer-limit)<br>
      (round-real x)))<br>                                                     <br>
(defun round-real (x)<br>                        (/ (round (* x 10000.0)) 10000.0))<br>
<br>                                                      (defun round-point (z)<br>
  (complex (round-real (realpart z)) (round-real (imagpart z))))<br>                <br>
(defparameter hiringshade 0.97)<br>                (defparameter loringshade 0.45)<br>
<br>                                               (defparameter ticklength 0.12)<br>
(defparameter smallticklength 0.09)<br>
<!--l. 5881--><p class="noindent" ></div>
<!--l. 5881--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-116100012.5.3" id="x85-116100012.5.3"></a></span>
<!--l. 5881--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-116200012.5.3" id="x85-116200012.5.3"></a></span>
</div>
<!--l. 5882--><p class="indent" >
                                                                          

                                                                          
<div class="lisp">
<!--l. 5883--><p class="indent" >   <div class="tabbing">
;;; This determines the pattern of lines and annuli to be drawn.
   <br>                                    (defun moby-grid (&#x0026;optional (fn &#x2019;sqrt) (stream t))<br>
  (comment-line stream &#x0022;Moby grid for function ~S&#x0022; fn)<br>
  (shaded-annulus 0.25 0.5 4 hiringshade loringshade fn stream)<br>
  (shaded-annulus 0.75 1.0 8 hiringshade loringshade fn stream)<br>
  (shaded-annulus (/ pi 2) 2.0 16 hiringshade loringshade fn stream)<br>
  (shaded-annulus 3 pi 32 hiringshade loringshade fn stream)<br>
  (moby-lines :horizontal 1.0 fn stream)<br>   (moby-lines :horizontal -1.0 fn stream)<br>
  (moby-lines :vertical 1.0 fn stream)<br>       (moby-lines :vertical -1.0 fn stream)<br>
  (let ((tickline 0.015)<br>                                       (axisline 0.008))<br>
    (ﬂet ((tick (n) (straight-line (complex n ticklength)<br>
                                    (complex n (- ticklength))<br>
                                    tickline<br>
                                    stream))<br>
           (smalltick (n) (straight-line (complex n smallticklength)<br>
                                         (complex n (- smallticklength))<br>
                                         tickline<br>
                                         stream)))<br>
      (comment-line stream &#x0022;Real axis&#x0022;)<br>      (straight-line #c(-5 0) #c(5 0) axisline stream)<br>
      (dotimes (j (ﬂoor units-to-show))<br>        (let ((q (+ j 1))) (tick q) (tick (- q))))<br>
      (dotimes (j (ﬂoor units-to-show (/ pi 2)))<br>        (let ((q (* (/ pi 2) (+ j 1))))<br>
          (smalltick q)<br>                                  (smalltick (- q)))))<br>
    (ﬂet ((tick (n) (straight-line (complex ticklength n)<br>
                                    (complex (- ticklength) n)<br>
                                    tickline<br>
                                    stream))<br>
           (smalltick (n) (straight-line (complex smallticklength n)<br>
                                         (complex (- smallticklength) n)<br>
                                         tickline<br>
                                         stream)))<br>
      (comment-line stream &#x0022;Imaginary axis&#x0022;)<br>      (straight-line #c(0 -5) #c(0 5) axisline stream)<br>
      (dotimes (j (ﬂoor units-to-show))<br>        (let ((q (+ j 1))) (tick q) (tick (- q))))<br>
      (dotimes (j (ﬂoor units-to-show (/ pi 2)))<br>        (let ((q (* (/ pi 2) (+ j 1))))<br>
          (smalltick q)<br>                                (smalltick (- q)))))))<br>
<!--l. 5929--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 5929--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-116300012.5.3" id="x85-116300012.5.3"></a></span>
<!--l. 5929--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-116400012.5.3" id="x85-116400012.5.3"></a></span>
</div>
<!--l. 5930--><p class="indent" >
                                                                          

                                                                          
<div class="lisp">
<!--l. 5931--><p class="indent" >   <div class="tabbing">
(defun straight-line (from to wid stream)
   <br>
  (format stream<br>           &#x0022;~%newpath  ~S ~S moveto  ~S ~S lineto  ~S ~<br>
           setlinewidth  1  setlinecap  stroke&#x0022;<br>              (realpart from)<br>
          (imagpart from)<br>                                    (realpart to)<br>
          (imagpart to)<br>                                             wid))<br>
<br>
<!--l. 5941--><p class="noindent" ></div>
<!--l. 5941--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-116500012.5.3" id="x85-116500012.5.3"></a></span>
<!--l. 5941--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-116600012.5.3" id="x85-116600012.5.3"></a></span>
</div>
<div class="lisp">
<!--l. 5942--><p class="indent" >   <div class="tabbing">
;;; This function draws the lines for the pattern.
   <br>                                 (defun moby-lines (orientation signum plotfn stream)<br>
  (let ((paramfn (ecase orientation<br>                   (:horizontal (if (&#x003C; signum 0) #&#x2019;-hline #&#x2019;hline))<br>
                   (:vertical (if (&#x003C; signum 0) #&#x2019;-vline #&#x2019;vline)))))<br>
    (ﬂet ((foo (from to other wid)<br>                          (ecase orientation<br>
               (:horizontal<br>                          (comment-line stream<br>
                              &#x0022;Horizontal line from (~S, ~S) to (~S, ~S)&#x0022;<br>
                              (round-real (* signum from))<br>
                              (round-real other)<br>
                              (round-real (* signum to))<br>
                              (round-real other)))<br>
               (:vertical<br>                             (comment-line stream<br>
                              &#x0022;Vertical line from (~S, ~S) to (~S, ~S)&#x0022;<br>
                              (round-real other)<br>
                              (round-real (* signum from))<br>
                              (round-real other)<br>
                              (round-real (* signum to)))))<br>
             (postscript-path<br>                                      stream<br>
                                                                          

                                                                          
               (parametric-path from<br>                                 to<br>
                                (funcall paramfn other)<br>
                                plotfn))<br>             (postscript-penstroke stream wid)))<br>
      (let* ((thick 0.05)<br>                                        (thin 0.02))<br>
        ;; Main axis<br>                                  (foo 0.5 tiny 0.0 thick)<br>
        (foo 0.5 1.0 0.0 thick)<br>                          (foo 2.0 1.0 0.0 thick)<br>
        (foo 2.0 big 0.0 thick)<br>                         ;; Parallels at 1 and -1<br>
        (foo 2.0 tiny 1.0 thin)<br>                          (foo 2.0 big 1.0 thin)<br>
        (foo 2.0 tiny -1.0 thin)<br>                         (foo 2.0 big -1.0 thin)<br>
        ;; Parallels at 2, 3, -2, -3<br>                       (foo tiny big 2.0 thin)<br>
        (foo tiny big -2.0 thin)<br>                        (foo tiny big 3.0 thin)<br>
        (foo tiny big -3.0 thin)))))<br>                                          <br>
(defun splice (p q)<br>                                      (let ((v (car (last p)))<br>
        (w (ﬁrst q)))<br>                                       (and (far-out v)<br>
         (far-out w)<br>                     (&#x003E;= (abs (- v w)) path-outer-delta)<br>
         ;; Two far-apart far-out points.  Try to walk around<br>
         ;;  outside the perimeter, in the shorter direction.<br>
         (let* ((pdiﬀ (phase (/ v w)))<br>                (npoints (ﬂoor (abs pdiﬀ) (asin .2)))<br>
                (delta (/ pdiﬀ (+ npoints 1)))<br>                (incr (cis delta)))<br>
           (do ((j 0 (+ j 1))<br>                (p (list w &#x0022;end splice&#x0022;) (cons (* (car p) incr) p)))<br>
               ((= j npoints) (cons &#x0022;start splice&#x0022; p)))))))<br>                    <br>
<!--l. 6004--><p class="noindent" ></div>
<!--l. 6004--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-116700012.5.3" id="x85-116700012.5.3"></a></span>
<!--l. 6004--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-116800012.5.3" id="x85-116800012.5.3"></a></span>
</div>
<div class="lisp">
<!--l. 6005--><p class="indent" >   <div class="tabbing">
;;; This function draws the annuli for the pattern.
   <br>     (defun shaded-annulus (inner outer sectors ﬁrstshade lastshade fn stream)<br>
  (assert (zerop (mod sectors 4)))<br>  (comment-line stream &#x0022;Annulus ~S ~S ~S ~S ~S&#x0022;<br>
                (round-real inner) (round-real outer)<br>
                sectors ﬁrstshade lastshade)<br>             (dotimes (jj sectors)<br>
    (let ((j (- sectors jj 1)))<br>       (let* ((lophase (+ tiny (* 2 pi (/ j sectors))))<br>
             (hiphase (* 2 pi (/ (+ j 1) sectors)))<br>
             (midphase (/ (+ lophase hiphase) 2.0))<br>
                                                                          

                                                                          
             (midradius (/ (+ inner outer) 2.0))<br>
             (quadrant (ﬂoor (* j 4) sectors)))<br>        (comment-line stream &#x0022;Sector from ~S to ~S (quadrant ~S)&#x0022;<br>
                      (round-real lophase)<br>                      (round-real hiphase)<br>
                      quadrant)<br>        (let ((p0 (reverse (parametric-path midradius<br>
                                            inner<br>
                                            (radial lophase quadrant)<br>
                                            fn)))<br>
              (p1 (parametric-path midradius<br>                                   outer<br>
                                   (radial lophase quadrant)<br>
                                   fn))<br>              (p2 (reverse (parametric-path midphase<br>
                                            lophase<br>
                                            (circumferential outer<br>
                                                             quadrant)<br>
                                            fn)))<br>
              (p3 (parametric-path midphase<br>                                   hiphase<br>
                                   (circumferential outer quadrant)<br>
                                   fn))<br>              (p4 (reverse (parametric-path midradius<br>
                                            outer<br>
                                            (radial hiphase quadrant)<br>
                                            fn)))<br>
              (p5 (parametric-path midradius<br>                                   inner<br>
                                   (radial hiphase quadrant)<br>
                                   fn))<br>              (p6 (reverse (parametric-path midphase<br>
                                            hiphase<br>
                                            (circumferential inner<br>
                                                             quadrant)<br>
                                            fn)))<br>
              (p7 (parametric-path midphase<br>                                   lophase<br>
                                   (circumferential inner quadrant)<br>
                                   fn)))<br>          (postscript-closed-path stream<br>
            (append<br>                    p0 (splice p0 p1) &#x2019;(&#x0022;middle radial&#x0022;)<br>
              p1 (splice p1 p2) &#x2019;(&#x0022;end radial&#x0022;)<br>              p2 (splice p2 p3) &#x2019;(&#x0022;middle circumferential&#x0022;)<br>
              p3 (splice p3 p4) &#x2019;(&#x0022;end circumferential&#x0022;)<br>
              p4 (splice p4 p5) &#x2019;(&#x0022;middle radial&#x0022;)<br>
              p5 (splice p5 p6) &#x2019;(&#x0022;end radial&#x0022;)<br>              p6 (splice p6 p7) &#x2019;(&#x0022;middle circumferential&#x0022;)<br>
              p7 (splice p7 p0) &#x2019;(&#x0022;end circumferential&#x0022;)<br>                  )))<br>
<!--l. 6068--><p class="noindent" ></div>
<!--l. 6068--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-116900012.5.3" id="x85-116900012.5.3"></a></span>
                                                                          

                                                                          
<!--l. 6068--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-117000012.5.3" id="x85-117000012.5.3"></a></span>
</div>
<!--l. 6069--><p class="indent" >
                                                                          

                                                                          
<div class="lisp">
<!--l. 6070--><p class="indent" >   <div class="tabbing">
        (postscript-shade stream
   <br>                                       (/ (+ (* ﬁrstshade (- (- sectors 1) j))<br>
                                (* lastshade j))<br>
                             (- sectors 1)))))))<br>
<br>                                     (defun postscript-penstroke (stream wid)<br>
  (format stream &#x0022;~%~S setlinewidth   1 setlinecap  stroke&#x0022;<br>           wid))<br>
<br>                                       (defun postscript-shade (stream shade)<br>
  (format stream &#x0022;~%currentgray   ~S setgray   ﬁll   setgray&#x0022;<br>
          shade))<br>        <br>            (defun postscript-closed-path (stream path)<br>
  (unless (every #&#x2019;far-out (remove-if-not #&#x2019;numberp path))<br>
    (postscript-raw-path stream path)<br>      (format stream &#x0022;~%  closepath&#x0022;)))<br>
<br>                                         (defun postscript-path (stream path)<br>
  (unless (every #&#x2019;far-out (remove-if-not #&#x2019;numberp path))<br>
    (postscript-raw-path stream path)))<br>
<br>                    ;;; Print a path as a series of PostScript &#x0022;lineto&#x0022; commands.<br>
(defun postscript-raw-path (stream path)<br>         (format stream &#x0022;~%newpath&#x0022;)<br>
  (let ((fmt &#x0022;~%  ~S ~S moveto&#x0022;))<br>                          (dolist (pt path)<br>
      (cond ((stringp pt)<br>                   (format stream &#x0022;~%  %~A&#x0022; pt))<br>
            (t (format stream<br>                                        fmt<br>
                       (clamp-real (realpart pt))<br>
                       (clamp-real (imagpart pt)))<br>
               (setq fmt &#x0022;~%  ~S ~S lineto&#x0022;))))))<br>
<br>                           ;;; Deﬁnitions of functions to be plotted that are not<br>
;;; standard Common Lisp functions.<br>                                         <br>
(defun one-plus-over-one-minus (x) (/ (+ 1 x) (- 1 x)))<br>                        <br>
(defun one-minus-over-one-plus (x) (/ (- 1 x) (+ 1 x)))<br>                        <br>
(defun sqrt-square-minus-one (x) (sqrt (- 1 (* x x))))<br>                          <br>
(defun sqrt-one-plus-square (x) (sqrt (+ 1 (* x x))))<br>
<!--l. 6116--><p class="noindent" ></div>
<!--l. 6116--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-117100012.5.3" id="x85-117100012.5.3"></a></span>
<!--l. 6116--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-117200012.5.3" id="x85-117200012.5.3"></a></span>
</div>
<!--l. 6117--><p class="indent" >
                                                                          

                                                                          
<div class="lisp">
<!--l. 6118--><p class="indent" >   <div class="tabbing">
;;; Because X3J13 voted for a new deﬁnition of the atan function,
   <br>                  ;;; the following deﬁnition was used in place of the atan function<br>
;;; provided by the Common Lisp implementation I was using.<br>                  <br>
(defun good-atan (x)<br>                            (/ (- (log (+ 1 (* x #c(0 1))))<br>
        (log (- 1 (* x #c(0 1)))))<br>                                  #c(0 2)))<br>
<br>                ;;; Because the ﬁrst edition had an erroneous deﬁnition of atanh,<br>
;;; the following deﬁnition was used in place of the atanh function<br>
;;; provided by the Common Lisp implementation I was using.<br>                  <br>
(defun really-good-atanh (x)<br>                                (/ (- (log (+ 1 x))<br>
        (log (- 1 x)))<br>                                                   2))<br>
<br>
<!--l. 6136--><p class="noindent" ></div>
<!--l. 6136--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-117300012.5.3" id="x85-117300012.5.3"></a></span>
<!--l. 6136--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-117400012.5.3" id="x85-117400012.5.3"></a></span>
</div>
<div class="lisp">
<!--l. 6137--><p class="indent" >   <div class="tabbing">
;;; This is the main procedure that is intended to be called by a user.
   <br>                                                    (defun picture (&#x0026;optional (fn #&#x2019;sqrt))<br>
  (with-open-ﬁle (stream (concatenate &#x2019;string<br>                                       (string-downcase (string fn))<br>
                                       &#x0022;-plot.ps&#x0022;)<br>
                          :direction :output)<br>
    (format stream &#x0022;% PostScript ﬁle for plot of function ~S~%&#x0022; fn)<br>
    (format stream &#x0022;% Plot is to ﬁt in a region ~S inches square~%&#x0022;<br>
            (/ text-width-in-picas 6.0))<br>                      (format stream<br>
            &#x0022;%  showing axes extending ~S units from the origin.~%&#x0022;<br>
            units-to-show)<br>    (let ((scaling (/ (* text-width-in-picas 12) (* units-to-show 2))))<br>
      (format stream &#x0022;~%~S ~:*~S scale&#x0022; scaling))<br>
    (format stream &#x0022;~%~S ~:*~S translate&#x0022; units-to-show)<br>
    (format stream &#x0022;~%newpath&#x0022;)<br>    (format stream &#x0022;~%  ~S ~S moveto&#x0022; (- units-to-show) (- units-to-show))<br>
    (format stream &#x0022;~%  ~S ~S lineto&#x0022; units-to-show (- units-to-show))<br>
                                                                          

                                                                          
    (format stream &#x0022;~%  ~S ~S lineto&#x0022; units-to-show units-to-show)<br>
    (format stream &#x0022;~%  ~S ~S lineto&#x0022; (- units-to-show) units-to-show)<br>
    (format stream &#x0022;~%  closepath&#x0022;)<br>               (format stream &#x0022;~%clip&#x0022;)<br>
    (moby-grid fn stream)<br>                                    (format stream<br>
            &#x0022;~%% End of PostScript ﬁle for plot of function ~S&#x0022;<br>
            fn)<br>                                           (terpri stream)))<br>
<!--l. 6165--><p class="noindent" ></div>
<!--l. 6165--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-117500012.5.3" id="x85-117500012.5.3"></a></span>
<!--l. 6165--><p class="noindent" ><span class="paragraphHead"><a 
href="#x85-117600012.5.3" id="x85-117600012.5.3"></a></span>
</div>
</div>
                                                                          

                                                                          
<!--l. 6169--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse69.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse67.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse67.html#tailclmse67.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse68.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse68.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse68.html"></a>   </div> </div> 
</body></html> 
