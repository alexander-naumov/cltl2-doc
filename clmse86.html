<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Использование списков как множеств</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 2107--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse87.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse85.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse85.html#tailclmse85.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse86.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch15.html#clmse86.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">15.5   </span> <a 
href="clm.html#QQ2-106-1388" id="x106-137900015.5">Использование
списков как множеств</a></h3>
<!--l. 2109--><p class="noindent" >Common Lisp содержит функции, которые позволяют обрабатывать
списки элементов как <i>множества</i>. Сюда входят функции добавления,
удаления и поиска элементов в списке, основанного на различных
критериях. Кроме того, включены функции объединения, пересечения и
разности.
<!--l. 2115--><p class="indent" >   Правила наименования данных функций и их именованных параметров в
основном следуют правилам именования функций для последовательностей.
Смотрите главу <a 
href="clmch14.html#x95-118600014">14<!--tex4ht:ref: KSEQUE --></a>.
<div class="defun">
<!--l. 2119--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx106-1379001"></a><a 
 id="x106-1379002r484"></a><b> member</b>  <i>item</i> <i>list</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx106-1379003"></a><a 
 id="x106-1379004r485"></a><b> member-if</b>  <i>predicate</i> <i>list</i> &#x0026;key  <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx106-1379005"></a><a 
 id="x106-1379006r486"></a><b> member-if-not</b>  <i>predicate</i> <i>list</i> &#x0026;key  <i>:key</i>
</div>
<!--l. 2123--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-138000015.5" id="x106-138000015.5"></a></span>
   Функция осуществляет поиск элемента, удовлетворяющего условию, в
списке <i>list</i>. Если элемент не найдёт, возвращается <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. Иначе возвращается
часть списка, начинающаяся с искомого элемента. Поиск осуществляется
только в верхнем уровне списка. Эти функции могут использоваться в
качестве предикатов.
<!--l. 2131--><p class="indent" >   Например: <div class="lisp"><div class="tabbing">
(member &#x2019;snerd &#x2019;(a b c d)) <span class="math"> ⇒</span> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>
   <br>           (member-if #&#x2019;numberp &#x2019;(a #\Space 5/3 foo)) <span class="math"> ⇒</span> (5/3 foo)<br>
(member &#x2019;a &#x2019;(g (a y) c a d e a f)) <span class="math"> ⇒</span> (a d e a f)<br>
<!--l. 2136--><p class="noindent" ></div>
<!--l. 2136--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-138100015.5" id="x106-138100015.5"></a></span>
                                                                          

                                                                          
<!--l. 2136--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-138200015.5" id="x106-138200015.5"></a></span>
</div>
<!--l. 2137--><p class="indent" >   Следует отметить, что в последнем примере значение, возвращённое
<tt><a 
href="#x106-1379002r484">member</a></tt>, равно <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> части списка, которая начинается на <tt>a</tt>. Если <tt><a 
href="#x106-1379002r484">member</a></tt>
вернула не <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> значение, то для изменения полученного элемента списка
можно использовать <tt><a 
href="clmse84.html#x104-1361002r474">rplaca</a></tt>.
<!--l. 2142--><p class="indent" >   Смотрите также <tt><a 
href="clmse80.html#x99-1239002r396">find</a></tt> и <tt><a 
href="clmse80.html#x99-1240002r399">position</a></tt>.
</div>
<div class="defun">
<!--l. 2145--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx106-1382001"></a><a 
 id="x106-1382002r487"></a><b> tailp</b>  <i>sublist</i> <i>list</i>
</div>
<!--l. 2147--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-138300015.5" id="x106-138300015.5"></a></span>
<tt>
   <a 
href="#x106-1382002r487">tailp</a></tt> истинен тогда и только тогда, когда существует такое целое число
<i>n</i>, что выполняется <div class="lisp"><div class="tabbing">
(eql <i>sublist</i> (nthcdr <i>n</i> <i>list</i>))
   <br>
<!--l. 2152--><p class="noindent" ></div>
<!--l. 2152--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-138400015.5" id="x106-138400015.5"></a></span>
<!--l. 2152--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-138500015.5" id="x106-138500015.5"></a></span>
</div>
<i>
<!--l. 2153--><p class="indent" >   list</i> может быть списком с точкой (подразумевается, что реализации могут
использовать <tt><a 
href="clmse32.html#x43-336002r24">atom</a></tt> и не могут <tt><a 
href="clmse83.html#x103-1283002r442">endp</a></tt> для проверки конца списка <i>list</i>).
FIXME
</div>
<div class="defun">
<!--l. 2158--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx106-1385001"></a><a 
 id="x106-1385002r488"></a><b> adjoin</b>  <i>item</i> <i>list</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
</div>
                                                                          

                                                                          
<!--l. 2160--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-138600015.5" id="x106-138600015.5"></a></span>
<tt>
   <a 
href="#x106-1385002r488">adjoin</a></tt> используется для добавления элементов во множество, если этого
элемента во множестве ещё не было. Условие равенства по-умолчанию <tt><a 
href="clmse33.html#x44-402003r45">eql</a></tt>.
<div class="lisp"><div class="tabbing">
(adjoin <i>item</i> <i>list</i>) <span class="math"> ≡</span> (if (member <i>item</i> <i>list</i>) <i>list</i> (cons <i>item</i> <i>list</i>))
   <br>
<!--l. 2165--><p class="noindent" ></div>
<!--l. 2165--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-138700015.5" id="x106-138700015.5"></a></span>
<!--l. 2165--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-138800015.5" id="x106-138800015.5"></a></span>
</div>
<!--l. 2166--><p class="indent" >   Условие равенства может быть любым предикатом. <i>item</i> добавляется в
список тогда и только тогда, когда в списке не было ни одного элемента,
«удовлетворяющего условию».
<tt>
<!--l. 2170--><p class="indent" >   <a 
href="#x106-1385002r488">adjoin</a></tt> отклоняется от обычных правил, описанных в главе <a 
href="clmch14.html#x95-118600014">14<!--tex4ht:ref: KSEQUE --></a> в части
обработки параметров <i>item</i> и <tt>:key</tt>. Если указана <tt>:key</tt> функция, то она
применяется к параметру <i>item</i>, также как и к каждому элементу
списка. Обоснование в том, что если <i>item</i> ещё не был в списке и если он
там появится, то применение функции <tt>:key</tt> к нему как элементу
списка не будет корректным, если этого не было при его добавлении.
<div class="lisp"><div class="tabbing">
(adjoin <i>item</i> <i>list</i> :key <i>fn</i>)
   <br>       <span class="math"> ≡</span> (if (member (funcall <i>fn</i> <i>item</i>) <i>list</i> :key <i>fn</i>) <i>list</i> (cons <i>item</i> <i>list</i>))<br>
<!--l. 2180--><p class="noindent" ></div>
<!--l. 2180--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-138900015.5" id="x106-138900015.5"></a></span>
                                                                          

                                                                          
<!--l. 2180--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-139000015.5" id="x106-139000015.5"></a></span>
</div>
<!--l. 2182--><p class="indent" >   Смотрите также <tt><a 
href="clmse83.html#x103-1339002r469">pushnew</a></tt>.
</div>
<div class="defun">
<!--l. 2185--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx106-1390001"></a><a 
 id="x106-1390002r489"></a><b> union</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx106-1390003"></a><a 
 id="x106-1390004r490"></a><b> nunion</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
</div>
<!--l. 2188--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-139100015.5" id="x106-139100015.5"></a></span>
<tt>
   <a 
href="#x106-1390002r489">union</a></tt> принимает два списка и возвращает новый список, содержащий всё,
что является элементами списков <i>list1</i> и <i>list2</i>. Если в списках есть
дубликаты, то в итоговом будет только один экземпляр. Например:
<div class="lisp"><div class="tabbing">
(union &#x2019;(a b c) &#x2019;(f a d))
   <br>                        <span class="math"> ⇒</span> (a b c f d) или (b c f a d) или (d f a b c) или ...<br>
<br>                              (union &#x2019;((x 5) (y 6)) &#x2019;((z 2) (x 4)) :key #&#x2019;car)<br>
   <span class="math"> ⇒</span> ((x 5) (y 6) (z 2)) или ((x 4) (y 6) (z 2)) или ...<br>
<!--l. 2199--><p class="noindent" ></div>
<!--l. 2199--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-139200015.5" id="x106-139200015.5"></a></span>
<!--l. 2199--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-139300015.5" id="x106-139300015.5"></a></span>
</div>
<!--l. 2201--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списках. Итоговый список может
иметь общие ячейки с или быть равным <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> переданным аргументам.
<!--l. 2206--><p class="indent" >   Функция <tt>:test</tt> может быть любым предикатом, и операция объединения
может быть описана следующим образом. Для всех возможных упорядоченных
пар, состоящих из одного элемента из списка <i>list1</i> и одного элемента из
списка <i>list2</i>, предикат устанавливает «равны» ли они. Для каждой пары
равных элементов, как минимум один из двух элементов будет помещён в
                                                                          

                                                                          
результат. Кроме того, любой элемент, которые не был равен ни одному
другому элементу, также будет помещён в результат. Это описание
может быть полезным при использовании хитрых функций проверки
равенства.
<!--l. 2215--><p class="indent" >   Аргумент <tt>:test-not</tt> может быть полезен, когда функция проверки
равенства является логическим отрицанием проверки равенства. Хороший
пример такой функции это <tt><a 
href="clmse80.html#x99-1248002r405">mismatch</a></tt>, которая логически инвертирована так,
что если аргументы не равны, то может быть получена возможная полезная
информация. Эта дополнительная «полезная информация» отбрасывается в
следующем примере. <tt><a 
href="clmse80.html#x99-1248002r405">mismatch</a></tt> используется только как предикат.
<div class="lisp"><div class="tabbing">
(union &#x2019;(#(a b) #(5 0 6) #(f 3))
   <br>                                                           &#x2019;(#(5 0 6) (a b) #(g h))<br>
       :test-not<br>                                            #&#x2019;mismatch)<br>
   <span class="math"> ⇒</span> (#(a b) #(5 0 6) #(f 3) #(g h))     ;Возможный результат<br>
   <span class="math"> ⇒</span> ((a b) #(f 3) #(5 0 6) #(g h))      ;Другой возможный результат<br>
<!--l. 2228--><p class="noindent" ></div>
<!--l. 2228--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-139400015.5" id="x106-139400015.5"></a></span>
<!--l. 2228--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-139500015.5" id="x106-139500015.5"></a></span>
</div>
<!--l. 2229--><p class="indent" >   Использование <tt><tt>:test-not</tt> #&#x2019;mismatch</tt> отличается от использования <tt><tt>:test</tt>
#&#x2019;equalp</tt>, например, потому что <tt><a 
href="clmse80.html#x99-1248002r405">mismatch</a></tt> определяет что <tt>#(a b)</tt>
и <tt>(a b)</tt> одинаковы, тогда как <tt><a 
href="clmse33.html#x44-408002r47">equalp</a></tt> определяет эти выражения
разными.
<tt>
<!--l. 2234--><p class="indent" >   <a 
href="#x106-1390004r490">nunion</a></tt> является деструктивной версией <tt><a 
href="#x106-1390002r489">union</a></tt>. Она выполняет ту же
операцию, но может разрушить аргументы, возможно при использовании их
ячеек для построения результата.
</div>
<div class="defun">
                                                                          

                                                                          
<!--l. 2239--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx106-1395001"></a><a 
 id="x106-1395002r491"></a><b> intersection</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx106-1395003"></a><a 
 id="x106-1395004r492"></a><b> nintersection</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
</div>
<!--l. 2242--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-139600015.5" id="x106-139600015.5"></a></span>
<tt>
   <a 
href="#x106-1395002r491">intersection</a></tt> принимает два списка и возвращает новый список
содержащий все элементы, которые есть и в первом и во втором списках
одновременно. Например: <div class="lisp"><div class="tabbing">
(intersection &#x2019;(a b c) &#x2019;(f a d)) <span class="math"> ⇒</span> (a)
   <br>
<!--l. 2248--><p class="noindent" ></div>
<!--l. 2248--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-139700015.5" id="x106-139700015.5"></a></span>
<!--l. 2248--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-139800015.5" id="x106-139800015.5"></a></span>
</div>
<!--l. 2250--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списках. Итоговый список может
иметь общие ячейки с или быть равным <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> переданным аргументам.
<!--l. 2255--><p class="indent" >   Функция <tt>:test</tt> может быть любым предикатом, и операция пересечения
может быть описана следующим образом. Для всех возможных упорядоченных
пар, состоящих из одного элемента из списка <i>list1</i> и одного элемента из
списка <i>list2</i>, предикат устанавливает «равны» ли они. Для каждой пары
равных элементов, только один из двух элементов будет помещён в
результат. Больше никаких элементов в итоговом списке не будет. Это
описание может быть полезным при использовании хитрых функций
проверки равенства.
<tt>
<!--l. 2263--><p class="indent" >   <a 
href="#x106-1395004r492">nintersection</a></tt> является является деструктивной версией <tt><a 
href="#x106-1395002r491">intersection</a></tt>.
Она выполняет ту же операцию, но может разрушить аргумент <i>list1</i>,
возможно при использовании их ячеек для построения результата. (Аргумент
<i>list2</i> не разрушается.)
                                                                          

                                                                          
</div>
<div class="defun">
<!--l. 2269--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx106-1398001"></a><a 
 id="x106-1398002r493"></a><b> set-diﬀerence</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx106-1398003"></a><a 
 id="x106-1398004r494"></a><b> nset-diﬀerence</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
</div>
<!--l. 2272--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-139900015.5" id="x106-139900015.5"></a></span>
<tt>
   <a 
href="#x106-1398002r493">set-difference</a></tt> возвращает список элементов списка <i>list1</i>, которые не
встречаются в списке <i>list2</i>. Данная операция не разрушает аргументы.
<!--l. 2276--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списке <i>list1</i>. Итоговый список может
иметь общие ячейки, или быть равным <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> аргументу <i>list1</i>.
<i>
<!--l. 2281--><p class="indent" >   :test</i> может быть любым предикатом, и операция разности множеств может
быть описана следующим образом. Для всех возможных упорядоченных пар,
состоящих из элементов первого и второго списков, используется предикат
для установки их «равенства». Элемент из списка <i>list1</i> помещается в
результат, тогда и только тогда, когда он не равен ни одному элементу
списка. Это позволяет делать очень интересные приложения. Например,
можно удалить из списка строк все строки, содержащие некоторый список
символов: <i>list2</i>. <div class="lisp"><div class="tabbing">
;; Удалить все имена специй содержащие буквы &#x0022;c&#x0022; или &#x0022;w&#x0022;.
   <br>                           (set-diﬀerence &#x2019;(&#x0022;strawberry&#x0022; &#x0022;chocolate&#x0022; &#x0022;banana&#x0022;<br>
                  &#x0022;lemon&#x0022; &#x0022;pistachio&#x0022; &#x0022;rhubarb&#x0022;)<br>
                &#x2019;(#\c #\w)<br>                                     :test<br>
                #&#x2019;(lambda (s c) (ﬁnd c s)))<br>
   <span class="math"> ⇒</span> (&#x0022;banana&#x0022; &#x0022;rhubarb&#x0022; &#x0022;lemon&#x0022;)     ;Возможен другой порядок элементов<br>
<!--l. 2298--><p class="noindent" ></div>
<!--l. 2298--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-140000015.5" id="x106-140000015.5"></a></span>
                                                                          

                                                                          
<!--l. 2298--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-140100015.5" id="x106-140100015.5"></a></span>
</div>
<tt>
<!--l. 2300--><p class="indent" >   <a 
href="#x106-1398004r494">nset-difference</a></tt> является деструктивной версией <tt><a 
href="#x106-1398002r493">set-difference</a></tt>.
Данная операция может разрушить <i>list1</i>.
</div>
<div class="defun">
<!--l. 2304--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx106-1401001"></a><a 
 id="x106-1401002r495"></a><b> set-exclusive-or</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx106-1401003"></a><a 
 id="x106-1401004r496"></a><b> nset-exclusive-or</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
</div>
<!--l. 2307--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-140200015.5" id="x106-140200015.5"></a></span>
<tt>
   <a 
href="#x106-1401002r495">set-exclusive-or</a></tt> возвращает список элементов, которые встречаются
только в списке <i>list1</i> и только в списке <i>list2</i>. Данная операция не разрушает
аргументы.
<!--l. 2312--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списке <i>list1</i>. Итоговый список может
иметь общие ячейки, или быть равным <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> аргументу <i>list1</i>.
<!--l. 2317--><p class="indent" >   Функция проверки равенства элементов может быть любым предикатом,
и операцию <tt><a 
href="#x106-1401002r495">set-exclusive-or</a></tt> можно описать следующим образом. Для всех
возможных упорядоченных пар, содержащих один элемент из списка <i>list1</i> и
один элемент из списка <i>list2</i>, функция используется для проверки
«равенства». Результат содержит точно те элементы списков <i>list1</i> и <i>list2</i>,
которые были только в различающихся парах.
<tt>
<!--l. 2324--><p class="indent" >   <a 
href="#x106-1401004r496">nset-exclusive-or</a></tt> является деструктивной версией <tt><a 
href="#x106-1401002r495">set-exclusive-or</a></tt>.
Данная операция может разрушить аргументы.
</div>
<div class="defun">
<!--l. 2328--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx106-1402001"></a><a 
 id="x106-1402002r497"></a><b> subsetp</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
</div>
<!--l. 2330--><p class="noindent" ><span class="paragraphHead"><a 
href="#x106-140300015.5" id="x106-140300015.5"></a></span>
<tt>
   <a 
href="#x106-1402002r497">subsetp</a></tt> является предикатом, который истинен, если каждый элемент
списка <i>list1</i> встречается в («равен» некоторому элементу в) списке <i>list2</i>,
                                                                          

                                                                          
иначе ложен.
</div>
                                                                          

                                                                          
<!--l. 2336--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse87.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse85.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse85.html#tailclmse85.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse86.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch15.html#clmse86.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse86.html"></a>  </div> </div> 
</body></html> 
