<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Использование списков как множеств</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-30 23:01:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 2107--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse84.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse82.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse82.html#tailclmse82.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse83.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch15.html#clmse83.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">15.5   </span> <a 
href="clm.html#QQ2-103-236" id="x103-20700015.5">Использование списков как множеств</a></h3>
<!--l. 2109--><p class="noindent" >Common Lisp содержит функции, которые позволяют обрабатывать
списки элементов как <i>множества</i>. Сюда входят функции добавления,
удаления и поиска элементов в списке, основанного на различных
критериях. Кроме того, включены функции объединения, пересечения и
разности.
<!--l. 2115--><p class="indent" >   Правила наименования данных функций и их именованных параметров в
основном следуют правилам именования функций для последовательностей.
Смотрите главу <a 
href="clmch14.html#x92-19300014">14<!--tex4ht:ref: KSEQUE --></a>.
<div class=defun>
<!--l. 2119--><p class="noindent" ><i>[Функция]</i><a 
 id="dx103-207001"></a><a 
 id="x103-207002r467"></a><b> member</b>  <i>item</i> <i>list</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-207003"></a><a 
 id="x103-207004r468"></a><b> member-if</b>  <i>predicate</i> <i>list</i> &#x0026;key  <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-207005"></a><a 
 id="x103-207006r469"></a><b> member-if-not</b>  <i>predicate</i> <i>list</i> &#x0026;key  <i>:key</i>
<!--l. 2123--><p class="noindent" >Функция осуществляет поиск элемента, удовлетворяющего условию, в списке
<i>list</i>. Если элемент не найдёт, возвращается <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. Иначе возвращается часть
списка, начинающаяся с искомого элемента. Поиск осуществляется только в
верхнем уровне списка. Эти функции могут использоваться в качестве
предикатов.
<!--l. 2131--><p class="indent" >   Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(member &#x2019;snerd &#x2019;(a b c d)) <span class="math"> ⇒</span> <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>
</td></tr></table>
<!--l. 2133--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(member-if #&#x2019;numberp &#x2019;(a #\Space 5/3 foo)) <span class="math"> ⇒</span> (5/3 foo)</td></tr></table>
<!--l. 2134--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(member &#x2019;a &#x2019;(g (a y) c a d e a f)) <span class="math"> ⇒</span> (a d e a f)</td></tr></table>
<!--l. 2136--><p class="indent" >
</div>
</div>
<!--l. 2137--><p class="noindent" >Следует отметить, что в последнем примере значение, возвращённое <tt><a 
href="#x103-207002r467">member</a></tt>,
равно <tt><a 
href="clmse32.html#x43-77002r44">eq</a></tt> части списка, которая начинается на <tt>a</tt>. Если <tt><a 
href="#x103-207002r467">member</a></tt> вернула не
<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> значение, то для изменения полученного элемента списка можно
                                                                          

                                                                          
использовать <tt><a 
href="clmse81.html#x101-205002r457">rplaca</a></tt>.
<!--l. 2142--><p class="indent" >   Смотрите также <tt><a 
href="clmse77.html#x96-197002r379">find</a></tt> и <tt><a 
href="clmse77.html#x96-197008r382">position</a></tt>.
</div>
<div class=defun>
<!--l. 2145--><p class="noindent" ><i>[Функция]</i><a 
 id="dx103-207007"></a><a 
 id="x103-207008r470"></a><b> tailp</b>  <i>sublist</i> <i>list</i>
<!--l. 2147--><p class="noindent" ><tt><a 
href="#x103-207008r470">tailp</a></tt> истинен тогда и только тогда, когда существует такое целое число <i>n</i>,
что выполняется <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql <i>sublist</i> (nthcdr <i>n</i> <i>list</i>))
</td></tr></table>
<!--l. 2152--><p class="indent" >
</div>
</div>
<i>
<!--l. 2153--><p class="noindent" >list</i> может быть списком с точкой (подразумевается, что реализации могут
использовать <tt><a 
href="clmse31.html#x42-76006r24">atom</a></tt> и не могут <tt><a 
href="clmse80.html#x100-201002r425">endp</a></tt> для проверки конца списка <i>list</i>).
FIXME
</div>
<div class=defun>
<!--l. 2158--><p class="noindent" ><i>[Функция]</i><a 
 id="dx103-207009"></a><a 
 id="x103-207010r471"></a><b> adjoin</b>  <i>item</i> <i>list</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2160--><p class="noindent" ><tt><a 
href="#x103-207010r471">adjoin</a></tt> используется для добавления элементов во множество, если этого
элемента во множестве ещё не было. Условие равенства по-умолчанию <tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt>.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(adjoin <i>item</i> <i>list</i>) <span class="math"> ≡</span> (if (member <i>item</i> <i>list</i>) <i>list</i> (cons <i>item</i> <i>list</i>))
</td></tr></table>
<!--l. 2165--><p class="indent" >
</div>
</div>
<!--l. 2166--><p class="noindent" >Условие равенства может быть любым предикатом. <i>item</i> добавляется в список
тогда и только тогда, когда в списке не было ни одного элемента,
«удовлетворяющего условию».
<tt>
<!--l. 2170--><p class="indent" >   <a 
href="#x103-207010r471">adjoin</a></tt> отклоняется от обычных правил, описанных в главе <a 
href="clmch14.html#x92-19300014">14<!--tex4ht:ref: KSEQUE --></a> в части
обработки параметров <i>item</i> и <tt>:key</tt>. Если указана <tt>:key</tt> функция, то она
                                                                          

                                                                          
применяется к параметру <i>item</i>, также как и к каждому элементу
списка. Обоснование в том, что если <i>item</i> ещё не был в списке и если он
там появится, то применение функции <tt>:key</tt> к нему как элементу
списка не будет корректным, если этого не было при его добавлении.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(adjoin <i>item</i> <i>list</i> :key <i>fn</i>)
</td></tr></table>
<!--l. 2177--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ≡</span> (if (member (funcall <i>fn</i> <i>item</i>) <i>list</i> :key <i>fn</i>) <i>list</i> (cons <i>item</i> <i>list</i>))</td></tr></table>
<!--l. 2180--><p class="indent" >
</div>
</div>
<!--l. 2182--><p class="indent" >   Смотрите также <tt><a 
href="clmse80.html#x100-202002r452">pushnew</a></tt>.
</div>
<div class=defun>
<!--l. 2185--><p class="noindent" ><i>[Функция]</i><a 
 id="dx103-207011"></a><a 
 id="x103-207012r472"></a><b> union</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-207013"></a><a 
 id="x103-207014r473"></a><b> nunion</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2188--><p class="noindent" ><tt><a 
href="#x103-207012r472">union</a></tt> принимает два списка и возвращает новый список, содержащий всё,
что является элементами списков <i>list1</i> и <i>list2</i>. Если в списках есть
дубликаты, то в итоговом будет только один экземпляр. Например:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(union &#x2019;(a b c) &#x2019;(f a d))
</td></tr></table>
<!--l. 2194--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (a b c f d) или (b c f a d) или (d f a b c) или ...</td></tr></table>
<!--l. 2195--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2196--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(union &#x2019;((x 5) (y 6)) &#x2019;((z 2) (x 4)) :key #&#x2019;car)</td></tr></table>
<!--l. 2197--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> ((x 5) (y 6) (z 2)) или ((x 4) (y 6) (z 2)) или ...</td></tr></table>
<!--l. 2199--><p class="indent" >
</div>
</div>
<!--l. 2201--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списках. Итоговый список может
иметь общие ячейки с или быть равным <tt><a 
href="clmse32.html#x43-77002r44">eq</a></tt> переданным аргументам.
                                                                          

                                                                          
<!--l. 2206--><p class="indent" >   Функция <tt>:test</tt> может быть любым предикатом, и операция объединения
может быть описана следующим образом. Для всех возможных упорядоченных
пар, состоящих из одного элемента из списка <i>list1</i> и одного элемента из
списка <i>list2</i>, предикат устанавливает «равны» ли они. Для каждой пары
равных элементов, как минимум один из двух элементов будет помещён в
результат. Кроме того, любой элемент, которые не был равен ни одному
другому элементу, также будет помещён в результат. Это описание
может быть полезным при использовании хитрых функций проверки
равенства.
<!--l. 2215--><p class="indent" >   Аргумент <tt>:test-not</tt> может быть полезен, когда функция проверки
равенства является логическим отрицанием проверки равенства. Хороший
пример такой функции это <tt><a 
href="clmse77.html#x96-197020r388">mismatch</a></tt>, которая логически инвертирована так,
что если аргументы не равны, то может быть получена возможная полезная
информация. Эта дополнительная «полезная информация» отбрасывается в
следующем примере. <tt><a 
href="clmse77.html#x96-197020r388">mismatch</a></tt> используется только как предикат.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(union &#x2019;(#(a b) #(5 0 6) #(f 3))
</td></tr></table>
<!--l. 2222--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       &#x2019;(#(5 0 6) (a b) #(g h))</td></tr></table>
<!--l. 2223--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :test-not</td></tr></table>
<!--l. 2224--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       #&#x2019;mismatch)</td></tr></table>
<!--l. 2225--><p class="indent" >     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (#(a b) #(5 0 6) #(f 3) #(g h))     ;Возможный результат</td></tr></table>
<!--l. 2226--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> ((a b) #(f 3) #(5 0 6) #(g h))      ;Другой возможный результат</td></tr></table>
<!--l. 2228--><p class="indent" >
</div>
</div>
<!--l. 2229--><p class="noindent" >Использование <tt><tt>:test-not</tt> #&#x2019;mismatch</tt> отличается от использования <tt><tt>:test</tt>
#&#x2019;equalp</tt>, например, потому что <tt><a 
href="clmse77.html#x96-197020r388">mismatch</a></tt> определяет что <tt>#(a b)</tt>
и <tt>(a b)</tt> одинаковы, тогда как <tt><a 
href="clmse32.html#x43-77008r47">equalp</a></tt> определяет эти выражения
разными.
<tt>
<!--l. 2234--><p class="indent" >   <a 
href="#x103-207014r473">nunion</a></tt> является деструктивной версией <tt><a 
href="#x103-207012r472">union</a></tt>. Она выполняет ту же
операцию, но может разрушить аргументы, возможно при использовании их
ячеек для построения результата.
</div>
                                                                          

                                                                          
<div class=defun>
<!--l. 2239--><p class="noindent" ><i>[Функция]</i><a 
 id="dx103-207015"></a><a 
 id="x103-207016r474"></a><b> intersection</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-207017"></a><a 
 id="x103-207018r475"></a><b> nintersection</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2242--><p class="noindent" ><tt><a 
href="#x103-207016r474">intersection</a></tt> принимает два списка и возвращает новый список содержащий
все элементы, которые есть и в первом и во втором списках одновременно.
Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(intersection &#x2019;(a b c) &#x2019;(f a d)) <span class="math"> ⇒</span> (a)
</td></tr></table>
<!--l. 2248--><p class="indent" >
</div>
</div>
<!--l. 2250--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списках. Итоговый список может
иметь общие ячейки с или быть равным <tt><a 
href="clmse32.html#x43-77002r44">eq</a></tt> переданным аргументам.
<!--l. 2255--><p class="indent" >   Функция <tt>:test</tt> может быть любым предикатом, и операция пересечения
может быть описана следующим образом. Для всех возможных упорядоченных
пар, состоящих из одного элемента из списка <i>list1</i> и одного элемента из
списка <i>list2</i>, предикат устанавливает «равны» ли они. Для каждой пары
равных элементов, только один из двух элементов будет помещён в
результат. Больше никаких элементов в итоговом списке не будет. Это
описание может быть полезным при использовании хитрых функций
проверки равенства.
<tt>
<!--l. 2263--><p class="indent" >   <a 
href="#x103-207018r475">nintersection</a></tt> является является деструктивной версией <tt><a 
href="#x103-207016r474">intersection</a></tt>.
Она выполняет ту же операцию, но может разрушить аргумент <i>list1</i>,
возможно при использовании их ячеек для построения результата. (Аргумент
<i>list2</i> не разрушается.)
</div>
<div class=defun>
<!--l. 2269--><p class="noindent" ><i>[Функция]</i><a 
 id="dx103-207019"></a><a 
 id="x103-207020r476"></a><b> set-diﬀerence</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-207021"></a><a 
 id="x103-207022r477"></a><b> nset-diﬀerence</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2272--><p class="noindent" ><tt><a 
href="#x103-207020r476">set-difference</a></tt> возвращает список элементов списка <i>list1</i>, которые не
встречаются в списке <i>list2</i>. Данная операция не разрушает аргументы.
<!--l. 2276--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списке <i>list1</i>. Итоговый список может
иметь общие ячейки, или быть равным <tt><a 
href="clmse32.html#x43-77002r44">eq</a></tt> аргументу <i>list1</i>.
                                                                          

                                                                          
<i>
<!--l. 2281--><p class="indent" >   :test</i> может быть любым предикатом, и операция разности множеств может
быть описана следующим образом. Для всех возможных упорядоченных пар,
состоящих из элементов первого и второго списков, используется предикат
для установки их «равенства». Элемент из списка <i>list1</i> помещается в
результат, тогда и только тогда, когда он не равен ни одному элементу
списка. Это позволяет делать очень интересные приложения. Например,
можно удалить из списка строк все строки, содержащие некоторый список
символов: <i>list2</i>. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;; Удалить все имена специй содержащие буквы &#x0022;c&#x0022; или &#x0022;w&#x0022;.
</td></tr></table>
<!--l. 2290--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(set-diﬀerence &#x2019;(&#x0022;strawberry&#x0022; &#x0022;chocolate&#x0022; &#x0022;banana&#x0022;</td></tr></table>
<!--l. 2291--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  &#x0022;lemon&#x0022; &#x0022;pistachio&#x0022; &#x0022;rhubarb&#x0022;)</td></tr></table>
<!--l. 2292--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                &#x2019;(#\c #\w)</td></tr></table>
<!--l. 2293--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                :test</td></tr></table>
<!--l. 2294--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                #&#x2019;(lambda (s c) (ﬁnd c s)))</td></tr></table>
<!--l. 2295--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (&#x0022;banana&#x0022; &#x0022;rhubarb&#x0022; &#x0022;lemon&#x0022;)     ;Возможен другой порядок элементов</td></tr></table>
<!--l. 2298--><p class="indent" >
</div>
</div>
<tt>
<!--l. 2300--><p class="indent" >   <a 
href="#x103-207022r477">nset-difference</a></tt> является деструктивной версией <tt><a 
href="#x103-207020r476">set-difference</a></tt>.
Данная операция может разрушить <i>list1</i>.
</div>
<div class=defun>
<!--l. 2304--><p class="noindent" ><i>[Функция]</i><a 
 id="dx103-207023"></a><a 
 id="x103-207024r478"></a><b> set-exclusive-or</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-207025"></a><a 
 id="x103-207026r479"></a><b> nset-exclusive-or</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2307--><p class="noindent" ><tt><a 
href="#x103-207024r478">set-exclusive-or</a></tt> возвращает список элементов, которые встречаются
только в списке <i>list1</i> и только в списке <i>list2</i>. Данная операция не разрушает
аргументы.
<!--l. 2312--><p class="indent" >   Порядок элементов в итоговом списке не обязательно совпадает с
порядком соответствующих элементов в списке <i>list1</i>. Итоговый список может
иметь общие ячейки, или быть равным <tt><a 
href="clmse32.html#x43-77002r44">eq</a></tt> аргументу <i>list1</i>.
<!--l. 2317--><p class="indent" >   Функция проверки равенства элементов может быть любым предикатом,
и операцию <tt><a 
href="#x103-207024r478">set-exclusive-or</a></tt> можно описать следующим образом. Для всех
                                                                          

                                                                          
возможных упорядоченных пар, содержащих один элемент из списка <i>list1</i> и
один элемент из списка <i>list2</i>, функция используется для проверки
«равенства». Результат содержит точно те элементы списков <i>list1</i> и <i>list2</i>,
которые были только в различающихся парах.
<tt>
<!--l. 2324--><p class="indent" >   <a 
href="#x103-207026r479">nset-exclusive-or</a></tt> является деструктивной версией <tt><a 
href="#x103-207024r478">set-exclusive-or</a></tt>.
Данная операция может разрушить аргументы.
</div>
<div class=defun>
<!--l. 2328--><p class="noindent" ><i>[Функция]</i><a 
 id="dx103-207027"></a><a 
 id="x103-207028r480"></a><b> subsetp</b>  <i>list1</i> <i>list2</i> &#x0026;key  <i>:test</i> <i>:test-not</i> <i>:key</i>
<!--l. 2330--><p class="noindent" ><tt><a 
href="#x103-207028r480">subsetp</a></tt> является предикатом, который истинен, если каждый элемент
списка <i>list1</i> встречается в («равен» некоторому элементу в) списке <i>list2</i>,
иначе ложен.
</div>
                                                                          

                                                                          
   <!--l. 2336--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse84.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse82.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse82.html#tailclmse82.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse83.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch15.html#clmse83.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 2336--><p class="indent" >   <a 
 id="tailclmse83.html"></a>  
</body></html> 
