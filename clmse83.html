<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Списки</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1461--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse84.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse82.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse82.html#tailclmse82.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse83.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch15.html#clmse83.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">15.2   </span> <a 
href="clm.html#QQ2-103-1292" id="x103-128300015.2">Списки</a></h3>
<!--l. 1463--><p class="noindent" >Следующие функции выполняет различные операции над списками.
<!--l. 1465--><p class="indent" >   Список является одним из первых Lisp&#x2019;овых типов данных. Имя «Lisp»
расшифровывается как «LISt Processing».
<div class="defun">
<!--l. 1469--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1283001"></a><a 
 id="x103-1283002r442"></a><b> endp</b>  <i>object</i>
</div>
<!--l. 1471--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-128400015.2" id="x103-128400015.2"></a></span>
   Предикат <tt><a 
href="#x103-1283002r442">endp</a></tt> используется для проверки конца списка. Возвращает
ложь для cons-ячеек, истину для <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, и генерирует ошибку для всех
остальных объектов других типов.
</div>
<div class="defun">
<!--l. 1477--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1284001"></a><a 
 id="x103-1284002r443"></a><b> list-length</b>  <i>list</i>
</div>
<!--l. 1479--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-128500015.2" id="x103-128500015.2"></a></span>
<tt>
   <a 
href="#x103-1284002r443">list-length</a></tt> возвращает длину списка <i>list</i>. <tt><a 
href="#x103-1284002r443">list-length</a></tt> отличается от
<tt><a 
href="clmse77.html#x96-1202002r368">length</a></tt> при использовании с циклическим списком. В таком случае <tt><a 
href="clmse77.html#x96-1202002r368">length</a></tt>
может не вернуть управление, тогда как <tt><a 
href="#x103-1284002r443">list-length</a></tt> вернёт <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. Например:
<div class="lisp"><div class="tabbing">
(list-length &#x2019;()) <span class="math"> ⇒</span> 0
   <br>          (list-length &#x2019;(a b c d)) <span class="math"> ⇒</span> 4<br>          (list-length &#x2019;(a (b c) d)) <span class="math"> ⇒</span> 3<br>
(let ((x (list &#x2019;a b c)))<br>                                    (rplacd (last x) x)<br>
  (list-length x)) <span class="math"> ⇒</span> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt><br>
<!--l. 1492--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1492--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-128600015.2" id="x103-128600015.2"></a></span>
<!--l. 1492--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-128700015.2" id="x103-128700015.2"></a></span>
</div>
<tt>
<!--l. 1493--><p class="indent" >   <a 
href="#x103-1284002r443">list-length</a></tt> может быть реализован так: <div class="lisp"><div class="tabbing">
(defun list-length (x)
   <br>                                       (do ((n 0 (+ n 2))            ;Счётчик<br>
       (fast x (cddr fast))     ;Быстрый указатель: на две позиции вперёд<br>
       (slow x (cdr slow)))     ;Медленный указатель: на одну позицию<br>
      (nil)<br>    ;; Если быстрый указатель дошёл до конца, вернуть длину.<br>
    (when (endp fast) (return n))<br>    (when (endp (cdr fast)) (return (+ n 1)))<br>
    ;; If fast pointer eventually equals slow pointer,<br>
    ;; then we must be stuck in a circular list.<br>
    ;; (A deeper property is the converse: if we are<br>
    ;; stuck in a circular list, then eventually the<br>
    ;; fast pointer will equal the slow pointer.<br>
    ;; That fact justiﬁes this implementation.)<br>
    (when (and (eq fast slow) (&#x003E; n 0)) (return nil))))<br>
<!--l. 1510--><p class="noindent" ></div>
<!--l. 1510--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-128800015.2" id="x103-128800015.2"></a></span>
<!--l. 1510--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-128900015.2" id="x103-128900015.2"></a></span>
</div>
<!--l. 1511--><p class="indent" >   Смотрите <tt><a 
href="clmse77.html#x96-1202002r368">length</a></tt>, которая возвращает длину любой последовательности.
</div>
<div class="defun">
<!--l. 1514--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1289001"></a><a 
 id="x103-1289002r444"></a><b> nth</b>  <i>n</i> <i>list</i>
</div>
                                                                          

                                                                          
<!--l. 1516--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-129000015.2" id="x103-129000015.2"></a></span>
<tt>
   (nth <i>n</i> <i>list</i>)</tt> возвращает <i>n</i>-нный элемент списка <i>list</i>. <i>car</i> элемент
списка принимается за «нулевой» элемент. Аргумент <i>n</i> должен быть
неотрицательным целым числом. Если длина списка не больше чем <i>n</i>, тогда
результат (), или другими словами <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. (Это согласовывается с концепцией
того, что <i>car</i> и <i>cdr</i> от () являются ().) Например: <div class="lisp"><div class="tabbing">
(nth 0 &#x2019;(foo bar gack)) <span class="math"> ⇒</span> foo
   <br>                                                       (nth 1 &#x2019;(foo bar gack)) <span class="math"> ⇒</span> bar<br>
(nth 3 &#x2019;(foo bar gack)) <span class="math"> ⇒</span> ()<br>
<!--l. 1529--><p class="noindent" ></div>
<!--l. 1529--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-129100015.2" id="x103-129100015.2"></a></span>
<!--l. 1529--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-129200015.2" id="x103-129200015.2"></a></span>
</div>
<tt>
<!--l. 1531--><p class="indent" >   <a 
href="#x103-1289002r444">nth</a></tt> может быть использован в связке с <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> для изменения элемента
списка. В этом случае, аргумент <i>n</i> должен быть меньше чем длина списка
<i>list</i>.
<!--l. 1535--><p class="indent" >   Следует отметить, что порядок аргументов в <tt><a 
href="#x103-1289002r444">nth</a></tt> обратный в отличие от
большинства других функций селекторов для последовательностей, таких ка
<tt><a 
href="clmse77.html#x96-1197002r365">elt</a></tt>.
</div>
<div class="defun">
<!--l. 1540--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1292001"></a><a 
 id="x103-1292002r445"></a><b> ﬁrst</b>  <i>list</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-1292003"></a><a 
 id="x103-1292004r446"></a><b> second</b>  <i>list</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-1292005"></a><a 
 id="x103-1292006r447"></a><b> third</b>  <i>list</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-1292007"></a><a 
 id="x103-1292008r448"></a><b> fourth</b>  <i>list</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-1292009"></a><a 
 id="x103-1292010r449"></a><b> ﬁfth</b>  <i>list</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-1292011"></a><a 
 id="x103-1292012r450"></a><b> sixth</b>  <i>list</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-1292013"></a><a 
 id="x103-1292014r451"></a><b> seventh</b>  <i>list</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-1292015"></a><a 
 id="x103-1292016r452"></a><b> eighth</b>  <i>list</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-1292017"></a><a 
 id="x103-1292018r453"></a><b> ninth</b>  <i>list</i><br 
class="newline" /><i>[Функция]</i><a 
 id="dx103-1292019"></a><a 
 id="x103-1292020r454"></a><b> tenth</b>  <i>list</i>
</div>
<!--l. 1551--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-129300015.2" id="x103-129300015.2"></a></span>
   Иногда эти функции удобно использовать для доступа к определёнными
элементам списка. <tt><a 
href="#x103-1292002r445">first</a></tt> то же, что и <tt><a 
href="clmse82.html#x102-1267002r410">car</a></tt>, <tt><a 
href="#x103-1292004r446">second</a></tt> то же, что и <tt><a 
href="clmse82.html#x102-1273004r413">cadr</a></tt>, <tt><a 
href="#x103-1292006r447">third</a></tt> то
же, что и <tt><a 
href="clmse82.html#x102-1273016r419">caddr</a></tt>, и так далее. Следует отметить, что нумерация начинается с
единицы (ﬁrst) в отличие от нумерации, которая начинается с нуля и
используется в <tt><a 
href="#x103-1289002r444">nth</a></tt>. <div class="lisp"><div class="tabbing">
(ﬁfth x) <span class="math"> ≡</span> (nth 4 x)
   <br>
<!--l. 1560--><p class="noindent" ></div>
<!--l. 1560--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-129400015.2" id="x103-129400015.2"></a></span>
<!--l. 1560--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-129500015.2" id="x103-129500015.2"></a></span>
</div>
<!--l. 1562--><p class="indent" >   Каждая из этих функций может быть использована в связке <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> для
изменения элемента массива.
</div>
<div class="defun">
<!--l. 1566--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1295001"></a><a 
 id="x103-1295002r455"></a><b> rest</b>  <i>list</i>
</div>
<!--l. 1568--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-129600015.2" id="x103-129600015.2"></a></span>
<tt>
   <a 
href="#x103-1295002r455">rest</a></tt> означает то же, что и <tt><a 
href="clmse82.html#x102-1270002r411">cdr</a></tt>, но мнемонически согласуется с <tt><a 
href="#x103-1292002r445">first</a></tt>.
<tt><a 
href="#x103-1295002r455">rest</a></tt> может использоваться в связке с <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt> для изменения элементов
массива.
</div>
<div class="defun">
<!--l. 1575--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1296001"></a><a 
 id="x103-1296002r456"></a><b> nthcdr</b>  <i>n</i> <i>list</i>
</div>
                                                                          

                                                                          
<!--l. 1577--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-129700015.2" id="x103-129700015.2"></a></span>
<tt>
   (nthcdr <i>n</i> <i>list</i>)</tt> выполняет для списка <i>lisp</i> операцию <tt><a 
href="clmse82.html#x102-1270002r411">cdr</a></tt> <i>n</i> раз, и
возвращает результат. Например: <div class="lisp"><div class="tabbing">
(nthcdr 0 &#x2019;(a b c)) <span class="math"> ⇒</span> (a b c)
   <br>                                                             (nthcdr 2 &#x2019;(a b c)) <span class="math"> ⇒</span> (c)<br>
(nthcdr 4 &#x2019;(a b c)) <span class="math"> ⇒</span> ()<br>
<!--l. 1585--><p class="noindent" ></div>
<!--l. 1585--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-129800015.2" id="x103-129800015.2"></a></span>
<!--l. 1585--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-129900015.2" id="x103-129900015.2"></a></span>
</div>
<!--l. 1586--><p class="indent" >   Другими словами, она возвращает <i>n</i>-нную <i>cdr</i> часть списка.
<div class="lisp">
<!--l. 1588--><p class="indent" >   <div class="tabbing">
(car (nthcdr n x)) <span class="math"> ≡</span> (nth n x)
   <br>
<!--l. 1590--><p class="noindent" ></div>
<!--l. 1590--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-130000015.2" id="x103-130000015.2"></a></span>
<!--l. 1590--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-130100015.2" id="x103-130100015.2"></a></span>
</div>
<!--l. 1591--><p class="indent" >   Аргумент <i>n</i> должен быть неотрицательным целым числом.
</div>
<div class="defun">
<!--l. 1594--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1301001"></a><a 
 id="x103-1301002r457"></a><b> last</b>  <i>list</i> &#x0026;optional  (<i>n</i> 1)
</div>
                                                                          

                                                                          
<!--l. 1596--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-130200015.2" id="x103-130200015.2"></a></span>
<tt>
   <a 
href="#x103-1301002r457">last</a></tt> возвращает последние <i>n</i> cons-ячеек списка <i>lisp</i>. Список <i>list</i>
может быть списком с точкой. Передача зацикленного списка является
ошибкой.
<!--l. 1601--><p class="indent" >   Аргумент <i>n</i> должен быть неотрицательным целым числом. Если <i>n</i> равен
нулю, тогда возвращается последний атом списка <i>list</i>. Если <i>n</i> не меньше чем
количество cons-ячеек, то возвращается весь список.
<!--l. 1606--><p class="indent" >   Например: <div class="lisp"><div class="tabbing">
(setq x &#x2019;(a b c d))
   <br>                       (last x) <span class="math"> ⇒</span> (d)<br>                       (rplacd (last x) &#x2019;(e f))<br>
x <span class="math"> ⇒</span> &#x2019;(a b c d e f)<br>                                    (last x 3) <span class="math"> ⇒</span> (d e f)<br>
(last &#x2019;()) <span class="math"> ⇒</span> ()<br>                                (last &#x2019;(a b c . d)) <span class="math"> ⇒</span> (c . d)<br>
(last &#x2019;(a b c . d) 0) <span class="math"> ⇒</span> d<br>                  (last &#x2019;(a b c . d) 2) <span class="math"> ⇒</span> (b c . d)<br>
(last &#x2019;(a b c . d) 1729) <span class="math"> ⇒</span> (a b c . d)<br>
<!--l. 1618--><p class="noindent" ></div>
<!--l. 1618--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-130300015.2" id="x103-130300015.2"></a></span>
<!--l. 1618--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-130400015.2" id="x103-130400015.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1621--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1304001"></a><a 
 id="x103-1304002r458"></a><b> list</b>  &#x0026;rest  <i>args</i>
</div>
<!--l. 1623--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-130500015.2" id="x103-130500015.2"></a></span>
<tt>
   <a 
href="#x103-1304002r458">list</a></tt> создаёт и возвращает список, составленный из аргументов.
Например: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(list 3 4 &#x2019;a (car &#x2019;(b . c)) (+ 6 -2)) <span class="math"> ⇒</span> (3 4 a b 4)
   <br>
<!--l. 1628--><p class="noindent" ></div>
<!--l. 1628--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-130600015.2" id="x103-130600015.2"></a></span>
<!--l. 1628--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-130700015.2" id="x103-130700015.2"></a></span>
</div>
<div class="lisp">
<!--l. 1630--><p class="indent" >   <div class="tabbing">
(list) <span class="math"> ⇒</span> ()
   <br>                                (list (list &#x2019;a &#x2019;b) (list &#x2019;c &#x2019;d &#x2019;e)) <span class="math"> ⇒</span> ((a b) (c d e))<br>
<!--l. 1633--><p class="noindent" ></div>
<!--l. 1633--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-130800015.2" id="x103-130800015.2"></a></span>
<!--l. 1633--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-130900015.2" id="x103-130900015.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1636--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1309001"></a><a 
 id="x103-1309002r459"></a><b> list*</b>  <i>arg</i> &#x0026;rest  <i>others</i>
</div>
<!--l. 1638--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-131000015.2" id="x103-131000015.2"></a></span>
<tt>
   <a 
href="#x103-1309002r459">list*</a></tt> похожа на <tt><a 
href="#x103-1304002r458">list</a></tt> за исключением того, что последняя <i>cons</i>-ячейка
создаваемого списка будет «с точкой». Последний аргумент используется как
последний элемент списка, а именно в последней cons-ячейки в <i>cdr</i> элементе.
Данный аргумент необязательно должен быть атомом, и если он не атом, то в
результате список будет иметь большую длину чем количество аргументов.
Например: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(list* &#x2019;a &#x2019;b &#x2019;c &#x2019;d) <span class="math"> ⇒</span> (a b c . d)
   <br>
<!--l. 1648--><p class="noindent" ></div>
<!--l. 1648--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-131100015.2" id="x103-131100015.2"></a></span>
<!--l. 1648--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-131200015.2" id="x103-131200015.2"></a></span>
</div>
<!--l. 1649--><p class="indent" >   Это то же, что и <div class="lisp"><div class="tabbing">
(cons &#x2019;a (cons &#x2019;b (cons &#x2019;c &#x2019;d)))
   <br>
<!--l. 1652--><p class="noindent" ></div>
<!--l. 1652--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-131300015.2" id="x103-131300015.2"></a></span>
<!--l. 1652--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-131400015.2" id="x103-131400015.2"></a></span>
</div>
<!--l. 1653--><p class="indent" >   А также: <div class="lisp"><div class="tabbing">
(list* &#x2019;a &#x2019;b &#x2019;c &#x2019;(d e f)) <span class="math"> ⇒</span> (a b c d e f)
   <br>                                                                             (list* x) <span class="math"> ≡</span> x<br>
<!--l. 1657--><p class="noindent" ></div>
<!--l. 1657--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-131500015.2" id="x103-131500015.2"></a></span>
                                                                          

                                                                          
<!--l. 1657--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-131600015.2" id="x103-131600015.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1660--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1316001"></a><a 
 id="x103-1316002r460"></a><b> make-list</b>  <i>size</i> &#x0026;key  <i>:initial-element</i>
</div>
<!--l. 1662--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-131700015.2" id="x103-131700015.2"></a></span>
   Функция создаёт и возвращает список содержащий количество <i>size</i>
элементов, каждый из которых будет инициализирован значением аргумента
<tt>:initial-element</tt> (который по-умолчанию <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>). <i>size</i> должен быть
неотрицательным целым числом. Например: <div class="lisp"><div class="tabbing">
(make-list 5) <span class="math"> ⇒</span> (<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>)
   <br>                      (make-list 3 <tt>:initial-element</tt> &#x2019;rah) <span class="math"> ⇒</span> (rah rah rah)<br>
<!--l. 1671--><p class="noindent" ></div>
<!--l. 1671--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-131800015.2" id="x103-131800015.2"></a></span>
<!--l. 1671--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-131900015.2" id="x103-131900015.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1674--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1319001"></a><a 
 id="x103-1319002r461"></a><b> append</b>  &#x0026;rest  <i>lists</i>
</div>
<!--l. 1676--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-132000015.2" id="x103-132000015.2"></a></span>
   Функция возвращает список содержащий все элементы указанных в
аргументах списков. Аргументы не разрушаются. Например: <div class="lisp"><div class="tabbing">
(append &#x2019;(a b c) &#x2019;(d e f) &#x2019;() &#x2019;(g)) <span class="math"> ⇒</span> (a b c d e f g)
   <br>
<!--l. 1682--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1682--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-132100015.2" id="x103-132100015.2"></a></span>
<!--l. 1682--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-132200015.2" id="x103-132200015.2"></a></span>
</div>
<!--l. 1683--><p class="indent" >   Следует отметить, что <tt><a 
href="clmse131.html#x161-2357002r804">append</a></tt> копирует верхний уровень всех переданных
списков <i>за исключением</i> последнего. Функция <tt><a 
href="clmse78.html#x97-1209002r372">concatenate</a></tt> выполняет
похожую операцию, но всегда копирует все аргументы. Смотрите также
<tt><a 
href="clmse131.html#x161-2359002r806">nconc</a></tt>, которая похожа на <tt><a 
href="clmse131.html#x161-2357002r804">append</a></tt>, но разрушает все аргументы кроме
последнего.
<!--l. 1689--><p class="indent" >   Последний аргумент может быть любым Lisp объектом, и в этом случае
этот объект становится последним элементов итогового списка. Например,
<tt>(append &#x2019;(a b c) &#x2019;d)</tt> <span class="math"> ⇒</span> <tt>(a b c . d)</tt>.
<tt>
<!--l. 1693--><p class="indent" >   (append <i>x</i> &#x2019;())</tt> может быть использовано для копирования списка <i>x</i>,
однако для этого больше подходит функция <tt><a 
href="#x103-1322002r462">copy-list</a></tt>.
</div>
<div class="defun">
<!--l. 1697--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1322001"></a><a 
 id="x103-1322002r462"></a><b> copy-list</b>  <i>list</i>
</div>
<!--l. 1699--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-132300015.2" id="x103-132300015.2"></a></span>
   Функция возвращает список, который равен <tt><a 
href="clmse33.html#x44-405002r46">equal</a></tt> и в то же время не
равен <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> списку <i>list</i>, Копируется только верхний уровень списка, то есть
<tt><a 
href="#x103-1322002r462">copy-list</a></tt> копирует только в направлении <i>cdr</i> элементов, но не в
направлении <i>car</i> элементов. Если список «с точкой», то есть <tt>(cdr (last
<i>list</i>))</tt> является не-<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> атомом, тогда итоговый список также будет «с
точкой». Смотрите также <tt><a 
href="clmse77.html#x96-1199002r367">copy-seq</a></tt> и <tt><a 
href="#x103-1324002r464">copy-tree</a></tt>.
</div>
<div class="defun">
<!--l. 1710--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1323001"></a><a 
 id="x103-1323002r463"></a><b> copy-alist</b>  <i>list</i>
</div>
<!--l. 1712--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-132400015.2" id="x103-132400015.2"></a></span>
<tt>
   <a 
href="#x103-1323002r463">copy-alist</a></tt> копирует ассоциативные списки. При этом, также
как и в <tt><a 
href="#x103-1322002r462">copy-list</a></tt>, копируется только верхний уровень списка <i>lisp</i>.
                                                                          

                                                                          
Кроме того, каждый элемент списка <i>list</i>, являющийся в свою очередь
cons-ячейкой, заменяется новой cons-ячейкой с теми же <i>car</i> и <i>cons</i>
элементами.
</div>
<div class="defun">
<!--l. 1720--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1324001"></a><a 
 id="x103-1324002r464"></a><b> copy-tree</b>  <i>object</i>
</div>
<!--l. 1722--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-132500015.2" id="x103-132500015.2"></a></span>
<tt>
   <a 
href="#x103-1324002r464">copy-tree</a></tt> копирует древовидно организованные cons-ячейки. Аргумент
<i>object</i> может быть любым Lisp&#x2019;овым объектом. Если он не является
cons-ячейкой, то ничего не произойдёт и данный объект будет возвращён в
качестве результата. В противном случае будет возвращена новая
cons-ячейка, в которой <i>car</i> и <i>cons</i> элементы будут результатами рекурсивных
вызовов <tt><a 
href="#x103-1324002r464">copy-tree</a></tt>. Другими словами, все cons-ячейки будут рекурсивно
скопированы, и рекурсия будет останавливаться только на атомах.
</div>
<div class="defun">
<!--l. 1732--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1325001"></a><a 
 id="x103-1325002r465"></a><b> revappend</b>  <i>x</i> <i>y</i>
</div>
<!--l. 1734--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-132600015.2" id="x103-132600015.2"></a></span>
<tt>
   (revappend <i>x</i> <i>y</i>)</tt> похожа на <tt>(append (reverse <i>x</i>) <i>y</i>)</tt> за исключением
того, что она потенциально более производительна. Аргументы <i>x</i> и <i>y</i> должны
быть списками. Аргумент <i>x</i> копируется (не разрушается) в отличие от
<tt><a 
href="#x103-1329002r467">nreconc</a></tt>, которая разрушает первый аргумент.
</div>
<div class="defun">
<!--l. 1742--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1326001"></a><a 
 id="x103-1326002r466"></a><b> nconc</b>  &#x0026;rest  <i>lists</i>
</div>
<!--l. 1744--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-132700015.2" id="x103-132700015.2"></a></span>
   В качестве аргументов <tt><a 
href="clmse131.html#x161-2359002r806">nconc</a></tt> принимает списки. Функция соединяет
списки и возвращает результат. При этом аргументы изменяются, а не
копируются. (В сравнении с <tt><a 
href="clmse131.html#x161-2357002r804">append</a></tt>, которая копирует аргументы, а не
                                                                          

                                                                          
разрушает их.) Например: <div class="lisp"><div class="tabbing">
(setq x &#x2019;(a b c))
   <br>                   (setq y &#x2019;(d e f))<br>                   (nconc x y) <span class="math"> ⇒</span> (a b c d e f)<br>
x <span class="math"> ⇒</span> (a b c d e f)<br>
<!--l. 1754--><p class="noindent" ></div>
<!--l. 1754--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-132800015.2" id="x103-132800015.2"></a></span>
<!--l. 1754--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-132900015.2" id="x103-132900015.2"></a></span>
</div>
<!--l. 1755--><p class="indent" >   Следует отметить, что в примере, значение <tt>x</tt> отличается от первоначального,
так как последняя cons-ячейка была изменена с помощью <tt><a 
href="clmse84.html#x104-1364002r475">rplacd</a></tt> значением
<tt>y</tt>. Если сейчас выполнить <tt>(nconc x y)</tt> ещё раз, тогда часть списка
зациклится: <tt>(a b c d e f d e f d e f ...)</tt>, и так до бесконечности. Если
<tt><a 
href="clmse111.html#x138-1846003r643">*print-circle*</a></tt> не равен <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, тогда вывод списка будет таким: <tt>(a b c .
#1=(d e f . #1#))</tt>.
<!--l. 1763--><p class="indent" >   Вызов <tt><a 
href="clmse131.html#x161-2359002r806">nconc</a></tt>, совпадающий с наиболее близким шаблоном выражения в
левой части приводит к эквивалентным побочным действиям, как в правой
части таблицы.
<div class="flushleft" 
>
<!--l. 1766--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" ><tt>(nconc)</tt>            </td><td align="left" ><tt>nil     ;</tt>Нет побочных эффектов</td>
</tr><tr><td align="left" ><tt>(nconc nil . <i>r</i>)    </tt></td><td align="left" ><tt>(nconc . <i>r</i>)</tt>                   </td>
</tr><tr><td align="left" ><tt>(nconc <i>x</i>)</tt>          </td><td align="left" ><i>x</i>                                           </td>
</tr><tr><td align="left" ><tt>(nconc <i>x</i> <i>y</i>)</tt>        </td><td align="left" ><tt>(let ((p <i>x</i>) (q <i>y</i>))</tt>            </td>
</tr><tr><td align="left" >                   </td><td align="left" ><tt>  (rplacd (last p) q)</tt>          </td>
</tr><tr><td align="left" >                   </td><td align="left" ><tt>  p)</tt>                           </td>
</tr><tr><td align="left" ><tt>(nconc <i>x</i> <i>y</i> . <i>r</i>)</tt>   </td><td align="left" ><tt>(nconc (nconc <i>x</i> <i>y</i>) . <i>r</i>)</tt>      </td></tr></table>
</div></div>
</div>
                                                                          

                                                                          
<div class="defun">
<!--l. 1782--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1329001"></a><a 
 id="x103-1329002r467"></a><b> nreconc</b>  <i>x</i> <i>y</i>
</div>
<!--l. 1784--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-133000015.2" id="x103-133000015.2"></a></span>
<tt>
   (nreconc <i>x</i> <i>y</i>)</tt> похожа на <tt>(nconc (nreverse <i>x</i>) <i>y</i>)</tt> за исключением
того, что она потенциально эффективнее. Оба аргумента должны быть
списками. Аргумент <i>x</i> разрушается. Сравните с <tt><a 
href="#x103-1325002r465">revappend</a></tt>.
<div class="lisp">
<!--l. 1791--><p class="indent" >   <div class="tabbing">
(setq planets &#x2019;(jupiter mars earth venus mercury))
   <br>                            (setq more-planets &#x2019;(saturn uranus pluto neptune))<br>
(nreconc more-planets planets)<br>
       <span class="math"> ⇒</span> (neptune pluto uranus saturn jupiter mars earth venus mercury)<br>
  теперь значение <tt>more-planets</tt> точно не определено<br>
<!--l. 1797--><p class="noindent" ></div>
<!--l. 1797--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-133100015.2" id="x103-133100015.2"></a></span>
<!--l. 1797--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-133200015.2" id="x103-133200015.2"></a></span>
</div>
<!--l. 1799--><p class="indent" >   Поведение <tt>(nreconc <i>x</i> <i>y</i>)</tt> совпадает с поведением <tt>(nconc (nreverse
<i>x</i>) <i>y</i>)</tt> в части побочных эффектов.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1804--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> push </b><a 
 id="dx103-1332001"></a><a 
 id="x103-1332002r468"></a> item place
   <br>
<!--l. 1805--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1805--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-133300015.2" id="x103-133300015.2"></a></span>
</div>
<!--l. 1806--><p class="indent" >   Форма <i>place</i> должна быть именем обобщённое переменной, содержащей
список. <i>item</i> может указывать на любой Lisp&#x2019;овый объект. <i>item</i> вставляется в
начало списка и данный список возвращается в качестве результата. Форма
<i>place</i> может быть любой формой, которая подходит для <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>. Если
рассматривать список как стек, тогда <tt><a 
href="#x103-1332002r468">push</a></tt> добавляет элемент на вершину
стека. Например: <div class="lisp"><div class="tabbing">
(setq x &#x2019;(a (b c) d))
   <br>                   (push 5 (cadr x)) <span class="math"> ⇒</span> (5 b c) и теперь x <span class="math"> ⇒</span> (a (5 b c) d)<br>
<!--l. 1817--><p class="noindent" ></div>
<!--l. 1817--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-133400015.2" id="x103-133400015.2"></a></span>
<!--l. 1817--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-133500015.2" id="x103-133500015.2"></a></span>
</div>
<!--l. 1818--><p class="indent" >   Действие от <div class="lisp"><div class="tabbing">
(push <i>item</i> <i>place</i>)
   <br>
<!--l. 1821--><p class="noindent" ></div>
<!--l. 1821--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-133600015.2" id="x103-133600015.2"></a></span>
<!--l. 1821--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-133700015.2" id="x103-133700015.2"></a></span>
</div>
<!--l. 1822--><p class="indent" >   эквивалентно действию <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(setf <i>place</i> (cons <i>item</i> <i>place</i>))
   <br>
<!--l. 1825--><p class="noindent" ></div>
<!--l. 1825--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-133800015.2" id="x103-133800015.2"></a></span>
<!--l. 1825--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-133900015.2" id="x103-133900015.2"></a></span>
</div>
<!--l. 1826--><p class="indent" >   за исключением того, что <tt><a 
href="#x103-1332002r468">push</a></tt> выполняет форму <i>place</i> только один раз, а
не три. Более того, в для некоторых форм <i>place</i> <tt><a 
href="#x103-1332002r468">push</a></tt> может быть
эффективнее чем версия с <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>.
<!--l. 1831--><p class="indent" >   Следует отметить, что <i>item</i> вычисляется прежде чем вычисляется
<i>place</i>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1836--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> pushnew </b><a 
 id="dx103-1339001"></a><a 
 id="x103-1339002r469"></a> item place &#x0026;key :test :test-not :key
   <br>
<!--l. 1837--><p class="noindent" ></div>
<!--l. 1837--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-134000015.2" id="x103-134000015.2"></a></span>
</div>
<!--l. 1838--><p class="indent" >   Форма <i>place</i> должна быть именем обобщённое переменной, содержащей
список. <i>item</i> может указывать на любой Lisp&#x2019;овый объект. Если <i>item</i> не
содержится в списке (этот факт устанавливается с помощью предиката
переданного в <tt>:test</tt>, который по-умолчанию <tt><a 
href="clmse33.html#x44-402003r45">eql</a></tt>), тогда <i>item</i> вставляется в
начало списка и данный список возвращается в качестве результата. В
противном случае возвращается исходный список. Форма <i>place</i> может быть
любой формой, которая подходит для <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>. Если рассматривать список как
                                                                          

                                                                          
множество, тогда <tt><a 
href="#x103-1339002r469">pushnew</a></tt> добавляет элемент в множество. Смотрите
<tt><a 
href="clmse86.html#x106-1385002r488">adjoin</a></tt>.
<!--l. 1848--><p class="indent" >   Именованные параметры <tt><a 
href="#x103-1339002r469">pushnew</a></tt> имеют тот же смысл, что и в функциях
для последовательностей. Смотрите главу <a 
href="clmch14.html#x95-118600014">14<!--tex4ht:ref: KSEQUE --></a>. По сути, данные аргументы
идентичны аргументам <tt><a 
href="clmse86.html#x106-1385002r488">adjoin</a></tt>.
<tt>
<!--l. 1852--><p class="indent" >   <a 
href="#x103-1339002r469">pushnew</a></tt> возвращает модифицированное содержимое переменной <i>place</i>.
Например: <div class="lisp"><div class="tabbing">
(setq x &#x2019;(a (b c) d))
   <br>              (pushnew 5 (cadr x)) <span class="math"> ⇒</span> (5 b c) и теперь x <span class="math"> ⇒</span> (a (5 b c) d)<br>
(pushnew &#x2019;b (cadr x)) <span class="math"> ⇒</span> (5 b c) и <tt>x</tt> не меняется<br>
<!--l. 1858--><p class="noindent" ></div>
<!--l. 1858--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-134100015.2" id="x103-134100015.2"></a></span>
<!--l. 1858--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-134200015.2" id="x103-134200015.2"></a></span>
</div>
<!--l. 1859--><p class="indent" >   Действие от <div class="lisp"><div class="tabbing">
(pushnew <i>item</i> <i>place</i> <tt>:test</tt> <i>p</i>)
   <br>
<!--l. 1862--><p class="noindent" ></div>
<!--l. 1862--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-134300015.2" id="x103-134300015.2"></a></span>
<!--l. 1862--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-134400015.2" id="x103-134400015.2"></a></span>
</div>
<!--l. 1863--><p class="indent" >   эквивалентно действию <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(setf <i>place</i> (adjoin <i>item</i> <i>place</i> <tt>:test</tt> <i>p</i>))
   <br>
<!--l. 1866--><p class="noindent" ></div>
<!--l. 1866--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-134500015.2" id="x103-134500015.2"></a></span>
<!--l. 1866--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-134600015.2" id="x103-134600015.2"></a></span>
</div>
<!--l. 1867--><p class="indent" >   за исключением того, что <tt><a 
href="#x103-1339002r469">pushnew</a></tt> выполняет форму <i>place</i> только один
раз, а не три. Более того, в для некоторых форм <i>place</i> <tt><a 
href="#x103-1339002r469">pushnew</a></tt> может быть
эффективнее чем версия с <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>.
<!--l. 1872--><p class="indent" >   Следует отметить, что <i>item</i> вычисляется прежде чем вычисляется
<i>place</i>.
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 1877--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> pop </b><a 
 id="dx103-1346001"></a><a 
 id="x103-1346002r470"></a> place
   <br>
<!--l. 1878--><p class="noindent" ></div>
<!--l. 1878--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-134700015.2" id="x103-134700015.2"></a></span>
</div>
<!--l. 1879--><p class="indent" >   Форма <i>place</i> должна быть именем обобщённое переменной, содержащей
список. Результатом <tt><a 
href="#x103-1346002r470">pop</a></tt> является результат <tt><a 
href="clmse82.html#x102-1267002r410">car</a></tt> функции для переданного
списка, и побочным эффектом является то, что в обобщённую переменную
сохраняется результат <tt><a 
href="clmse82.html#x102-1270002r411">cdr</a></tt> для списка. Форма <i>place</i> может быть любой
формой, которая подходит для <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>. Если рассматривать исходный список
как стек, то <tt><a 
href="#x103-1346002r470">pop</a></tt> достаёт элемент из вершины стека и возвращает его.
Например: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(setq stack &#x2019;(a b c))
   <br>                                        (pop stack) <span class="math"> ⇒</span> a and now stack <span class="math"> ⇒</span> (b c)<br>
<!--l. 1890--><p class="noindent" ></div>
<!--l. 1890--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-134800015.2" id="x103-134800015.2"></a></span>
<!--l. 1890--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-134900015.2" id="x103-134900015.2"></a></span>
</div>
<!--l. 1891--><p class="indent" >   Действия от <tt>(pop <i>place</i>)</tt> эквивалентно <div class="lisp"><div class="tabbing">
(prog1 (car <i>place</i>) (setf <i>place</i> (cdr <i>place</i>)))
   <br>
<!--l. 1894--><p class="noindent" ></div>
<!--l. 1894--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-135000015.2" id="x103-135000015.2"></a></span>
<!--l. 1894--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-135100015.2" id="x103-135100015.2"></a></span>
</div>
<!--l. 1895--><p class="indent" >   за исключением того, что <tt><a 
href="#x103-1346002r470">pop</a></tt> выполняет форму <i>place</i> только один раз, а
не три. Более того, в для некоторых форм <i>place</i> <tt><a 
href="#x103-1346002r470">pop</a></tt> может быть эффективнее
чем версия с <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>.
</div>
<div class="defun">
<!--l. 1901--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1351001"></a><a 
 id="x103-1351002r471"></a><b> butlast</b>  <i>list</i> &#x0026;optional  <i>n</i>
</div>
<!--l. 1903--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-135200015.2" id="x103-135200015.2"></a></span>
   Функция создаёт и возвращает список с такими же элементами кроме <i>n</i>
последних, что и в списке <i>list</i>. <i>n</i> по-умолчанию равно 1. Аргумент не
разрушается. Если длина списка <i>list</i> меньше чем <i>n</i>, тогда возвращается ().
Например: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(butlast &#x2019;(a b c d)) <span class="math"> ⇒</span> (a b c)
   <br>            (butlast &#x2019;((a b) (c d))) <span class="math"> ⇒</span> ((a b))<br>            (butlast &#x2019;(a)) <span class="math"> ⇒</span> ()<br>
(butlast nil) <span class="math"> ⇒</span> ()<br>
<!--l. 1915--><p class="noindent" ></div>
<!--l. 1915--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-135300015.2" id="x103-135300015.2"></a></span>
<!--l. 1915--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-135400015.2" id="x103-135400015.2"></a></span>
</div>
<!--l. 1916--><p class="indent" >   Имя функции образовано от фразы «all elements but the last» («все
элементы кроме последних»).
</div>
<div class="defun">
<!--l. 1920--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1354001"></a><a 
 id="x103-1354002r472"></a><b> nbutlast</b>  <i>list</i> &#x0026;optional  <i>n</i>
</div>
<!--l. 1922--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-135500015.2" id="x103-135500015.2"></a></span>
   Это деструктивная версия <tt><a 
href="#x103-1351002r471">butlast</a></tt>. Данная функция изменяет
<i>cdr</i> элемент cons-ячейки на <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. Искомая cons-ячейка находится на
позиции <i>n</i>+1 с конца списка. Если длина списка <i>list</i> меньше чем <i>n</i>, тогда
возвращается (), и аргумент не модифицируется. (Таким образом можно
написать <tt>(setq a (nbutlast a))</tt>, а не <tt>(nbutlast a)</tt>.) Например:
<div class="lisp"><div class="tabbing">
(setq foo &#x2019;(a b c d))
   <br>                                                              (nbutlast foo) <span class="math"> ⇒</span> (a b c)<br>
foo <span class="math"> ⇒</span> (a b c)<br>                                       (nbutlast &#x2019;(a)) <span class="math"> ⇒</span> ()<br>
(nbutlast &#x2019;<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>) <span class="math"> ⇒</span> ()<br>
<!--l. 1935--><p class="noindent" ></div>
<!--l. 1935--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-135600015.2" id="x103-135600015.2"></a></span>
                                                                          

                                                                          
<!--l. 1935--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-135700015.2" id="x103-135700015.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1938--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx103-1357001"></a><a 
 id="x103-1357002r473"></a><b> ldiﬀ</b>  <i>list</i> <i>sublist</i>
</div>
<!--l. 1940--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-135800015.2" id="x103-135800015.2"></a></span>
   Аргумент <i>list</i> должен быть списком, и <i>sublist</i> должен быть подсписком
<i>list</i>. <tt><a 
href="#x103-1357002r473">ldiff</a></tt> (означает «list diﬀerence») возвращает новый список, элементы
которого содержат все элементы списка <i>list</i> до подсписка <i>sublist</i>. Если <i>sublist</i>
не является частью <i>list</i> (или в частности равен <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>), тогда возвращается
копия всего списка <i>list</i>. Аргумент <i>list</i> не разрушается. Например:
<div class="lisp"><div class="tabbing">
(setq x &#x2019;(a b c d e))
   <br>                                                           (setq y (cdddr x)) <span class="math"> ⇒</span> (d e)<br>
(ldiﬀ x y) <span class="math"> ⇒</span> (a b c)<br>
но (ldiﬀ &#x2019;(a b c d) &#x2019;(c d)) <span class="math"> ⇒</span> (a b c d)
   <br>
<!--l. 1954--><p class="noindent" ></div>
<!--l. 1954--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-135900015.2" id="x103-135900015.2"></a></span>
<!--l. 1954--><p class="noindent" ><span class="paragraphHead"><a 
href="#x103-136000015.2" id="x103-136000015.2"></a></span>
</div>
<!--l. 1955--><p class="indent" >   так как подсписок не равен <tt><a 
href="clmse33.html#x44-397002r44">eq</a></tt> ни одной части списка.
</div>
                                                                          

                                                                          
<!--l. 1958--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse84.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse82.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse82.html#tailclmse82.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse83.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch15.html#clmse83.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse83.html"></a>  </div> </div> 
</body></html> 
