<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Establishing New Variable Bindings</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 2160--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse40.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse38.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse38.html#tailclmse38.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse39.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse39.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">7.5   </span> <a 
 id="x51-830007.5"></a>Establishing New Variable Bindings</h3>
<!--l. 2163--><p class="noindent" >During the invocation of a function represented by a lambda-expression (or a
closure of a lambda-expression, as produced by <i>function</i>), new bindings are
established for the variables that are the parameters of the lambda-expression.
These bindings initially have values determined by the parameter-binding protocol
discussed in section <a 
href="clmse29.html#x39-640005.2.2">5.2.2<!--tex4ht:ref: LAMBDA-EXPRESSIONS-SECTION --></a>.
<!--l. 2171--><p class="indent" >   The following constructs may also be used to establish bindings of variables,
both ordinary and functional.
<div class=defspec>
<!--l. 2175--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> let </b> <a 
 id="dx51-83001"></a><a 
 id="x51-83002r84"></a>   ( {<i>var|(varvalue)</i>}∗ )  {<i>declaration</i>}∗  {<i>form</i>}∗
</td></tr></table>
<!--l. 2176--><p class="indent" >
</div>
   A <i>let</i> form can be used to execute a series of forms with speciﬁed variables
bound to speciﬁed values.
   More precisely, the form <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((var1 value1)
</td></tr></table>
<!--l. 2182--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (var2 value2)</td></tr></table>
<!--l. 2183--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ...</td></tr></table>
<!--l. 2184--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (varm valuem))</td></tr></table>
<!--l. 2185--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  declaration1</td></tr></table>
<!--l. 2186--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  declaration2</td></tr></table>
<!--l. 2187--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 2188--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  declarationp</td></tr></table>
<!--l. 2189--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  body1</td></tr></table>
                                                                          

                                                                          
<!--l. 2190--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  body2</td></tr></table>
<!--l. 2191--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 2192--><p class="indent" >                                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  bodyn)</td></tr></table>
<!--l. 2194--><p class="indent" >
</div>
</div>
<!--l. 2195--><p class="noindent" >ﬁrst evaluates the expressions value1, value2, and so on, in that order, saving the
resulting values. Then all of the variables varj are bound to the corresponding
values in parallel; each binding will be a lexical binding unless there is a <i>special</i>
declaration to the contrary. The expressions bodyk are then evaluated in order;
the values of all but the last are discarded (that is, the body of a <i>let</i>
form is an implicit <i>progn</i>). The <i>let</i> form returns what evaluating bodyn
produces (if the body is empty, which is fairly useless, <i>let</i> returns <i>nil</i> as its
value). The bindings of the variables have lexical scope and indeﬁnite
extent.
<!--l. 2207--><p class="indent" >   Instead of a list <i>(varj valuej)</i>, one may write simply varj. In this case varj is
initialized to <i>nil</i>. As a matter of style, it is recommended that varj be written only
when that variable will be stored into (such as by <i>setq</i>) before its ﬁrst use. If it is
important that the initial value be <i>nil</i> rather than some undeﬁned value, then it is
clearer to write out <i>(varj <i>nil</i>)</i> if the initial value is intended to mean “false,” or
<i>(varj &#x2019;<i>(</i><i>)</i>)</i> if the initial value is intended to be an empty list. Note that the code <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let (x)
</td></tr></table>
<!--l. 2217--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (integer x))</td></tr></table>
<!--l. 2218--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setq x (gcd y z))</td></tr></table>
<!--l. 2219--><p class="indent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...)</td></tr></table>
<!--l. 2221--><p class="indent" >
</div>
</div>
<!--l. 2222--><p class="noindent" >is incorrect; although <i>x</i> is indeed set before it is used, and is set to a value of the
declared type <i>integer</i>, nevertheless <i>x</i> momentarily takes on the value <i>nil</i> in
violation of the type declaration.
<!--l. 2227--><p class="indent" >   Declarations may appear at the beginning of the body of a <i>let</i>. See
<i>declare</i>.
                                                                          

                                                                          
<div class=newer>
<!--l. 2231--><p class="indent" >   See also <i>destructuring-bind</i>.
</div>
<div class=new>
<!--l. 2235--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to regularize the binding formats for <i>do</i>, <i>do*</i>,
<i>let</i>, <i>let*</i>, <i>prog</i>, <i>prog*</i>, and <i>compiler-let</i>. The new syntactic deﬁnition for <i>let</i> makes
the value optional:
<div class=defmac>
<!--l. 2242--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> let </b> <a 
 id="dx51-83003"></a><a 
 id="x51-83004r85"></a>   ( {<i>var|(var [<i>value</i>] )</i>}∗ )  {<i>declaration</i>}∗  {<i>form</i>}∗
</td></tr></table>
<!--l. 2243--><p class="indent" >
</div>
   This changes <i>let</i> to allow a list <i>(var)</i> to appear, meaning the same as simply
var.
</div>
</div>
</div>
<div class=defspec>
<!--l. 2251--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> let* </b> <a 
 id="dx51-83005"></a><a 
 id="x51-83006r86"></a>   ( {<i>var|(varvalue)</i>}∗ )  {<i>declaration</i>}∗  {<i>form</i>}∗
</td></tr></table>
<!--l. 2252--><p class="indent" >
</div>
   <i>let*</i> is similar to <i>let</i>, but the bindings of variables are performed sequentially
rather than in parallel. This allows the expression for the value of a variable to
refer to variables previously bound in the <i>let*</i> form.
   More precisely, the form <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let* ((var1 value1)
</td></tr></table>
<!--l. 2260--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (var2 value2)</td></tr></table>
<!--l. 2261--><p class="indent" >                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       ...</td></tr></table>
                                                                          

                                                                          
<!--l. 2262--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (varm valuem))</td></tr></table>
<!--l. 2263--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  declaration1</td></tr></table>
<!--l. 2264--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  declaration2</td></tr></table>
<!--l. 2265--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 2266--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  declarationp</td></tr></table>
<!--l. 2267--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  body1</td></tr></table>
<!--l. 2268--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  body2</td></tr></table>
<!--l. 2269--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 2270--><p class="indent" >                                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  bodyn)</td></tr></table>
<!--l. 2272--><p class="indent" >
</div>
</div>
<!--l. 2273--><p class="noindent" >ﬁrst evaluates the expression value1, then binds the variable var1 to that value; then
it evaluates value2 and binds var2; and so on. The expressions bodyj are then
evaluated in order; the values of all but the last are discarded (that is, the body of
a <i>let*</i> form is an implicit <i>progn</i>). The <i>let*</i> form returns the results of evaluating
bodyn (if the body is empty, which is fairly useless, <i>let*</i> returns <i>nil</i> as its
value). The bindings of the variables have lexical scope and indeﬁnite
extent.
<!--l. 2283--><p class="indent" >   Instead of a list <i>(varj valuej)</i>, one may write simply varj. In this case varj is
initialized to <i>nil</i>. As a matter of style, it is recommended that varj be written only
when that variable will be stored into (such as by <i>setq</i>) before its ﬁrst use. If it is
important that the initial value be <i>nil</i> rather than some undeﬁned value,
then it is clearer to write out <i>(varj <i>nil</i>)</i> if the initial value is intended to
mean “false,” or <i>(varj &#x2019;<i>(</i><i>)</i>)</i> if the initial value is intended to be an empty
list.
<!--l. 2293--><p class="indent" >   Declarations may appear at the beginning of the body of a <i>let*</i>. See
<i>declare</i>.
<div class=new>
<!--l. 2297--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to regularize the binding formats for <i>do</i>, <i>do*</i>,
<i>let</i>, <i>let*</i>, <i>prog</i>, <i>prog*</i>, and <i>compiler-let</i>. The new syntactic deﬁnition for <i>let*</i>
makes the value optional:
<div class=defmac>
<!--l. 2304--><p class="noindent" ><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> let* </b> <a 
 id="dx51-83007"></a><a 
 id="x51-83008r87"></a>   ( {<i>var|(var [<i>value</i>] )</i>}∗ )  {<i>declaration</i>}∗  {<i>form</i>}∗
</td></tr></table>
<!--l. 2305--><p class="indent" >
</div>
   This changes <i>let*</i> to allow a list <i>(var)</i> to appear, meaning the same as simply
var.
</div>
</div>
</div>
<div class=obsolete>
<div class=defspec>
<!--l. 2313--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> compiler-let </b> <a 
 id="dx51-83009"></a><a 
 id="x51-83010r88"></a>   ( {<i>var|(varvalue)</i>}∗ )  {<i>form</i>}∗
</td></tr></table>
<!--l. 2315--><p class="indent" >
</div>
   When executed by the Lisp interpreter, <i>compiler-let</i> behaves exactly like <i>let</i>
with all the variable bindings implicitly declared <i>special</i>. When the compiler
processes this form, however, no code is compiled for the bindings; instead,
the processing of the body by the compiler (including, in particular, the
expansion of any macro calls within the body) is done with the special
variables bound to the indicated values in the execution context of the
compiler. This is primarily useful for communication among complicated
macros.
   Declarations may not appear at the beginning of the body of a <i>compiler-let</i>.
<div class=rationale>
   <b>Rationale:</b> Because of the unorthodox handling by <i>compiler-let</i> of its variable
bindings, it would be complicated and confusing to permit declarations that apparently
referred to the variables bound by <i>compiler-let</i>. Disallowing declarations eliminates the
problem.
</div>
   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to regularize the binding formats for <i>do</i>, <i>do*</i>,
<i>let</i>, <i>let*</i>, <i>prog</i>, <i>prog*</i>, and <i>compiler-let</i>. The new syntactic deﬁnition for
<i>compiler-let</i> makes the value optional:
<div class=defmac>
   <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> compiler-let </b> <a 
 id="dx51-83011"></a><a 
 id="x51-83012r89"></a>   ( {<i>var|(var [<i>value</i>] )</i>}∗ )  {<i>form</i>}∗
</td></tr></table>
<!--l. 2348--><p class="indent" >
</div>
   This changes <i>compiler-let</i> to allow a list <i>(var)</i> to appear, meaning the same as
simply var.
</div>
</div>
</div>
<div class=newer>
<!--l. 2356--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to remove <i>compiler-let</i> from the language. Many
uses of <i>compiler-let</i> can be replaced with more portable code that uses <i>macrolet</i>
or <i>symbol-macrolet</i>.
</div>
<div class=defspec>
<!--l. 2365--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> progv </b> <a 
 id="dx51-83013"></a><a 
 id="x51-83014r90"></a>   symbols values  {<i>form</i>}∗
</td></tr></table>
<!--l. 2366--><p class="indent" >
</div>
   <i>progv</i> is a special form that allows binding one or more dynamic variables
whose names may be determined at run time. The sequence of forms (an implicit
<i>progn</i>) is evaluated with the dynamic variables whose names are in the list
symbols bound to corresponding values from the list values. (If too few values are
supplied, the remaining symbols are bound and then made to have no value; see
<i>makunbound</i>. If too many values are supplied, the excess values are ignored.) The
results of the <i>progv</i> form are those of the last form. The bindings of the dynamic
variables are undone on exit from the <i>progv</i> form. The lists of symbols and values
are computed quantities; this is what makes <i>progv</i> diﬀerent from, for
example, <i>let</i>, where the variable names are stated explicitly in the program
text.
<i>
   progv</i> is particularly useful for writing interpreters for languages embedded in
Lisp; it provides a handle on the mechanism for binding dynamic variables.
                                                                          

                                                                          
</div>
<div class=defspec>
<!--l. 2388--><p class="noindent" ><div class=tabbing>
   )
</div> }∗ ) {<i>form</i>}∗   <i>[Special form]</i><b> labels </b> <a 
 id="dx51-83017"></a><a 
 id="x51-83018r92"></a>  ( {<i>(namelambda−list [[ <i> {<i>declaration</i>}∗ |
doc-string
</div> ]] form∗)∗) form ∗macrolet((namevarlist &#x003C; declaration ∗|doc − string &#x003E; form∗)∗) form∗
<i>
<!--l. 2398--><p class="indent" >   ﬂet</i> may be used to deﬁne locally named functions. Within the body of the <i>ﬂet</i>
form, function names matching those deﬁned by the <i>ﬂet</i> refer to the locally
deﬁned functions rather than to the global function deﬁnitions of the same
name.
<!--l. 2403--><p class="indent" >   Any number of functions may be simultaneously deﬁned. Each deﬁnition is
similar in format to a <i>defun</i> form: ﬁrst a name, then a parameter list (which may
contain <i>&#x0026;optional</i>, <i>&#x0026;rest</i>, or <i>&#x0026;key</i> parameters), then optional declarations and
documentation string, and ﬁnally a body. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬂet ((safesqrt (x) (sqrt (abs x))))
</td></tr></table>
<!--l. 2409--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ;; The safesqrt function is used in two places.</td></tr></table>
<!--l. 2410--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (safesqrt (apply #&#x2019;+ (map &#x2019;list #&#x2019;safesqrt longlist))))</td></tr></table>
<!--l. 2412--><p class="indent" >
</div>
</div>
<!--l. 2414--><p class="indent" >   The <i>labels</i> construct is identical in form to the <i>ﬂet</i> construct. These constructs
diﬀer in that the scope of the deﬁned function names for <i>ﬂet</i> encompasses only
the body, whereas for <i>labels</i> it encompasses the function deﬁnitions themselves.
That is, <i>labels</i> can be used to deﬁne mutually recursive functions, but
<i>ﬂet</i> cannot. This distinction is useful. Using <i>ﬂet</i> one can locally redeﬁne
a global function name, and the new deﬁnition can refer to the global
deﬁnition; the same construction using <i>labels</i> would not have that eﬀect. <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun integer-power (n k)       ;A highly &#x0022;bummed&#x0022; integer
</td></tr></table>
<!--l. 2424--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (integer n))          ; exponentiation routine</td></tr></table>
<!--l. 2425--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (type (integer 0 *) k))</td></tr></table>
<!--l. 2426--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (labels ((expt0 (x k a)</td></tr></table>
<!--l. 2427--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (declare (integer x a) (type (integer 0 *) k))</td></tr></table>
<!--l. 2428--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (cond ((zerop k) a)</td></tr></table>
<!--l. 2429--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   ((evenp k) (expt1 (* x x) (ﬂoor k 2) a))</td></tr></table>
<!--l. 2430--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (t (expt0 (* x x) (ﬂoor k 2) (* x a)))))</td></tr></table>
<!--l. 2431--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (expt1 (x k a)</td></tr></table>
<!--l. 2432--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (declare (integer x a) (type (integer 1 *) k))</td></tr></table>
<!--l. 2433--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (cond ((evenp k) (expt1 (* x x) (ﬂoor k 2) a))</td></tr></table>
<!--l. 2434--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (t (expt0 (* x x) (ﬂoor k 2) (* x a))))))</td></tr></table>
<!--l. 2435--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (expt0 n k 1)))</td></tr></table>
<!--l. 2437--><p class="indent" >
</div>
</div>
<i>
<!--l. 2439--><p class="indent" >   macrolet</i> is similar in form to <i>ﬂet</i> but deﬁnes local macros, using the same
format used by <i>defmacro</i>. The names established by <i>macrolet</i> as names for macros
are lexically scoped.
<div class=new>
<!--l. 2445--><p class="indent" >   I have observed that, while most Common Lisp users pronounce <i>macrolet</i> to
rhyme with “silhouette,” a small but vocal minority pronounce it to rhyme with
“Chevrolet.” A very few extremists furthermore adjust their pronunciation of <i>ﬂet</i>
similarly: they say “ﬂay.” Hey, hey! Tr`es outr´e.
</div>
<!--l. 2453--><p class="indent" >   Macros often must be expanded at “compile time” (more generally, at a time
before the program itself is executed), and so the run-time values of variables are
not available to macros deﬁned by <i>macrolet</i>.
<div class=obsolete>
<!--l. 2459--><p class="indent" >   The precise rule is that the macro-expansion functions deﬁned by
<i>macrolet</i> are deﬁned in the global environment; lexically scoped entities that
would ordinarily be lexically apparent are not visible within the expansion
functions.
</div>
                                                                          

                                                                          
<div class=newer>
<!--l. 2466--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to retract the previous sentence and specify
that the macro-expansion functions created by <i>macrolet</i> are deﬁned in the lexical
environment in which the <i>macrolet</i> form appears, not in the null lexical
environment. Declarations, <i>macrolet</i> deﬁnitions, and <i>symbol-macrolet</i> deﬁnitions
aﬀect code within the expansion functions in a <i>macrolet</i>, but the consequences are
undeﬁned if such code attempts to refer to any local variable or function bindings
that are visible in that lexical environment.
</div>
<!--l. 2477--><p class="indent" >   However, lexically scoped entities are visible within the body of the <i>macrolet</i>
form and are visible to the code that is the expansion of a macro call. The
following example should make this clear: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Example of scoping in macrolet.
</td></tr></table>
<!--l. 2483--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2484--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun foo (x ﬂag)</td></tr></table>
<!--l. 2485--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (macrolet ((fudge (z)</td></tr></table>
<!--l. 2486--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                ;;The parameters <i>x</i> and <i>ﬂag</i> are not accessible</td></tr></table>
<!--l. 2487--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                ;; at this point; a reference to <i>ﬂag</i> would be to</td></tr></table>
<!--l. 2488--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                ;; the global variable of that name.</td></tr></table>
<!--l. 2489--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                <tt>‘</tt>(if ﬂag</td></tr></table>
<!--l. 2490--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                     (* ,z ,z)</td></tr></table>
<!--l. 2491--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                     ,z)))</td></tr></table>
<!--l. 2492--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ;;The parameters <i>x</i> and <i>ﬂag</i> are accessible here.</td></tr></table>
<!--l. 2493--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (+ x</td></tr></table>
<!--l. 2494--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (fudge x)</td></tr></table>
<!--l. 2495--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (fudge (+ x 1)))))</td></tr></table>
<!--l. 2497--><p class="indent" >
</div>
</div>
<!--l. 2498--><p class="noindent" >The body of the <i>macrolet</i> becomes <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(+ x
</td></tr></table>
<!--l. 2500--><p class="indent" >                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (if ﬂag</td></tr></table>
                                                                          

                                                                          
<!--l. 2501--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (* x x)</td></tr></table>
<!--l. 2502--><p class="indent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       x))</td></tr></table>
<!--l. 2503--><p class="indent" >                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (if ﬂag</td></tr></table>
<!--l. 2504--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (* (+ x 1) (+ x 1))</td></tr></table>
<!--l. 2505--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (+ x 1)))</td></tr></table>
<!--l. 2507--><p class="indent" >
</div>
</div>
<!--l. 2508--><p class="noindent" >after macro expansion. The occurrences of <i>x</i> and <i>ﬂag</i> legitimately refer to the
parameters of the function <i>foo</i> because those parameters are visible at the site of
the macro call which produced the expansion.
<div class=newer>
<!--l. 2513--><p class="indent" >   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to specify that the body of each function or
expander function deﬁned by <i>ﬂet</i>, <i>labels</i>, or <i>macrolet</i> is implicitly enclosed in a
<i>block</i> construct whose name is the same as the name of the function. Therefore
<i>return-from</i> may be used to exit from the function.
</div>
<div class=newer>
<!--l. 2522--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to extend <i>ﬂet</i> and <i>labels</i> to accept any
function-name (a symbol or a list whose car is <i>setf </i>—see section <a 
href="clmse35.html#x47-770007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>) as a name for
a function to be locally deﬁned. In this way one can create local deﬁnitions for
<i>setf </i> expansion functions. (X3J13 explicitly declined to extend <i>macrolet</i> in the
same manner.)
</div>
<div class=new>
<!--l. 2531--><p class="indent" >   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to change <i>ﬂet</i>, <i>labels</i>, and <i>macrolet</i> to allow
declarations to appear before the body. The new descriptions are therefore as
follows:
<div class=defmac>
<!--l. 2538--><p class="noindent" ><div class=tabbing>
   )
</div> }∗ ) {<i>declaration</i>}∗  {<i>form</i>}∗  <i>[Macro]</i><b> labels </b> <a 
 id="dx51-83021"></a><a 
 id="x51-83022r94"></a>  ( {<i>(namelambda−list [[ <i> {<i>declaration</i>}∗
| doc-string
</div> ]] form∗)∗)declaration ∗ form ∗macrolet((namevarlist &#x003C; declaration ∗|doc − string &#x003E; form∗)∗)declaration∗ form∗
                                                                          

                                                                          
<!--l. 2548--><p class="indent" >   These are now syntactically more similar to such other binding forms as
<i>let</i>.
<!--l. 2551--><p class="indent" >   For <i>ﬂet</i> and <i>labels</i>, the bodies of the locally deﬁned functions are part of the
scope of pervasive declarations appearing before the main body. (This is
consistent with the treatment of initialization forms in <i>let</i>.) For <i>macrolet</i>,
however, the bodies of the locally deﬁned macro expander functions are not
included in the scope of pervasive declarations appearing before the main body.
(This is consistent with the rule, stated below, that the bodies of macro expander
functions are in the global environment, not the local lexical environment.) Here is
an example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬂet ((stretch (x) (* x *stretch-factor*))
</td></tr></table>
<!--l. 2563--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (chop (x) (- x *chop-margin*)))</td></tr></table>
<!--l. 2564--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (inline stretch chop))   ;Illegal in original Common Lisp</td></tr></table>
<!--l. 2565--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (if (&#x003E; x *chop-margin*) (stretch (chop x)) (chop (stretch x))))</td></tr></table>
<!--l. 2567--><p class="indent" >
</div>
</div>
<!--l. 2568--><p class="noindent" >X3J13 voted to permit declarations of the sort noted above.
</div>
</div>
</div>
<div class=new>
<div class=defspec>
<!--l. 2576--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Special form]</i><b> symbol-macrolet </b> <a 
 id="dx51-83023"></a><a 
 id="x51-83024r95"></a>   ( {<i>(varexpansion)</i>}∗ )  {<i>declaration</i>}∗  {<i>form</i>}∗
</td></tr></table>
<!--l. 2578--><p class="indent" >
</div>
   X3J13 voted in June 1988 ⟨<b>?</b>⟩ to adopt the Common Lisp Object System. Part
of this proposal is a general mechanism, <i>symbol-macrolet</i>, for treating certain
variable names as if they were parameterless macro calls. This facility may be
useful independent of CLOS. X3J13 voted in March 1989 ⟨<b>?</b>⟩ to modify the
                                                                          

                                                                          
deﬁnition of <i>symbol-macrolet</i> substantially and also voted ⟨<b>?</b>⟩ to allow
declarations before the body of <i>symbol-macrolet</i> but with peculiar treatment of
<i>special</i> and type declarations.
   The forms are executed as an implicit <i>progn</i> in a lexical environment that
causes every reference to any deﬁned var to be replaced by the corresponding
expansion. It is as if the reference to the var were a parameterless macro call; the
expansion is evaluated or otherwise processed in place of the reference (in
                                                                          

                                                                          
particular, the expansion form is itself subject to further expansion—this is one of
the changes ⟨<b>?</b>⟩ from the original deﬁnition in the CLOS proposal). Note,
however, that the names of such symbol macros occupy the name space
of variables, not the name space of functions; just as one may have a
function (or macro, or special form) and a variable with the same name
without interference, so one may have an ordinary macro (or function,
or special form) and a symbol macro with the same name. The use of
<i>symbol-macrolet</i> can therefore be shadowed by <i>let</i> or other constructs that bind
variables; <i>symbol-macrolet</i> does not substitute for all occurrences of a var
as a variable but only for those occurrences that would be construed as
references in the scope of a lexical binding of var as a variable. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(symbol-macrolet ((pollyanna &#x2019;goody))
</td></tr></table>
<!--l. 2618--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (list pollyanna (let ((pollyanna &#x2019;two-shoes)) pollyanna)))</td></tr></table>
<!--l. 2619--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ⇒ (goody two-shoes), not (goody goody)</td></tr></table>
<!--l. 2621--><p class="indent" >
</div>
</div>
<!--l. 2623--><p class="noindent" >One might think that <i>&#x2019;goody</i> simply replaces all occurrences of <i>pollyanna</i>, and so the
value of the <i>let</i> would be <i>goody</i>; but this is not so. A little reﬂection shows that
under this incorrect interpretation the body in expanded form would be <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list &#x2019;goody (let ((&#x2019;goody &#x2019;two-shoes)) &#x2019;goody))
</td></tr></table>
<!--l. 2629--><p class="indent" >
</div>
</div>
<!--l. 2630--><p class="noindent" >which is syntactically malformed. The correct expanded form is <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(list &#x2019;goody (let ((pollyanna &#x2019;two-shoes)) pollyanna))
</td></tr></table>
<!--l. 2633--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 2634--><p class="noindent" >because the rebinding of <i>pollyanna</i> by the <i>let</i> form shadows the symbol macro
deﬁnition.
<!--l. 2637--><p class="indent" >   The expansion for each var is not evaluated at binding time but only after it
has replaced a reference to the var. The <i>setf </i> macro allows a symbol macro to be
used as a place, in which case its expansion is used; moreover, <i>setq</i> of
a variable that is really a symbol macro will be treated as if <i>setf </i> had
been used. The values of the last form are returned, or <i>nil</i> if there is no
value.
<!--l. 2645--><p class="indent" >   See <i>macroexpand</i> and <i>macroexpand-1</i>; they will expand symbol macros as well
as ordinary macros.
<!--l. 2648--><p class="indent" >   Certain declarations before the body are handled in a peculiar manner; see
section <a 
href="clmse51.html#x65-1040009.1">9.1<!--tex4ht:ref: DECLARE-SYNTAX-SECTION --></a>.
</div>
</div>
                                                                          

                                                                          
   <!--l. 2655--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse40.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse38.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse38.html#tailclmse38.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse39.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse39.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 2655--><p class="indent" >   <a 
 id="tailclmse39.html"></a>  
</body></html> 
