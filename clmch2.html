<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>2 Data Types Типы данных</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 6--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse3.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse2.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse2.html#tailclmse2.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmch2.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clm.html#clmch2.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h2 class="chapterHead"><span class="titlemark">Chapter 2</span><br /><a 
 id="x9-150002"></a>Data Types Типы данных</h2>
<!--l. 9--><p class="noindent" >Common Lisp provides a variety of types of data objects. It is important to note
that in Lisp it is data objects that are typed, not variables. Any variable can have
any Lisp object as its value. (It is possible to make an explicit declaration that a
variable will in fact take on one of only a limited set of values. However, such a
declaration may always be omitted, and the program will still run correctly. Such
a declaration merely constitutes advice from the user that may be useful in
gaining eﬃciency. See <i>declare</i>.)
<!--l. 18--><p class="indent" >   Common Lisp предоставляет множество типов для объектов данных.
Необходимо подчеркнуть, что в Lisp&#x2019;е типизированы данные, а не
переменные. Любая переменная может содержать данные любого типа.
(Можно указать явно, что некоторая переменная фактически может
содержать только один или конечное множество типов объектов.
Однако, такая декларация может быть опущена, и программа будет
выполняться корректно. Такая декларация содержит рекомендация от
пользователя, и это может быть полезным при оптимизации. См.
<i>declare</i>.)
<!--l. 28--><p class="indent" >   In Common Lisp, a data type is a (possibly inﬁnite) set of Lisp objects. Many
Lisp objects belong to more than one such set, and so it doesn&#x2019;t always make
sense to ask what is the type of an object; instead, one usually asks only whether
an object belongs to a given type. The predicate <i>typep</i> may be used to ask
whether an object belongs to a given type, and the function <i>type-of </i> returns a
type to which a given object belongs.
<!--l. 37--><p class="indent" >   В Common Lisp&#x2019;е тип данных является (возможно бесконечным)
множеством Lisp объектов. Многие объекты Lisp&#x2019;а принадлежат к более чем
одному множеству типов, так что иногда не имеет смысла спрашивать тип
объекта; вместо этого задается вопрос о принадлежности объекта к
нужному типу. Предикат <i>typep</i> может использоваться для определения
принадлежности объекта к заданному типу, а функция <i>type-of </i> возвращает
тип, к которому принадлежит заданный объект.
<!--l. 46--><p class="indent" >   The data types deﬁned in Common Lisp are arranged into a hierarchy
(actually a partial order) deﬁned by the subset relationship. Certain sets of
objects, such as the set of numbers or the set of strings, are interesting enough to
deserve labels. Symbols are used for most such labels (here, and throughout this
book, the word “symbol” refers to atomic symbols, one kind of Lisp object,
elsewhere known as literal atoms). See chapter <a 
href="clmch4.html#x26-440004">4<!--tex4ht:ref: DTSPEC --></a> for a complete description of
                                                                          

                                                                          
type speciﬁers.
<!--l. 56--><p class="indent" >   Типы данных в Common Lisp сложены в иерархию (фактически в порядке
убывания объема) определенную отношениями подмножеств. Несомненно
множества объектов, такие как множество чисел и множество строк
заслуживают идентификаторы. Для многих этих идентификаторов
используются символы (здесь и далее, слово «символ» ссылается на тип Lisp
объектов символ, известный также как literal atom). См. главу <a 
href="clmch4.html#x26-440004">4<!--tex4ht:ref: DTSPEC --></a> подробно
описывающую определения типов.
<!--l. 65--><p class="indent" >   The set of all objects is speciﬁed by the symbol <i>t</i>. The empty data type, which
contains no objects, is denoted by <i>nil</i>.
<!--l. 69--><p class="indent" >   Множество все объектов определяется символом <i>t</i>. Пустой тип данных,
который не содержит объектов обозначается с помощью <i>nil</i>.
<div class=obsolete>
<!--l. 74--><p class="indent" >   A type called <i>common</i> encompasses all the data objects required by the
Common Lisp language. A Common Lisp implementation is free to provide other
data types that are not subtypes of <i>common</i>.
</div>
<div class=newer>
<!--l. 80--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to remove the type <i>common</i> (and the
predicate <i>commonp</i>) from the language, on the grounds that it has not proved to
be useful in practice and that it could be diﬃcult to redeﬁne in the face of other
changes to the Common Lisp type system (such as the introduction of CLOS
classes).
</div>
<!--l. 89--><p class="indent" >   The following categories of Common Lisp objects are of particular interest:
numbers, characters, symbols, lists, arrays, structures, and functions. There are
others as well. Some of these categories have many subdivisions. There are also
standard types deﬁned to be the union of two or more of these categories. The
categories listed above, while they are data types, are neither more nor less “real”
than other data types; they simply constitute a particularly useful slice across the
type hierarchy for expository purposes.
<!--l. 100--><p class="indent" >   Следующие категории объектов Common Lisp&#x2019;а в особенности интересны:
числа (numbers), знаки (characters), символы (symbols), списки (lists),
массивы (arrays), структуры (structures) и функции (functions). Другие типы
тоже, конечно, интересны. Некоторые из этих категорий имеют много
подразделов. Так же есть стандартные типы, которые определены,
как объединение двух и более данных категорий. Вышеупомянутые
категории, являясь типами объектов, are neither more nor less «real»
                                                                          

                                                                          
than other data types; они просто составляют объединения типов для
наглядности.
<!--l. 110--><p class="indent" >   Here are brief descriptions of various Common Lisp data types. The remaining
sections of this chapter go into more detail and also describe notations for objects
of each type. Descriptions of Lisp functions that operate on data objects of each
type appear in later chapters.
<!--l. 116--><p class="indent" >   Вот краткое изложение о различных Common Lisp&#x2019;овых типах данных.
Оставшиеся разделы данной главы рассматривают типы более детально, а
также описывают нотации для объектов для каждого типа. Описание
Lisp&#x2019;овых функций, что оперируют объектами данных каждого типа будет
даваться в следующих главах.
      <ul class="itemize1">
      <li class="itemize">Numbers are provided in various forms and representations. Common
      Lisp provides a true integer data type: any integer, positive or negative,
      has in principle a representation as a Common Lisp data object, subject
      only to total memory limitations (rather than machine word width).
      A true rational data type is provided: the quotient of two integers, if
      not an integer, is a ratio. Floating-point numbers of various ranges and
      precisions are also provided, as well as Cartesian complex numbers.
      </li>
      <li class="itemize">Числа  имеют различные формы и представления. Common Lisp
      предоставляет целочисленный (integer) тип данных: любое целое
      число, положительное или отрицательное ограничено размерами
      памяти  (преимущественно  равными  ширине  машинного  слова).
      Также  предоставляется  рациональный  или  дробный  (rational)
      тип  данных:  это  отношение  двух  целых  чисел,  не  являющееся
      целым числом. Также предоставляются числа с плавающей точкой
      различных интервалов и точностей. И наконец в языке также есть
      комплексные числа.
      </li>
      <li class="itemize">Characters represent printed glyphs such as letters or text formatting
      operations. Strings are one-dimensional arrays of characters. Common
      Lisp  provides  for  a  rich  character  set,  including  ways  to  represent
      characters of various type styles.
      </li>
      <li class="itemize">Строковые символы представляют печатные символы такие, как
                                                                          

                                                                          
      буквы  или  управляющие  форматированием  символы.  Строки
      являются   одномерными   массивами   символов.   Common   Lisp
      предоставляет  богатое  множество  символов,  включая  пути  для
      представления различных стилей печати.
      </li>
      <li class="itemize">Symbols (sometimes called atomic symbols for emphasis or clarity) are
      named data objects. Lisp provides machinery for locating a symbol
      object, given its name (in the form of a string). Symbols have property
      lists, which in eﬀect allow symbols to be treated as record structures
      with an extensible set of named components, each of which may be any
      Lisp object. Symbols also serve to name functions and variables within
      programs.
      </li>
      <li class="itemize">Символы   (иногда   называемые   atomic   symbols   для   ясности)
      являются именованными оpбъектами данных. Lisp предоставляет
      механизм  определеющий  местоположение  объекта  символа  по
      заданному  имени  (в  форме  строки).  У  символов  есть  списки
      свойств,  которые  фактически  позволяют  использовать  символы
      в  качестве  структур,  с  расширяемым  множеством  имен  полей,
      каждое из которых может быть любым Lisp объектом. Символы
      также   служат   для   именования   функций   и   переменных   в
      программе.
      </li>
      <li class="itemize">Lists are sequences represented in the form of linked cells called conses.
      There is a special object (the symbol <i>nil</i>) that is the empty list. All
      other lists are built recursively by adding a new element to the front
      of an existing list. This is done by creating a new cons, which is an
      object having two components called the car and the cdr. The car may
      hold anything, and the cdr is made to point to the previously existing
      list. (Conses may actually be used completely generally as two-element
      record structures, but their most important use is to represent lists.)
      </li>
      <li class="itemize">Списки  (прим.  автора:  те  самые,  из  которых  и  заварилась  вся
      каша) это последовательности представленная в форме связанных
      ячеек, называемых cons-ячейками. Для обозначения пустого списка
                                                                          

                                                                          
      служит  специальный  объект  (обозначаемые  символом  <i>nil</i>).  Все
      остальные списки создаются рекурсивно, с помощью добавления
      новых элементов в начало существующего списка. Это происходит
      так:  создается  новая  cons-ячейка,  которая  является  объектом,
      имеющим  два  компонента,  называемых  car  и  cdr.  Car  может
      хранить,  что  угодно,  а  cdr  создан  для  хранения  указателя  на
      существующий ранее список. (Cons-ячейки могут использоваться
      для хранения храненеия записи структуры из двух элементов, но
      это не главное их предназначение.)
      </li>
      <li class="itemize">Arrays are dimensioned collections of objects. An array can have any
      non-negative number of dimensions and is indexed by a sequence of
      integers. A general array can have any Lisp object as a component;
      other types of arrays are specialized for eﬃciency and can hold only
      certain types of Lisp objects. It is possible for two arrays, possibly
      with diﬀering dimension information, to share the same set of elements
      (such that modifying one array modiﬁes the other also) by causing one
      to be displaced to the other. One-dimensional arrays of any kind are
      called vectors. One-dimensional arrays of characters are called strings.
      One-dimensional arrays of bits (that is, of integers whose values are 0
      or 1) are called bit-vectors.
      </li>
      <li class="itemize">Массивы - это n-мерные коллекции объектов. Массив может иметь
      любое неотрицательное количество измерений и индексироваться
      с помощью последовательности целых чисел. Общий тип массива
      может  содержать  любой  Lisp  объект;  другие  типы  массивов
      специализируются для эффективности и могут содержать только
      определенные типы Lisp объектов. Также существует возможность
      того, что два массива, возможно с разным количеством измерений,
      указывают на одно и то же подмножество объектов (если изменить
      первый массив, изменится и второй). Это достигается с помощью
      указания для одного массива быть относительным для другого
      массива. Одномерные массивы любого типа называются векторами
      (vectors).  Одномерные  массивы  строковых  символов  называются
      строки.  Одномерные  массивы  битов  (это  целое  число,  которое
      может  содержать  0  или  1)  называются  битовыми  векторами
                                                                          

                                                                          
      (bit-vectors).
      </li>
      <li class="itemize">Hash tables provide an eﬃcient way of mapping any Lisp object (a key)
      to an associated object.
      </li>
      <li class="itemize">Хеш-таблицы предоставляют эффективный путь для связывания
      любого Lisp объекта (ключа) с другим объектом (значением).
      </li>
      <li class="itemize">Readtables are used to control the built-in expression parser <i>read</i>.
      </li>
      <li class="itemize">Таблицы   чтения   (readtables)   используется   для   управления
      парсером выражений <i>read</i>. (прим. автора: это та знаменитая штука
      для создания макроридеров для изменения синтаксиса языка)
      </li>
      <li class="itemize">Packages  are collections of symbols that serve as name spaces. The
      parser recognizes symbols by looking up character sequences in the
      current package.
      </li>
      <li class="itemize">Пакеты являются коллекциями символов и служат для разделения
      пространств имен. Парсер распознает символы с помощью поиска
      последовательностей строковых символов в текущем пакете.
      </li>
      <li class="itemize">Pathnames       represent        names        of        ﬁles        in        a
      fairly implementation-independent manner. They are used to interface
      to the external ﬁle system.
      </li>
      <li class="itemize">Pathnames  представляют имена файлов на кроссплатформенный
      лад. Они используются для взаимодействия с внешней файловой
      системой.
      </li>
      <li class="itemize">Streams represent sources or sinks of data, typically characters or bytes.
      They are used to perform I/O, as well as for internal purposes such as
                                                                          

                                                                          
      parsing strings.
      </li>
      <li class="itemize">Потоки  представляют  источники  данных,  обычно  строковых
      символов или байт. Они используются для ввода/вывода, а также
      для внутренних нужд, например для парсинга строк.
      </li>
      <li class="itemize">Random-states are data structures used to encapsulate the state of the
      built-in random-number generator.
      </li>
      <li class="itemize">Random-states - это структуры данных, используемые для хранения
      состояния встроенного генератора случайных чисел (ГСЧ).
      </li>
      <li class="itemize">Structures are user-deﬁned record structures, objects that have named
      components. The <i>defstruct</i> facility is used to deﬁne new structure types.
      Some Common Lisp implementations may choose to implement certain
      system-supplied data types, such as bignums, readtables, streams, hash
      tables, and pathnames, as structures, but this fact will be invisible to
      the user.
      </li>
      <li class="itemize">Структуры - это определенные пользователем объекты, имеющие
      именованные поля. <i>defstruct</i> используется для определения новых
      типов  структур.  Некоторые  реализации  Common  Lisp  могут
      реализовывать  некоторые  системные  типы  такие,  как  bignums,
      readtables,  streams,  hash  tables  и  pathnames  как  структуры,  но
      фактически это не будет видно пользователю.</li></ul>
<div class=obsolete>
      <ul class="itemize1">
      <li class="itemize">Functions are objects that can be invoked as procedures; these may take
      arguments and return values. (All Lisp procedures can be construed to
      return values and therefore every procedure is a function.) Such objects
      include compiled-functions (compiled code objects). Some functions are
      represented as a list whose car is a particular symbol such as <i>lambda</i>.
      Symbols may also be used as functions.</li></ul>
                                                                          

                                                                          
</div>
<div class=newer>
<!--l. 322--><p class="indent" >   X3J13 voted in June 1988 ⟨<b>?</b>⟩ to specify that symbols are not of type
<i>function</i>, but are automatically coerced to functions in certain situations (see
section <a 
href="clmse15.html#x22-400002.13">2.13<!--tex4ht:ref: FUNCTION-TYPE-SECTION --></a>).
</div>
<div class=new>
<!--l. 329--><p class="indent" >   X3J13 voted in June 1988 ⟨<b>?</b>⟩ to adopt the Common Lisp Condition System,
thereby introducing a new category of data objects:
<!--l. 334--><p class="indent" >   Для адаптации Системы Условий Common Lisp, вводятся следующие
категории объектов данных:
      <ul class="itemize1">
      <li class="itemize">Conditions   are   objects   used   to   aﬀect   control   ﬂow   in   certain
      conventional  ways  by  means  of  signals  and  handlers  that  intercept
      those signals. In particular, errors are signaled by raising particular
      conditions, and errors may be trapped by establishing handlers for those
      conditions.
      </li>
      <li class="itemize">Условия (conditions) - это объекты, используемые для управления
      ходом
      выполнения  программы,  с  помощью  сигналов  и  обработчиков
      этих  самых  сигналов.  В  частности,  ошибки  сигнализируются  с
      помощью генерации условия, и эти ошибки могут быть обработаны
      с помощью установки обработчиков для генерируемых условий.</li></ul>
</div>
<div class=new>
<!--l. 355--><p class="indent" >   X3J13 voted in June 1988 ⟨<b>?</b>⟩ to adopt the Common Lisp Object System,
thereby introducing additional categories of data objects:
<!--l. 360--><p class="indent" >   Для адаптации Объектной Системы Common Lisp, вводятся следующие
категории объектов данных:
      <ul class="itemize1">
      <li class="itemize">Classes determine the structure and behavior of other objects, their
      instances. Every Common Lisp data object belongs to some class. (In
      some ways the CLOS class system is a generalization of the system of
      type speciﬁers of the ﬁrst edition of this book, but the class system
      augments the type system rather than supplanting it.)
                                                                          

                                                                          
      </li>
      <li class="itemize">Классы  определяют  структуру  и  поведение  других  объектов,
      являющихся  экземплярами  данных  классов.  Каждый  объект
      данных принадлежит некоторому классу.
      </li>
      <li class="itemize">Methods  are chunks of code that operate on arguments satisfying a
      particular pattern of classes. Methods are not functions; they are not
      invoked directly on arguments but instead are bundled into generic
      functions.
      </li>
      <li class="itemize">Методы  -  это  код,  который  оперирует  аргументами,  которые
      соотвествуют                       некоторому                       шаблону.
      Методы не являются функциями; они не вызваются напрямую, а
      объединяются в дженерик-функции (generic functions).
      </li>
      <li class="itemize">Generic functions are functions that contain, among other information,
      a set of methods. When invoked, a generic function executes a subset
      of its methods. The subset chosen for execution depends in a speciﬁc
      way on the classes or identities of the arguments to which it is applied.
      </li>
      <li class="itemize">Generic                                                                 функции
      - это функции, которые содержат, кроме всего прочего, множество
      методов. При вызове generic функция вызывает подмножество ее
      методов. Подмножество для выполнения выделяется с помощью
      определения  классов  аргументов  и  выбора  им  соответстующих
      методов.</li></ul>
</div>
<!--l. 404--><p class="indent" >   These categories are not always mutually exclusive. The required relationships
among the various data types are explained in more detail in section <a 
href="clmse17.html#x24-420002.15">2.15<!--tex4ht:ref: DATA-TYPE-RELATIONSHIPS --></a>.
<!--l. 408--><p class="indent" >   Эти категории не всегда взаимоисключаемы. Указанные отношения
между различными типами данных более детально описано в разделе <a 
href="clmse17.html#x24-420002.15">2.15<!--tex4ht:ref: DATA-TYPE-RELATIONSHIPS --></a>.
   <div class="sectionTOCS">
    <span class="sectionToc" >2.1 <a 
href="clmse3.html#x10-160002.1">Numbers Числа</a></span>
                                                                          

                                                                          
<br />     <span class="subsectionToc" >2.1.1 <a 
href="clmse3.html#x10-170002.1.1">Integers Целые числа</a></span>
<br />     <span class="subsectionToc" >2.1.2 <a 
href="clmse3.html#x10-180002.1.2">Ratios Дробные числа</a></span>
<br />     <span class="subsectionToc" >2.1.3 <a 
href="clmse3.html#x10-190002.1.3">Floating-Point Numbers Числа с плавающей точкой</a></span>
<br />     <span class="subsectionToc" >2.1.4 <a 
href="clmse3.html#x10-200002.1.4">Complex Numbers Комплексные числа</a></span>
<br />    <span class="sectionToc" >2.2 <a 
href="clmse4.html#x11-210002.2">Characters Строковые символы</a></span>
<br />     <span class="subsectionToc" >2.2.1 <a 
href="clmse4.html#x11-220002.2.1">Standard Characters</a></span>
<br />     <span class="subsectionToc" >2.2.2 <a 
href="clmse4.html#x11-230002.2.2">Line Divisions Разделители строк</a></span>
<br />     <span class="subsectionToc" >2.2.3 <a 
href="clmse4.html#x11-240002.2.3">Non-standard Characters Нестандартные символы</a></span>
<br />     <span class="subsectionToc" >2.2.4 <a 
href="clmse4.html#x11-250002.2.4">Character Attributes Устарело</a></span>
<br />     <span class="subsectionToc" >2.2.5 <a 
href="clmse4.html#x11-260002.2.5">String Characters Устарело</a></span>
<br />    <span class="sectionToc" >2.3 <a 
href="clmse5.html#x12-270002.3">Symbols Символы</a></span>
<br />    <span class="sectionToc" >2.4 <a 
href="clmse6.html#x13-280002.4">Lists and Conses Списки и Cons-ячейки</a></span>
<br />    <span class="sectionToc" >2.5 <a 
href="clmse7.html#x14-290002.5">Arrays Массивы</a></span>
<br />     <span class="subsectionToc" >2.5.1 <a 
href="clmse7.html#x14-300002.5.1">Vectors Векторы</a></span>
<br />     <span class="subsectionToc" >2.5.2 <a 
href="clmse7.html#x14-310002.5.2">Strings Строки</a></span>
<br />     <span class="subsectionToc" >2.5.3 <a 
href="clmse7.html#x14-320002.5.3">Bit-Vectors</a></span>
<br />    <span class="sectionToc" >2.6 <a 
href="clmse8.html#x15-330002.6">Hash Tables Хеш-таблицы</a></span>
<br />    <span class="sectionToc" >2.7 <a 
href="clmse9.html#x16-340002.7">Readtables Readtables</a></span>
<br />    <span class="sectionToc" >2.8 <a 
href="clmse10.html#x17-350002.8">Packages Пакеты</a></span>
<br />    <span class="sectionToc" >2.9 <a 
href="clmse11.html#x18-360002.9">Pathnames Имена файлов</a></span>
<br />    <span class="sectionToc" >2.10 <a 
href="clmse12.html#x19-370002.10">Streams Потоки</a></span>
<br />    <span class="sectionToc" >2.11 <a 
href="clmse13.html#x20-380002.11">Random-States Random-States</a></span>
<br />    <span class="sectionToc" >2.12 <a 
href="clmse14.html#x21-390002.12">Structures Структуры</a></span>
<br />    <span class="sectionToc" >2.13 <a 
href="clmse15.html#x22-400002.13">Functions Функции</a></span>
<br />    <span class="sectionToc" >2.14 <a 
href="clmse16.html#x23-410002.14">Unreadable Data Objects Нечитаемые объекты данных</a></span>
<br />    <span class="sectionToc" >2.15 <a 
href="clmse17.html#x24-420002.15">Overlap, Inclusion, and Disjointness of Types</a></span>
   </div>














                                                                          

                                                                          
   <!--l. 6--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse3.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse2.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse2.html#tailclmse2.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch2.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clm.html#clmch2.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 6--><p class="indent" >   <a 
 id="tailclmch2.html"></a>  
</body></html> 
