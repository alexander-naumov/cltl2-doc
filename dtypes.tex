%Part{Dtypes, Root = "CLM.MSS"}
% Chapter of Common Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\chapter{Data Types Типы данных}
\label{DTYPES}

Common Lisp provides a variety of types of data objects.  It is important to
note that in Lisp it is data objects that are typed, not variables.
Any variable can have any Lisp object as its value.
(It is possible to make an explicit declaration that a variable will
in fact take on one of only a limited set of values.  However, such
a declaration may always be omitted, and the program will still run correctly.
Such a declaration merely constitutes advice from the user
that may be useful in gaining efficiency.  See \cdf{declare}.)

Common Lisp предоставляет множество типов для объектов
данных. Необходимо подчеркнуть, что в Lisp'е типизированы данные,
а не переменные. Любая переменная может содержать данные любого
типа. (Можно указать явно, что некоторая переменная фактически
может содержать только один или конечное множество типов
объектов. Однако, такая декларация может быть опущена, и программа
будет выполняться корректно. Такая декларация содержит
рекомендация от пользователя, и это может быть полезным при
оптимизации. См. \cdf{declare}.)

In Common Lisp, a data type is a (possibly infinite) set of
Lisp objects.  Many Lisp objects belong to more than one
such set, and so it doesn't always make sense to ask what is \emph{the} type
of an object; instead, one usually asks only whether an object belongs
to a given type.  The predicate \cdf{typep} may be used to ask
whether an object belongs to a given type,
and the function \cdf{type-of} returns \emph{a} type
to which a given object belongs.

В Common Lisp'е тип данных является (возможно бесконечным)
множеством Lisp объектов. Многие объекты Lisp'а принадлежат к
более чем одному множеству типов, так что иногда не имеет смысла
спрашивать тип объекта; вместо этого задается вопрос о
принадлежности объекта к нужному типу. Предикат \cdf{typep} может
использоваться для определения принадлежности объекта к заданному
типу, а функция \cdf{type-of} возвращает тип, к которому
принадлежит заданный объект.

The data types defined in Common Lisp are arranged into a hierarchy (actually
a partial order) defined by the subset relationship.
Certain sets of objects, such as the set of numbers or the
set of strings, are interesting enough to deserve labels.
Symbols are used for most
such labels (here, and throughout this book, the word ``symbol''
refers to atomic symbols, one kind of Lisp object,
elsewhere known as literal atoms).  See chapter~\ref{DTSPEC}
for a complete description of type specifiers.

Типы данных в Common Lisp сложены в иерархию (фактически в порядке
убывания объема) определенную отношениями подмножеств. Несомненно
множества объектов, такие как множество чисел и множество строк
заслуживают идентификаторы. Для многих этих идентификаторов
используются символы (здесь и далее, слово <<символ>> ссылается на
тип Lisp объектов символ, известный также как literal
atom). См. главу~\ref{DTSPEC} подробно описывающую определения
типов. 

The set of all objects is specified
by the symbol {\true}.  The empty data type, which contains no objects, is
denoted by {\nil}.

Множество все объектов определяется символом {\true}. Пустой тип
данных, который не содержит объектов обозначается с помощью
{\nil}. 

\begin{obsolete}
A type called \cdf{common} encompasses all the data
objects required by the Common Lisp language.  A Common Lisp implementation
is free to provide other data types that are not subtypes of \cdf{common}.
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989
\issue{COMMON-TYPE}
to remove the type \cdf{common} (and the predicate \cdf{commonp})
from the language, on the grounds that it has
not proved to be useful in practice and that it could be difficult to redefine in the
face of other changes to the Common Lisp type system (such as the introduction
of CLOS classes).
\end{newer}

The following categories of Common Lisp objects are of particular interest:
numbers, characters, symbols, lists, arrays, structures, and functions.
There are others as well.
Some of these categories
have many subdivisions.  There are also standard types defined to
be the union
of two or more of these categories.  The categories listed above, while they
are data types, are neither more nor less ``real'' than other data types;
they simply constitute a particularly useful slice across
the type hierarchy for expository purposes.

Следующие категории объектов Common Lisp'а в особенности
интересны: числа (numbers), знаки (characters), символы (symbols),
списки (lists), массивы (arrays), структуры (structures) и функции
(functions). Другие типы тоже, конечно, интересны. Некоторые из
этих категорий имеют много подразделов. Так же есть стандартные
типы, которые определены, как объединение двух и более данных
категорий. Вышеупомянутые категории, являясь типами объектов, are
neither more nor less <<real>> than other data types; они просто
составляют объединения типов для наглядности. 

Here are brief descriptions of various Common Lisp data types.
The remaining sections of this chapter go into more detail
and also describe notations for objects
of each type.  Descriptions of Lisp functions that operate
on data objects of each type appear in later chapters.

Вот краткое изложение о различных Common Lisp'овых типах
данных. Оставшиеся разделы данной главы рассматривают типы более
детально, а также описывают нотации для объектов для каждого
типа. Описание Lisp'овых функций, что оперируют объектами данных
каждого типа будет даваться в следующих главах. 

\begin{itemize}
\item
\emph{Numbers} are provided in various forms and representations.
Common Lisp provides a true integer data type: any integer,
positive or negative, has in principle a representation as a
Common Lisp data object, subject only to total memory limitations (rather than
machine word width).
A true rational data type is provided: the quotient of two integers,
if not an integer, is a ratio.
Floating-point numbers of various ranges and precisions are also
provided, as well as
Cartesian complex numbers.

\item
\emph{Числа} имеют различные формы и представления. Common Lisp
предоставляет целочисленный (integer) тип данных: любое целое
число, положительное или отрицательное ограничено размерами памяти
(преимущественно равными ширине машинного слова). Также
предоставляется рациональный или дробный (rational) тип данных:
это отношение двух целых чисел, не являющееся целым числом. Также
предоставляются числа с плавающей точкой различных интервалов и
точностей. И наконец в языке также есть комплексные числа. 

\item
\emph{Characters} represent printed glyphs such as letters
or text formatting operations.  Strings are one-dimensional
arrays of characters.
Common Lisp provides for a rich character set, including ways to
represent characters of various type styles.

\item
\emph{Строковые} символы представляют печатные символы такие, как
буквы или управляющие форматированием символы. Строки являются
одномерными массивами символов. Common Lisp предоставляет богатое
множество символов, включая пути для представления различных
стилей печати. 

\item
\emph{Symbols} (sometimes called \emph{atomic symbols} for emphasis
or clarity) are named data objects.  Lisp provides machinery
for locating a symbol object, given its name (in the form
of a string).  Symbols have \emph{property lists}, which in effect
allow symbols to be treated as record structures with an extensible
set of named components, each of which may be any Lisp object.
Symbols also serve to name functions and variables within programs.

\item
\emph{Символы} (иногда называемые \emph{atomic symbols} для ясности)
являются именованными оpбъектами данных. Lisp предоставляет
механизм определеющий местоположение объекта символа по заданному
имени (в форме строки). У символов есть \emph{списки свойств},
которые фактически позволяют использовать символы в качестве
структур, с расширяемым множеством имен полей, каждое из которых
может быть любым Lisp объектом. Символы также служат для
именования функций и переменных в программе. 

\item
\emph{Lists} are sequences represented in the form of linked cells
called \emph{conses}.  There is a special object (the symbol {\nil})
that is the empty list.  All other lists are built recursively by adding a new
element to the front of an existing list.  This is done by
creating a new \emph{cons}, which is an object having two components
called the \emph{car} and the \emph{cdr}.  The \emph{car} may hold anything,
and the \emph{cdr} is made to point to the previously existing list.
(Conses may actually be used completely generally as two-element
record structures, but their most important use is to represent
lists.)

\item
\emph{Списки} (прим. автора: те самые, из которых и заварилась вся
каша) это последовательности представленная в форме связанных
ячеек, называемых \emph{cons-ячейками}. Для обозначения пустого
списка служит специальный объект (обозначаемые символом
{\nil}). Все остальные списки создаются рекурсивно, с помощью
добавления новых элементов в начало существующего списка. Это
происходит так: создается новая cons-ячейка, которая является
объектом, имеющим два компонента, называемых \emph{car} и {\it
cdr}. Car может хранить, что угодно, а cdr создан для хранения
указателя на существующий ранее список. (Cons-ячейки могут
использоваться для хранения храненеия записи структуры из двух
элементов, но это не главное их предназначение.) 

\item
\emph{Arrays} are dimensioned collections of objects.
An array can have any non-negative number of dimensions and is indexed
by a sequence of integers.  A general array can have any Lisp object as
a component; other types of arrays are specialized for efficiency
and can hold only certain types of Lisp objects.
It is possible for two arrays, possibly with differing dimension information,
to share the same set of elements (such that modifying one array modifies
the other also) by causing one to be \emph{displaced} to the other.
One-dimensional arrays of any kind are called \emph{vectors}.
One-dimensional arrays of characters are called \emph{strings}.
One-dimensional arrays of bits (that is, of integers whose values are 0 or 1)
are called \emph{bit-vectors}.

\item
\emph{Массивы} - это n-мерные коллекции объектов. Массив может
иметь любое неотрицательное количество измерений и индексироваться
с помощью последовательности целых чисел. Общий тип массива может
содержать любой Lisp объект; другие типы массивов специализируются
для эффективности и могут содержать только определенные типы Lisp
объектов. Также существует возможность того, что два массива,
возможно с разным количеством измерений, указывают на одно и то же
подмножество объектов (если изменить первый массив, изменится и
второй). Это достигается с помощью указания для одного массива
\emph{быть относительным} для другого массива. Одномерные массивы
любого типа называются \emph{векторами (vectors)}. Одномерные
массивы строковых символов называются \emph{строки}. Одномерные
массивы битов (это целое число, которое может содержать 0 или 1)
называются \emph{битовыми векторами (bit-vectors)}. 

\item
\emph{Hash tables} provide an efficient way of mapping any
Lisp object (a \emph{key}) to an associated object.

\item
\emph{Хеш-таблицы} предоставляют эффективный путь для связывания
любого Lisp объекта (\emph{ключа}) с другим объектом (значением). 

\item
\emph{Readtables} are used to control the built-in expression parser
\cdf{read}.

\item
\emph{Таблицы чтения (readtables)} используется для управления
парсером выражений \cdf{read}. (прим. автора: это та знаменитая
штука для создания макроридеров для изменения синтаксиса языка) 

\item
\emph{Packages} are collections of symbols that serve as name spaces.
The parser recognizes symbols by looking up character sequences
in the current package.

\item
\emph{Пакеты} являются коллекциями символов и служат для разделения
пространств имен. Парсер распознает символы с помощью поиска
последовательностей строковых символов в текущем пакете. 

\item
\emph{Pathnames} represent names of files in a fairly implementation-independent
manner.  They are used to interface to the external file system.

\item
\emph{Pathnames} представляют имена файлов на кроссплатформенный
лад. Они используются для взаимодействия с внешней файловой
системой. 

\item
\emph{Streams} represent sources or sinks of data, typically characters
or bytes.  They are used to perform I/O, as well as for internal
purposes such as parsing strings.

\item
\emph{Потоки} представляют источники данных, обычно строковых
символов или байт. Они используются для ввода/вывода, а также для
внутренних нужд, например для парсинга строк. 

\item
\emph{Random-states} are data structures used to encapsulate the state
of the built-in random-number generator.

\item
\emph{Random-states} - это структуры данных, используемые для
хранения состояния встроенного генератора случайных чисел (ГСЧ).

\item
\emph{Structures} are user-defined record structures, objects that
have named components.  The \cdf{defstruct} facility is used
to define new structure types.  Some Common Lisp implementations may
choose to implement certain system-supplied data types,
such as \emph{bignums}, \emph{readtables}, \emph{streams},
\emph{hash tables}, and \emph{pathnames}, as structures,
but this fact will be invisible to the user.

\item
\emph{Структуры} - это определенные пользователем объекты, имеющие
именованные поля. \cdf{defstruct} используется для определения
новых типов структур. Некоторые реализации Common Lisp могут
реализовывать некоторые системные типы такие, как \emph{bignums},
\emph{readtables}, \emph{streams}, \emph{hash tables} и {\it
pathnames} как структуры, но фактически это не будет видно
пользователю. 
\end{itemize}

\begin{obsolete}
\begin{itemize}
\item
\emph{Functions} are objects that can be invoked as procedures;
these may take arguments and return values.  (All Lisp procedures
can be construed to return values and therefore every procedure is
a function.)
Such objects include \emph{compiled-functions} (compiled code objects).
Some functions are represented as a list whose \emph{car} is a particular
symbol such as \cdf{lambda}.
Symbols may also be used as functions.
\end{itemize}
\end{obsolete}

\begin{newer}
X3J13 voted in June 1988 \issue{FUNCTION-TYPE}
to specify that symbols are not of type \cdf{function},
but are automatically coerced to functions
in certain situations (see section~\ref{FUNCTION-TYPE-SECTION}).
\end{newer}

\begin{new}
X3J13 voted in June 1988
\issue{CONDITION-SYSTEM}
to adopt the Common Lisp Condition System,
thereby introducing a new category of data objects:

Для адаптации Системы Условий Common Lisp, вводятся следующие
категории объектов данных: 

\begin{itemize}
\item
\emph{Conditions} are objects used to affect control flow in certain
conventional ways by means of signals and handlers that intercept those signals.
In particular, errors are signaled by raising particular conditions,
and errors may be trapped by establishing handlers for those conditions.

\item
\emph{Условия (conditions)} - это объекты, используемые для
управления ходом выполнения программы, с помощью сигналов и
обработчиков этих самых сигналов. В частности, ошибки
сигнализируются с помощью генерации условия, и эти ошибки могут
быть обработаны с помощью установки обработчиков для генерируемых
условий.
\end{itemize}
\end{new}

\begin{new}
X3J13 voted in June 1988
\issue{CLOS}
to adopt the Common Lisp Object System,
thereby introducing additional categories of data objects:

Для адаптации Объектной Системы Common Lisp, вводятся следующие
категории объектов данных: 

\begin{itemize}
\item
\emph{Classes} determine the structure and behavior of other
objects, their \emph{instances}.  Every Common Lisp data object
belongs to some class.  (In some ways the CLOS class system is
a generalization of the system of type specifiers of the first edition of this book,
but the class system augments the type system rather than supplanting it.)

\item
\emph{Классы} определяют структуру и поведение других объектов,
являющихся \emph{экземплярами} данных классов. Каждый объект данных
принадлежит некоторому классу. 

\item
\emph{Methods} are chunks of code that operate on arguments
satisfying a particular pattern of classes.  Methods are
not functions; they are not invoked directly on arguments
but instead are bundled into generic functions.

\item
\emph{Методы} - это код, который оперирует аргументами, которые
соотвествуют некоторому шаблону. Методы не являются функциями; они
не вызваются напрямую, а объединяются в дженерик-функции (generic
functions). 

\item
\emph{Generic functions} are functions that contain, among other
information, a set of methods.  When invoked, a generic function
executes a subset of its methods.  The subset chosen for execution
depends in a specific way on the classes or identities of the arguments
to which it is applied.

\item
\emph{Generic функции} - это функции, которые содержат, кроме всего
прочего, множество методов. При вызове generic функция вызывает
подмножество ее методов. Подмножество для выполнения выделяется с
помощью определения классов аргументов и выбора им соответстующих
методов. 
\end{itemize}
\end{new}

These categories are not always mutually exclusive.
The required relationships among the various data types are
explained in more detail in section~\ref{DATA-TYPE-RELATIONSHIPS}.

Эти категории не всегда взаимоисключаемы. Указанные отношения
между различными типами данных более детально описано в
разделе~\ref{DATA-TYPE-RELATIONSHIPS}. 


\section{Numbers Числа}

Several kinds of numbers are defined in Common Lisp.
They are divided into \emph{integers}; \emph{ratios};
\emph{floating-point numbers}, with names provided for
up to four different floating-point representations; and \emph{complex numbers}.

В Common Lisp'е определены некоторые виды чисел. Они
подразделяются на \emph{целочисленные (integer)}; \emph{дробные
(ratios)}; \emph{плавающей точкой (floating-point)}, с
четырьмя видами пердставления и \emph{комплексные}.

\begin{newer}
X3J13 voted in March 1989 \issue{REAL-NUMBER-TYPE} to add the type \cdf{real}.

X3J13 voted in March 1989 \issue{REAL-NUMBER-TYPE} добавляет тип \cdf{real}.

The \cdf{number} data type encompasses all kinds of
             numbers.  For convenience, there are names for some
             subclasses of numbers as well.  Integers and ratios are of
             type \cdf{rational}.  Rational numbers and floating-point
             numbers are of type \cdf{real}.  Real numbers and complex
             numbers are of type \cdf{number}.

Числовой тип данных захватывает все числовые типы. Также для
удобства предоставлены имены для некоторых числовых
подтипов. Целые числа и дроби принадлежат к
\emph{рациональному}. Рациональные числа и с плавающей точкой к
\emph{действительному}. Действительные и комплексные к \emph{числовому} типу.

             Although the names of these types were chosen with the
             terminology of mathematics in mind, the correspondences
             are not always exact.  Integers and ratios model the
             corresponding mathematical concepts directly.  Numbers
             of type \cdf{float} may be used to approximate real
             numbers, both rational and irrational.  The \cdf{real} type
             includes all Common Lisp numbers that represent
             mathematical real numbers, though there are
             mathematical real numbers (irrational numbers)
             that do not have an exact Common Lisp representation.
             Only \cdf{real} numbers may be ordered using the \cd{<}, \cd{>}, \cd{<=},
             and \cd{>=} functions.

Несмотря на то, что эти типы выбирались из математической
терминологии, соответствие не всегда полное. Модель целочисленных
(integers) и дробных (ratios) типов полностью совпадает с
математической. Числа с \emph{плавающей точкой (float)} могут
использоваться для аппроксимации действительных (real) чисел:
рациональных (rational) и иррациональных
(irrational). \emph{Действительный (real)} тип включает все Common Lisp
числе, что отображают действительные (real) математические числа,
однако для математических действительных (real) чисел
(иррациональных (irrational)) аналогии в Cоmmon Lisp'е нет. Только
\emph{действительные (real)} числа могут быть отсортированы с помощью
функций \cd{<}, \cd{>}, \cd{<=} и \cd{>=}. (Ох жеш FIXME). 

\beforenoterule
\begin{incompatibility}
The Fortran 77 standard defines the term
             \emph{real datum} to mean ``a processor approximation to the value
             of a real number.''  In practice the Fortran \emph{basic real} type
             is the floating-point data type that Common Lisp calls
             \cdf{single-float}.  The Fortran \emph{double precision} type is
             Common Lisp's \cdf{double-float}.  The Pascal \cdf{real} data type is
             an ``implementation-defined subset of the real numbers.''  In
             practice this is usually a floating-point type, often what
             Common Lisp calls \cdf{double-float}.

Примечание о совместимости: стандарт Fortran 77 определяет термин
\emph{действительное число}, как <<аппроксимация значения действительного
числа>>. На практике Fortran'овский \emph{базовый действительный} тип
соотносится с числом плавающей точкой, которое в Common Lisp
зовется \emph{single-float}. Fortran тип \emph{с двойной точностью} является
Common Lisp типом \emph{double-float}. Pascal'евский \emph{действительный} тип
данных является <<платформозависимым подмножеством действительных
чисел>>. На практике это обычно тип с плавающей точкой, то, что в
Common Lisp'е называется \emph{double-float}. 

             A translation of an algorithm written in Fortran or Pascal
             that uses \cdf{real} data usually will use some appropriate
             precision of Common Lisp's \cdf{float} type.  Some algorithms may
             gain accuracy or flexibility by using Common Lisp's
             \cdf{rational} or \cdf{real} type instead.

Трансляция алгоритмов написанные на Фортране или Паскале, что
используют \emph{действительные} числа, обычно соответствует необходимой
точности для Common Lisp'овых типов \emph{с плавающей точкой}
(float). Некоторые алгоритмы могут получить выигрыш или гибкость с
использованием Common Lisp'овых \emph{дробных (rational)} или
\emph{действительных (real)} типов. 
\end{incompatibility}
\afternoterule
\end{newer}

\subsection{Integers Целые числа}
\label{INTEGERS-SECTION}

\indexterm{integer}
The \cdf{integer} data type is intended to represent mathematical integers.
Unlike most programming languages, Common Lisp in principle imposes no limit on
the magnitude of an integer; storage
is automatically allocated as necessary to represent large integers.

\emph{Целочисленный} тип даных предназначен для отображения
математических целых чисел. В отличие от большинства языков
программирования, Common Lisp принципиально не навязывает
ограничений на величину целого числа; место для хранения
выделяется автоматически по мере необходимости для отображения
больших чисел.

In every Common Lisp implementation there is a range of integers that are
represented more efficiently than others; each such integer is called a
\emph{fixnum}, and an integer that is not a fixnum is called a
\emph{bignum}.
Common Lisp is designed to hide this distinction as much as possible;
the distinction between fixnums and bignums is visible to
the user in only a few places where the efficiency of representation is
important.  Exactly which integers are
fixnums is implementation-dependent; typically they will be those
integers in the range $-2^{\hbox{\scriptsize\it n}}$ to $2^{\hbox{\scriptsize\it n}}-1$,
inclusive, for some \emph{n} not less than 15.
See \cdf{most-positive-fixnum} and \cdf{most-negative-fixnum}.

В каждой реализации Common Lisp'а есть интервал целых чисел,
которые хранятся более оптимально, чем другие; каждое такое число
называется \emph{fixnum}, и число не являющееся fixnum называется
\emph{bignum}. Common Lisp спроектирован так, чтобы скрыть различие так
сильно, как это возможно; различие между fixnums и bignums видимо
пользователю, только в тех местах, где важна эффективность работы
алгоритма. Какие числа являются fixnums зависит от реализации;
обычно это числа в интервале от $-2^{\hbox{\scriptsize\it n}}$ to
$2^{\hbox{\scriptsize\it n}}-1$, включительно, для некоторого n не меньше
15. См. \cdf{most-positive-fixnum} и \cdf{most-negative-fixnum}. 

\begin{new}
X3J13 voted in January 1989
\issue{FIXNUM-NON-PORTABLE}
to specify that \cdf{fixnum} must be a supertype
of the type \cd{(signed-byte 16)}, and additionally that the value
of \cdf{array-dimension-limit} must be a fixnum (implying that the implementor
should choose the range of fixnums to be large enough to accommodate the
largest size of array to be supported).

\cdf{fixnum} должен быть супертипом для типа \cd{(signed-byte 16)},
и в дополнение к этому, значения \cdf{array-dimension-limit} должно
принадлежать fixnum (реализаторы должны выбрать интервал fixnum,
чтобы в него можно было включить наибольший число поддерживаемых
измерений для массивов). 

\beforenoterule
\begin{rationale}
This specification allows programmers to declare variables in portable code
to be of type \cdf{fixnum} for efficiency.  Fixnums are guaranteed to
encompass at least the set of 16-bit signed integers
(compare this to the data type \cd{short int} in the C programming language).
In addition, any valid array index must be a fixnum, and therefore variables
used to hold array indices (such as a \cdf{dotimes} variable)
may be declared \cdf{fixnum} in portable code.

Объяснение: Эта спецификация позволяет программистам объявлять
переменные в переносимом коде типа \cdf{fixnum} для
эффективности. Fixnums гарантированно заключают в себе множество
знаковых 16-битных чисел чисел (это сравнимо с типом
данных \cd{short int} в языке программирования C). В дополнение к
всему, любой корректный индекс массива должен быть fixnum, и в
таком случае переменные, которые хранят индексы массива (например
переменная в \cdf{dotimes}) могут быть объявлены как \cdf{fixnum} в
переносимом коде. 
\end{rationale}
\afternoterule
\end{new}

Integers are ordinarily written in decimal notation, as a sequence
of decimal digits, optionally preceded by a sign and optionally followed
by a decimal point.
For example:

Целые числа обычно записываются в десятичном виде, как последовательность десятичных цифр, опционально с предшевствующим знаком и опционально с последующей точкой. Например:
\begin{lisp}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\=\kill
\>0~~~~~\';\textrm{Zero} \\*
\>-0~~~~~\';\textrm{This \emph{always} means the same as \cd{0}} \\*
\>+6~~~~~\';\textrm{The first perfect number} \\
\>28~~~~~\';\textrm{The second perfect number} \\
\>1024.~~~~~\';\textrm{Two to the tenth power} \\*
\>-1~~~~~\';\textrm{$e^{\pi i}$} \\*
\>15511210043330985984000000.~~~~~\';\textrm{25 factorial (25!), probably a bignum}
\end{lisp}

\begin{lisp}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\=\kill
\>0~~~~~\';\textrm{Нуль} \\*
\>-0~~~~~\';\textrm{Это \emph{всегда} значит то же, что и \cd{0}} \\*
\>+6~~~~~\';\textrm{Первое совершенное число} \\
\>28~~~~~\';\textrm{Второе совершенное число} \\
\>1024.~~~~~\';\textrm{Два в десятой степени} \\*
\>-1~~~~~\';\textrm{$e^{\pi i}$} \\*
\>15511210043330985984000000.~~~~~\';\textrm{факториал от 25 (25!),
скорее все bignum}
\end{lisp}

\beforenoterule
\begin{incompatibility}
MacLisp and Lisp Machine Lisp normally assume that integers
are written in octal (radix-8) notation unless a decimal
point is present.
Interlisp assumes integers are written in decimal notation and uses a
trailing \cdf{Q} to indicate octal radix; however, a decimal point,
even in trailing position, \emph{always} indicates a floating-point number.
This is of course consistent with Fortran.  Ada does not permit
trailing decimal points but instead requires them to be embedded.
In Common Lisp, integers written as described
above are always construed to be
in decimal notation, whether or not the decimal point is present;
allowing the decimal point to be present permits compatibility with
MacLisp.

Примечание о совместимости: точка в конце числа используется для
совместимости с MacLisp.
\end{incompatibility}
\afternoterule

\vskip 0pt plus 8pt%manual

Integers may be notated in radices other than ten.
The notation

Целые числа могут быть представлены с основаниями отличнымии от
десяти. Синтаксис: 
\begin{lisp}
\#\emph{nn}r\emph{ddddd}     \textrm{or}     \#\emph{nn}R\emph{ddddd}
\end{lisp}
means the integer in radix-\emph{nn} notation denoted by the digits
\emph{ddddd}.  More precisely, one may write \cd{\#}, a non-empty sequence
of decimal digits representing an unsigned decimal integer \emph{n},
\cdf{r} (or \cdf{R}), an optional sign, and a sequence of radix-\emph{n}
digits, to indicate an integer written in radix \emph{n} (which must be
between 2 and 36, inclusive).  Only legal digits
for the specified radix may be used; for example, an octal number may
contain only the digits 0 through 7.  For digits above 9,
letters of the alphabet of either
case may be used in order.  Binary, octal, and
hexadecimal radices are useful enough to warrant the special
abbreviations \cd{\#b} for \cd{\#2r}, \cd{\#o} for \cd{\#8r}, and
\cd{\#x} for \cd{\#16r}.
For example:

означает, что целое число с основанием \emph{nn} определенное с
помощью цифр и букв \emph{ddddd}. Более точное описание:
символ \cd{\#}, непустая последовательность десятичных цифр
представляющих десятичное число \emph{n}, \cdf{r} (или \cdf{R}), опционально знак + или -, и последовательность цифр для заданной системы счисления (система счисления должна быть между 2 и 36, включительно). Только корректные символы для заданной системы счисления могут использоваться для задания числа; например для восьмеричного числа могут использоваться только цифры от 0 до 7 включительно. Для систем счисления больших десятичной, могут использоваться буквы алфавита в любом регистре в алфавитном порядке. Двоичные, восьмеричные и шестнадцатиричные основания можно использовать с помощью следующих аббревиатур: \cd{\#b} для \cd{\#2r}, \cd{\#o} для \cd{\#8r}, \cd{\#x} для \cd{\#16r}. Например:
\begin{lisp}
~~~~~~~~~~~~~~~~\=\kill
\>\#2r11010101~~~~~\';\textrm{Another way of writing \cd{213} decimal} \\
\>\#b11010101~~~~~\';\textrm{Ditto} \\
\>\#b+11010101~~~~~\';\textrm{Ditto} \\
\>\#o325~~~~~\';\textrm{Ditto, in octal radix} \\
\>\#xD5~~~~~\';\textrm{Ditto, in hexadecimal radix} \\
\>\#16r+D5~~~~~\';\textrm{Ditto} \\
\>\#o-300~~~~~\';\textrm{Decimal -192, written in base 8} \\
\>\#3r-21010~~~~~\';\textrm{Same thing in base 3} \\
\>\#25R-7H~~~~~\';\textrm{Same thing in base 25} \\
\>\#xACCEDED~~~~~\';\textrm{181202413, in hexadecimal radix}
\end{lisp}

\begin{lisp}
~~~~~~~~~~~~~~~~\=\kill
\>\#2r11010101~~~~~\';\textrm{Другой способ определения
числа \cd{213}} \\
\>\#b11010101~~~~~\';\textrm{то же самое} \\
\>\#b+11010101~~~~~\';\textrm{то же самое} \\
\>\#o235~~~~~\';\textrm{То же самое, в восьмеричной системе} \\
\>\#xD5~~~~~\';\textrm{То же самое, в шестнадцатиричной системе} \\
\>\#16r+D5~~~~~\';\textrm{То же самое} \\
\>\#o-300~~~~~\';\textrm{Десятичное число -192, записанное восьмеричным числом} \\
\>\#3r-21010~~~~~\';\textrm{То же самое, в троичное системе счисления} \\
\>\#25R-7H~~~~~\';\textrm{То же самое с основанием 25} \\
\>\#xACCEDED~~~~~\';\textrm{181202413, в шестнадцатиричной системе}
\end{lisp}

\subsection{Ratios Дробные числа}

\indexterm{ratio}
\indexterm{rational}
A \emph{ratio} is a number representing the mathematical ratio
of two integers.  Integers and ratios collectively constitute
the type \cdf{rational}.
The canonical representation of a rational number is as an
integer if its value is integral, and otherwise as the ratio of two
integers, the \emph{numerator} and \emph{denominator}, whose greatest
common divisor is 1, and of which the denominator is positive (and in
fact greater than 1, or else the value would be integral).
A ratio is notated with
\cd{/} as a separator, thus: \cd{3/5}.  It is possible to notate
ratios in non-canonical (unreduced) forms, such as \cd{4/6}, but the
Lisp function \cd{prin1} always prints the canonical form for a
ratio.

\emph{Дробное число} - это число отображающее математическое отношение
между двумя целыми числами. Целые и дробные числа вместе
составляют тип рациональных (rational) чисел. Образцовое
отображение дробных чисел - это целое число, если значение целое,
в противном случае это отношение двух целых чисел, \emph{числителя} и
\emph{знаменателя}, наибольший общий делитель которых единица, в котором
знаменатель положителен (и фактически больший чем единица, иначе
дробь является целым числом). Дробь записывается с помощью
разделителя \cd{/}, так: \cd{3/5}. Есть возможность
использовать нестандартную запись такую, как \cd{4/6}, но Lisp
функция \cd{prin1} всегда выводит дробь в стандартной форме. 

If any computation produces a result that is a ratio of
two integers such that the denominator evenly divides the
numerator, then the result is immediately converted to the equivalent
integer.  This is called the rule of \emph{rational canonicalization}.

Если какое-либо вычисление привело к результату, являющемуся
дробью двух целых чисел, где знаменатель делит числитель нацело,
тогда результат немедленно преобразуется в эквивалентное целое
число. Это называется правилом \emph{канонизации дробей}.

Rational numbers may be written as the possibly signed quotient of
decimal numerals: an optional sign followed by two non-empty sequences of
digits separated by a \cd{/}.  This syntax may be described as
follows:

Дробные числа могут быть записаны так: опционально знак + или -,
за ним следуют две непустые последовательности цифр разделенных с
помощью \cd{/} . Такой синтаксис может быть описан так:

\begin{tabbing}
\emph{ratio} ::= \Mopt{\emph{sign}} \Mplus{\emph{digit}} \cd{/} \Mplus{\emph{digit}}
\end{tabbing}

The second sequence may not consist
entirely of zeros.
For example:

Вторая последовательность не может состоять только из
нулей. Например:  
\begin{lisp}
2/3~~~~~~~~~~~~~~~~~~~~;\textrm{This is in canonical form} \\
4/6~~~~~~~~~~~~~~~~~~~~;\textrm{A non-canonical form for the same number} \\
-17/23~~~~~~~~~~~~~~~~~;\textrm{A not very interesting ratio} \\
-30517578125/32768~~~~~;\textrm{This is $(-5/2)^{15}$} \\
10/5~~~~~~~~~~~~~~~~~~~;\textrm{The canonical form for this is \cd{2}}
\end{lisp}

\begin{lisp}
2/3~~~~~~~~~~~~~~~~~;\textrm{Это каноническая запись} \\
4/6~~~~~~~~~~~~~~~~~;\textrm{Это неканоническая запись предыдущего числа} \\
-17/23~~~~~~~~~~~~~~;\textrm{Не очень интересная дробь} \\
-30517578125/32768~~;\textrm{Это $(-5/12)^{15}$} \\
10/5~~~~~~~~~~~~~~~~;\textrm{Это каноническая запись для \cd{2}}
\end{lisp}

To notate rational numbers in radices other than ten,
one uses the same radix specifiers
(one of \cd{\#\emph{nn}R}, \cd{\#O}, \cd{\#B}, or \cd{\#X}) as for integers.
For example:

Для задания дробей в системе счисления отличной от десятичной, необходимо
использовать спецификатор основания (один из \cd{\#\emph{nn}R}, \cd{\#O}, \cd{\#B} или \cd{\#X}) как и для
целых чисел. Например:

\begin{lisp}
\#o-101/75~~~~~~~~~~;\textrm{Octal notation for \cd{-65/61}} \\
\#3r120/21~~~~~~~~~~;\textrm{Ternary notation for \cd{15/7}} \\
\#Xbc/ad~~~~~~~~~~~~;\textrm{Hexadecimal notation for \cd{188/173}} \\
\#xFADED/FACADE~~~~~;\textrm{Hexadecimal notation for \cd{1027565/16435934}}
\end{lisp}

\begin{lisp}
\#o-101/75~~~~~~~~~;\textrm{Восьмеричная запись для \cd{-65/61}} \\
\#3r120/21~~~~~~~~~;\textrm{Третичная запись для \cd{15/7}} \\
\#Xbc/ad~~~~~~~~~~~;\textrm{Шестнадцатиричная запись для \cd{188/173}} \\
\#xFADED/FACADE~~~~;\textrm{Шестнадцатиричная запись для \cd{1027565/16435934}} 
\end{lisp}

\subsection{Floating-Point Numbers Числа с плавающей точкой}

Common Lisp allows an implementation to provide one or more kinds of
floating-point number, which collectively make up the type \cdf{float}.
Now a floating-point number is a (mathematical)
rational number of the form
$\emph{s} \cdot \emph{f} \cdot \emph{b}^{\hbox{\scriptsize\it e}-\hbox{\scriptsize\it p}}$,
where \emph{s} is $+1$ or $-1$, the \emph{sign};
\emph{b} is an integer greater than 1,
the \emph{base} or \emph{radix} of the representation;
\emph{p} is a positive integer,
the \emph{precision} (in base-\emph{b} digits) of the floating-point number;
\emph{f} is a positive integer between
$\emph{b}^{\,\hbox{\scriptsize\it p}-1}$ and $\emph{b}^{\,\hbox{\scriptsize\it p}}-1$ (inclusive),
the \emph{significand};
and \emph{e} is an integer, the \emph{exponent}.
The value of \emph{p} and the range of \emph{e}
depends on the implementation and on the type of floating-point number
within that implementation.
In addition, there is a floating-point zero;
depending on the implementation, there may also be a ``minus zero.''
If there is no minus zero, then \cd{0.0} and \cd{-0.0} are
both interpreted as simply a floating-point zero.

Common Lisp позволяет реализации предоставлять один и более типов чисел с
плавающе точкой, которые все вместе составляют тип \cdf{float}.
Число с плавающей точкой является (математически) рациональным числом формы
$\emph{s} \cdot \emph{f} \cdot \emph{b}^{\hbox{\scriptsize\it e}-\hbox{\scriptsize\it p}}$,
где \emph{s} $+1$ или $-1$, является \emph{знаком};
\emph{b} целое число большее 1,
является \emph{основанием} для представления;
\emph{p} положительное целое, является \emph{точностью} (количество цифр по
основанию \emph{b}) числа с плавающей точкой;
\emph{f} положительное целое между $\emph{b}^{\,\hbox{\scriptsize\it p}-1}$ и
$\emph{b}^{\,\hbox{\scriptsize\it p}}-1$ (включительно), является мантиссой;
и \emph{e} целое число, является экспонентой.
Значение \emph{p} и интервал \emph{e} зависит от реализации, также может быть
<<минус ноль>>. Если <<минус ноль>> отсутствует, тогда \cd{0.0} и \cd{-0.0} оба
интепретируются, как ноль с плавающей точкой.

\beforenoterule
\begin{implementation}
The form of the above description should not be construed
to require the internal representation to be in sign-magnitude form.
Two's-complement and other representations are also acceptable.  Note
that the radix of the internal representation may be other than 2, as on
the IBM 360 and 370, which use radix 16; see
\cdf{float-radix}.
\end{implementation}
\afternoterule

Floating-point numbers may be provided in a variety of precisions and sizes,
depending on the implementation.  High-quality floating-point
software tends to depend critically on the precise nature of the
floating-point arithmetic and so may not always be completely portable.
As an aid in writing programs that are
moderately portable, however, certain definitions are made here:

Числа с плавающей точкой могут предоставляться с различными точностями и
размерами, в зависимости от реализации. Высококачественные программы с
вычислениями с плавающей точкой зависят от того, какая точность предоставляется,
и не всегда могут быть полностью перенесимы. Для содействия по умеренной
переносимости программ, сделаны следующие определения:
\begin{itemize}
\item
A \emph{short} floating-point number (type \cdf{short-float})
is of the representation of smallest
fixed precision provided by an implementation.

\item
\emph{Короткий} тип числа с плавающей точкой (тип \cdf{short-float}) является
представлением числа с наименьшей фиксированной точностью, предоставляемого реализацией.

\item
A \emph{long} floating-point number (type \cdf{long-float})
is of the representation of the largest fixed 
precision provided by an implementation.

\item
\emph{Длинный} тип числа с плавающей точкой (тип \cdf{long-float}) является
представлением числа с наибольшей фиксированной точностью, предоставляемого реализацией.

\item
Intermediate between short and long formats are two others, arbitrarily
called \emph{single} and \emph{double} (types \cdf{single-float} and \cdf{double-float}).

\item
Промежуточными форматами между коротким и длинным форматами является два других
формата, называемых \emph{одинарный} и \emph{двойной} (типы \cdf{single-float} и \cdf{double-float}).
\end{itemize}

The precise definition of these categories is implementation-dependent.
However, the rough intent is that short floating-point numbers be
precise to at least four decimal places (but also have
a space- efficient representation);
single floating-point numbers, to at least seven decimal places;
and double floating-point numbers, to at least fourteen decimal places.
It is suggested that
the precision (measured in bits, computed as $p \log_2 b$)
and the exponent size (also measured in bits, computed as the base-2
logarithm of 1 plus the maximum exponent value) be at least as great
as the values in table~\ref{Floating-Format-Requirements-Table}.

Определение точности для этих категорий зависит от реализации. Однако, примерная
цель, что короткий тип с плавающий точкой должен содержать точность, как минимум
4 позиции после запятой (и также должен иметь эффективное представление в
памяти);
одинарный тип с плавающей точкой -- как минимум 7 знаков после запятой;
двойной тип с плавающей точкой -- как минимум 14 знаков после запятой.
Предполагается, что размер точности (измеряется в битах и рассчитывается как $p \log_2 b$) и экспоненты (измеряется в битах и рассчитывается как логарифм
с основанием 2 от (1 плюс максимальное значение экспоненты) должен быть как
минимум таким же большим как значения из таблицы~\ref{Floating-Format-Requirements-Table-ru}.

\begin{table}[t]
\caption{Recommended Minimum Floating-Point Precision and Exponent Size}
\label{Floating-Format-Requirements-Table}
\begin{tabular}{@{}lll@{}}
{Format\quad\quad}&{Minimum Precision\quad\quad}&{Minimum Exponent Size} \\ \hlinesp
Short&13 bits&5 bits \\
Single&24 bits&8 bits \\
Double&50 bits&8 bits \\
Long&50 bits&8 bits
\end{tabular}
\end{table}

\begin{table}[t]
\caption{Рекомендуемый размер для точности и экспоненты для типа с плавающей точкой}
\label{Floating-Format-Requirements-Table-ru}
\begin{tabular}{@{}lll@{}}
{Формат\quad\quad}&{Минимальная точность\quad\quad}&{Минимальный размер экспоненты} \\ \hlinesp
Короткое&13 бит&5 бит \\
Одинарное&24 бит&8 бит \\
Двойное&50 бит&8 бит \\
Длинное&50 бит&8 бит
\end{tabular}
\end{table}

Floating-point numbers are written in either decimal fraction
or computerized scientific notation: an optional sign,
then a non-empty sequence of digits with an embedded decimal point,
then an optional decimal exponent specification.
If there is no exponent specifier, then
the decimal point is required, and there must be digits
after it.
The exponent specifier consists of an exponent marker,
an optional sign, and a non-empty sequence of digits.
For preciseness, here is a modified-BNF description of floating-point
notation.

Числа с плавающей точкой записываются в двух формах десятичной дробью и
компьютеризированной научной записью: необязательный знак, затем непустая
последовательность цифр с встроенной точкой, затем необязательная
часть определения экспоненты.
Если определения экспоненты нет, тогда требуется точка, и после нее должны быть
цифры.
Определение экспоненты составляется из маркера экспоненты, необязательного знака
и непустой последовательности цифр.
Для ясности приведена БНФ для записи чисел с плавающей точкой.
\begin{tabbing}
\emph{floating-point-number} ::= \=\Mopt{\emph{sign}} \Mstar{\emph{digit}} {\it
decimal-point} \Mplus{\emph{digit}} \Mopt{\emph{exponent}} \\*
\>\hbox to 0pt{\hss\Mor~}\Mopt{{\it
sign}} \Mplus{\emph{digit}} \Mopt{\emph{decimal-point} \Mstar{\emph{digit}}} {\it
exponent} \\
\emph{sign} ::= \cd{+} {\Mor} \cdf{-} \\
\emph{decimal-point} ::= \cd{.} \\
\emph{digit} ::= \cd{0} {\Mor} \cd{1} {\Mor} \cd{2} {\Mor} \cd{3} {\Mor} \cd{4}
         {\Mor} \cd{5} {\Mor} \cd{6} {\Mor} \cd{7} {\Mor} \cd{8} {\Mor} \cd{9}\\
\emph{exponent} ::= \emph{exponent-marker} \Mopt{\emph{sign}} \Mplus{\emph{digit}}\\*
\emph{exponent-marker} ::= \cdf{e} {\Mor} \cdf{s} {\Mor} \cdf{f}
{\Mor} \cdf{d} {\Mor} \cdf{l} {\Mor} \cdf{E} {\Mor} \cdf{S} {\Mor} \cdf{F} {\Mor}
\cdf{D} {\Mor} \cdf{L}
\end{tabbing}

\begin{tabbing}
\emph{число-с-плавающей-точкой} ::= \=\Mopt{\emph{знак}} \Mstar{\emph{цифра}} {\it
точка} \Mplus{\emph{цифра}} \Mopt{\emph{экспонента}} \\*
\>\hbox to 0pt{\hss\Mor~}\Mopt{{\it
знак}} \Mplus{\emph{цифра}} \Mopt{\emph{точка} \Mstar{\emph{цифра}}} {\it
экспонента} \\
\emph{знак} ::= \cd{+} {\Mor} \cdf{-} \\
\emph{точка} ::= \cd{.} \\
\emph{цифра} ::= \cd{0} {\Mor} \cd{1} {\Mor} \cd{2} {\Mor} \cd{3} {\Mor} \cd{4}
         {\Mor} \cd{5} {\Mor} \cd{6} {\Mor} \cd{7} {\Mor} \cd{8} {\Mor} \cd{9}\\
\emph{экспонента} ::= \emph{маркер-экспоненты} \Mopt{\emph{знак}} \Mplus{\emph{цифра}}\\*
\emph{маркер-экспоненты} ::= \cdf{e} {\Mor} \cdf{s} {\Mor} \cdf{f}
{\Mor} \cdf{d} {\Mor} \cdf{l} {\Mor} \cdf{E} {\Mor} \cdf{S} {\Mor} \cdf{F} {\Mor}
\cdf{D} {\Mor} \cdf{L}
\end{tabbing}
If no exponent specifier is present, or if the exponent marker \cdf{e}
(or \cdf{E}) is used, then the precise format to be used is not
specified.  When such a representation is read and
converted to an internal floating-point data object, the format specified
by the variable \cd{*read-default-float-format*} is used; the initial
value of this variable is \cdf{single-float}.

Если определение экспоненты отсутствует или если используется маркер
экспоненты \cdf{e} (или \cdf{E}), тогда используемые формат точности не
задан. Когда такое представление считывается и конвертируется во внутренний
формат объекта числа с плавающей точкой, формат задается с помощью
переменной \cd{*read-default-float-format*}; первоначальное значение данной
переменной \cdf{single-float}.

The letters \cdf{s}, \cdf{f}, \cdf{d}, and \cdf{l} (or their
respective uppercase equivalents) explicitly specify the
use of \emph{short}, \emph{single}, \emph{double}, and \emph{long} format, respectively.

Буквы  \cdf{s}, \cdf{f}, \cdf{d} и \cdf{l} (или их эквиваленты в верхнем регистре)
явно задают использование типа: \emph{короткий}, \emph{одинарный}, \emph{двойной} и
\emph{длинный}, соответственно.

Examples of floating-point numbers:
\begin{lisp}
0.0~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Floating-point zero in default format} \\
0E0~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Also floating-point zero in default format} \\
-.0~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{This may be a zero or a minus zero,} \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~; \textrm{depending on the implementation} \\
0.~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{The \emph{integer} zero, not a floating-point zero!} \\
0.0s0~~~~~~~~~~~~~~~~~~~~~~~;\textrm{A floating-point zero in \emph{short} format} \\
0s0~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Also a floating-point zero in \emph{short} format} \\
3.1415926535897932384d0~~~~~;\textrm{A \emph{double}-format approximation to $\pi$} \\
6.02E+23~~~~~~~~~~~~~~~~~~~~;\textrm{Avogadro's number, in default format} \\
602E+21~~~~~~~~~~~~~~~~~~~~~;\textrm{Also Avogadro's number, in default format} \\
3.010299957f-1~~~~~~~~~~~~~~;\textrm{$\log_{10} 2$, in \emph{single} format} \\
-0.000000001s9~~~~~~~~~~~~~~;\textrm{$e^{\pi i}$ in \emph{short} format, the hard way}
\end{lisp}

Examples of floating-point numbers:
\begin{lisp}
0.0~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Ноль с плавающей точкой в формате по умолчанию} \\
0E0~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Также ноль с плавающей точкой в формате по умолчанию} \\
-.0~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Это может быть нулем или минус нулем} \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~; \textrm{в зависимости от реализации} \\
0.~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{\emph{Целый} ноль, не с плавающей точкой!} \\
0.0s0~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Ноль с плавающей точкой в \emph{коротком} формате} \\
0s0~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Также ноль с плавающей точкой в \emph{коротком} формате} \\
3.1415926535897932384d0~~~~~;\textrm{Аппроксиммация числе пи в \emph{двойном} формате} \\
6.02E+23~~~~~~~~~~~~~~~~~~~~;\textrm{Число Авогадро в формате по умолчанию} \\
602E+21~~~~~~~~~~~~~~~~~~~~~;\textrm{Также число Авогадро в формате по умолчанию} \\
3.010299957f-1~~~~~~~~~~~~~~;\textrm{$\log_{10} 2$, в \emph{одинарном} формате} \\
-0.000000001s9~~~~~~~~~~~~~~;\textrm{$e^{\pi i}$ в коротком формате}
\end{lisp}

\begin{new}%CORR
\emph{Notice of correction.}
The first edition unfortunately listed an incorrect value (\cd{3.1010299957f-1})
for the base-10 logarithm of 2.
\end{new}

The internal format used for an external representation depends only
on the exponent marker and not on the number of decimal digits
in the external representation.

Внутренний формат использует для внешнего представления в только от
маркера экспоненты и не учитывает количество знаков после запятой во внешнем
представлении. 

While Common Lisp provides terminology and notation sufficient
to accommodate four distinct floating-point formats,
not all implementations will have the means to support
that many distinct formats.
An implementation is therefore permitted to provide
fewer than four distinct internal floating-point formats,
in which case at least one of them will be ``shared''
by more than one of the external format names \emph{short}, \emph{single},
\emph{double}, and \emph{long} according to the following rules:

Тогда как Common Lisp предоставляет терминологию и систему обозначений для
включения 4 различных типов чисел с плавающей точкой, не все реализации будет
иметь намерения для поддержки такого большого количества типов.
Реализация разрешается предоставлять меньшее, чем 4, количество внутренних
форматов чисел с плавающей точкой, в таком случае как минимум один из этих типов
будет <<общим>> для более одного внешнего имени \emph{короткого}, \emph{одинарного},
\emph{двойного}, and \emph{длинного} в соответствии со следующими правилами:
\begin{itemize}
\item
If one internal format is provided, then it is considered to be
\emph{single}, but serves also as \emph{short}, \emph{double}, and \emph{long}.
The data types \cdf{short-float},
\cdf{single-float}, \cdf{double-float}, and \cdf{long-float} are
considered to be identical.  An expression such as \cd{(eql 1.0s0 1.0d0)}
will be true in such an implementation
because the two numbers \cd{1.0s0} and \cd{1.0d0} will
be converted into the same internal format and therefore be considered
to have the same data type, despite the differing external syntax.
Similarly, \cd{(typep 1.0L0 'short-float)} will be true in such
an implementation.
For output purposes all floating-point numbers are assumed to be
of \emph{single} format and thus will print using the
exponent letter \cdf{E} or \cdf{F}.

\item
If two internal formats are provided, then either of two correspondences
may be used, depending on which is the more appropriate:
\begin{itemize}
\item
One format is \emph{short}; the other is \emph{single} and serves also
as \emph{double} and \emph{long}.
The data types
\cdf{single-float}, \cdf{double-float}, and \cdf{long-float} are
considered to be identical, but \cdf{short-float} is distinct.
An expression such as \cd{(eql 1.0s0 1.0d0)}
will be false, but \cd{(eql 1.0f0 1.0d0)} will be true.
Similarly, \cd{(typep 1.0L0 'short-float)} will be false,
but \cd{(typep 1.0L0 'single-float)} will be true.
For output purposes all floating-point numbers are assumed to be
of \emph{short} or \emph{single} format.

\item
One format is \emph{single} and serves also as \emph{short};
the other is \emph{double} and serves also as \emph{long}.
The data types \cdf{short-float} and \cdf{single-float} are considered to be
identical, and the data types \cdf{double-float} and \cdf{long-float} are
considered to be identical.
An expression such as \cd{(eql 1.0s0 1.0d0)}
will be false, as will \cd{(eql 1.0f0 1.0d0)};
but \cd{(eql 1.0d0 1.0L0)} will be true.
Similarly, \cd{(typep 1.0L0 'short-float)} will be false,
but \cd{(typep 1.0L0 'double-float)} will be true.
For output purposes all floating-point numbers are assumed to be
of \emph{single} or \emph{double} format.
\end{itemize}

\item
If three internal formats are provided, then either of two correspondences
may be used, depending on which is the more appropriate:
\begin{itemize}
\item
One format is \emph{short}; another format is \emph{single}; and the third format is
\emph{double} and serves also as \emph{long}.  Similar constraints apply.

\item
One format is \emph{single} and serves also as \emph{short};
another is \emph{double}; and the third format is \emph{long}.
\end{itemize}
\end{itemize}

\beforenoterule
\begin{implementation}
It is recommended that an implementation
provide as many distinct floating-point formats as feasible,
using table~\ref{Floating-Format-Requirements-Table} as a guideline.
Ideally, short-format floating-point numbers should have an
``immediate'' representation that does not require heap allocation;
single-format
floating-point numbers should approximate IEEE proposed standard
single-format floating-point numbers; and double-format floating-point
numbers should approximate IEEE proposed standard double-format
floating-point numbers
\cite{IEEE-PROPOSED-FLOATING-POINT-STANDARD,IEEE-FLOATING-POINT-IMPL-GUIDE,IEEE-FLOATING-POINT-IMPL-GUIDE-ERRATA}.
\end{implementation}
\afternoterule


\subsection{Complex Numbers Комплексные числа}

Complex numbers (type \cdf{complex})
are represented in Cartesian form, with a real part and an imaginary
part, each of which is a non-complex number (integer, ratio, or floating-point
number).  It should be emphasized that the parts of a complex
number are not necessarily floating-point numbers; in this, Common Lisp
is like PL/I and differs from Fortran.  However, both parts must
be of the same type: either both are rational, or both are of the
same floating-point format. 

Комплексные числа (тип \cdf{complex})
представляются в алгебраической форме, с действительной и мнимой частями, каждая
из которых является некомплексным числом (целым, дробным, или с плавающей
точкой). Следует отметить, что части комплексного числа не
обязательно числа с плавающей точкой; в это Common Lisp похож на PL/I и
отличается от Fortran'а. Однако обе части должны быть одного типа: обе
рациональные, или обе какого-либо формата с плавающей точкой.

Complex numbers may be notated by writing the characters \cd{\#C}
followed by a list of the real and imaginary parts.
If the two parts as notated are not of the same type, then
they are converted according to the rules of floating-point contagion
as described in chapter~\ref{NUMBER}.
(Indeed, \cd{\#C(\emph{a} \emph{b})} is equivalent to \cd{\#,(complex \emph{a} \emph{b})};
see the description of the function \cdf{complex}.)
For example:

Комплексные числа могут быть обозначены с помощью записи символа \cd{\#C} с
последующим списком действительной и мнимой частей.
Если две части, как было отмечено, не принадлежат одному типу, тогда они будут
преобразованы в соотвествии с правилами преобразования чисел с плавающей точкой
описанными в главе~\ref{NUMBER}.
\begin{lisp}
\#C(3.0s1 2.0s-1)~~~~~;\textrm{Real and imaginary parts are short format}\\
\#C(5 -3)~~~~~~~~~~~~~;\textrm{A Gaussian integer} \\
\#C(5/3 7.0)~~~~~~~~~~;\textrm{Will be converted internally to \cd{\#C(1.66666 7.0)}} \\
\#C(0 1)~~~~~~~~~~~~~~;\textrm{The imaginary unit, that is, \emph{i}}
\end{lisp}

\begin{lisp}
\#C(3.0s1 2.0s-1)~~~~~;\textrm{Действительная и мнимая части в коротком формате}\\
\#C(5 -3)~~~~~~~~~~~~~;\textrm{Целое Гаусса} \\
\#C(5/3 7.0)~~~~~~~~~~;\textrm{Будет преобразовано в \cd{\#C(1.66666 7.0)}} \\
\#C(0 1)~~~~~~~~~~~~~~;\textrm{Мнимая единица, \emph{i}}
\end{lisp}

The type of a specific complex number is indicated by a list
of the word \cdf{complex} and the type of the components; for example,
a specialized representation for complex numbers with short floating-point
parts would be of type \cd{(complex short-float)}.  The type \cdf{complex}
encompasses all complex representations.

Тип заданного комплексного числа определяется с помощью списка: слова
\cdf{complex} и типа компонентов; например, специализированное представление для
комплексных чисел с частями принадлежащими типу короткое с плавающей точкой,
будет выглядеть так \cd{(complex short-float)}. Тип \cdf{complex} включает все
представления комплексных типов.

A complex number of type \cd{(complex rational)}, that is, one whose
components are rational, can never have a zero imaginary part.
If the result of a computation would be a complex rational
with a zero imaginary part, the result is immediately
converted to a non-complex rational number by taking the
real part.  This is called the rule of \emph{complex canonicalization}.
This rule does not apply to floating-point complex numbers;
\cd{\#C(5.0 0.0)} and \cd{5.0} are different.

Комплексное число типа \cd{(complex rational)}, в котором части принадлежат
дробному типу, никогда не может содержать нулевую мнимую часть. Если в
результате вычислений получится комплексное число с нулевой мнимой частью, то
данное число будет автоматически сконвертировано в некомплексное дробное число,
равное действительной часть исходного числа. Это называется правилом {\it
 канонизации комплексного числа}. Данное правило не применяется для комплексных
чисел с плавающими точками; \cd{\#C(5.0 0.0)} и \cd{5.0} различные числа.

\goodbreak

\section{Characters Строковые символы}

Characters are represented as data objects of type \cdf{character}.

Строковые символы представляют собой объекты данных, принадлежащих типу
\cd{строковый символ (character)}.
\begin{obsolete}
There are two subtypes of interest,
called \cdf{standard-char} and \cdf{string-char}.
\end{obsolete}
\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL} to remove the type \cdf{string-char}.
\end{newer}

A character object can be notated by writing \cd{\#{\Xbackslash}} followed
by the character itself.  For example, \cd{\#{\Xbackslash}g} means the character
object for a lowercase g.  This works well enough for printing
characters.  Non-printing characters have names, and can be notated
by writing \cd{\#{\Xbackslash}} and then the name; for example, \cd{\#{\Xbackslash}Space}
(or \cd{\#{\Xbackslash}SPACE} or \cd{\#{\Xbackslash}space} or \cd{\#{\Xbackslash}sPaCE})
means the space character.  The syntax for character names after \cd{\#{\Xbackslash}}
is the same as that for symbols.  However, only character names
that are known to the particular implementation may be used.

Объект строкового символа может быть записан, как знак \cd{\#{\Xbackslash}} и последующий строковый символ. Например:  \cd{\#{\Xbackslash}g}
обозначает строковый символ g в нижнем регистре. Это работает достаточно хорошо
для вывода символов. Невыводимые строковые символы имеют имена, и могут быть
записаны с помощью \cd{\#{\Xbackslash}} и последующего имени; например,
\cd{\#{\Xbackslash}Space} (или \cd{\#{\Xbackslash}SPACE} или
\cd{\#{\Xbackslash}space} или \cd{\#{\Xbackslash}sPaCE}) обозначает символ пробела.
Синтаксис для записи имени строкового символа после \cd{\#{\Xbackslash}}, такой
же как и для Lisp символов. Однако в работе могут использоваться только те
имена, которые известны данной реализации.

\subsection{Standard Characters}

Common Lisp defines a standard character set (subtype \cdf{standard-char})
for two purposes.
Common Lisp programs that are \emph{written} in the standard character set
can be read by any Common Lisp implementation; and Common Lisp programs
that \emph{use} only standard characters as data objects are most likely
to be portable.  The Common Lisp character set consists of a space character
\cd{\#{\Xbackslash}Space}, a newline character \cd{\#{\Xbackslash}Newline}, and the
following ninety-four
non-blank printing characters or their equivalents:

Common Lisp определяет множество стандартных символов (подтип
\cdf{standard-char}) для двух целей.
Common Lisp программы, которые \emph{записаны} используя множество стандартных
символов, могут быть прочитаны любой реализацией Common Lisp; и Common Lisp
программы, которые \emph{используют} только стандартные символы в качестве
объектов данных, скорее всего будут портируемыми. Множество строковых символов
Common Lisp состоит из символа пробела, \cd{\#{\Xbackslash}Space}, символа
новой строки \cd{\#{\Xbackslash}Newline}, и следующих сорока четырех печатаемых
символов и их эквивалентов:
\begin{lisp}
! " \# \$ \% \& ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? \\
{\Xatsign} A B C D E F G H I J K L M N O P Q R S T U V W X Y Z {\Xlbracket} {\Xbackslash} {\Xrbracket} {\Xcircumflex} {\Xunderscore} \\
{\Xbq} a b c d e f g h i j k l m n o p q r s t u v w x y z {\Xlbrace} | {\Xrbrace} {\Xtilde}
\end{lisp}
The Common Lisp standard character set is apparently equivalent to
the ninety-five standard ASCII printing characters plus a newline character.
Nevertheless, Common Lisp is designed to be relatively independent of
the ASCII character encoding.  For example, the collating sequence
is not specified except to say that digits must be properly ordered,
the uppercase letters must be properly ordered, and
the lowercase letters must be properly ordered
(see \cd{char<} for a precise specification).
Other character encodings, particularly EBCDIC, should be easily accommodated
(with a suitable mapping of printing characters).

Множество стандартных строковых символов Common Lisp'а явно соответствует
множеству из сорока пяти стандартных ASCII печатаемых символов и символа новой
строки. Как бы то ни было, Common Lisp спроектирован так, чтобы быть независимым
от ASCII кодировки символов. Например, сортировка последовательности не
определена, кроме того, что можно сказать, что цифры могут быть корректно
отсортированы, буквы в верхнем регистре могут быть корректно отсортрованы и
буквы в нижнем регистре могут быть корректно отсортированы (смотрите
спецификацию функции \cd{char<}). Другие реализация кодировка строковых
символов, в частности EBCDIC, должна быть легко приспособлена (с необходимым
соотвествием выводимых символов).

Of the ninety-four non-blank printing characters, the following are
used in only limited ways in the syntax of Common Lisp programs:

Из сорока четырех печатаемых символов, следующие испльзуются с ограничениями
связанными с синтаксисом Common Lisp програм:
\begin{lisp}
{\Xlbracket}~~{\Xrbracket}~~{\Xlbrace}~~{\Xrbrace}~~?~~!~~{\Xcircumflex}~~{\Xunderscore}~~{\Xtilde}~~\$~~\% 
\end{lisp}

\begin{obsolete}
\noindent
All of these characters except \cd{!} and \cd{{\Xunderscore}} are used within
\cdf{format} strings as formatting directives.
Except for this,
\cd{{\Xlbracket}}, \cd{{\Xrbracket}}, \cd{{\Xlbrace}}, \cd{{\Xrbrace}},
\cd{?}, and \cd{!} are not used in Common Lisp and are reserved to the user
for syntactic extensions; \cd{{\Xcircumflex}} and \cd{{\Xunderscore}}
are not yet used in Common Lisp
but are part of the syntax of reserved tokens
and are reserved to implementors;
\cd{{\Xtilde}} is not yet used in Common Lisp and is reserved to implementors;
and \cd{\$} and \cd{\%} are normally regarded as alphabetic characters
but are not used in the names of any standard Common Lisp functions,
variables, or other entities.
\end{obsolete}

\begin{newer}
X3J13 voted in June 1989 \issue{PRETTY-PRINT-INTERFACE}
to add a \cdf{format} directive \cd{{\Xtilde}{\Xunderscore}} (see chapter~\ref{PPRINT}).
\end{newer}

The following characters are called \emph{semi-standard}:

Следующие строковые символы называются \emph{слегка стандартизированными}:
\begin{lisp}
\#{\Xbackslash}Backspace~~\#{\Xbackslash}Tab~~\#{\Xbackslash}Linefeed~~\#{\Xbackslash}Page~~\#{\Xbackslash}Return~~\#{\Xbackslash}Rubout
\end{lisp}
Not all implementations of Common Lisp need to support them; but those
implementations that
use the standard ASCII character set should support them, treating them as
corresponding respectively to the ASCII characters BS (octal code 010),
HT (011), LF (012), FF (014), CR (015), and DEL
(177). These characters are not
members of the subtype \cdf{standard-char} unless synonymous with
one of the standard characters specified above.
For example, in a given implementation it might
be sensible for the implementor to define
\cd{\#{\Xbackslash}Linefeed} or \cd{\#{\Xbackslash}Return} to be synonymous with \cd{\#{\Xbackslash}Newline},
or \cd{\#{\Xbackslash}Tab} to be synonymous with \cd{\#{\Xbackslash}Space}.

Не все реализации Common Lisp'а нуждаются в поддержке этих символов; но те
реализации, что используют ASCII кодировку должны их поддерживать,
соответственно BS (восьмеричный код 010), HT (011), LF (012), FF (014), CR
(015) и DEL (177). Эти строковые символы не являются членами подтипа
\cdf{standard-char}, если не будут созданы синонимы для них.
Например, разработчик реализации может 
определить \cd{\#{\Xbackslash}Linefeed} или \cd{\#{\Xbackslash}Return} как
синоним для \cd{\#{\Xbackslash}Newline},
или \cd{\#{\Xbackslash}Tab} как синоним для \cd{\#{\Xbackslash}Space}.

\subsection{Line Divisions Разделители строк}

The treatment of line divisions is one of the most difficult issues
in designing portable software, simply because there is so little agreement
among operating systems.  Some use a single character to delimit lines;
the recommended ASCII character for this purpose is the line feed character
LF (also called the new line character, NL),
but some systems use the carriage
return character CR.  Much more common is the two-character sequence
CR followed by LF.  Frequently line divisions have no representation
as a character but are implicit in the structuring of a file into records,
each record containing a line of text.  A deck of punched cards has this
structure, for example.

Обработки разделителей строк является одним из самых сложных моментов в
проектировании переносимой программы, преимущественно потому, что между
операционными системами очень мало соглашений по этому поводу. Некоторые
используют только один символ; рекомендуемый для этого ASCII символ является
символом перевода строки LF (также называемый символом новой строки, NL),
но некоторые системы используют символ перевода каретки CR. Более
широко используется последовательность из двух символов CR и последующем
LF. Часто разделители строк не имеют выводимого представления, но неявно влияют
на структурирование файла в записи, каждая запись содержит строку
текста. Наприимер, дека перфокарт имеет такию структуру.

Common Lisp provides an abstract interface by requiring that there be a single
character, \cd{\#{\Xbackslash}Newline}, that within the language serves as a line
delimiter.  (The language C has a similar requirement.)
An implementation of Common Lisp must translate between this internal
single-character representation and whatever external representation(s)
may be used.

Common Lisp предоставляет абстрактный интерфейс, требуя наличия одного символа
\cd{\#{\Xbackslash}Newline}, который являет разделителем строк. (Язык C имеет
подобное требование.)
Реализация Common Lisp'а должна транслировать это односимвольное представление
разделители в то, что требуется во внешних системах в данной операционной системе.

\beforenoterule
\begin{implementation}
How the character called \cd{\#{\Xbackslash}Newline} is represented
internally is not specified here, but it is strongly suggested that
the ASCII LF character be used in Common Lisp implementations that use the
ASCII character encoding.  The ASCII CR character is a workable,
but in most cases inferior, alternative.
\end{implementation}
\afternoterule

\begin{newer}
When the first edition was written it was not yet clear that UNIX would
become so widely accepted.  The decision to represent
the line delimiter as a single character has proved to be a good one.
\end{newer}

The requirement that a line division be represented as a single character
has certain consequences.  A character string
written in the middle of a program in such a way as to span more than
one line must contain exactly one character to represent each line division.
Consider this code fragment:

Требование того, что разделитель строк должен быть представлен одним символом,
имеет следующие последствия. Строковый объект, записанный в середине программы и
содержащий несколько строк, должен содержать только один символ для каждого
разделителя. Рассмотрим фрагмент следующего кода:
\begin{lisp}
(setq a-string "This string \\
contains \\
forty-two characters.")
\end{lisp}
Between \cdf{g} and \cdf{c} there must be exactly one character,
\cd{\#{\Xbackslash}Newline}; a two-character sequence, such as \cd{\#{\Xbackslash}Return} and then
\cd{\#{\Xbackslash}Newline}, is not acceptable, nor is the absence of a character.
The same is true between \cdf{s} and \cdf{f}.

Между \cdf{g} and \cdf{c} должен быть только один символ,
\cd{\#{\Xbackslash}Newline}; последовательность из двух строковых символов
такая, как \cd{\#{\Xbackslash}Return} и\cd{\#{\Xbackslash}Newline},
некорректна.
Такя же ситуация и между \cdf{s} и \cdf{f}.

When the character \cd{\#{\Xbackslash}Newline} is written to an output file,
the Common Lisp implementation must take the appropriate action
to produce a line division.  This might involve writing out a
record or translating \cd{\#{\Xbackslash}Newline} to a CR/LF sequence.

Когда строковый символ \cd{\#{\Xbackslash}Newline} записывается в выходной файл,
реализация Common Lisp'а должна предпринять соотвествующие действия для
разделения строк. Это может быть реализовано, как трансляция
\cd{\#{\Xbackslash}Newline} в последовательность CR/LF.

\beforenoterule
\begin{implementation}
If an implementation uses the ASCII character encoding,
uses the CR/LF sequence externally to delimit lines,
uses LF to represent \cd{\#{\Xbackslash}Newline} internally, and supports \cd{\#{\Xbackslash}Return}
as a data object corresponding to the ASCII character CR, the
question arises as to what action to take when the program
writes out \cd{\#{\Xbackslash}Return} followed by \cd{\#{\Xbackslash}Newline}.
It should first be noted that \cd{\#{\Xbackslash}Return} is not a standard Common Lisp
character, and the action to be taken when \cd{\#{\Xbackslash}Return} is written out
is therefore not defined by the Common Lisp language.  A plausible approach
is to buffer the \cd{\#{\Xbackslash}Return} character and suppress it if and only if the
next character is \cd{\#{\Xbackslash}Newline} (the net effect is to generate a CR/LF
sequence).
Another plausible
approach is simply to ignore
the difficulty and declare that writing \cd{\#{\Xbackslash}Return} and then
\cd{\#{\Xbackslash}Newline} results in the sequence CR/CR/LF in the output.
\end{implementation}
\afternoterule

\subsection{Non-standard Characters Нестандартные символы}

Any implementation may provide additional characters, whether printing
characters or named characters.  Some plausible examples:

Любая реализация может предоставлять дополнительные строковые символы, и
печатаемые и именовынные. Некоторые вероятные примеры:

\newpage%manual

\begin{lisp}
\#{\Xbackslash}$\pi$~~\#{\Xbackslash}$\alpha$~~\#{\Xbackslash}Break~~\#{\Xbackslash}Home-Up~~\#{\Xbackslash}Escape
\end{lisp}
The use of such characters may render Common Lisp programs non-portable.

Использование таких символов, может создавать проблемы для портируемости Common
Lisp программы.

\begin{obsolete}
\subsection{Character Attributes Устарело}
Every object of type \cdf{character}
has three attributes: \emph{code}, \emph{bits}, and \emph{font}.
The code attribute is intended to distinguish among the printed glyphs
and formatting functions for characters; it is a numerical encoding
of the character proper.
The bits attribute allows extra
flags to be associated with a character.  The font attribute permits
a specification of the style of the glyphs (such as italics).
Each of these attributes may be understood to be a non-negative integer.

The font attribute may be notated in unsigned decimal notation
between the \cd{\#} and the \cd{{\Xbackslash}}.  For example,
\cd{\#3{\Xbackslash}a} means the letter \cdf{a} in font 3.
This might mean the same thing as \cd{\#{\Xbackslash}$\alpha$} if font 3
were used to represent Greek letters.
Note that not all Common Lisp implementations provide for non-zero
font attributes; see \cdf{char-font-limit}.

The bits attribute may be notated
by preceding the name of the character by the names or initials
of the bits,
separated by hyphens.  The character itself may be written
instead of the name, preceded if necessary by \cd{{\Xbackslash}}.  For example:
\begin{lisp}
\hskip 0.5\textwidth\=\kill
\#{\Xbackslash}Control-Meta-Return\>\#{\Xbackslash}Meta-Control-Q \\
\#{\Xbackslash}Hyper-Space\>\#{\Xbackslash}Meta-{\Xbackslash}a \\
\#{\Xbackslash}Control-A\>\#{\Xbackslash}Meta-Hyper-{\Xbackslash}: \\
\#{\Xbackslash}C-M-Return\>\#{\Xbackslash}Hyper-{\Xbackslash}$\pi$
\end{lisp}
Note that not all Common Lisp implementations provide for non-zero
bits attributes; see \cdf{char-bits-limit}.
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to replace the notion of bits and font attributes with
that of implementation-defined attributes.
\end{newer}

\begin{obsolete}
\subsection{String Characters Устарело}

Any character whose bits and font attributes are zero may be contained
in strings.  All such characters together constitute a subtype of
the characters; this subtype is called \cdf{string-char}.
\end{obsolete}


\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to eliminate the type \cdf{string-char}.
Two new subtypes of \cdf{character} are \cdf{base-character},
defined to be equivalent to the result of the function call
\begin{lisp}
(upgraded-array-element-type 'standard-char)
\end{lisp}
and \cdf{extended-character}, defined to be equivalent to the type specifier
\begin{lisp}
(and character (not base-character))
\end{lisp}
An implementation may support additional subtypes of \cdf{character}
that may or may not be supertypes of \cdf{base-character}.
In addition, an implementation may define \cdf{base-character}
to be equivalent to \cdf{character}.  The choice of any base characters
that are not standard characters is implementation-defined.
Only base characters can be elements of a base string.
No upper bound is specified for the number of distinct characters
of type \cdf{base-character}---that is implementation-dependent---but the lower
bound is 96, the number of standard Common Lisp characters.
\end{newer}

\section{Symbols Символы}

Symbols are Lisp data objects that serve several purposes
and have several interesting characteristics.  Every object of
type \cdf{symbol} has a name,
called its \emph{print name}.  Given a symbol, one can
obtain its name in the form of a string.  Conversely,
given the name of a symbol as a string, one can obtain the
symbol itself.  (More precisely, symbols are organized into
\emph{packages}, and all the symbols in a package are uniquely
identified by name.  See chapter~\ref{XPACK}.)

Символы (прим. переводчика: не строковые) являются Lisp'овыми объектами данных,
созданы для нескольких целей и имеют несколько интересных характеристик. Каждый
объект типа \cdf{symbol} имеет имя, называемое его \emph{выводимым именем (print
  name)}. Существует возможность получить имя символа в виде строки. Также
возможно обратное действие, получение имени символа из строки. (Более подробно:
символы могут быть организованы в \emph{пакеты}, и все символы в пакете имеют
уникальные имена. Смотрите главу~\ref{XPACK}.)

Symbols have a component called the \emph{property list}, or \emph{plist}.
By convention this is always a list whose even-numbered
components (calling the first component zero) are symbols,
here functioning as property names, and whose odd-numbered components
are associated property values.  Functions are provided for manipulating
this property list; in effect, these allow a symbol to be treated as an
extensible record structure.

У символов есть компонент, называемый \emph{список свойств}, или \emph{иplist}.
Список свойств всегда является списком, у которого четные элементы (начиная с
нулевого) являеются символами, они выступают в качестве имен свойств, и нечетные
элементы являются связанными со свойствами значениями. Для манипуляций с этим
списком свойств предоставляются функции, это позволяет символу выступать в роли расширяемой структуры.

Symbols are also used to represent certain kinds of variables in Lisp
programs, and there are functions for dealing with the values associated
with symbols in this role. 

Символы также используются для представления определенных видов переменных в
Lisp программах, и для манипуляции значениями связанными с символами в такой
роли также предоставляются функции.

A symbol can be notated simply by writing its name.
If its name is not empty, and if the name consists only of
uppercase alphabetic, numeric, or certain pseudo-alphabetic
special characters (but not
delimiter characters such as parentheses or space), and if
the name of the symbol cannot be mistaken for a number, then
the symbol can be notated by the sequence of characters in its name.
Any uppercase letters that appear in the (internal) name may
be written in either case in the external notation (more on this below).
For example:

Символ может быть обозначен просто записью его имени.
Если его имя непустое, и если его имя содержит только алфавитные буквы в верхнем
регистре, цифры или некоторые псевдо-алфавитные строковые символы (но не
разделители, как круглые скобки и пробелы), и если имя символа не может быть
интерпретировано как число, тогда имя символа задается последовательностью букв
его имени.
Все буквы записанные в имени символа переводятся в верхний регистр во внутреннем
представлении.
Например:
\begin{lisp}
~~~~~~~~~~~~~~~~~~~~\=\kill
FROBBOZ\>;\textrm{The symbol whose name is \cdf{FROBBOZ}} \\
frobboz\>;\textrm{Another way to notate the same symbol} \\
fRObBoz\>;\textrm{Yet another way to notate it} \\
unwind-protect\>;\textrm{A symbol with a \cdf{-} in its name} \\
+\$\>;\textrm{The symbol named \cd{+\$}} \\
1+\>;\textrm{The symbol named \cd{1+}} \\
+1\>;\textrm{This is the integer 1, not a symbol} \\
pascal{\Xunderscore}style\>;\textrm{This symbol has an underscore in its name} \\
b{\Xcircumflex}2-4*a*c\>;\textrm{This is a single symbol!} \\
\>;~\textrm{It has several special characters in its name} \\
file.rel.43\>;\textrm{This symbol has periods in its name} \\
/usr/games/zork\>;\textrm{This symbol has slashes in its name}
\end{lisp}

\begin{lisp}
~~~~~~~~~~~~~~~~~~~~\=\kill
FROBBOZ\>;\textrm{Символ, имя которого \cdf{FROBBOZ}} \\
frobboz\>;\textrm{Другой путь записи того же символа} \\
fRObBoz\>;\textrm{Еще один путь записи полюбившегося символа} \\
unwind-protect\>;\textrm{Символ с дефисом в имени} \\
+\$\>;\textrm{Символ с именем \cd{+\$}} \\
1+\>;\textrm{Символ с именем \cd{1+}} \\
+1\>;\textrm{Это число 1, а не символ} \\
pascal{\Xunderscore}style\>;\textrm{Этот символ содержит знак подчеркивания в своем
  имени} \\
b{\Xcircumflex}2-4*a*c\>;\textrm{Это один символ} \\
\>;~\textrm{Этот символ содержит некоторые специальные знаки в своем имени} \\
file.rel.43\>;\textrm{Символ содержит точки в своем имени} \\
/usr/games/zork\>;\textrm{Символ содержит наклонные черты в своем имени}
\end{lisp}

In addition to letters and numbers, the following characters are normally
considered to be alphabetic for the purposes of notating
symbols:

В дополнение к буквам и числам, следующие строковые символы допускаются в
использовании в написании имени символа:
\begin{lisp}
+~~-~~*~~/~~{\Xatsign}~~\$~~\%~~{\Xcircumflex}~~\&~~{\Xunderscore}~~=~~<~~>~~{\Xtilde}~~.
\end{lisp}
Some of these characters have conventional purposes for naming things;
for example, symbols that name special variables
generally have names beginning and ending with
\cd{*}.  The last character listed above, the period, is considered alphabetic
\emph{provided} that a token does not consist entirely of periods.
A single period standing by itself is used in the notation
of conses and dotted lists; a token consisting of two or more periods
is syntactically illegal.  (The period also serves as the decimal point
in the notation of numbers.)

Некоторые из этих строковых символов имеют специальные общеприянтые значения
для имен;
например, символы, которые задают специальные переменные, обычно имеют имена
начинающиеся и заканчивающиеся зведочкой \d{*}.
Одиночная точка используется для задания cons-ячеек или списков с точкой. Точка
также является разделителем дробной части.

The following characters are also alphabetic by default but are explicitly
reserved to the user for definition as reader macro characters
(see section~\ref{MACRO-CHARACTERS-SECTION}) or any other desired purpose
and therefore should not be used routinely in names of symbols:

Следующие строковые символы предназначены для использования в качестве
макросимволов для изменения и расширения синтаксиса языка:
\begin{lisp}
?~~!~~{\Xlbracket}~~{\Xrbracket}~~{\Xlbrace}~~{\Xrbrace}
\end{lisp}

A symbol may have uppercase letters, lowercase letters, or both
in its print name.
However, the Lisp reader normally converts lowercase letters to
the corresponding uppercase letters when reading symbols.
The net effect is that most of the time case makes no
difference when \emph{notating} symbols.  Case \emph{does} make
a difference internally and when printing a symbol.
Internally the symbols that name all standard Common Lisp functions,
variables, and keywords have uppercase names; their names appear
in lowercase in this book for readability.  Typing such names
with lowercase letters works because the function \cdf{read} will convert
lowercase letters to the equivalent uppercase letters.

Выводимое имя символ может содержать буквы в верхнем и нижнем регистрах.
Однако, при чтении Lisp reader обычно ковертирует буквы нижнего регистра в
верхний.
В реализации все символы, которые именуют все стандартные Common Lisp переменные
и функции хранятся в верхнем регистре. Однако в книге все эти символы для
удобства приводятся в нижнем регистре. Использование имен символов в нижнем
регистре при написании программы возможно потому, что \cdf{read} конвертирует все
читываемые символы в верхний регистр.

\begin{newer}
X3J13 voted in June 1989 \issue{READ-CASE-SENSITIVITY} to introduce
\cdf{readtable-case}, which controls whether \cdf{read} will alter the case
of letters read as part of the name of a symbol.

Переменная \cdf{readtable-case} контролирует поведение функции \cdf{read}
касаемо преобразования регистров букв в именах символов.
\end{newer}

If a symbol cannot be simply notated by the characters of its name
because the (internal) name contains special characters or lowercase letters,
then there are two ``escape'' conventions for notating them.
Writing a \cd{{\Xbackslash}} character before any character causes the character
to be treated itself as an ordinary character for use in a symbol name;
in particular, it suppresses internal conversion of lowercase letters
to their uppercase equivalents.
If any character in a notation is preceded by \cd{{\Xbackslash}}, then that
notation can never be interpreted as a number.
For example:

Если символ не может быть задан, потому что в его имени используются
недопустимые буквы и знаки, их можно <<экранировать>> двумя способами. Один из
них заключается в использовании обратной наклонной черты перед каждым
экранируемым знаком. В таком случае имя символа никогда не будет ошибочно
интепретировано, как число.
Например:
\begin{lisp}
~~~~~~~~~~~~~~~~~~~~~~~~\=\kill
{\Xbackslash}(\>;\textrm{Символ с именем \cd{(}} \\
{\Xbackslash}+1\>;\textrm{Символ с именем \cd{+1}} \\
+{\Xbackslash}1\>;\textrm{Также симол с именем \cd{+1}} \\
{\Xbackslash}frobboz\>;\textrm{Символ с именем \cdf{fROBBOZ}} \\
3.14159265{\Xbackslash}s0\>;\textrm{Символ с именем \cd{3.14159265s0}} \\
3.14159265{\Xbackslash}S0\>;\textrm{Другой символ с именем \cd{3.14159265S0}} \\
3.14159265s0\>;\textrm{short-format с плавающей точкой для аппроксимации числа $\pi$} \\
APL{\Xbackslash}{\Xbackslash}360\>;\textrm{Символ с именем \cd{APL{\Xbackslash}360}} \\
apl{\Xbackslash}{\Xbackslash}360\>;\textrm{Также символ с именем \cd{APL{\Xbackslash}360}} \\
{\Xbackslash}(b{\Xcircumflex}2{\Xbackslash}){\Xbackslash} -{\Xbackslash} 4*a*c\>;\textrm{Имя \cd{(B{\Xcircumflex}2) - 4*A*C};} \\
\>;~\textrm{содержит скобки и два пробела} \\
{\Xbackslash}({\Xbackslash}b{\Xcircumflex}2{\Xbackslash}){\Xbackslash} -{\Xbackslash} 4*{\Xbackslash}a*{\Xbackslash}c\>;\textrm{Имя \cd{(b{\Xcircumflex}2) - 4*a*c};} \\
\>;~\textrm{буквы явно указаны в нижнем регистре}
\end{lisp}
It may be tedious to insert a \cd{{\Xbackslash}} before \emph{every} delimiter
character in the name of a symbol if there are many of them.
An alternative convention is to surround the name of a symbol
with vertical bars; these cause every character between them to
be taken as part of the symbol's name, as if \cd{{\Xbackslash}} had been written
before each one, excepting only
\cd{|} itself and \cd{{\Xbackslash}}, which must nevertheless be preceded by \cd{{\Xbackslash}}.
For example:

Использование \cd{{\Xbackslash}} перед \emph{каждой} буквой утомительно, если
таких <<запрещенных>> букв в имени много. Алтернативным методом экранирования
знаков в имени символа является заключение всего имени или только его части в
скобки из вертикальных черт. Это эквивалентно тому, что каждая буква была бы
экранирована обратной косой чертой.
\begin{lisp}
~~~~~~~~~~~~~~~~~~~~\=\kill
|"|\>;\textrm{То же что и \cd{{\Xbackslash}"}} \\
|(b{\Xcircumflex}2) - 4*a*c|\>;\textrm{Имя \cd{(b{\Xcircumflex}2) - 4*a*c}} \\
|frobboz|\>;\textrm{Имя \cdf{frobboz}, а не \cdf{FROBBOZ}} \\
|APL{\Xbackslash}360|\>;\textrm{Имя \cd{APL360}, потому что \cd{{\Xbackslash}} экранирует the \cd{3}} \\
|APL{\Xbackslash}{\Xbackslash}360|\>;\textrm{Имя \cd{APL{\Xbackslash}360}} \\
|apl{\Xbackslash}{\Xbackslash}360|\>;\textrm{Имя \cd{apl{\Xbackslash}360}} \\
|{\Xbackslash}|{\Xbackslash}||\>;\textrm{То же, что и \cd{{\Xbackslash}|{\Xbackslash}|}: имя \cd{||}} \\
|(B{\Xcircumflex}2) - 4*A*C|\>;\textrm{Имя \cd{(B{\Xcircumflex}2) - 4*A*C};} \\
\>;~\textrm{содержит скобки и два пробела} \\
|(b{\Xcircumflex}2) - 4*a*c|\>;\textrm{Имя \cd{(b{\Xcircumflex}2) - 4*a*c}}
\end{lisp}

%???
%\begin{newer}
%X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
%to clarify that the print name of a symbol may contain any character,
%although it may be necessary to use an escape character in the notation.
%However, some or all of the implementation-defined attributes may be removed
%from the character, at the discretion of the implementation,
%before inclusion in the print name.
%\end{newer}

\section{Lists and Conses Списки и Cons-ячейки}

\indexterm{cons}
A \cdf{cons} is a record structure containing two components
called the \emph{car} and the \emph{cdr}.  Conses are used primarily
to represent lists.

\cd{cons-ячейка} является записью структуры, содержащей два элемента, называемых
\emph{car} и \emph{cdr}. Cons-ячейки используются преимущественно для отображения
списков.

A \emph{list} is recursively defined to be either the empty list
or a cons whose \emph{cdr} component is a list.
A list is therefore a chain of conses linked by their \emph{cdr} components
and terminated by {\nil}, the empty list.  The \emph{car} components of the conses
are called the \emph{elements} of the list.  For each element of the list
there is a cons.  The empty list has no elements at all.

\emph{Список} рекурсивно определяется пустым списком или cons-ячейкой, у
которой \emph{cdr} элемент является списком.
Таким образом, список является цепочкой cons-ячеек связанных с помощью их {\it
  cdr} элементов, заканчивающейся пустым списком с помощью {\nil}. \emph{car}
элементы cons-ячеек называются \emph{элементами} списка. Для каждого элемента
списка существует cons-ячейка. Пустой список не имеет элементов вообще.

A list is notated by writing the elements of the list in order,
separated by blank space (space, tab, or return characters)
and surrounded by parentheses.

Список записывается с помощью элементов в необходимом порядке, разделяемых
пробелом (пробел, таб, возврат каретки) и окруженных круглыми скобками.
\begin{lisp}
(a b c)~~~~~~~~~~~~~~~;\textrm{A list of three symbols} \\
(2.0s0 (a 1) \#{\Xbackslash}*)~~~~~;\textrm{A list of three things: a short floating-point} \\
~~~~~~~~~~~~~~~~~~~~~~;~\textrm{number, another list, and a character object}
\end{lisp}

\begin{lisp}
(a b c)~~~~~~~~~~~~~~~;\textrm{Список трех элементов} \\
(2.0s0 (a 1) \#{\Xbackslash}*)~~~~~;\textrm{Список трех элементов: короткого с
  плавающей точкой} \\
~~~~~~~~~~~~~~~~~~~~~~;~\textrm{числа, другого списка, и строкового символа}
\end{lisp}
The empty list {\nil} therefore can be written as {\emptylist}, because it is a list
with no elements.

Таким образом, пустой список {\nil} может быть записан, как {\emptylist}, потому что
является списком без элементов.

A \emph{dotted list} is one whose last cons does not have {\nil} for
its \emph{cdr}, rather some other data object (which is also not a cons,
or the first-mentioned cons would not be the last cons of the list).
Such a list is called ``dotted'' because of the special notation
used for it: the elements of the list are written between
parentheses as before, but after the last element and before
the right parenthesis are written a dot (surrounded by blank space)
and then the \emph{cdr} of the last cons.  As a special case,
a single cons is notated by writing the \emph{car} and the \emph{cdr} between
parentheses and separated by a space-surrounded dot.
For example:

\emph{Список с точкой} является списком, последняя cons-ячейка которого в {\it
  cdr} элементе содержит
объект данных, а не {\nil} (который не является
cons-ячейкой, иначе исходная cons-ячейка не была бы последней).
Такой список называется <<список с точкой>> по причине используемой для него
специальной записи: элементы списка записанные в двух последних поизициях списка
перед закрывающей круглое скобкой разделяются точкой (обрамленной с двух сторон
пробелами). Тогда последнее значение будет содержаться в \emph{cdr} элементе
последней cons-ячейки. В особых случаях, одиночная cons-ячейка может быть
записана с помощью \emph{car} и \emph{cdr} элементов, обрамленных в круглые скобки
и разделенных с помощью точки, окруженной пробелами. 
Например:
\begin{lisp}
(a . 4)~~~~~~~~~;\textrm{A cons whose \emph{car} is a symbol} \\
~~~~~~~~~~~~~~~~;~\textrm{and whose \emph{cdr} is an integer} \\
(a b c . d)~~~~~;\textrm{A dotted list with three elements whose last cons} \\
~~~~~~~~~~~~~~~~;~\textrm{has the symbol \cdf{d} in its \emph{cdr}}
\end{lisp}

\begin{lisp}
(a . 4)~~~~~~~~~;\textrm{const-ячейка, \emph{car} которой является символом} \\
~~~~~~~~~~~~~~~~;~\textrm{и \emph{cdr} которой равен целому числу} \\
(a b c . d)~~~~~;\textrm{Список с точкой с тремя элементами, у последней} \\
~~~~~~~~~~~~~~~~;~\textrm{cons-ячейки \emph{cdr} равен символу \cdf{d}}
\end{lisp}

\beforenoterule
\begin{incompatibility}
In MacLisp, the dot in dotted-list notation
need not be surrounded by white space or other delimiters.
The dot is required to be delimited in Common Lisp, as in Lisp Machine Lisp.
\end{incompatibility}
\afternoterule

It is legitimate to write something like \cd{(a b . (c d))};
this means the same as \cd{(a b c d)}.  The standard Lisp
output routines will never print a list in the first form, however;
they will avoid dot notation wherever possible.

Правильной записью также является что-то наподобие \cd{(a b . (c d))};
она означает то же, что и \cd{(a b c d)}. Стандартный Lisp вывод никогда не
распечатает список в первом виде, таким образом, он старается избавиться от
записи с точкой, когда это возможно.

Often the term \emph{list} is used to refer either to true lists or to
dotted lists.  When the distinction is important,
the term ``true list'' will be used to refer to a list
terminated by {\nil}.  Most functions
advertised to operate on lists expect to be given true lists. Throughout
this book, unless otherwise specified, it is an error to pass a dotted
list to a function that is specified to require a list as an argument.

Часто термин \emph{список} употребляется и для обычных списков и для списков с
точкой. Когда разница важна, для списка, заканчивающегося с помощью {\nil},
будет употребляться термин <<Ъ список>>. Большинство функций указывают, что
оперируют списками, ожидая что они Ъ. Везде в этой книге, если не указано иное,
передача списка с точкой в такие функции является ошибкой.

\beforenoterule
\begin{implementation}
Implementors are encouraged to use the equivalent
of the predicate \cdf{endp} wherever it is necessary to test
for the end of a list.  Whenever feasible, this test should explicitly
signal an error if a list is found to be terminated by a non-{\nil} atom.
However, such an explicit error signal is not required, because
some such tests occur in important loops where efficiency is important.
In such cases, the predicate \cdf{atom} may be used to test
for the end of the list, quietly treating any non-{\nil} list-terminating
atom as if it were {\nil}.
\end{implementation}
\afternoterule

Sometimes the term \emph{tree} is used to refer to some cons
and all the other conses transitively accessible to it
through \emph{car} and \emph{cdr} links until non-conses are reached;
these non-conses are called the \emph{leaves} of the tree.

Иногда используется термин \emph{дерево} для ссылки на некоторую cons-ячейку,
которая содержит другие cons-ячейки в своих \emph{car} и \emph{cdr} элементах,
которые также содержат cons-ячейки в своих элементах и так далее, пока не будут
достингуты элементы, не являющиеся cons-ячейками.
Такие элементы, не являющиеся cons-ячейками называются \emph{листьями} дерева.

Lists, dotted lists, and trees are not mutually exclusive data types;
they are simply useful points of view about structures of conses.
There are yet other terms, such as \emph{association list}.
None of these are true Lisp data types.  Conses are a data type,
and {\nil} is the sole object of type \cdf{null}.
The Lisp data type \cdf{list} is taken to mean the union of the
\cdf{cons} and \cdf{null} data types, and therefore encompasses both
true lists and dotted lists.

Списки, списки с точкой, и деревья вместе не завершают список типов данных;
они просто являются удобной точкой для рассмотрения таки структур, как
cons-ячейки.
Существуют также другие термины, такие как, например, \emph{ассоциативный
  список}. Ни один из этих типов данных не является Lisp'овым типом
данных. Cons-ячейки являются таким типом данных, и {\nil} является объектом типа
\cdf{null}. Lisp'овый тип данных \cd{список} подразумаевает объединение типов
\cd{cons-ячеек} и \cdf{null}, и по этой причине содержит в себе оба типа Ъ
список и список с точкой.

\section{Arrays Массивы}
\label{ARRAY-TYPE-SECTION}

\indexterm{array}
An \cdf{array} is an object with components arranged according
to a Cartesian coordinate system.
In general, these components may be any Lisp data objects.

\cd{Массив} является объектом с элементами расположенными в соответсвии с
Декартовой системой координат.

The number of dimensions of an array is called its \emph{rank}
(this terminology is borrowed from APL);
the rank is a non-negative integer.
Likewise, each dimension is itself a non-negative integer.
The total number of elements in the array is the product of all the
dimensions.

Количество измерений массива называется \emph{ранг} (это терминология взята из
APL); ранг является неотрицательных целым.
Также каждое измерение само по себе является неотрицательным целым.
Общее количество элементов в массиве является произведением всех измерений.

An implementation of Common Lisp may impose a limit on the rank of an array,
but this limit may not be smaller than 7.  Therefore, any Common Lisp
program may assume the use of arrays of rank 7 or less.
(A program may determine the actual limit on array ranks for
a given implementation by examining the constant \cdf{array-rank-limit}.)

Реализация Common Lisp'а может налагать ограничение на ранг массива, но данное
ограничение не может быть менее 7. Таким образом, любая Common Lisp программа
может использователь массивы с семью и менее измеренеиями.
(Программа может получить текущее ограничение для ранга для заданной реализации
с помощью константы \cdf{array-rank-limit}.)

It is permissible for a dimension to be zero.  In this case,
the array has no elements, and any attempt to access an element
is in error.  However, other properties of the array, such as the
dimensions themselves, may be used.
If the rank is zero, then there are no dimensions, and the
product of the dimensions is then by definition 1.
A zero-rank array therefore has a single element.

Существование нулевого ранга допускается. В этом случае, массив не содержит
элементов, и любой доступ к элементам является ошибкой. Тогда как другие
свойства массива могут использоваться. Если ранг равен нулю, тогда массив не
имеет измерений, и их произведение приравнивается к 1 (FIXME).
Таким образом массив с нулевым рангом содержит один элемент.

An array element is specified by a sequence of indices.
The length of the sequence must equal the rank of the array.
Each index must be a non-negative integer strictly less than
the corresponding array dimension.  Array indexing is
therefore zero-origin, not one-origin as in (the default case of)
Fortran.

Элемент массива задается последовательностью индексов.
Длина данной последовательности должна равнятся рангу массива.
Каждый индекс должен быть неотрицательным целым строго меньшим размеру
соотвествующего измерения. Также индексация массива начинается с нуля, а не с
единицы, как в по умолчанию Fortran'е.

As an example, suppose that the variable \cdf{foo} names a 3-by-5 array.
Then the first index may be 0, 1, or 2, and the second index
may be 0, 1, 2, 3, or 4.  One may refer to array elements using
the function \cdf{aref}; for example, \cd{(aref foo 2 1)}
refers to element (2, 1) of the array.  Note that \cdf{aref} takes
a variable number of arguments: an array, and as many indices
as the array has dimensions.
A zero-rank array has no dimensions, and therefore
\cdf{aref} would take such an array and no indices, and return the sole
element of the array.

В качестве примера, предположим, что переменная \cdf{foo} обозначает двумерный
массив с размерами измерений 3 и 5. Первый индекс может быть 0, 1 или 2, и второй
индекс может быть 0, 1, 2, 3 или 4. Обращение к элементам массива может быть
осуществлено с помощью функции \cdf{aref}; например, \cd{(aref foo 2 1)}
ссылается на элемент массива (2, 1). Следует отметить, что \cdf{aref} принимает
переменное число аргументов: массив, и столько индексов, сколько измерений у
массива.
Массив с нулевым рангом не имеет измерений, и в таком случае \cdf{aref} принимает
только один параметр -- массив, и не принимает индексы, и возвращает одиночный
элемент массива.

In general, arrays can be multidimensional,
can share their contents with other array objects, and can have their
size altered dynamically (either enlarging or shrinking) after creation.
A one-dimensional array may also have a \emph{fill pointer}.

В общем случае, Массивы могут быть многомерными, могут иметь общее содержимое с
другими массивами. и могут динамически менять свой размер после создания (и
увеличивать, и уменьшать).
Одномерный массив может также иметь \emph{указатель заполнения}.

Multidimensional arrays store their components in row-major order;
that is, internally a multidimensional array is stored as a one-dimensional
array, with the multidimensional index sets ordered lexicographically,
last index varying fastest.  This is important in two situations:
(1) when arrays with different dimensions share their contents, and
(2) when accessing very large arrays in a virtual-memory implementation.
(The first situation is a matter of semantics; the second, a matter
of efficiency.)

Многомерные массивы сохраняют элементы построчно;
это значит, что внутренне многомерный массив хранится как одномерный массив с
порядком элементов, соответствующим лексикографическому порядку их индексов. Это
важно в двух ситуациях:
(1) когда массивы с разными измерениями имеют общее содержимое, и 
(2) когда осуществляется доступ к очень большому массиву в виртуальной памяти.
(Первая ситуация касается семантики; вторая -- эффективности)

An array that is not displaced to another array, has no fill pointer, and
is not to have its size adjusted dynamically after creation is called a
\emph{simple} array.  The user may provide declarations that certain arrays
will be simple.  Some implementations can handle simple arrays in an
especially efficient manner; for example, simple arrays may have a more
compact representation than non-simple arrays.

Массив, что не указывает на другой массив, не имеет указателя заполнения и не
имеет динамически расширяемого размера после создания называется \emph{простым}
массивом. Пользователи могут декларировать то, что конкретный массив будет
простым. Некоторые реализации могут обрабатывать простые массивы более
эффективным способом; например, простые массивы могут храниться более компактно,
что непростые массивы. 

\begin{newer}
X3J13 voted in June 1989
\issue{ADJUST-ARRAY-NOT-ADJUSTABLE}
to clarify that if one or more of the \cd{:adjustable}, \cd{:fill-pointer},
and \cd{:displaced-to} arguments is true when \cdf{make-array}
is called, then whether the resulting
array is simple is unspecified; but if all three arguments are false,
then the resulting array is guaranteed to be simple.

Если один или более из \cd{:adjustable}, \cd{:fill-pointer} и
\cd{:displaced-to} аргументов равен true, когда вызывается \cdf{make-array},
тогда является ли результат простым массивом не определено; однако если все три
аргумента равны false, тогда результат гарантированно будет простым массивом.
\end{newer}

\subsection{Vectors Векторы}

One-dimensional arrays are called \emph{vectors} in Common Lisp
and constitute the type \cdf{vector} (which is therefore a subtype of \cdf{array}).
Vectors and lists are collectively considered to be
\emph{sequences}.  They differ in that any component of a one-dimensional array
can be accessed in constant time,
whereas the average component access time for a
list is linear in the length of the list; on the other hand, adding a new
element to the front of a list takes constant time, whereas the same
operation on an array takes time linear in the length of the array.

В Common Lisp'е одномерные массивы называется \emph{векторами}, и составляют тип
\cd{вектор} (который в свою очередь является подтипом \cd{массива}).
Вектора и списки вместе являются \emph{последовательностями}. Они отличаются тем,
что любой элемент одномерного массива может быть получен за константное время,
тогда как среднее время доступа к компоненту для списка линейно зависит от длины
списка, с другой стороны, добавление нового элемента в начала списка занимает
константное время, тогда как эта же операция для массива занимает время линейно
зависящее от длины массива.

A general vector (a one-dimensional array
that can have any data object as an element but that has
no additional paraphernalia) can be notated by notating the
components in order, separated by whitespace and surrounded by \cd{\#(}
and \cd{)}.
For example:

Обычный вектор (одномерный массив, который может содержать любой тип объектов,
но не имеющий дополнительных атрибутов) может быть записан с помощью
перечисления элементов разделенных пробелом и окруженных \cd{\#(} и
\cd{)}.
Например:
\begin{lisp}
\#(a b c)~~~~~~~~~~~~~~~~~~~~;\textrm{A vector of length 3} \\*
\#()~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{An empty vector} \\
\#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{A vector containing the primes below 50}
\end{lisp}

\begin{lisp}
\#(a b c)~~~~~~~~~~~~~~~~~~~~;\textrm{Вектор из трех элементов} \\*
\#()~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Путой вектор} \\
\#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Вектор содержит простые числа меньшие пятидесяти}
\end{lisp}
Note that when the function \cdf{read} parses this syntax, it always constructs
a \emph{simple} general vector.

Следует отметить, что когда функция \cdf{read} парсит данный синтаксис, она
всегда создает \emph{простой} массив.

\beforenoterule
\begin{rationale}
Many people have suggested that brackets be used
to notate vectors, as \cd{{\Xlbracket}a b c{\Xrbracket}}
instead of \cd{\#(a b c)}.  This notation
would be shorter, perhaps more readable, and certainly in accord with
cultural conventions in other parts of computer science and mathematics.
However, to preserve the usefulness of the user-definable macro-character
feature of the function \cdf{read}, it is necessary to leave some
characters to the user for this purpose.  Experience in MacLisp has
shown that users, especially implementors of languages for use
in artificial intelligence research, often want
to define special kinds of brackets.  Therefore Common Lisp avoids using
brackets and braces for any syntactic purpose.

Многие люди рекомендовали использовать квадратные скобки для задания векторов
так: \cd{{\Xlbracket}a b c{\Xrbracket}} вместо \cd{\#(a b c)}. Данная запись
короче, возможно более читаема, и безусловно совпадает с культурными традициями
в других частях компьютерных наук и математики. Однако, для достижения
предельной полезности от пользовательских макросимволов, что расширяют
возможности функции \cdf{read}, необходимо было оставить некоторые строковые
символы для этих пользовательских целей. Опыт использования MacLisp'а
показывает, что пользователи, особенно разработчики языков для использования в
исследованиях искусственного интеллекта, часто хотят определять специальные
значения для квадратных скобос. Таким образом Common Lisp не использует
квадратных и фигурных скобок в своем синтаксисе.
\end{rationale}
\afternoterule

Implementations may provide certain specialized representations of
arrays for efficiency in the case where all the components are of
the same specialized (typically numeric) type.  All implementations
provide specialized arrays for the cases when the components
are characters (or rather, a special subset of the characters);
the one-dimensional instances of
this specialization are called \emph{strings}.
All implementations are also required to provide specialized arrays
of bits, that is, arrays of type \cd{(array bit)};
the one-dimensional instances of
this specialization are called \emph{bit-vectors}.

Реализации могут предоставлять специализированные представления массивов для
достижения эффективности в случаях, когда все элементы принадлежат одному
определенному типу (например, числовому). Все реализации предоставляют
специальные массивы в случаях, когда все элементы являются строковыми символами
(или специализированное подмножество строковых символов);
такие одномерные массивы называются \emph{строки}.
Все реализации также должны предоставлять специализированные битовые массивы,
которые принадлежат типу \cd{(array bit)};
такие одномерные массивы назваются \emph{битовые векторы}.

\subsection{Strings Строки}
\label{STRING-TYPE-SECTION}

\begin{obsolete}
A string is simply a vector of characters.
More precisely, a string is a specialized vector whose elements
are of type \cdf{string-char}.
\end{obsolete}
\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to eliminate the type \cdf{string-char} and to redefine the type
\cdf{string} to be the union of one or more specialized vector
types, the types of whose elements are subtypes of the type \cdf{character}.
Subtypes of \cdf{string} include \cdf{simple-string}, \cdf{base-string},
and \cdf{simple-base-string}.

\vskip 3pt
\begin{lisp}
base-string \EQ\ (vector base-character) \\*
simple-base-string \EQ\ (simple-array base-character (*))
\end{lisp}
An implementation may support
other string subtypes as well.  All Common Lisp functions that operate
on strings treat all strings uniformly; note, however,
that it is an error to attempt to insert
an extended character into a base string.
\end{newer}

\newpage%manual

The type \cdf{string} is therefore a subtype of the type \cdf{vector}.

\cd{Строковый} тип является подтипом \cd{векторного} типа.

A string can be written as the sequence of characters contained in the
string, preceded and followed by a \cd{{\Xdquote}} (double quote) character.
Any \cd{{\Xdquote}} or \cd{{\Xbackslash}} character in the sequence must additionally
have a \cd{{\Xbackslash}} character before it.

Строка может быть записана как последовательность символов содержащихся в
строке, с предшествующим и последующим символом двойной кавычки \cd{{\Xdquote}}.
Любой символ \cd{{\Xdquote}} или \cd{{\Xbackslash}} в данной последовательности должен
иметь предшествующий символ \cd{{\Xbackslash}}.

For example:

Например:
\begin{lisp}
{\Xdquote}Foo{\Xdquote}~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{A string with three characters in it} \\*
{\Xdquote}{\Xdquote}~~~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{An empty string} \\
{\Xdquote}{\Xbackslash}{\Xdquote}APL{\Xbackslash}{\Xbackslash}360?{\Xbackslash}{\Xdquote} he cried.{\Xdquote}~~~~~;\textrm{A string with twenty characters} \\*
{\Xdquote}|x| = |-x|{\Xdquote}~~~~~~~~~~~~~~~~~~;\textrm{A ten-character string}
\end{lisp}

\begin{lisp}
{\Xdquote}Foo{\Xdquote}~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Строка из трех символов} \\*
{\Xdquote}{\Xdquote}~~~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{Пустая строка} \\
{\Xdquote}{\Xbackslash}{\Xdquote}APL{\Xbackslash}{\Xbackslash}360?{\Xbackslash}{\Xdquote} he
cried.{\Xdquote}~~~~~;\textrm{Строка из двенадцати символов} \\*
{\Xdquote}|x| = |-x|{\Xdquote}~~~~~~~~~~~~~~~~~~;\textrm{Строка из десяти символов}
\end{lisp}
Notice that any vertical bar \cd{|} in a string need not be
preceded by a \cd{{\Xbackslash}}.  Similarly, any double quote in the name
of a symbol written using vertical-bar notation need not be
preceded by a \cd{{\Xbackslash}}.  The double-quote and vertical-bar notations
are similar but distinct: double quotes indicate a character string
containing the sequence of characters,
whereas vertical bars indicate a symbol whose name is the contained
sequence of characters.

Необходимо отметить, что символ вертикальной черты \cd{|} в строке не должен быть
экранирован с помощью \cd{{\Xbackslash}}. Также как и любая двойная кавычка в имени
символа, записанного с использованием вертикальных черт, не нуждается в
экранировании. Записи с помощью двойной кавычки и вертикальной черты похожи, но
используются для разных целей: двойная кавычка указывает на строку, содержающую
строковые символы, тогда как вертикальная черта указывает на символ, имя
которого содержит последовательность строковых символов.

The characters contained by the double quotes, taken from left to right,
occupy locations within the string with increasing indices.
The leftmost character is string element number 0, the next one
is element number 1, the next one is element number 2, and so on.

Строковые символы обрамленные двойными кавычками, считываются слева
направо. Индекс символа больше индекса предыдущего символа на 1. Самый левый
символ строки имеет индекс 0, следующий 1, следующий 2, и т.д.

Note that the function \cd{prin1} will print any character vector
(not just a simple one)
using this syntax, but the function \cdf{read} will always construct
a simple string when it reads this syntax.

Следует отметить, что функция \cd{prin1} будет выводить на печать любой вектор
строковых символов (не только простой), используя данный синтаксис, но функция
\cdf{read} будет всегда создавать простую строку, при разборе данного синтаксиса.

\subsection{Bit-Vectors}

A bit-vector can be written as the sequence of bits contained in the
string, preceded by \cd{\#*}; any delimiter character, such as whitespace,
will terminate the bit-vector syntax.
For example:

Битовый вектор может быть записан в виде последовательности битов заключенных в
строку с предшествующей \cd{\#*}; любой разделитится, например, как пробел
завершает синаксис битового вектора.
Например:
\begin{lisp}
\#*10110~~~~~;\textrm{A five-bit bit-vector; bit 0 is a 1} \\
\#*~~~~~~~~~~;\textrm{An empty bit-vector}
\end{lisp}

\begin{lisp}
\#*10110~~~~~;\textrm{Пятибитный битовый вектор; нулевой бит 1} \\
\#*~~~~~~~~~~;\textrm{Пустой битовый вектор}
\end{lisp}

The bits notated following the \cd{\#*}, taken from left to right,
occupy locations within the bit-vector with increasing indices.
The leftmost notated bit is bit-vector element number 0, the next one
is element number 1, and so on.

Биты записанные после \cd{\#*}, читаются слева направо. Индекс каждого бита
больше индекса предыдущего бита на 1. Индекс самого левого бита 0, следующего 1
и т.д.

The function \cd{prin1} will print any bit-vector (not just a simple one)
using this syntax, but the function \cdf{read} will always construct
a simple bit-vector when it reads this syntax.

Функция \cd{prin1} распечатывают любой битовый вектор (не только простой)
используя этот синтаксис, однако функция \cdf{read} будет всегда создавать простой
битовый веткор, когда разбирает данный синтаксис.

\section{Hash Tables Хеш-таблицы}
Hash tables provide an efficient way of mapping any
Lisp object (a \emph{key}) to an associated object.
They are provided as primitives of Common Lisp because
some implementations may need to use internal storage
management strategies that would make it very difficult
for the user to implement hash tables in a portable fashion.
Hash tables are described in chapter~\ref{HASH}.

Хеш-таблицы предоставляют эффективный путь для связи любого Lisp объекта ({\it
 ключа}) с другим объектом. Они предоставляются как примитивы Common Lisp'а,
потому что некоторые реализации могут нуждаться в использовании стратегий
управления внутренними хранилищами, что создало бы сложности для пользователя в
реализации портируемых хеш-таблиц.
Хеш-таблицы описаны в главе~\ref{HASH}.

\section{Readtables Readtables}

A readtable is a data structure that maps characters into syntax
types for the Lisp expression parser.
In particular, a readtable indicates for
each character with syntax \emph{macro character} what its macro
definition is.  This is a mechanism by which the user may reprogram
the parser to a limited but useful extent.
See section~\ref{READTABLE-SECTION}.

Readtable является структурой данных, которая отображает символы в
синтаксические типы для парсера Lisp выражений.
В частности, readtable указывает для каждого строкового символа с синтаксисом
\emph{макросимвола}, какой макрос ему соотвествует. Это механизм, с помощью
которого пользователь может запрограммировать парсер для выполнения
ограниченных, но полезных расширений.
Смотрите раздел~\ref{READTABLE-SECTION}.

\section{Packages Пакеты}

Packages are collections of symbols that serve as name spaces.
The parser recognizes symbols by looking up character sequences
in the current package.  Packages can be used to hide
names internal to a module from other code.  Mechanisms are provided
for exporting symbols from a given package to the primary ``user'' package.
See chapter~\ref{XPACK}.

Пакеты являются коллекциями символов, которые предоставлены в качестве
пространства имен. Парсер распознает символы с помощью поиска строки в текущем
пакете. Пакеты могут использоваться для скрытия имен внутрь модуля от другого
кода. Также предоставляются механизмы для экспортирования символов из заданного
пакета в главный <<user>> пакет.
Смотрите главу~\ref{XPACK}.

\section{Pathnames Имена файлов}
Pathnames are the means by which a Common Lisp program can
interface to an external file system in a reasonably implementation-independent
manner.  See section~\ref{PATHNAME}.

Имена файлов являеются сущностями, с помощью которых Common Lisp программа может
взаимодействовать с внешней файловой системой в приемлемой платформонезависимой
форме. Смотрите раздел~\ref{PATHNAME}.

\section{Streams Потоки}

A stream is a source or sink of data, typically characters or bytes.
Nearly all functions that perform I/O do so with respect to a specified
stream.  The function \cdf{open} takes a pathname and returns a stream
connected to the file specified by the pathname.
There are a number of standard streams that are used by default for
various purposes.  See chapter~\ref{STREAM}.

Поток является источником или набором данных, обычно строковых символов или
байтов. Почти все функции, что выполняют ввод/вывод, делают это в отношении
заданного потока. Функция \cdf{open} принимает путь к файлу и возвращается поток
подключенный к файлу заданному в параметре.
Существует несколько стандартных потоков, которые используются по умолчанию для
различных целей. Смотрите главу~\ref{STREAM}.

\begin{newer}
X3J13 voted in January 1989
\issue{STREAM-ACCESS}
to introduce subtypes of type \cdf{stream}:
\cdf{broadcast-stream}, \cdf{concatenated-stream},
\cdf{echo-stream}, \cdf{synonym-stream}, \cdf{string-stream}, \cdf{file-stream},
and \cdf{two-way-stream} are disjoint subtypes of \cdf{stream}.
Note particularly that a synonym stream is always and only of type
\cdf{synonym-stream}, regardless of the type of the stream for which it is a synonym.
\end{newer}

\section{Random-States Random-States}

An object of type \cdf{random-state} is used to encapsulate
state information used by the pseudo-random number generator.
For more information about \cdf{random-state} objects,
see section~\ref{RANDOM}.

Объект типа \cdf{random-state} используется для инкапсулирования информации о
состоянии, используемом генератором случайных чисел (ГСЧ). Для боле подробной
информации об объектах \cdf{random-state} смотрите главу~\ref{RANDOM}.

\section{Structures Структуры}

Structures are instances of user-defined data types that have
a fixed number of named components.  They are analogous to
records in Pascal.
Structures are declared using the \cdf{defstruct} construct;
\cdf{defstruct} automatically defines access and constructor functions for
the new data type.

Структуры являются экземплярами определенных пользователем типов данных, которые
имеют ограниченное количество именованных полей (свойств). Они являются
аналогами записей в Pascal'е.
Структуры декларируются используя конструкцию \cdf{defsctruct};
\cdf{defstruct} автоматически определяет конструктор и функции доступа для нового
типа данных.

Different structures may print out in different ways;
the definition of a structure type may specify a print procedure
to use for objects of that type (see the
\cd{:print-function} option to \cdf{defstruct}).
The default notation for structures is

Различные структуры могут выводится на печать различными способами;
определение типа структуры может задавать процедуру вывода на печать для
объектов данного типа (смотрите опцию \cd{:print-function} для \cdf{defstruct}).
Записью по умолчанию для структур является:
\begin{lisp}
\#S(\emph{structure-name} \\
~~~~~~~~\emph{slot-name-1} \emph{slot-value-1} \\
~~~~~~~~\emph{slot-name-2} \emph{slot-value-2} \\
~~~~~~~~~~~~~~~~~~~~~~...)
\end{lisp}
where \cd{\#S} indicates structure syntax, \emph{structure-name} is
the name (a symbol) of the structure type, each \emph{slot-name} is the name
(also a symbol) of a component, and each corresponding \emph{slot-value}
is the representation of the Lisp object in that slot.

\begin{lisp}
\#S(\emph{имя-структуры} \\
~~~~~~~~\emph{имя-слота-1} \emph{значение-слота-1} \\
~~~~~~~~\emph{имя-слота-2} \emph{значение-слота-2} \\
~~~~~~~~~~~~~~~~~~~~~~...)
\end{lisp}
где \cd{\#S} указывает на синтаксис структуры, \emph{имя-структуры} является
именем (символ) типа данной структуры, каждый \emph{имя-слота} является именем
слота (также символ), и каждое соответствующее \emph{значение-слота} --
отображением Lisp объекта в данном слоте.

\section{Functions Функции}
\label{FUNCTION-TYPE-SECTION}

\begin{obsolete}
A \emph{function} is anything that may be correctly given to the \cdf{funcall}
or \cdf{apply} function, and is
to be executed as code when arguments are supplied.

A \emph{compiled-function} is a compiled code object.

A lambda-expression
(a list whose \emph{car} is the symbol \cdf{lambda}) may serve as a function.
Depending on the implementation, it may be possible for other lists to
serve as functions.  For example, an implementation might choose to
represent a ``lexical closure'' as a list whose \emph{car} contains some
special marker.

A symbol may serve as a function; an attempt to invoke a symbol as a function
causes the contents of the symbol's function cell to be used.
See \cdf{symbol-function} and \cdf{defun}.

The result of evaluating a \cdf{function} special form
will always be a function.
\end{obsolete}

\begin{newer}
X3J13 voted in June 1988 \issue{FUNCTION-TYPE}
to revise these specifications.  The type \cdf{function} is to be disjoint
from \cdf{cons} and \cdf{symbol}, and so a list whose \emph{car} is \cdf{lambda}
is not, properly speaking, of type \cdf{function}, nor is any symbol.
However,
standard Common Lisp functions that accept functional arguments
will accept a symbol or a list whose \emph{car} is \cdf{lambda}
and automatically coerce it to be a function; such standard
functions include \cdf{funcall}, \cdf{apply}, and \cdf{mapcar}.
Such functions do not, however, accept a lambda-expression as a functional
argument; therefore one may not write

\vskip 3pt
\begin{lisp}
(mapcar '(lambda (x y) (sqrt (* x y))) p q)
\end{lisp}
but instead one must write something like
\begin{lisp}
(mapcar \#'(lambda (x y) (sqrt (* x y))) p q)
\end{lisp}

This change makes it impermissible to represent a lexical closure
as a list whose \emph{car} is some special marker.

The value of a \cdf{function} special form
will always be of type \cdf{function}.
\end{newer}

\section{Unreadable Data Objects Нечитаемые объекты данных}

Some objects may print in implementation-dependent ways.
Such objects cannot necessarily be reliably reconstructed from
a printed representation, and so they are usually printed in
a format informative to the user but not acceptable to the \cdf{read} function:
\cd{\#<\emph{useful information}>}.
The Lisp reader will signal an error on encountering \cd{\#<}.

Некоторые объекты могут быть выведены на печать в виде, который зависит от
реализации.
Такие объекты не могут быть полностью реконструированы из распечатанной формы,
так как они обычно распечатываются в форме информативной для пользователя, но не
подходящей для функции \cdf{read}:
\cd{\#<\emph{полезная информация}}.

As a hypothetical example, an implementation might print
\begin{lisp}
\#<stack-pointer si:rename-within-new-definition-maybe \#o311037552>
\end{lisp}
for an implementation-specific ``internal stack pointer'' data type
whose printed representation includes the name of the type,
some information about the stack slot pointed to, and the machine address
(in octal) of the stack slot.

\begin{newer}
See \cdf{print-unreadable-object}, a macro that prints an object using \cd{\#<}
syntax.
\end{newer}

\section{Overlap, Inclusion, and Disjointness of Types}
\label{DATA-TYPE-RELATIONSHIPS}

The Common Lisp data type hierarchy is tangled and purposely left somewhat
open-ended so that implementors may experiment with new data types
as extensions to the language.  This section explicitly states all
the defined relationships between types, including subtype/supertype
relationships,
disjointness, and exhaustive partitioning.  The user of Common Lisp
should not depend on any relationships not explicitly stated here.
For example, it is not valid to assume that because a number
is not complex and not rational that it must be a \cdf{float}, because
implementations are permitted to provide yet other kinds of numbers.

First we need some terminology.
If \emph{x} is a supertype of \emph{y}, then any object of type \emph{y} is also
of type \emph{x}, and \emph{y} is said to be a subtype of \emph{x}.  If types
\emph{x} and \emph{y} are disjoint, then no object (in any implementation) may
be both of type \emph{x} and of type \emph{y}.  Types $\emph{a}_1$ through
$\emph{a}_{\hbox{\scriptsize\it n}}$ are an \emph{exhaustive union}
of type \emph{x} if each $\emph{a}_j$
is a subtype of \emph{x}, and any object of type \emph{x} is
necessarily of at least one of the types $\emph{a}_{\hbox{\scriptsize\it j}}$;
$\emph{a}_1$ through $\emph{a}_{\hbox{\scriptsize\it n}}$ are furthermore an \emph{exhaustive partition}
if they are also pairwise disjoint.

\begin{itemize}
\item
The type \cdf{t} is a supertype of every type whatsoever.
Every object is of type \cdf{t}.

\item
The type {\nil} is a subtype of every type whatsoever.
No object is of type {\nil}.
\end{itemize}

\begin{obsolete}
\begin{itemize}
\item
The types \cdf{cons}, \cdf{symbol}, \cdf{array}, \cdf{number}, and \cdf{character}
are pairwise disjoint.
\end{itemize}
\end{obsolete}

\begin{new}
X3J13 voted in June 1988
\issue{DATA-TYPES-HIERARCHY-UNDERSPECIFIED}
to extend the preceding paragraph as follows.

\begin{itemize}
\item
The types \cdf{cons}, \cdf{symbol}, \cdf{array}, \cdf{number}, \cdf{character},
\cdf{hash-table}, \cdf{readtable}, \cdf{package}, \cdf{pathname},
\cdf{stream}, \cdf{random-state}, and any single other type created by
\cdf{defstruct} or \cdf{defclass}
are pairwise disjoint.
\end{itemize}

The wording of the first edition was intended to allow implementors to use
the \cdf{defstruct} facility to define the built-in types \cdf{hash-table},
\cdf{readtable}, \cdf{package}, \cdf{pathname}, \cdf{stream}, \cdf{random-state}.
The change still permits this implementation strategy but
forbids these built-in types from including, or being included in,
other types (in the sense of the \cdf{defstruct} \cd{:include} option).
\end{new}

\begin{new}
X3J13 voted in June 1988 \issue{FUNCTION-TYPE}
to specify that the type \cdf{function}
is disjoint from the types \cdf{cons}, \cdf{symbol}, \cdf{array}, \cdf{number}, and \cdf{character}.
The type \cdf{compiled-function} is a subtype of \cdf{function};
implementations are free to define other subtypes of \cdf{function}.
\end{new}

\begin{obsolete}
\begin{itemize}
\item
The types \cdf{rational}, \cdf{float}, and \cdf{complex} are pairwise disjoint
subtypes of \cdf{number}.
\end{itemize}
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989 \issue{REAL-NUMBER-TYPE} to rewrite the preceding item
as follows.
\begin{itemize}
\item
The types \cdf{real} and \cdf{complex} are pairwise disjoint
subtypes of \cdf{number}.
\end{itemize}

\beforenoterule
\begin{rationale}
It might be thought that \cdf{real} and \cdf{complex} should
form an exhaustive partition of the type \cdf{number}.  This is purposely
avoided here in order to permit compatible experimentation with extensions
to the Common Lisp number system.
\end{rationale}
\afternoterule

\begin{itemize}
\item
The types \cdf{rational} and \cdf{float} are pairwise disjoint
subtypes of \cdf{real}.
\end{itemize}

\beforenoterule
\begin{rationale}
It might be thought that \cdf{rational} and \cdf{float} should
form an exhaustive partition of the type \cdf{real}.  This is purposely
avoided here in order to permit compatible experimentation with extensions
to the Common Lisp number system.
\end{rationale}
\afternoterule
\end{newer}

\begin{itemize}
\item
The types \cdf{integer} and \cdf{ratio} are disjoint subtypes of \cdf{rational}.
\end{itemize}

\beforenoterule
\begin{rationale}
It might be thought that \cdf{integer} and \cdf{ratio} should
form an exhaustive partition of the type \cdf{rational}.  This is purposely
avoided here in order to permit compatible experimentation with extensions
to the Common Lisp rational number system.
\end{rationale}
\afternoterule

\begin{obsolete}
\begin{itemize}
\item
The types \cdf{fixnum} and \cdf{bignum} are disjoint subtypes of \cdf{integer}.
\end{itemize}

\beforenoterule
\begin{rationale}
It might be thought that \cdf{fixnum} and \cdf{bignum} should
form an exhaustive partition of the type \cdf{integer}.  This is purposely
avoided here in order to permit compatible experimentation with
extensions to the Common Lisp integer number system, such as the idea of
adding explicit representations of infinity or of positive and negative
infinity.
\end{rationale}
\afternoterule
\end{obsolete}

\begin{new}
X3J13 voted in January 1989
\issue{FIXNUM-NON-PORTABLE}
to specify that the types \cdf{fixnum} and \cdf{bignum}
do in fact form an exhaustive partition of the type \cdf{integer}; more precisely,
they voted to specify that the type \cdf{bignum} is by definition equivalent
to \cd{(and~integer (not~fixnum))}.  This is consistent with the
first edition text in section~\ref{INTEGERS-SECTION}.

I interpret this to mean that implementators could still experiment with
such extensions as adding explicit representations of infinity, but such infinities
would necessarily be of type \cdf{bignum}.
\end{new}

\begin{itemize}
\item
The types \cdf{short-float}, \cdf{single-float}, \cdf{double-float}, and
\cdf{long-float} are subtypes of \cdf{float}.  Any two of them must be
either disjoint or identical; if identical, then any other types between
them in the above ordering must also be identical to them
(for example, if \cdf{single-float} and \cdf{long-float} are identical types,
then \cdf{double-float} must be identical to them also).

\item
The type \cdf{null} is a subtype of \cdf{symbol}; the only object of type
\cdf{null} is {\nil}.

\item
The types \cdf{cons} and \cdf{null} form an exhaustive partition of the type
\cdf{list}.
\end{itemize}

\begin{obsolete}
\begin{itemize}
\item
The type \cdf{standard-char} is a subtype of \cdf{string-char};
\cdf{string-char} is a subtype of \cdf{character}.
\end{itemize}
\end{obsolete}


\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL} to remove the type \cdf{string-char}.
The preceding item is replaced by the following.
\begin{itemize}
\item
The type \cdf{standard-char} is a subtype of \cdf{base-character}.
The types \cdf{base-character} and \cdf{extended-character}
form an exhaustive partition of \cdf{character}.
\end{itemize}
\end{newer}

\begin{obsolete}
\begin{itemize}
\item
The type \cdf{string} is a subtype of \cdf{vector}, for \cdf{string}
means \cd{(vector string-char)}.
\end{itemize}
\end{obsolete}

\newpage%manual
\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL} to remove the type \cdf{string-char}.
The preceding item is replaced by the following.
\begin{itemize}
\item
The type \cdf{string} is a subtype of \cdf{vector}; it is the union of
all types \cd{(vector~\emph{c})} such that \emph{c} is a subtype of \cdf{character}.
\end{itemize}
\end{newer}

\begin{itemize}
\item
The type \cdf{bit-vector} is a subtype of \cdf{vector}, for \cdf{bit-vector}
means \cd{(vector bit)}.

\item
The types \cd{(vector t)}, \cdf{string}, and \cdf{bit-vector} are disjoint.

\item
The type \cdf{vector} is a subtype of \cdf{array}; for all types \emph{x},
the type \cd{(vector \emph{x})} is the same as the type \cd{(array \emph{x} (*))}.

\item
The type \cdf{simple-array} is a subtype of \cdf{array}.
\end{itemize}

\begin{obsolete}
\begin{itemize}
\item
The types \cdf{simple-vector}, \cdf{simple-string}, and
\cdf{simple-bit-vector} are disjoint subtypes of \cdf{simple-array}, for they
respectively mean \cd{(simple-array t (*))}, \cd{(simple-array string-char (*))},
and \cd{(simple-array bit (*))}.
\end{itemize}
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL} to remove the type \cdf{string-char}.
The preceding item is replaced by the following.
\begin{itemize}
\item
The types \cdf{simple-vector}, \cdf{simple-string}, and
\cdf{simple-bit-vector} are disjoint subtypes of \cdf{simple-array}, for they
mean \cd{(simple-array t (*))}, the union of all types
\cd{(simple-array \emph{c} (*))} such that \emph{c} is a subtype of \cdf{character},
and \cd{(simple-array bit (*))}, respectively.
\end{itemize}
\end{newer}

\begin{itemize}
\item
The type \cdf{simple-vector} is a subtype of \cdf{vector} and indeed
is a subtype of \cd{(vector t)}.

\item
The type \cdf{simple-string} is a subtype of \cdf{string}.
(Note that although \cdf{string} is a subtype of \cdf{vector},
\cdf{simple-string} is not a subtype of \cdf{simple-vector}.)
\end{itemize}

\beforenoterule
\begin{rationale}
The hypothetical name \cdf{simple-general-vector} would have been more accurate than
\cdf{simple-vector}, but in this instance euphony and
user convenience were deemed more important to the design
of Common Lisp than a rigid symmetry.
\end{rationale}
\afternoterule

\begin{itemize}
\item
The type \cdf{simple-bit-vector} is a subtype of \cdf{bit-vector}.
(Note that although \cdf{bit-vector} is a subtype of \cdf{vector},
\cdf{simple-bit-vector} is not a subtype of \cdf{simple-vector}.)

\item
The types \cdf{vector} and \cdf{list} are disjoint subtypes of \cdf{sequence}.

\item
The types \cdf{random-state}, \cdf{readtable}, \cdf{package}, \cdf{pathname},
\cdf{stream}, and \cdf{hash-table} are pairwise disjoint.
\end{itemize}

\begin{new}
X3J13 voted in June 1988
\issue{DATA-TYPES-HIERARCHY-UNDERSPECIFIED}
to make \cdf{random-state}, \cdf{readtable}, \cdf{package}, \cdf{pathname},
\cdf{stream}, and \cdf{hash-table}
pairwise disjoint from a number of other types as well;
see note above.
\end{new}

\begin{new}
X3J13 voted in January 1989
\issue{STREAM-ACCESS}
to introduce subtypes of type \cdf{stream}.

\begin{itemize}
\item
The types \cdf{two-way-stream}, \cdf{echo-stream},
\cdf{broadcast-stream}, \cdf{file-stream}, \cdf{synonym-stream}, \cdf{string-stream}, and
\cdf{concatenated-stream} are disjoint subtypes of \cdf{stream}.
\end{itemize}
\end{new}

\begin{itemize}
\item
Any two types created by \cdf{defstruct} are disjoint unless
one is a supertype of the other by virtue of
the \cd{:include} option.
\end{itemize}

\begin{obsolete}
\begin{itemize}
\item
An exhaustive union for the type \cdf{common} is formed by the types
\cdf{cons}, \cdf{symbol}, \cd{(array \emph{x})} where \emph{x} is either {\true} or 
a subtype
of \cdf{common}, \cdf{string}, \cdf{fixnum}, \cdf{bignum}, \cdf{ratio},
\cdf{short-float}, \cdf{single-float}, \cdf{double-float}, \cdf{long-float},
\cd{(complex \emph{x})} where \emph{x} is a
subtype of \cdf{common},
\cdf{standard-char}, \cdf{hash-table}, \cdf{readtable}, \cdf{package}, \cdf{pathname},
\cdf{stream}, \cdf{random-state}, and all types created by the user
via \cdf{defstruct}.
An implementation may not unilaterally add subtypes to
\cdf{common}; however, future revisions to the Common Lisp standard may
extend the definition of the \cdf{common} data type.
Note that a type such as \cdf{number} or \cdf{array} may or may
not be a subtype of \cdf{common}, depending on whether or not the given
implementation has extended the set of objects of that type.
\end{itemize}
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989
\issue{COMMON-TYPE}
to remove the type \cdf{common} from the language.
\end{newer}
