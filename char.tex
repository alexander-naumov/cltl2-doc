%Part{Char, Root = "CLM.MSS"}
%%% Chapter of Common Lisp Manual.  Copyright 1984, 1987, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\chapter{Characters Строковые символы}

Common Lisp provides a character data type; objects of this type
represent printed symbols such as letters.

Common Lisp содержит тип данных для строковых типов. Объекты данного типа
представляют печатаемые символы, как например буквы.

In general, characters in Common Lisp are not true objects; \cdf{eq} cannot
be counted upon to operate on them reliably.  In particular,
it is possible that the expression
\begin{lisp}
(let ((x z) (y z)) (eq x y))
\end{lisp}
may be false rather than true, if the value of \cdf{z} is a character.

Строковые символы в Common Lisp'е не совсем объекты. Нельзя положится на то, что
\cdf{eq} будет работать с ними правильно. В частности, возможно что выражение
\begin{lisp}
(let ((x z) (y z)) (eq x y))
\end{lisp}
может быть ложным, а не истины, если значение \cdf{z} является строковым
символом.

\beforenoterule
\begin{rationale}
This odd breakdown of \cdf{eq} in the case of characters
allows the implementor enough design freedom to produce exceptionally
efficient code on conventional architectures.  In this respect the
treatment of characters exactly parallels that of numbers, as described
in chapter~\ref{NUMBER}.
\end{rationale}
\afternoterule

\begin{table}
\caption{Standard Character Labels, Glyphs, and Descriptions}
\label{STANDARD-CHAR-REPERTOIRE-TABLE}
\tabcolsep0pt
\def\arraystretch{1.1}

\begin{tabular*}{\textwidth}{@{}l@{\extracolsep{\fill}}llllllll@{}}
           &&&\cd{SM05}&\cd{{\Xatsign}}&\textrm{commercial at}&\cd{SD13}&\cd{{\Xbq}}&\textrm{grave accent} \\
\cd{SP02}&\cd{!}&\textrm{exclamation mark}&\cd{LA02}&\cdf{A}&\textrm{capital A}&\cd{LA01}&\cdf{a}&\textrm{small a} \\
\cd{SP04}&\cd{"}&\textrm{quotation mark}&\cd{LB02}&\cdf{B}&\textrm{capital B}&\cd{LB01}&\cdf{b}&\textrm{small b} \\
\cd{SM01}&\cd{\#}&\textrm{number sign}&\cd{LC02}&\cdf{C}&\textrm{capital C}&\cd{LC01}&\cdf{c}&\textrm{small c} \\
\cd{SC03}&\cd{\$}&\textrm{dollar sign}&\cd{LD02}&\cdf{D}&\textrm{capital D}&\cd{LD01}&\cdf{d}&\textrm{small d} \\
\cd{SM02}&\cd{\%}&\textrm{percent sign}&\cd{LE02}&\cdf{E}&\textrm{capital E}&\cd{LE01}&\cdf{e}&\textrm{small e} \\
\cd{SM03}&\cd{\&}&\textrm{ampersand}&\cd{LF02}&\cdf{F}&\textrm{capital F}&\cd{LF01}&\cdf{f}&\textrm{small f} \\
\cd{SP05}&\cd{'}&\textrm{apostrophe}&\cd{LG02}&\cdf{G}&\textrm{capital G}&\cd{LG01}&\cdf{g}&\textrm{small g} \\
\cd{SP06}&\cd{(}&\textrm{left parenthesis}&\cd{LH02}&\cdf{H}&\textrm{capital H}&\cd{LH01}&\cdf{h}&\textrm{small h} \\
\cd{SP07}&\cd{)}&\textrm{right parenthesis}&\cd{LI02}&\cdf{I}&\textrm{capital I}&\cd{LI01}&\cdf{i}&\textrm{small i} \\
\cd{SM04}&\cdf{*}&\textrm{asterisk}&\cd{LJ02}&\cdf{J}&\textrm{capital J}&\cd{LJ01}&\cdf{j}&\textrm{small j} \\
\cd{SA01}&\cdf{+}&\textrm{plus sign}&\cd{LK02}&\cdf{K}&\textrm{capital K}&\cd{LK01}&\cdf{k}&\textrm{small k} \\
\cd{SP08}&\cd{,}&\textrm{comma}&\cd{LL02}&\cdf{L}&\textrm{capital L}&\cd{LL01}&\cdf{l}&\textrm{small l} \\
\cd{SP10}&\cdf{-}&\textrm{hyphen or minus sign}&\cd{LM02}&\cdf{M}&\textrm{capital M}&\cd{LM01}&\cdf{m}&\textrm{small m} \\
\cd{SP11}&\cd{.}&\textrm{period or full stop}&\cd{LN02}&\cdf{N}&\textrm{capital N}&\cd{LN01}&\cdf{n}&\textrm{small n} \\
\cd{SP12}&\cdf{/}&\textrm{solidus}&\cd{LO02}&\cdf{O}&\textrm{capital O}&\cd{LO01}&\cdf{o}&\textrm{small o} \\
\cd{ND10}&\cd{0}&\textrm{digit 0}&\cd{LP02}&\cdf{P}&\textrm{capital P}&\cd{LP01}&\cdf{p}&\textrm{small p} \\
\cd{ND01}&\cd{1}&\textrm{digit 1}&\cd{LQ02}&\cdf{Q}&\textrm{capital Q}&\cd{LQ01}&\cdf{q}&\textrm{small q} \\
\cd{ND02}&\cd{2}&\textrm{digit 2}&\cd{LR02}&\cdf{R}&\textrm{capital R}&\cd{LR01}&\cdf{r}&\textrm{small r} \\
\cd{ND03}&\cd{3}&\textrm{digit 3}&\cd{LS02}&\cdf{S}&\textrm{capital S}&\cd{LS01}&\cdf{s}&\textrm{small s} \\
\cd{ND04}&\cd{4}&\textrm{digit 4}&\cd{LT02}&\cdf{T}&\textrm{capital T}&\cd{LT01}&\cdf{t}&\textrm{small t} \\
\cd{ND05}&\cd{5}&\textrm{digit 5}&\cd{LU02}&\cdf{U}&\textrm{capital U}&\cd{LU01}&\cdf{u}&\textrm{small u} \\
\cd{ND06}&\cd{6}&\textrm{digit 6}&\cd{LV02}&\cdf{V}&\textrm{capital V}&\cd{LV01}&\cdf{v}&\textrm{small v} \\
\cd{ND07}&\cd{7}&\textrm{digit 7}&\cd{LW02}&\cdf{W}&\textrm{capital W}&\cd{LW01}&\cdf{w}&\textrm{small w} \\
\cd{ND08}&\cd{8}&\textrm{digit 8}&\cd{LX02}&\cdf{X}&\textrm{capital X}&\cd{LX01}&\cdf{x}&\textrm{small x} \\
\cd{ND09}&\cd{9}&\textrm{digit 9}&\cd{LY02}&\cdf{Y}&\textrm{capital Y}&\cd{LY01}&\cdf{y}&\textrm{small y} \\
\cd{SP13}&\cd{:}&\textrm{colon}&\cd{LZ02}&\cdf{Z}&\textrm{capital Z}&\cd{LZ01}&\cdf{z}&\textrm{small z} \\
\cd{SP14}&\cd{;}&\textrm{semicolon}&\cd{SM06}&\cd{{\Xlbracket}}&\textrm{left square bracket}&\cd{SM11}&\cd{{\Xlbrace}}&\textrm{left curly bracket} \\
\cd{SA03}&\cdf{<}&\textrm{less-than sign}&\cd{SM07}&\cd{{\Xbackslash}}&\textrm{reverse solidus}&\cd{SM13}&\cd{|}&\textrm{vertical bar} \\
\cd{SA04}&\cdf{=}&\textrm{equals sign}&\cd{SM08}&\cd{{\Xrbracket}}&\textrm{right square bracket}&\cd{SM14}&\cd{{\Xrbrace}}&\textrm{right curly bracket} \\
\cd{SA05}&\cdf{>}&\textrm{greater-than sign}&\cd{SD15}&\cd{{\Xcircumflex}}&\textrm{circumflex accent}&\cd{SD19}&\cd{{\Xtilde}}&\textrm{tilde} \\
\cd{SP15}&\cd{?}&\textrm{question mark}&\cd{SP09}&\cd{{\Xunderscore}}&\textrm{low line}&
\end{tabular*}

\vfill
\begin{small}
\noindent
The characters in this table plus the space and newline characters make up
the standard Common Lisp character repertoire (type \cdf{standard-char}).
The character labels and character descriptions shown here are taken
from ISO standard 6937/2 .  The first character of the label
categorizes the character as Latin, Numeric, or Special.
\end{small}
\end{table}

\begin{table}
\caption{Стандартные метки символов, символы и описания}
\label{STANDARD-CHAR-REPERTOIRE-TABLE}
\tabcolsep0pt
\def\arraystretch{1.1}

\begin{tabular*}{\textwidth}{@{}l@{\extracolsep{\fill}}llllllll@{}}
           &&&\cd{SM05}&\cd{{\Xatsign}}&\textrm{собака}&\cd{SD13}&\cd{{\Xbq}}&\textrm{обратная кавычка} \\
\cd{SP02}&\cd{!}&\textrm{восклицательный знак}&\cd{LA02}&\cdf{A}&\textrm{прописная A}&\cd{LA01}&\cdf{a}&\textrm{маленькая a} \\
\cd{SP04}&\cd{"}&\textrm{двойная кавычка}&\cd{LB02}&\cdf{B}&\textrm{прописная B}&\cd{LB01}&\cdf{b}&\textrm{маленькая b} \\
\cd{SM01}&\cd{\#}&\textrm{диез, решётка}&\cd{LC02}&\cdf{C}&\textrm{прописная C}&\cd{LC01}&\cdf{c}&\textrm{маленькая c} \\
\cd{SC03}&\cd{\$}&\textrm{знак доллара}&\cd{LD02}&\cdf{D}&\textrm{прописная D}&\cd{LD01}&\cdf{d}&\textrm{маленькая d} \\
\cd{SM02}&\cd{\%}&\textrm{знак процента}&\cd{LE02}&\cdf{E}&\textrm{прописная E}&\cd{LE01}&\cdf{e}&\textrm{маленькая e} \\
\cd{SM03}&\cd{\&}&\textrm{амперсанд}&\cd{LF02}&\cdf{F}&\textrm{прописная F}&\cd{LF01}&\cdf{f}&\textrm{маленькая f} \\
\cd{SP05}&\cd{'}&\textrm{апостроф}&\cd{LG02}&\cdf{G}&\textrm{прописная G}&\cd{LG01}&\cdf{g}&\textrm{маленькая g} \\
\cd{SP06}&\cd{(}&\textrm{левая круглая скобка}&\cd{LH02}&\cdf{H}&\textrm{прописная H}&\cd{LH01}&\cdf{h}&\textrm{маленькая h} \\
\cd{SP07}&\cd{)}&\textrm{права круглая скобка}&\cd{LI02}&\cdf{I}&\textrm{прописная I}&\cd{LI01}&\cdf{i}&\textrm{маленькая i} \\
\cd{SM04}&\cdf{*}&\textrm{звёздочка}&\cd{LJ02}&\cdf{J}&\textrm{прописная J}&\cd{LJ01}&\cdf{j}&\textrm{маленькая j} \\
\cd{SA01}&\cdf{+}&\textrm{знак плюс}&\cd{LK02}&\cdf{K}&\textrm{прописная K}&\cd{LK01}&\cdf{k}&\textrm{маленькая k} \\
\cd{SP08}&\cd{,}&\textrm{запятая}&\cd{LL02}&\cdf{L}&\textrm{прописная L}&\cd{LL01}&\cdf{l}&\textrm{маленькая l} \\
\cd{SP10}&\cdf{-}&\textrm{дефис или знак минус}&\cd{LM02}&\cdf{M}&\textrm{прописная M}&\cd{LM01}&\cdf{m}&\textrm{маленькая m} \\
\cd{SP11}&\cd{.}&\textrm{точка}&\cd{LN02}&\cdf{N}&\textrm{прописная N}&\cd{LN01}&\cdf{n}&\textrm{маленькая n} \\
\cd{SP12}&\cdf{/}&\textrm{слеш}&\cd{LO02}&\cdf{O}&\textrm{прописная O}&\cd{LO01}&\cdf{o}&\textrm{маленькая o} \\
\cd{ND10}&\cd{0}&\textrm{цифра 0}&\cd{LP02}&\cdf{P}&\textrm{прописная P}&\cd{LP01}&\cdf{p}&\textrm{маленькая p} \\
\cd{ND01}&\cd{1}&\textrm{цифра 1}&\cd{LQ02}&\cdf{Q}&\textrm{прописная Q}&\cd{LQ01}&\cdf{q}&\textrm{маленькая q} \\
\cd{ND02}&\cd{2}&\textrm{цифра 2}&\cd{LR02}&\cdf{R}&\textrm{прописная R}&\cd{LR01}&\cdf{r}&\textrm{маленькая r} \\
\cd{ND03}&\cd{3}&\textrm{цифра 3}&\cd{LS02}&\cdf{S}&\textrm{прописная S}&\cd{LS01}&\cdf{s}&\textrm{маленькая s} \\
\cd{ND04}&\cd{4}&\textrm{цифра 4}&\cd{LT02}&\cdf{T}&\textrm{прописная T}&\cd{LT01}&\cdf{t}&\textrm{маленькая t} \\
\cd{ND05}&\cd{5}&\textrm{цифра 5}&\cd{LU02}&\cdf{U}&\textrm{прописная U}&\cd{LU01}&\cdf{u}&\textrm{маленькая u} \\
\cd{ND06}&\cd{6}&\textrm{цифра 6}&\cd{LV02}&\cdf{V}&\textrm{прописная V}&\cd{LV01}&\cdf{v}&\textrm{маленькая v} \\
\cd{ND07}&\cd{7}&\textrm{цифра 7}&\cd{LW02}&\cdf{W}&\textrm{прописная W}&\cd{LW01}&\cdf{w}&\textrm{маленькая w} \\
\cd{ND08}&\cd{8}&\textrm{цифра 8}&\cd{LX02}&\cdf{X}&\textrm{прописная X}&\cd{LX01}&\cdf{x}&\textrm{маленькая x} \\
\cd{ND09}&\cd{9}&\textrm{цифра 9}&\cd{LY02}&\cdf{Y}&\textrm{прописная Y}&\cd{LY01}&\cdf{y}&\textrm{маленькая y} \\
\cd{SP13}&\cd{:}&\textrm{двоеточие}&\cd{LZ02}&\cdf{Z}&\textrm{прописная Z}&\cd{LZ01}&\cdf{z}&\textrm{маленькая z} \\
\cd{SP14}&\cd{;}&\textrm{точка с запятой}&\cd{SM06}&\cd{{\Xlbracket}}&\textrm{левая квадратная скобка}&\cd{SM11}&\cd{{\Xlbrace}}&\textrm{левая фигурная скобка} \\
\cd{SA03}&\cdf{<}&\textrm{знак меньше чем}&\cd{SM07}&\cd{{\Xbackslash}}&\textrm{обратный слеш}&\cd{SM13}&\cd{|}&\textrm{вертикальная черта} \\
\cd{SA04}&\cdf{=}&\textrm{знак равенства}&\cd{SM08}&\cd{{\Xrbracket}}&\textrm{правая квадратная скобка}&\cd{SM14}&\cd{{\Xrbrace}}&\textrm{правая фигурная скобка} \\
\cd{SA05}&\cdf{>}&\textrm{знак больше чем}&\cd{SD15}&\cd{{\Xcircumflex}}&\textrm{крыша}&\cd{SD19}&\cd{{\Xtilde}}&\textrm{тильда} \\
\cd{SP15}&\cd{?}&\textrm{вопросительный знак}&\cd{SP09}&\cd{{\Xunderscore}}&\textrm{знак подчеркивания}&
\end{tabular*}
\vfill
\begin{small}
\noindent
Символы в этой таблице, а также пробел и символы новой строки составляют
стандартный набор символов для Common Lisp'а (тип \cdf{standard-char}).
Метки символов и описания символов взяти из ISO 6937/2. Первый символ на метке
классифицирует символ как Latin, Numeric или Special.
\end{small}

\end{table}

If two objects are to be compared for ``identity,'' but either might be
a character, then the predicate \cdf{eql} is probably appropriate.

Для сравнения двух объектов, один из которых может быть символом, необходимо
использовать предикат \cdf{eql}.

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to approve the following definitions and terminology for use in
discussing character facilities in Common Lisp.

A \emph{character repertoire} defines a collection of characters
independent of their specific rendered image or font.  (This corresponds
to the mathematical notion of a set, but the term \emph{character set}
is avoided here because it has been used in the past to mean
both what is here called a repertoire and what is here called a coded
character set.)
Character repertoires are specified independent of coding and their characters
are identified only with a unique \emph{character label},
a graphic symbol, and a character description.
As an example, table~\ref{STANDARD-CHAR-REPERTOIRE-TABLE}
shows the character labels, graphic symbols, and character descriptions for
all of the characters in the repertoire \cdf{standard-char}
except for \cd{\#{\Xbackslash}Space} and \cd{\#{\Xbackslash}Newline}.

Every Common Lisp implementation must support the standard character repertoire
as well as repertoires named \cdf{base-char}, \cdf{extended-char},
and \cdf{character}.  Other repertoires may be supported as well.
X3J13 voted in June 1989 \issue{MORE-CHARACTER-PROPOSAL} to specify that names of
repertoires may be used as type specifiers.  Such types must be subtypes of \cdf{character};
that is, in a given implementation
the repertoire named \cdf{character} must encompass all the character objects supported
by that implementation.

A \emph{coded character set} is a character repertoire plus an \emph{encoding}
that provides a bijective mapping between each character in the set and a number
(typically a non-negative integer)
that serves as the character representation.
There are numerous internationally standardized coded character sets.

A character may be included in one or more character repertoires.
Similarly, a character may be included in one or more coded character sets.

To ensure that each character is uniquely defined, we may use a universal registry of
characters that incorporates a collection of distinguished repertoires
called \emph{character scripts} that form an exhaustive partition of all characters.
That is, each character is included in exactly one character script.
(Draft ISO 10646 Coded Character Set Standard, if eventually approved as a standard,
may become the practical realization of this universal registry.)

(X3J13 voted in June 1989 \issue{MORE-CHARACTER-PROPOSAL} to specify that
an implementation must document the character scripts it supports.
For each script the documentation should discuss character labels,
glyphs, and descriptions; any canonicalization processes performed
by the reader that result in treating distinct characters as equivalent;
any canonicalization performed by \cdf{format} in processing directives;
the behavior of \cdf{char-upcase}, \cdf{char-downcase}, and the predicates
\cdf{alpha-char-p}, \cdf{upper-case-p}, \cdf{lower-case-p}, \cdf{both-case-p},
\cdf{graphic-char-p}, \cdf{alphanumericp}, \cdf{char-equal}, \cdf{char-not-equal},
\cdf{char-lessp}, \cdf{char-greaterp}, \cdf{char-not-greaterp}, and \cdf{char-not-lessp}
for characters in the script; and behavior with respect to input and output,
including coded character sets and external coding schemes.)

In Common Lisp a \emph{character} data object is identified by its \emph{character code},
a unique numerical code.  Each character code is composed from a character script
and a character label.  The convention by which a character script and
character label compose a character code is implementation dependent.
[X3J13 did not approve all parts of the proposal from its Subcommittee
on Characters.  As a result, some features that were approved appear to
have no purpose.  X3J13 wished to support the standardization by ISO of character
scripts and coded character sets but declined to design facilities for use in
Common Lisp until there has been more progress by ISO in this area.
The approval of the terminology for scripts and labels gives a hint
to implementors of likely directions for Common Lisp in the future.]

A character object that is classified as \emph{graphic}, or displayable,
has an associated \emph{glpyh}.  The glyph is the visual representation
of the character.  All other character data objects are classified as
\emph{non-graphic}.

This terminology assigns names to Common Lisp concepts
in a manner consistent with
related concepts discussed in various ISO standards for coded
character sets and provides a demarcation between standardization
activities.  For example, facilities for manipulating characters,
character scripts, and coded character sets are properly defined
by a Common Lisp standard, but Common Lisp should not define
standard character sets or standard character scripts.
\end{newer}

\section{Character Attributes Свойства }

Every character has three attributes: code, bits, and font.
The code attribute is intended to distinguish among the printed glyphs
and formatting functions for characters.  The bits attribute allows extra
flags to be associated with a character.  The font attribute permits
a specification of the style of the glyphs (such as italics).

Каждый символ имеет три свойства: код, биты и шрифт.


\begin{new}
The treatment of character attributes in Common Lisp has not been
entirely successful.  The font attribute has not been widely used,
for two reasons.  First, a single integer, limited in most
implementations to 255 at most, is not an adequate, convenient, or portable
representation for a font.  Second, in many applications where font
information matters it is more convenient or more efficient to represent
font information as shift codes that apply to many characters, rather than
attaching font information separately to each character.

As for the bits attribute, it was intended to support
character input from extended keyboards having extra ``shift'' keys.
This, in turn, was imagined to support the programming of a portable
EMACS-like editor in Common Lisp.  (The EMACS command set
is most convenient when the keyboard has separate ``control'' and
``meta'' keys.)   The bits attribute has been used in the implementation
of such editors and other interactive interfaces.  However, software
that relies crucially on these extended characters will not be portable
to Common Lisp implementations that do not support them.

X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
and in June 1989 \issue{MORE-CHARACTER-PROPOSAL}
to revise considerably the treatment
of characters in the language.  The bits and font attributes are eliminated;
instead a character may have \emph{implementation-defined attributes}.
The treatment of such attributes by existing character-handling functions
is carefully constrained by certain rules.

Implementations are free to
continue to support bits and font attributes, but they are
formally regarded as implementation-defined attributes.
The rules are generally consistent with the previous
treatment of the bits and font attributes.
My guess is that
the font attribute as currently defined will wither away,
but the bits attribute as defined by the first edition will
continue to be supported as a \emph{de facto} standard extension,
because it fills a useful small purpose.
\end{new}

\begin{defun}[Constant]
char-code-limit

The value of \cdf{char-code-limit} is a non-negative
integer that is the upper exclusive bound on values produced
by the function \cdf{char-code}, which returns the \emph{code} component
of a given character; that is, the values returned by \cdf{char-code}
are non-negative and strictly less than the value of
\cdf{char-code-limit}.

Значением \cdf{char-code-limit} является неотрицательное целое число, которое
отображает наибольшее из возможных значений функции \cdf{char-code}
невключительно. То есть значения, возвращаемые \cdf{char-code} неотрицательных и
строго меньше чем значение \cdf{char-code-limit}.

\begin{new}
Common Lisp does not at present explicitly guarantee that all integers between
zero and the value of \cdf{char-code-limit} are valid character codes, and so
it is wise in any case for the programmer to assume that the space of
assigned character codes may be sparse.
\end{new}
\end{defun}

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to eliminate \cdf{char-font-limit}.

Experience has shown that numeric codes are not an especially
convenient, let alone portable, representation for font information.
A system based on typeface names, type styles, and point sizes would be much better.
(Macintosh software developers made the same discovery and have recently
converted to a new font identification scheme.)
\end{newer}

\section{Predicates on Characters Предикаты для строковых символов}

The predicate \cdf{characterp} may be used to determine
whether any Lisp object is a character object.

Для определения является ли
Lisp'овый объект строковым символом может использоваться предикат
\cdf{characterp}. 

\begin{defun}[Function]
standard-char-p char

The argument \emph{char} must be a character object.
\cdf{standard-char-p} is true if the argument is a ``standard character,''
that is, an object of type \cdf{standard-char}.

Note that any character with a non-zero bits or
font attribute is non-standard.

Аргумент \emph{char} должен быть строковым символом.
\cdf{standard-char-p} истинен, если аргумент являеются <<стандартным строковым
символом>>, то есть объект принадлежит типу \cdf{standard-char}.

Следует отметить, что любой символ с ненулевым битом или свойством шрифта не
является стандартным.
\end{defun}

\begin{defun}[Function]
graphic-char-p char

The argument \emph{char} must be a character object.
\cdf{graphic-char-p} is true if the argument is a ``graphic'' (printing)
character, and false if it is a ``non-graphic'' (formatting or control)
character.  Graphic characters have a standard textual representation
as a single glyph, such as \cdf{A} or \cdf{*} or \cdf{=}.
By convention, the space character is considered to be graphic.
Of the standard characters
all but \cd{\#{\Xbackslash}Newline} are graphic.
The semi-standard characters
\cd{\#{\Xbackslash}Backspace}, \cd{\#{\Xbackslash}Tab}, \cd{\#{\Xbackslash}Rubout}, \cd{\#{\Xbackslash}Linefeed}, \cd{\#{\Xbackslash}Return},
and \cd{\#{\Xbackslash}Page} are not graphic.

Аргумент \emph{char} должен быть строковым символом.
\cdf{graphic-char-p} истинен, если аргумент является <<графическим>> (выводимым)
символом, или ложен, если аргумент является <<неграфическим>> (форматирующим или
управляющим) символом. Графические символы имеют стандартное текстовое
представление в качестве одного знака, такого как например \cdf{A} или \cdf{*}
или \cdf{=}.
По соглашению, символы пробела рассматриваются как графические.
Все стандартные символы за исключением \cd{\#{\Xbackslash}Newline} являются
графическими.
Не совсем стандартные символы
\cd{\#{\Xbackslash}Backspace}, \cd{\#{\Xbackslash}Tab},
\cd{\#{\Xbackslash}Rubout}, \cd{\#{\Xbackslash}Linefeed},
\cd{\#{\Xbackslash}Return} и  \cd{\#{\Xbackslash}Page} графическими не являются.

Programs may assume that
graphic characters of font 0 are all of the same width
when printed, for example, for purposes of columnar
formatting.  (This does not prohibit the use of a variable-pitch font
as font 0, but merely implies that every implementation of Common Lisp
must provide \emph{some} mode of operation in which font 0 is
a fixed-pitch font.)
Portable programs should assume that, in general,
non-graphic characters and characters of
other fonts may be of varying widths.

Any character with a non-zero bits attribute is non-graphic.
\end{defun}

\begin{defun}[Function]
alpha-char-p char

The argument \emph{char} must be a character object.
\cdf{alpha-char-p} is true if the argument is an alphabetic
character, and otherwise is false.

If a character is alphabetic, then it is perforce graphic.
Therefore any character with a non-zero bits attribute cannot be alphabetic.
Whether a character is alphabetic may depend on its font number.

Of the standard characters (as defined by \cdf{standard-char-p}),
the letters \cdf{A} through \cdf{Z} and \cdf{a} through \cdf{z} are alphabetic.

Аргумент \emph{char} должен быть строковым символом.
\cdf{alpha-char-p} истинен, если аргумент являются алфавитным символом, иначе
предикат ложен.

Если символ является алфавитным, тогда он является графическим.

Из стандартных символов (как определено с помощью \cdf{standard-char-p}), буквы
c \cdf{A} по \cdf{Z} и с \cdf{a} по \cdf{z} являются алфавитными.
\end{defun}

\begin{defun}[Function]
upper-case-p char \\
lower-case-p char \\
both-case-p char

The argument \emph{char} must be a character object.

Аргумент \emph{char} должен быть строковым символом.

\cdf{upper-case-p} is true if the argument is an uppercase
character, and otherwise is false.

\cdf{upper-case-p} истинен, если аргумент является символом в верхнем регистре,
иначе ложен.

\cdf{lower-case-p} is true if the argument is a lowercase
character, and otherwise is false.

\cdf{lower-case-p} истинен, если аргумент является символом в нижнем регистре,
иначе ложен.

\cdf{both-case-p} is true if the argument is an uppercase character and
there is a corresponding lowercase character (which can be obtained
using \cdf{char-downcase}), or if the argument is a lowercase character and
there is a corresponding uppercase character (which can be obtained
using \cdf{char-upcase}).

\cdf{lower-case-p} истинен, если аргумент является символом в верхнем регистре,
и для этого символа существует аналогичный в нижнем регистре (это может быть
установлено с помощью \cdf{char-downcase}), или если аргумент является символом
в нижнем регистре, 
и для этого символа существует аналогичный в верхнем регистре (это может быть
установлено с помощью \cdf{char-upcase}).

If a character is either uppercase or lowercase, it is necessarily
alphabetic (and therefore is graphic, and therefore has a zero bits
attribute).  However, it is permissible in theory for an alphabetic
character to be neither uppercase nor lowercase (in a non-Roman font,
for example).

Of the standard characters (as defined by \cdf{standard-char-p}),
the letters \cdf{A} through \cdf{Z} are uppercase and \cdf{a}
through \cdf{z} are lowercase.

Из стандартных символов (как определено с помощью \cdf{standard-char-p}), буквы
c \cdf{A} по \cdf{Z} имеют верхний регистр и буквы с \cdf{a} по \cdf{z} в нижний.
\end{defun}

\begin{defun}[Function]
digit-char-p char &optional (radix 10)

The argument \emph{char} must be a character object,
and \emph{radix} must be a non-negative integer.
If \emph{char} is not a digit of the radix
specified by \emph{radix}, then \cdf{digit-char-p} is
false; otherwise it returns
a non-negative integer that is the ``weight'' of \emph{char} in that radix.

Аргумент \emph{char} должен быть строковым символом, и \emph{radix}
неотрицательным целым числом.
Если \emph{char} не является цифрой для указанной в \emph{radix} системы
счисления, тогда \cdf{digit-char-p} ложен, иначе предикат позвращает значение
данного символа в этой системе счисления.

Digits are necessarily graphic characters.

Цифры принадлежат графическим символам.

Of the standard characters (as defined by \cdf{standard-char-p}),
the characters \cd{0} through \cd{9}, \cdf{A} through \cdf{Z},
and \cdf{a} through \cdf{z}
are digits.  The weights of \cd{0} through \cd{9} are the integers 0 through 9,
and of \cdf{A} through \cdf{Z} (and also \cdf{a} through \cdf{z}) are 10 through 35.
\cdf{digit-char-p} returns the weight for one of these digits if and only if
its weight is strictly less than \emph{radix}.  Thus, for example,
the digits for radix 16 are
\begin{lisp}
0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
\end{lisp}

Из стандартных символов (как определено с помощью \cdf{standard-char-p}),
символы с \cd{0} по \cd{9}, с \cd{A} по \cd{Z} и с \cd{a} по \cd{z} являются
цифровыми. Веса c \cd{0} по \cd{9} совпадают с числами с 0 по 9, и с \cd{A} по
\cd{Z} (а также с \cdf{a} по \cd{z}) совпадают с числами с 10 по 35.
\cdf{digit-char-p} возвращает вес одной их этих цифр тогда и только тогда, когда
их вес строко меньше чем \emph{radix}. Таким образом, например, цифры для
шестнадцатеричной системы счисления будут такими
\begin{lisp}
0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
\end{lisp}

Here is an example of the use of \cdf{digit-char-p}:
\begin{lisp}
(defun convert-string-to-integer (str \&optional (radix 10)) \\
~~"Given a digit string and optional radix, return an integer." \\
~~(do ((j 0 (+ j 1)) \\
~~~~~~~(n 0 (+ (* n radix) \\
~~~~~~~~~~~~~~~(or (digit-char-p (char str j) radix) \\
~~~~~~~~~~~~~~~~~~~(error "Bad radix-{\Xtilde}D digit: {\Xtilde}C" \\
~~~~~~~~~~~~~~~~~~~~~~~~~~radix \\
~~~~~~~~~~~~~~~~~~~~~~~~~~(char str j)))))) \\
~~~~~~((= j (length str)) n)))
\end{lisp}

Далее указан пример использования \cdf{digit-char-p}:
\begin{lisp}
(defun convert-string-to-integer (str \&optional (radix 10)) \\
~~"Принимает строку и опционально систему счисления, возвращает целое число." \\
~~(do ((j 0 (+ j 1)) \\
~~~~~~~(n 0 (+ (* n radix) \\
~~~~~~~~~~~~~~~(or (digit-char-p (char str j) radix) \\
~~~~~~~~~~~~~~~~~~~(error "Bad radix-{\Xtilde}D digit: {\Xtilde}C" \\
~~~~~~~~~~~~~~~~~~~~~~~~~~radix \\
~~~~~~~~~~~~~~~~~~~~~~~~~~(char str j)))))) \\
~~~~~~((= j (length str)) n)))
\end{lisp}
\end{defun}

\begin{defun}[Function]
alphanumericp char

The argument \emph{char} must be a character object.
\cdf{alphanumericp} is true if \emph{char} is either alphabetic
or numeric.  By definition,
\begin{lisp}
(alphanumericp x) \\
~~~\EQ\ (or (alpha-char-p x) (not (null (digit-char-p x))))
\end{lisp}
Alphanumeric characters are therefore necessarily graphic
(as defined by the predicate \cdf{graphic-char-p}).

Of the standard characters (as defined by \cdf{standard-char-p}),
the characters \cd{0} through \cd{9}, \cdf{A} through \cdf{Z},
and \cdf{a} through \cdf{z} are alphanumeric.
\end{defun}

\begin{defun}[Function]
char= character &rest more-characters \\
char/= character &rest more-characters \\
char< character &rest more-characters \\
char> character &rest more-characters \\
char<= character &rest more-characters \\
char>= character &rest more-characters

The arguments must all be character objects.
These functions compare the objects using the implementation-dependent
total ordering on characters, in a manner analogous to numeric
comparisons by \cdf{=} and related functions.

Все аргументы должны быть строковыми символами.
Эти функции сравнивают объекты используя 

The total ordering on characters is guaranteed to have the following
properties:
\begin{itemize}
\item
The standard alphanumeric characters obey the following partial ordering:
\begin{lisp}
A<B<C<D<E<F<G<H<I<J<K<L<M<N<O\hbox{<P<Q<R<S<T<U<V<W<X<Y<Z} \\
\hbox to 0pt{a<b<c<d<e<f<g<h<i<j<k<l<m<n<o<\hss}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~p<q<r<s<t<u<v<w<x<y<z \\
0<1<2<3<4<5<6<7<8<9 \\
\emph{either} 9<A \emph{or} Z<0 \\
\emph{either} 9<a \emph{or} z<0
\end{lisp}
This implies that alphabetic ordering holds within each case (upper and
lower), and that the digits as a group
are not interleaved with letters.  However, the ordering
or possible interleaving of
uppercase letters and lowercase letters is unspecified.
(Note that both the ASCII and the EBCDIC character sets
conform to this specification.  As it happens, neither ordering
interleaves uppercase and lowercase letters:
in the ASCII ordering, \cd{9<A} and \cd{Z<a},
whereas in the EBCDIC ordering \cd{z<A} and \cd{Z<0}.)
\end{itemize}

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to replace the notion of bits and font attributes with
that of implementation-defined attributes.
\begin{itemize}
\item
If two characters have identical implementation-defined attributes,
then their ordering by \cdf{char<} is consistent with the numerical
ordering by the predicate \cdf{<} on their codes, and similarly
for \cdf{char>}, \cdf{char<=}, and \cdf{char>=}.

\item
If two characters differ in any implementation-defined
attribute, then they are not \cdf{char=}.
\end{itemize}
\end{newer}

The total ordering is not necessarily the same as the total
ordering on the integers produced by applying \cdf{char-int} to the
characters (although it is a reasonable implementation technique to
use that ordering).

While alphabetic characters of a given case must be
properly ordered, they need not be contiguous; thus \cd{(char<= \#{\Xbackslash}a x
\#{\Xbackslash}z)} is \emph{not} a valid way of determining whether or not \cdf{x} is a
lowercase letter.  That is why a separate
\cdf{lower-case-p} predicate is provided.

\begin{lisp}
(char= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is true.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is false.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{is false.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{is true.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}D) \textrm{is false.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}D) \textrm{is true.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is true.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is false.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}x \#{\Xbackslash}d) \textrm{is false.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}x \#{\Xbackslash}d) \textrm{is false.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}y \#{\Xbackslash}x \#{\Xbackslash}c) \textrm{is false.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}y \#{\Xbackslash}x \#{\Xbackslash}c) \textrm{is true.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}d) \textrm{is false.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}d) \textrm{is false.} \\
(char< \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{is true.} \\
(char<= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{is true.} \\
(char< \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is false.} \\
(char<= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{is true.} \\
(char< \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}y \#{\Xbackslash}z) \textrm{is true.} \\
(char<= \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}y \#{\Xbackslash}z) \textrm{is true.} \\
(char< \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}e \#{\Xbackslash}y) \textrm{is false.} \\
(char<= \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}e \#{\Xbackslash}y) \textrm{is true.} \\
(char> \#{\Xbackslash}e \#{\Xbackslash}d) \textrm{is true.} \\
(char>= \#{\Xbackslash}e \#{\Xbackslash}d) \textrm{is true.} \\
(char> \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}b \#{\Xbackslash}a) \textrm{is true.} \\
(char>= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}b \#{\Xbackslash}a) \textrm{is true.} \\
(char> \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{is false.} \\
(char>= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{is true.} \\
(char> \#{\Xbackslash}e \#{\Xbackslash}d \#{\Xbackslash}b \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{is false.} \\
(char>= \#{\Xbackslash}e \#{\Xbackslash}d \#{\Xbackslash}b \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{is false.} \\
(char> \#{\Xbackslash}z \#{\Xbackslash}A) \textrm{may be true or false.} \\
(char> \#{\Xbackslash}Z \#{\Xbackslash}a) \textrm{may be true or false.}
\end{lisp}

\begin{lisp}
(char= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{истина.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{ложь.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{ложь.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{истина.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}D) \textrm{ложь.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}D) \textrm{истина.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{истина.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{ложь.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}x \#{\Xbackslash}d) \textrm{ложь.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}x \#{\Xbackslash}d) \textrm{ложь.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}y \#{\Xbackslash}x \#{\Xbackslash}c) \textrm{ложь.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}y \#{\Xbackslash}x \#{\Xbackslash}c) \textrm{истина.} \\
(char= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}d) \textrm{ложь.} \\
(char/= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}d) \textrm{ложь.} \\
(char< \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{истина.} \\
(char<= \#{\Xbackslash}d \#{\Xbackslash}x) \textrm{истина.} \\
(char< \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{ложь.} \\
(char<= \#{\Xbackslash}d \#{\Xbackslash}d) \textrm{истина.} \\
(char< \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}y \#{\Xbackslash}z) \textrm{истина.} \\
(char<= \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}y \#{\Xbackslash}z) \textrm{истина.} \\
(char< \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}e \#{\Xbackslash}y) \textrm{ложь.} \\
(char<= \#{\Xbackslash}a \#{\Xbackslash}e \#{\Xbackslash}e \#{\Xbackslash}y) \textrm{истина.} \\
(char> \#{\Xbackslash}e \#{\Xbackslash}d) \textrm{истина.} \\
(char>= \#{\Xbackslash}e \#{\Xbackslash}d) \textrm{истина.} \\
(char> \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}b \#{\Xbackslash}a) \textrm{истина.} \\
(char>= \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}b \#{\Xbackslash}a) \textrm{истина.} \\
(char> \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{ложь.} \\
(char>= \#{\Xbackslash}d \#{\Xbackslash}d \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{истина.} \\
(char> \#{\Xbackslash}e \#{\Xbackslash}d \#{\Xbackslash}b \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{ложь.} \\
(char>= \#{\Xbackslash}e \#{\Xbackslash}d \#{\Xbackslash}b \#{\Xbackslash}c \#{\Xbackslash}a) \textrm{ложь.} \\
(char> \#{\Xbackslash}z \#{\Xbackslash}A) \textrm{может быть истиной или ложью.} \\
(char> \#{\Xbackslash}Z \#{\Xbackslash}a) \textrm{может быть истиной или ложью.}
\end{lisp}

There is no requirement that \cd{(eq c1 c2)} be true merely because
\cd{(char= c1 c2)} is true.  While \cdf{eq} may distinguish two character
objects that \cdf{char=} does not, it is distinguishing them not
as \emph{characters}, but in some sense on the basis of a lower-level
implementation characteristic.
(Of course, if \cd{(eq c1 c2)} is true,
then one may expect \cd{(char= c1 c2)} to be true.)
However, \cdf{eql} and \cdf{equal}
compare character objects in the same
way that \cdf{char=} does.
\end{defun}

\begin{defun}[Function]
char-equal character &rest more-characters \\
char-not-equal character &rest more-characters \\
char-lessp character &rest more-characters \\
char-greaterp character &rest more-characters \\
char-not-greaterp character &rest more-characters \\
char-not-lessp character &rest more-characters

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to replace the notion of bits and font attributes with
that of implementation-defined attributes.  The effect, if any,
of each such attribute on the behavior of
\cdf{char-equal}, \cdf{char-not-equal}, \cdf{char-lessp}, \cdf{char-greaterp},
\cdf{char-not-greaterp}, and \cdf{char-not-lessp} must be specified
as part of the definition of that attribute.
\end{newer}


For the standard characters, the ordering is such that
\cd{A=a}, \cd{B=b}, and so on, up to \cd{Z=z}, and furthermore either
\cd{9<A} or \cd{Z<0}.
For example:
\begin{lisp}
(char-equal \#{\Xbackslash}A \#{\Xbackslash}a) \textrm{is true.} \\
(char= \#{\Xbackslash}A \#{\Xbackslash}a) \textrm{is false.} \\
(char-equal \#{\Xbackslash}A \#{\Xbackslash}Control-A) \textrm{is true.}
\end{lisp}

Для стандартных символов, порядок 
\begin{lisp}
(char-equal \#{\Xbackslash}A \#{\Xbackslash}a) \textrm{истина.} \\
(char= \#{\Xbackslash}A \#{\Xbackslash}a) \textrm{ложь.} \\
(char-equal \#{\Xbackslash}A \#{\Xbackslash}Control-A) \textrm{истина.}
\end{lisp}

\end{defun}

\section{Character Construction and Selection}

These functions may be used to extract attributes of a character
and to construct new characters.

\begin{defun}[Function]
char-code char

The argument \emph{char} must be a character object.
\cdf{char-code} returns the code attribute of the character object;
this will be a non-negative integer less than the (normal) value of
the variable \cdf{char-code-limit}.

\begin{new}
This is usually what you need in order to treat a character as an
index into a vector.  The length of the vector should then be
equal to \cdf{char-code-limit}.  Be careful how you initialize this
vector; remember that you cannot necessarily
expect all non-negative integers less than
\cdf{char-code-limit} to be valid character codes.
\end{new}
\end{defun}

\medskip
\begin{new}
The references to the ``normal'' values of the ``variables''
\cdf{char-code-limit},
\cdf{char-bits-limit}, and \cdf{char-font-limit} in the descriptions
of \cdf{char-code}, \cdf{char-bits}, and \cdf{char-font} were an oversight on
my part.  Early in the design of Common Lisp they were indeed variables,
but they are at present defined to be constants, and their values therefore
are always normal and should not change.  But this point is now moot.
\end{new}

\begin{defun}[Function]
code-char code &optional (bits 0) (font 0)

Returns a character with the code attribute given by code. If no such character
exists and one cannot be created, nil is returned.
For example:

\begin{lisp}
(char= (code-char (char-code c)) c)
\end{lisp}
\end{defun}

\section{Character Conversions Преобразование строковых символов}

These functions perform various transformations on characters,
including case conversions.

Данные функции выполняют различные преобразования символов, включая изменение
регистра.

\begin{defun}[Function]
character object

The function \cdf{character} coerces its argument to be a character
if possible; see \cdf{coerce}.
\begin{lisp}
(character x) \EQ\ (coerce x 'character)
\end{lisp}

Функция \cdf{character} если возможно возвращает преобразованный в символ
аргумент \emph{object}. Смотрите \cdf{coerce}.
\begin{lisp}
(character x) \EQ\ (coerce x 'character)
\end{lisp}
\end{defun}


\begin{defun}[Function]
char-upcase char \\
char-downcase char

The argument \emph{char} must be a character object.
\cdf{char-upcase} attempts to convert its argument to an uppercase
equivalent; \cdf{char-downcase} attempts to convert its argument
to a lowercase equivalent.

Аргумент \emph{char} должен быть строковым символом.
\cdf{char-upcase} пытается возвести символ в верхний
регистр. \cdf{char-downcase} пытается возвести символ в нижний регистр.
\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to replace the notion of bits and font attributes with
that of implementation-defined attributes.  The effect of
\cdf{char-upcase} and \cdf{char-downcase} is to preserve
implementation-defined attributes.
\end{newer}

\end{defun}

\begin{defun}[Function]
digit-char weight &optional (radix 10)

All arguments must be integers.  \cdf{digit-char}
determines whether or not it is possible to construct
a character object whose \emph{code} is such that the
result character has the weight \emph{weight} when considered as
a digit of the radix \emph{radix} (see the predicate \cdf{digit-char-p}).
It returns such a character if that is possible, and otherwise returns {\false}.

Все аргумента должны быть целыми числами. \cdf{digit-char} устанавливает может
ли быть создан символ, у которого код \emph{code} такой, что итоговый символ
имеет вес \emph{weight}, когда рассматривается как цифра системы счисления
\emph{radix} (смотрите предикат \cdf{digit-char-p}).
В случае успеха возвращается этот символ, иначе {\false}.

\cdf{digit-char} cannot return {\false} \emph{radix} is between 2 and 36
inclusive, and \emph{weight} is non-negative and less than \emph{radix}.

\cdf{digit-char} не может вернуть {\false}, если \emph{radix} находится между 2
и 36 включительно и \emph{weight} имеет неотрицательное значение и меньше чем
\emph{radix}.

If more than one character object can encode
such a weight in the given radix, one will be chosen consistently
by any given implementation; moreover, among the standard characters,
uppercase letters are preferred to lowercase letters.
For example:
\begin{lisp}
(digit-char 7) \EV\ \#{\Xbackslash}7 \\
(digit-char 12) \EV\ {\false} \\
(digit-char 12 16) \EV\ \#{\Xbackslash}C~~~~~;\textrm{not} \#{\Xbackslash}c \\
(digit-char 6 2) \EV\ {\false} \\
(digit-char 1 2) \EV\ \#{\Xbackslash}1
\end{lisp}

Если для результата подходят несколько символов, выбор лежит на плечах
реализации. Но символы в верхнем регистре предпочтительнее символов в нижем.
Например:
\begin{lisp}
(digit-char 7) \EV\ \#{\Xbackslash}7 \\
(digit-char 12) \EV\ {\false} \\
(digit-char 12 16) \EV\ \#{\Xbackslash}C~~~~~;\textrm{not} \#{\Xbackslash}c \\
(digit-char 6 2) \EV\ {\false} \\
(digit-char 1 2) \EV\ \#{\Xbackslash}1
\end{lisp}
\end{defun}

\begin{defun}[Function]
char-int char

The argument \emph{char} must be a character object.
\cdf{char-int} returns a non-negative integer encoding the character object.

If the font and bits attributes of \emph{char} are zero, then
\cdf{char-int} returns the same integer \cdf{char-code} would.
Also,
\begin{lisp}
(char= c1 c2) \EQ\ (= (char-int c1) (char-int c2))
\end{lisp}
for characters \cd{c1} and \cd{c2}.

This function is provided primarily for the purpose of hashing characters.

Аргумент \emph{char} должен быть строковым символом.
\cdf{char-int} возвращает неотрицательный целый числовой код символа.

Следует отметить, что
\begin{lisp}
(char= c1 c2) \EQ\ (= (char-int c1) (char-int c2))
\end{lisp}
для любых символов \cd{c1} и \cd{c2}
\end{defun}

\begin{defun}[Function]
char-name char

The argument \emph{char} must be a character object.
If the character has a name, then that name (a string) is returned;
otherwise {\false} is returned.  All characters that have
zero font and bits attributes and that are non-graphic
(do not satisfy the predicate \cdf{graphic-char-p}) have names.
Graphic characters may or may not have names.

The standard newline and space characters have the respective
names \cdf{Newline} and \cdf{Space}.
The semi-standard characters have the names
\cdf{Tab}, \cdf{Page}, \cdf{Rubout}, \cdf{Linefeed}, \cdf{Return}, and \cdf{Backspace}.


Characters that have names can be notated as \cd{\#{\Xbackslash}} followed
by the name.  (See section~\ref{SHARP-SIGN-MACRO-CHARACTER-SECTION}.)
Although the name may be written in any case,
it is stylish to capitalize it thus: \cd{\#{\Xbackslash}Space}.

\cdf{char-name} will only locate ``simple'' character names;
it will not construct names such as \cdf{Control-Space} on the
basis of the character's bits attribute.

\begin{new}
The easiest way to get a name that includes the bits attribute of
a character \cdf{c} is \cd{(format nil "{\Xtilde}:C" c)}.
\end{new}
\end{defun}

\begin{defun}[Function]
name-char name

The argument \emph{name} must be an object coerceable to a string
as if by the function \cdf{string}.
If the name is the same as the name of a character object
(as determined by \cdf{string-equal}), that object
is returned; otherwise {\false} is returned.

Аргумент \emph{name} должен быть объектом, который можно превратить в строку,
например, с помощью функции \cdf{string}.
Если имя совпадает с именем некоторого строкового символа (проверка
осуществляется с помощью \cdf{string-equal}), тогда будет
возвращен этот символ, иначе возвращается {\false}.
\end{defun}