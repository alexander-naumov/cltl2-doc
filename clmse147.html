<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Series Functions</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-04 00:46:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 120--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse148.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse146.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse146.html#tailclmse146.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse147.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmap1.html#clmse147.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">A.2   </span> <a 
href="clm.html#QQ2-181-504" id="x181-462000A.2">Series Functions</a></h3>
<!--l. 123--><p class="noindent" >Throughout this chapter the notation <tt>S<span class="math"><sub>j</sub></span></tt> is used to denote the <i>j</i>th element of the
series <tt>S</tt>. As in a list or vector, the ﬁrst element of a series has the subscript
zero.
<!--l. 127--><p class="indent" >   The <tt>#</tt> macro character syntax <tt>#Z<i>list</i></tt> denotes a series that contains
the elements of <i>list</i>. This syntax is also used when series are printed.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(choose-if #&#x2019;symbolp #Z(a 2 b)) <span class="math"> ⇒</span> #Z(a b)
</td></tr></table>
<!--l. 131--><p class="indent" >
</div>
</div>
<!--l. 132--><p class="noindent" >Series are self-evaluating objects and the series data type is disjoint from all other
types.
<div class=defun>
<!--l. 136--><p class="noindent" ><i>[Type speciﬁer]</i><a 
 id="dx181-462001"></a><a 
 id="x181-462002r972"></a><b> series</b>  <i>element-type</i>
<!--l. 138--><p class="noindent" >The type speciﬁer <tt>(series <i>element-type</i>)</tt> denotes the set of series whose
elements are all members of the type <i>element-type</i>.
</div>
<div class=defun>
<!--l. 145--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-462003"></a><a 
 id="x181-462004r973"></a><b> series</b>  <i>arg</i> &#x0026;rest  <i>args</i>
<!--l. 147--><p class="noindent" >The function <tt><a 
href="#x181-462004r973">series</a></tt> returns an unbounded series that endlessly repeats the
values of the arguments. The second example below shows the preferred method
for constructing a bounded series. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(series &#x2019;b &#x2019;c) <span class="math"> ⇒</span> #Z(b c b c b c ...)
</td></tr></table>
<!--l. 152--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan (list &#x2019;a &#x2019;b &#x2019;c)) <span class="math"> ⇒</span> #Z(a b c)</td></tr></table>
<!--l. 154--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<!--l. 157--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.1   </span> <a 
href="clmli1.html#QQ2-181-505" id="x181-463000A.2.1">Scanners</a></h4>
<!--l. 159--><p class="noindent" >Scanners create series outputs based on non-series inputs. Either they operate
based on some formula (for example, scanning a range of integers) or they
enumerate the elements in an aggregate data structure (for example, scanning the
elements in a list or array).
<div class=defun>
<!--l. 165--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-463001"></a><a 
 id="x181-463002r974"></a><b> scan-range</b>  &#x0026;key  (:start 0) (:by 1) (:type &#x2019;number) <i>:upto</i> <i>:below</i>
<i>:downto</i> <i>:above</i> <i>:length</i>
<!--l. 168--><p class="noindent" >The function <tt><a 
href="#x181-463002r974">scan-range</a></tt> returns a series of numbers starting with the <tt>:start</tt>
argument (default integer <tt>0</tt>) and counting up by the <tt>:by</tt> argument (default
integer <tt>1</tt>). The <tt>:type</tt> argument (default <tt>number</tt>) is a type speciﬁer indicating the
type of numbers in the series produced. The <tt>:type</tt> argument must be a (not
necessarily proper) subtype of <tt>number</tt>. The <tt>:start</tt> and <tt>:by</tt> arguments must be of
that type.
<!--l. 177--><p class="indent" >   One of the last ﬁve arguments may be used to specify the kind of end test to
be used; these are called <i>termination arguments</i>. If <tt>:upto</tt> is speciﬁed,
counting continues only so long as the numbers generated are less than or
equal to <tt>:upto</tt>. If <tt>:below</tt> is speciﬁed, counting continues only so long
as the numbers generated are less than <tt>:below</tt>. If <tt>:downto</tt> is speciﬁed,
counting continues only so long as the numbers generated are greater than
or equal to <tt>:downto</tt>. If <tt>:above</tt> is speciﬁed, counting continues only so
long as the numbers generated are greater than <tt>:above</tt>. If <tt>:length</tt> is
speciﬁed, it must be a non-negative integer and the output series has this
length.
<!--l. 190--><p class="indent" >   If none of the termination arguments are speciﬁed, the output has
unbounded length. If more than one termination argument is speciﬁed, it is an
error.
<div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range :upto 4) <span class="math"> ⇒</span> #Z(0 1 2 3 4)
</td></tr></table>
<!--l. 195--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range :from 1 :by -1 :above -4) <span class="math"> ⇒</span> #Z(1 0 -1 -2 -3)</td></tr></table>
<!--l. 196--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range :from .5 :by .1 :type &#x2019;ﬂoat) <span class="math"> ⇒</span> #Z(.5 .6 .7 ...)</td></tr></table>
<!--l. 197--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-range) <span class="math"> ⇒</span> #Z(0 1 2 3 4 5 6 ...)</td></tr></table>
<!--l. 199--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 202--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-463003"></a><a 
 id="x181-463004r975"></a><b> scan</b>  <i>sequence</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-463005"></a><a 
 id="x181-463006r976"></a><b> scan</b>  <i>type</i> <i>sequence</i>
<!--l. 205--><p class="noindent" ><tt><a 
href="#x181-463006r976">scan</a></tt> returns a series containing the elements of <i>sequence</i> in order. The <i>type</i>
argument is a type speciﬁer indicating the type of sequence to be scanned; it must
be a (not necessarily proper) subtype of <tt>sequence</tt>. If <i>type</i> is omitted, it defaults
to <tt><a 
href="clmse80.html#x100-201034r441">list</a></tt>. (This function exhibits an argument pattern that is unusual for
Common Lisp: an “optional” argument preceding a required argument. This
pattern cannot be expressed in the usual manner with <tt>&#x0026;optional</tt>. It is
indicated above by two deﬁnition lines, showing the two possible argument
patterns.)
<!--l. 216--><p class="indent" >   If the <i>sequence</i> is a list, it must be a proper list ending in <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. Scanning is
signiﬁcantly more eﬃcient if it can be determined at compile time whether <i>type</i> is
a subtype of <tt><a 
href="clmse80.html#x100-201034r441">list</a></tt> or <tt><a 
href="clmse87.html#x109-213010r505">vector</a></tt> and for vectors what the length of the vector is.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan &#x2019;(a b c)) <span class="math"> ⇒</span> #Z(a b c)
</td></tr></table>
<!--l. 221--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan &#x2019;string &#x0022;BAR&#x0022;) <span class="math"> ⇒</span> #Z(#\B #\A #\R)</td></tr></table>
<!--l. 223--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 226--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-463007"></a><a 
 id="x181-463008r977"></a><b> scan-sublists</b>  <i>list</i>
<!--l. 228--><p class="noindent" ><tt><a 
href="#x181-463008r977">scan-sublists</a></tt> returns a series containing the successive sublists of <i>list</i>. The <i>list</i>
must be a proper list ending in <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. <div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-sublists &#x2019;(a b c)) <span class="math"> ⇒</span> #Z((a b c) (b c) (c))
</td></tr></table>
<!--l. 233--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 236--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-463009"></a><a 
 id="x181-463010r978"></a><b> scan-multiple</b>  <i>type</i> <i>ﬁrst-sequence</i> &#x0026;rest  <i>more-sequences</i>
<!--l. 238--><p class="noindent" >Several sequences can be scanned at once by using several calls on <tt><a 
href="#x181-463006r976">scan</a></tt>. Each call
on <tt><a 
href="#x181-463006r976">scan</a></tt> will test to see when its sequence runs out of elements and execution will
stop as soon as any of the sequences are exhausted. Although very robust, this
approach to scanning can be ineﬃcient. In situations where it is known in advance
which sequence is the shortest, <tt><a 
href="#x181-463010r978">scan-multiple</a></tt> can be used to obtain the same
results more rapidly.
<tt>
<!--l. 247--><p class="indent" >   <a 
href="#x181-463010r978">scan-multiple</a></tt> is similar to <tt><a 
href="#x181-463006r976">scan</a></tt> except that several sequences can be
scanned at once. If there are <i>n</i> sequence inputs, <tt><a 
href="#x181-463010r978">scan-multiple</a></tt> returns <i>n</i> series
containing the elements of these sequences. It must be the case that none of the
sequence inputs is shorter than the ﬁrst sequence. All of the output series are the
same length as the ﬁrst input sequence. Extra elements in the other input
sequences are ignored. Using <tt><a 
href="#x181-463010r978">scan-multiple</a></tt> is more eﬃcient than using multiple
instances of <tt><a 
href="#x181-463006r976">scan</a></tt>, because <tt><a 
href="#x181-463010r978">scan-multiple</a></tt> only has to check for the ﬁrst input
running out of elements.
<!--l. 257--><p class="indent" >   If <i>type</i> is of the form <tt>(values <span class="math"><i>t</i><sub>1</sub></span> <span class="math">…</span> <span class="math"><i>t</i>x<sub>m</sub></span>)</tt>, then there must be <span class="math"><i>m</i></span> sequence
inputs and the <i>i</i>th sequence must have type <span class="math"><i>t</i><sub>i</sub></span>. Otherwise there can be any
number of sequence inputs, each of which must have type <i>type</i>. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(multiple-value-bind (data weights)
</td></tr></table>
<!--l. 262--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (scan-multiple &#x2019;list &#x2019;(1 6 3 2 8) &#x2019;(2 3 3 3 2))</td></tr></table>
<!--l. 263--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (collect (map-fn t #&#x2019;* data weights)))</td></tr></table>
<!--l. 264--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> (2 18 9 6 16)</td></tr></table>
<!--l. 266--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 269--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-463011"></a><a 
 id="x181-463012r979"></a><b> scan-lists-of-lists</b>  <i>lists-of-lists</i> &#x0026;optional  <i>leaf-test</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-463013"></a><a 
 id="x181-463014r980"></a><b> scan-lists-of-lists-fringe</b>  <i>lists-of-lists</i> &#x0026;optional  <i>leaf-test</i>
<!--l. 272--><p class="noindent" >The argument <i>lists-of-lists</i> is viewed as a tree where each internal node is a
non-empty list and the elements of the list are the children of the node.
<tt><a 
href="#x181-463012r979">scan-lists-of-lists</a></tt> and <tt><a 
href="#x181-463014r980">scan-lists-of-lists-fringe</a></tt> each scan <i>lists-of-lists</i>
in preorder and return a series of its nodes. <tt><a 
href="#x181-463012r979">scan-lists-of-lists</a></tt> returns every
node in the tree. <tt><a 
href="#x181-463014r980">scan-lists-of-lists-fringe</a></tt> returns only the leaf
nodes.
<!--l. 281--><p class="indent" >   The scan proceeds as follows. The argument <i>lists-of-lists</i> can be any Lisp
object. If <i>lists-of-lists</i> is an atom or satisﬁes the predicate <i>leaf-test</i> (if present), it
is a leaf node. (The predicate can count on being applied only to conses.)
Otherwise, <i>lists-of-lists</i> is a (not necessarily proper) list. The ﬁrst element of
<i>lists-of-lists</i> is recursively scanned in full, followed by the second and so on until a
non-cons <i>cdr</i> is encountered. Whether or not this ﬁnal <i>cdr</i> is <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>, it is ignored.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-lists-of-lists &#x2019;((2) (nil)))
</td></tr></table>
<!--l. 290--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(((2) (nil)) (2) 2 (nil) nil)</td></tr></table>
<!--l. 291--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-lists-of-lists-fringe &#x2019;((2) (nil))) <span class="math"> ⇒</span> #Z(2 nil)</td></tr></table>
<!--l. 292--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-lists-of-lists-fringe &#x2019;((2) (nil))</td></tr></table>
<!--l. 293--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                            #&#x2019;(lambda (e) (numberp (car e))))</td></tr></table>
<!--l. 294--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z((2) nil)</td></tr></table>
<!--l. 296--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 299--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-463015"></a><a 
 id="x181-463016r981"></a><b> scan-alist</b>  <i>a-list</i> &#x0026;optional  (<i>test</i> #&#x2019;eql)<br 
class="newline" /><i>[Function]</i><a 
 id="dx181-463017"></a><a 
 id="x181-463018r982"></a><b> scan-plist</b>  <i>plist</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-463019"></a><a 
 id="x181-463020r983"></a><b> scan-hash</b>  <i>table</i>
<!--l. 303--><p class="noindent" >When given an association list, a property list, or a hash table (respectively), each
of these functions produces two outputs: a series of keys <i>K</i> and a series of the
corresponding values <i>V </i>. Each key in the input appears exactly once in the
                                                                          

                                                                          
output, even if it appears more than once in the input. (The <i>test</i> argument of
<tt><a 
href="#x181-463016r981">scan-alist</a></tt> speciﬁes the equality test between keys; it defaults to <tt><a 
href="clmse32.html#x43-77004r45">eql</a></tt>.) The two
outputs have the same length. Each <i>V </i><span class="math"><sub>j</sub></span> is the value returned by the appropriate
accessing function (<tt><a 
href="clmse79.html#x99-200004r394">cdr</a></tt> of <tt><a 
href="clmse84.html#x104-208006r483">assoc</a></tt>, <tt><a 
href="clmse50.html#x65-156008r130">getf</a></tt>, or <tt><a 
href="clmse85.html#x106-210006r491">gethash</a></tt>, respectively) when given
<i>K</i><span class="math"><sub>j</sub></span>. <tt><a 
href="#x181-463016r981">scan-alist</a></tt> and <tt><a 
href="#x181-463018r982">scan-plist</a></tt> scan keys in the order they appear in
the underlying structure. <tt><a 
href="#x181-463020r983">scan-hash</a></tt> scans keys in no particular order.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-plist &#x2019;(a 1 b 3)) <span class="math"> ⇒</span> #Z(a b) and #Z(1 3)
</td></tr></table>
<!--l. 318--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-alist &#x2019;((a . 1) nil (a . 3) (b . 2)))</td></tr></table>
<!--l. 319--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(a b) and #Z(1 2)</td></tr></table>
<!--l. 321--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 324--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-463021"></a><a 
 id="x181-463022r984"></a><b> scan-symbols</b>  &#x0026;optional  (<i>package</i> *package*)
<!--l. 326--><p class="noindent" ><tt><a 
href="#x181-463022r984">scan-symbols</a></tt> returns a series, in no particular order, and possibly containing
duplicates, of the symbols accessible in <i>package</i> (which defaults to the current
package).
</div>
<div class=defun>
<!--l. 332--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-463023"></a><a 
 id="x181-463024r985"></a><b> scan-ﬁle</b>  <i>ﬁle-name</i> &#x0026;optional  (<i>reader</i> #&#x2019;read)
<!--l. 334--><p class="noindent" ><tt><a 
href="#x181-463024r985">scan-file</a></tt> opens the ﬁle named by the string <i>ﬁle-name</i> and applies the function
<i>reader</i> to it repeatedly until the end of the ﬁle is reached. <i>Reader</i> must accept the
standard input function arguments <i>input-stream</i>, <i>eof-error-p</i>, and <i>eof-value</i> as its
arguments. (For instance, <i>reader</i> can be <tt><a 
href="clmse109.html#x136-255003r634">read</a></tt>, <tt>read-preserving-white-space</tt>,
<tt><a 
href="clmse109.html#x136-255013r638">read-line</a></tt>, or <tt><a 
href="clmse109.html#x136-255015r639">read-char</a></tt>.) If omitted, <i>reader</i> defaults to <tt><a 
href="clmse109.html#x136-255003r634">read</a></tt>. <tt><a 
href="#x181-463024r985">scan-file</a></tt>
returns a series of the values returned by <i>reader</i>, up to but not including the value
returned when the end of the ﬁle is reached. The ﬁle is correctly closed, even if an
abort occurs.
</div>
<div class=defun>
<!--l. 347--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-463025"></a><a 
 id="x181-463026r986"></a><b> scan-fn</b>  <i>type</i> <i>init</i> <i>step</i> &#x0026;optional  <i>test</i>
<!--l. 349--><p class="noindent" >The higher-order function <tt><a 
href="#x181-463026r986">scan-fn</a></tt> supports the general concept of scanning. The
                                                                          

                                                                          
<i>type</i> argument is a type speciﬁer indicating the type of values returned by <i>init</i>
and <i>step</i>. The <tt><a 
href="clmse42.html#x54-130002r105">values</a></tt> type speciﬁer can be used for this argument to
indicate multiple types; however, <i>type</i> cannot indicate zero values. If <i>type</i>
indicates <span class="math"><i>m</i></span> types <span class="math"><i>t</i><sub>1</sub>,…,<i>t</i><sub>m</sub></span>, then <tt><a 
href="#x181-463026r986">scan-fn</a></tt> returns <span class="math"><i>m</i></span> series <i>T1</i>, <span class="math">…</span>, <i>Tm</i>, where
<i>Ti</i> has the type <tt>(series <span class="math"><i>t</i><sub>i</sub></span>)</tt>. The arguments <i>init</i>, <i>step</i>, and <i>test</i> are
functions.
<!--l. 362--><p class="indent" >   The <i>init</i> must be of type <tt>(function () (values <span class="math"><i>t</i><sub>1</sub></span>  ... <span class="math"><i>t</i><sub>m</sub></span>))</tt>.
<!--l. 365--><p class="indent" >   The <i>step</i> must be of type <tt>(function (<span class="math"><i>t</i><sub>1</sub></span>  ... <span class="math"><i>t</i><sub>m</sub></span>) (values <span class="math"><i>t</i><sub>1</sub></span>  ...
<span class="math"><i>t</i><sub>m</sub></span>))</tt>.
<!--l. 368--><p class="indent" >   The <i>test</i> (if present) must be of type <tt>(function (<span class="math"><i>t</i><sub>1</sub></span>  ... <span class="math"><i>t</i><sub>m</sub></span>) t)</tt>.
<!--l. 371--><p class="indent" >   The elements of the <i>Ti</i> are computed as follows: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values <i>T1</i><span class="math"><sub>0</sub></span> ... <i>Tm</i><span class="math"><sub>0</sub></span>) = (funcall <i>init</i>)
</td></tr></table>
<!--l. 373--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values <i>T1</i><span class="math"><sub>j</sub></span> ... <i>Tm</i><span class="math"><sub>j</sub></span>) = (funcall <i>step</i> <i>T1</i><span class="math"><sub>(j−1)</sub></span> ... <i>Tm</i><span class="math"><sub>(j−1)</sub></span>)</td></tr></table>
<!--l. 375--><p class="indent" >
</div>
</div>
<!--l. 377--><p class="indent" >   The outputs all have the same length. If there is no <i>test</i>, the outputs have
unbounded length. If there is a <i>test</i>, the outputs consist of the elements up to, but
not including, the ﬁrst elements (with index <i>j</i>, say) for which the following
termination test is not <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(funcall <i>test</i> <i>T1</i><span class="math"><sub>j</sub></span> ... <i>Tm</i><span class="math"><sub>j</sub></span>)
</td></tr></table>
<!--l. 383--><p class="indent" >
</div>
</div>
<!--l. 384--><p class="noindent" >It is guaranteed that <i>step</i> will not be applied to the elements that pass this
termination test.
<!--l. 387--><p class="indent" >   If <i>init</i>, <i>step</i>, or <i>test</i> has side eﬀects when invoked, it can count on being called
in the order indicated by the equations above, with <i>test</i> called just before <i>step</i> on
each cycle. However, given the lazy evaluation nature of series, these functions will
not be called until their outputs are actually used (if ever). In addition, no
assumptions can be made about the relative order of evaluation of these
                                                                          

                                                                          
calls with regard to execution in other parts of a given series expression.
The ﬁrst example below scans down a list stepping two elements at a
time. The second example generates two unbounded series: the integers
counting up from 1 and the sequence of partial sums of the ﬁrst <i>i</i> integers.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-fn t #&#x2019;(lambda () &#x2019;(a b c d)) #&#x2019;cddr #&#x2019;null)
</td></tr></table>
<!--l. 399--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z((a b c d) (c d))</td></tr></table>
<!--l. 400--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 401--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(scan-fn &#x2019;(values integer integer)</td></tr></table>
<!--l. 402--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         #&#x2019;(lambda () (values 1 0))</td></tr></table>
<!--l. 403--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         #&#x2019;(lambda (i sum) (values (+ i 1) (+ sum i))))</td></tr></table>
<!--l. 404--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(1 2 3 4 ...) and #Z(0 1 3 6 ...)</td></tr></table>
<!--l. 406--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 409--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-463027"></a><a 
 id="x181-463028r987"></a><b> scan-fn-inclusive</b>  <i>type</i> <i>init</i> <i>step</i> <i>test</i>
<!--l. 411--><p class="noindent" >The higher-order function <tt><a 
href="#x181-463028r987">scan-fn-inclusive</a></tt> is the same as <tt><a 
href="#x181-463026r986">scan-fn</a></tt> except
that the ﬁrst set of elements for which <i>test</i> returns a non-null value is included in
the output. As with <tt><a 
href="#x181-463026r986">scan-fn</a></tt>, it is guaranteed that <i>step</i> will not be applied to the
elements for which <i>test</i> is non-null.
</div>
<!--l. 419--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.2   </span> <a 
href="clmli1.html#QQ2-181-506" id="x181-464000A.2.2">Mapping</a></h4>
<!--l. 421--><p class="noindent" >By far the most common kind of series operation is mapping. In cognizance of this
fact, four diﬀerent ways are provided for specifying mapping: one fundamental
form (<tt><a 
href="#x181-464002r988">map-fn</a></tt>) and three shorthand forms that are more convenient in particular
common situations.
<div class=defun>
<!--l. 426--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-464001"></a><a 
 id="x181-464002r988"></a><b> map-fn</b>  <i>type</i> <i>function</i> &#x0026;rest  <i>series-inputs</i>
<!--l. 428--><p class="noindent" >The higher-order function <tt><a 
href="#x181-464002r988">map-fn</a></tt> supports the general concept of mapping. The
                                                                          

                                                                          
<i>type</i> argument is a type speciﬁer indicating the type of values returned by
<i>function</i>. The <tt><a 
href="clmse42.html#x54-130002r105">values</a></tt> construct can be used to indicate multiple types; however,
<i>type</i> cannot indicate zero values. If <i>type</i> indicates <span class="math">m</span> types <span class="math">t<sub>1</sub>,…,t<sub>m</sub></span>, then <tt><a 
href="#x181-464002r988">map-fn</a></tt>
returns <span class="math">m</span> series <i>T1</i>, <span class="math">…</span>, <i>Tm</i>, where <i>Ti</i> has the type <tt>(series <span class="math">t<sub>i</sub></span>)</tt>. The
argument <i>function</i> is a function. The remaining arguments (if any) are all
series. Let these series be <i>S1</i>, <span class="math">…</span>, <i>Sn</i> and suppose that <i>Si</i> has the type
<tt>(series <span class="math"><i>s</i><sub>i</sub></span>)</tt>.
<!--l. 443--><p class="indent" >   The <i>function</i> must be of type <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(function (<span class="math"><i>s</i><sub>1</sub></span> ... <span class="math"><i>s</i><sub>n</sub></span>) (values <span class="math"><i>t</i><sub>1</sub></span> ... <span class="math"><i>t</i><sub>m</sub></span>))
</td></tr></table>
<!--l. 446--><p class="indent" >
</div>
</div>
<!--l. 448--><p class="indent" >   The length of each output is the same as the length of the shortest input. If
there are no bounded series inputs, the outputs are unbounded. The elements of
the <i>Ti</i> are the results of applying <i>function</i> to the corresponding elements of the
series inputs. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values <i>T1</i><span class="math"><sub>j</sub></span> ... <i>Tm</i><span class="math"><sub>j</sub></span>) <span class="math"> ≡</span> (funcall <i>function</i> <i>S1</i><span class="math"><sub>j</sub></span> ... <i>Sn</i><span class="math"><sub>j</sub></span>)
</td></tr></table>
<!--l. 454--><p class="indent" >
</div>
</div>
<!--l. 456--><p class="indent" >   If <i>function</i> has side eﬀects, it can count on being called ﬁrst on the <i>Si</i><span class="math"><sub>0</sub></span>, then
on the <i>Si</i><span class="math"><sub>1</sub></span>, and so on. However, given the lazy evaluation nature of series,
<i>function</i> will not be called on any group of input elements until the result is
actually used (if ever). In addition, no assumptions can be made about the
relative order of evaluation of the calls on <i>function</i> with regard to execution in
other parts of a given series expression. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(map-fn &#x2019;integer #&#x2019;+ #Z(1 2 3) #Z(4 5)) <span class="math"> ⇒</span> #Z(5 7)
</td></tr></table>
<!--l. 464--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(map-fn t #&#x2019;gensym) <span class="math"> ⇒</span> #Z(#:G3 #:G4 #:G5 ...)</td></tr></table>
<!--l. 465--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(map-fn &#x2019;(values integer rational) #&#x2019;ﬂoor #Z(1/4 9/5 12/3))</td></tr></table>
                                                                          

                                                                          
<!--l. 466--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(0 1 4) and #Z(1/4 4/5 0)</td></tr></table>
<!--l. 468--><p class="indent" >
</div>
</div>
<!--l. 470--><p class="indent" >   The <tt>#</tt> macro character syntax <tt>#M</tt> makes it easy to specify uses of
<tt><a 
href="#x181-464002r988">map-fn</a></tt> where <i>type</i> is <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> and the <i>function</i> is a named function. The notation
<tt>(#M<i>function</i> ...)</tt> is an abbreviation for <tt>(map-fn t #&#x2019;<i>function</i> ...)</tt>. The
form <i>function</i> can be the printed representation of any Lisp object. The
notation <tt>#M</tt><i>function</i> can appear only in the function position of a list.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect (#M1+ (scan &#x2019;(1 2 3)))) <span class="math"> ⇒</span> (2 3 4)
</td></tr></table>
<!--l. 479--><p class="indent" >
</div>
</div>
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Макрос]</i><b> mapping </b><a 
 id="dx181-464003"></a><a 
 id="x181-464004r989"></a> ( {( {var | ( {var}* )} value)}* )  {declaration}*  { form}*
</td></tr></table>
<!--l. 484--><p class="indent" >
</div>
<!--l. 484--><p class="noindent" ><span class="paragraphHead"><a 
href="#x181-465000A.2.2" id="x181-465000A.2.2"></a></span>
   The macro <tt><a 
href="#x181-464004r989">mapping</a></tt> makes it easy to specify uses of <tt><a 
href="#x181-464002r988">map-fn</a></tt> where <i>type</i> is <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>
and the <i>function</i> is a literal <tt>lambda</tt>. The syntax of <tt><a 
href="#x181-464004r989">mapping</a></tt> is analogous to that
of <tt><a 
href="clmse38.html#x50-99002r74">let</a></tt>. The binding list speciﬁes zero or more variables that are bound in parallel
to successive values of series. The <i>value</i> part of each pair is an expression that
must produce a series. The <i>declarations</i> and <i>forms</i> are treated as the body of a
<tt>lambda</tt> expression that is mapped over the series values. A series of the ﬁrst
values returned by this <tt>lambda</tt> expression is returned as the result of <tt><a 
href="#x181-464004r989">mapping</a></tt>.
<div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping ((x r) (y s)) ...) <span class="math"> ≡</span>
</td></tr></table>
<!--l. 497--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (map-fn t #&#x2019;(lambda (x y) ...) r s)</td></tr></table>
<!--l. 498--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 499--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping ((x (scan &#x2019;(2 -2 3))))</td></tr></table>
<!--l. 500--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (expt (abs x) 3))</td></tr></table>
<!--l. 501--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(8 8 27)</td></tr></table>
<!--l. 503--><p class="indent" >
</div>
</div>
<!--l. 505--><p class="indent" >   The form <tt><a 
href="#x181-464004r989">mapping</a></tt> supports a special syntax that facilitates the use of series
functions returning multiple values. Instead of being a single variable, the variable
part of a <i>var-value</i> pair can be a list of variables. This list is treated the same
way as the ﬁrst argument to <tt><a 
href="clmse42.html#x54-133002r111">multiple-value-bind</a></tt> and can be used
to access the elements of multiple series returned by a series function.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping (((i v) (scan-plist &#x2019;(a 1 b 2))))
</td></tr></table>
<!--l. 512--><p class="indent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (list i v))</td></tr></table>
<!--l. 513--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z((a 1) (b 2))</td></tr></table>
<!--l. 515--><p class="indent" >
</div>
</div>
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Макрос]</i><b> iterate </b><a 
 id="dx181-465001"></a><a 
 id="x181-465002r990"></a> ( {( {var | ( {var}* )} value)}* )  {declaration}*  { form}*
</td></tr></table>
<!--l. 520--><p class="indent" >
</div>
                                                                          

                                                                          
<!--l. 520--><p class="noindent" ><span class="paragraphHead"><a 
href="#x181-466000A.2.2" id="x181-466000A.2.2"></a></span>
   The form <tt><a 
href="#x181-465002r990">iterate</a></tt> is the same as <tt><a 
href="#x181-464004r989">mapping</a></tt>, except that after mapping
the <i>forms</i> over the <i>values</i>, the results are discarded and <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> is returned.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((item (scan &#x2019;((1) (-2) (3)))))
</td></tr></table>
<!--l. 525--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (iterate ((x (#Mcar item)))</td></tr></table>
<!--l. 526--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (if (plusp x) (prin1 x))))</td></tr></table>
<!--l. 527--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> nil (after printing “<tt>13</tt>”)</td></tr></table>
<!--l. 529--><p class="indent" >
</div>
</div>
<!--l. 531--><p class="indent" >   To a ﬁrst approximation, <tt><a 
href="#x181-465002r990">iterate</a></tt> and <tt><a 
href="#x181-464004r989">mapping</a></tt> diﬀer in the same way as <tt><a 
href="clmse41.html#x53-124007r97">mapc</a></tt>
and <tt><a 
href="clmse41.html#x53-124003r95">mapcar</a></tt>. In particular, like <tt><a 
href="clmse41.html#x53-124007r97">mapc</a></tt>, <tt><a 
href="#x181-465002r990">iterate</a></tt> is intended to be used in
situations where the <i>forms</i> are being evaluated for side eﬀects rather than for
their results. However, given the lazy evaluation semantics of series, the
diﬀerence between <tt><a 
href="#x181-465002r990">iterate</a></tt> and <tt><a 
href="#x181-464004r989">mapping</a></tt> is more than just a question of
eﬃciency.
<!--l. 538--><p class="indent" >   If <tt><a 
href="clmse41.html#x53-124003r95">mapcar</a></tt> is used in a situation where the output is not used, time is wasted
unnecessarily creating the output list. However, if <tt><a 
href="#x181-464004r989">mapping</a></tt> is used in a situation
where the output is not used, no computation is performed, because series
elements are not computed until they are used. Thus <tt><a 
href="#x181-465002r990">iterate</a></tt> can be thought of
as a declaration that the indicated computation is to be performed even though
the output is not used for anything.
</div>
<!--l. 547--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.3   </span> <a 
href="clmli1.html#QQ2-181-509" id="x181-467000A.2.3">Truncation and Other Simple Transducers</a></h4>
<!--l. 549--><p class="noindent" >Transducers compute series from series and form the heart of most series
expressions. Mapping is by far the most common transducer. This section presents
a number of additional simple transducers.
<div class=defun>
<!--l. 554--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-467001"></a><a 
 id="x181-467002r991"></a><b> cotruncate</b>  &#x0026;rest  <i>series-inputs</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-467003"></a><a 
 id="x181-467004r992"></a><b> until</b>  <i>bools</i> &#x0026;rest  <i>series-inputs</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-467005"></a><a 
 id="x181-467006r993"></a><b> until-if</b>  <i>pred</i> &#x0026;rest  <i>series-inputs</i>
<!--l. 558--><p class="noindent" >Each of these functions accepts one or more series inputs S1, <span class="math">…</span>, <i>Sn</i> as its <tt>&#x0026;rest</tt>
argument and returns <span class="math"><i>n</i></span> series outputs <i>T1</i>, <span class="math">…</span>, <i>Tn</i> that contain the same elements
in the same order—that is, <i>Ti<span class="math"><sub>j</sub></span>=Si<span class="math"><sub>j</sub></span></i>. Let <span class="math"><i>k</i></span> be the length of the shortest input <i>Si</i>.
<tt><a 
href="#x181-467002r991">cotruncate</a></tt> truncates the series so that each output has length <span class="math"><i>k</i></span>. Let <span class="math"><i>k</i>′</span> be the
position of the ﬁrst element in the boolean series <i>bools</i> that is not <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> or, if every
element is <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>, the length of <i>bools</i>. <tt><a 
href="#x181-467004r992">until</a></tt> truncates the series so that each output
has length <tt>(min <i>k</i> <span class="math"><i>k</i>′</span>)</tt>. Let <span class="math">itk′′</span> be the position of the ﬁrst element in <i>S1</i> such
that <tt>(<i>pred</i> <i>S1<span class="math"><sub>k′′</sub></span></i>)</tt> is not <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> or, if there is no such element, the length of <i>S1</i>.
<tt><a 
href="#x181-467006r993">until-if</a></tt> truncates the series so that each output has length <tt>(min <i>k</i> <span class="math"><i>k</i>′′</span>)</tt>.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(cotruncate #Z(1 2 -3 4) #Z(a b c))
</td></tr></table>
<!--l. 575--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(1 2 -3) and #Z(a b c)</td></tr></table>
<!--l. 576--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(until #Z(nil nil t nil) #Z(1 2 -3 4) #Z(a b c))</td></tr></table>
<!--l. 577--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(1 2) and #Z(a b)</td></tr></table>
<!--l. 578--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(until-if #&#x2019;minusp #Z(1 2 -3 4) #Z(a b c))</td></tr></table>
<!--l. 579--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(1 2) and #Z(a b)</td></tr></table>
<!--l. 581--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 584--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-467007"></a><a 
 id="x181-467008r994"></a><b> previous</b>  <i>items</i> &#x0026;optional  (<i>default</i> nil) (<i>amount</i> 1)
<!--l. 586--><p class="noindent" >The series returned by <tt><a 
href="#x181-467008r994">previous</a></tt> is the same as the input series <i>items</i> except that
it is shifted to the right by the positive integer <i>amount</i>. The shifting is done by
inserting <i>amount</i> copies of <i>default</i> before <i>items</i> and discarding <i>amount</i> elements
from the end of <i>items</i>. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(previous #Z(10 11 12) 0) <span class="math"> ⇒</span> #Z(0 10 11)
</td></tr></table>
<!--l. 594--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 597--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-467009"></a><a 
 id="x181-467010r995"></a><b> latch</b>  <i>items</i> &#x0026;key  <i>:after</i> <i>:before</i> <i>:pre</i> <i>:post</i>
<!--l. 599--><p class="noindent" >The series returned by <tt><a 
href="#x181-467010r995">latch</a></tt> is the same as the input series <i>items</i> except that
some of the elements are replaced by other values. <tt><a 
href="#x181-467010r995">latch</a></tt> acts like a <i>latch</i>
electronic circuit component. Each input element causes the creation of a
corresponding output element. After a speciﬁed number of non-null input
elements have been encountered, the latch is triggered and the output mode is
permanently changed.
<!--l. 608--><p class="indent" >   The <tt>:after</tt> and <tt>:before</tt> arguments specify the latch point. The latch point is
just after the <tt>:after</tt>-th non-null element in <i>items</i> or just before the <tt>:before</tt>-th
non-null element. If neither <tt>:after</tt> nor <tt>:before</tt> is speciﬁed, an <tt>:after</tt> of <tt>1</tt> is
assumed. If both are speciﬁed, it is an error.
<!--l. 614--><p class="indent" >   If a <tt>:pre</tt> is speciﬁed, every element prior to the latch point is replaced by
this value. If a <tt>:post</tt> is speciﬁed, every element after the latch point is
replaced by this value. If neither is speciﬁed, a <tt>:post</tt> of <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> is assumed.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(latch #Z(nil c nil d e)) <span class="math"> ⇒</span> #Z(nil c nil nil nil)
</td></tr></table>
<!--l. 619--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(latch #Z(nil c nil d e) :before 2 :post t) <span class="math"> ⇒</span> #Z(nil c nil t t)</td></tr></table>
<!--l. 621--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 624--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-467011"></a><a 
 id="x181-467012r996"></a><b> collecting-fn</b>  <i>type</i> <i>init</i> <i>function</i> &#x0026;rest  <i>series-inputs</i>
<!--l. 626--><p class="noindent" >The higher-order function <tt><a 
href="#x181-467012r996">collecting-fn</a></tt> supports the general concept of a
simple transducer with internal state. The <i>type</i> argument is a type speciﬁer
indicating the type of values returned by <i>function</i>. The <tt><a 
href="clmse42.html#x54-130002r105">values</a></tt> construct can be
used to indicate multiple types; however, <i>type</i> cannot indicate zero values. If
<i>type</i> indicates <span class="math"><i>m</i></span> types <span class="math"><i>t</i><sub>1</sub>,…,<i>t</i><sub>m</sub></span>, then <tt><a 
href="#x181-467012r996">collecting-fn</a></tt> returns <span class="math"><i>m</i></span> series
T1, <span class="math">…</span>, <i>Tm</i>, where <i>Ti</i> has the type <tt>(series <span class="math"><i>t</i><sub>i</sub></span>)</tt>. The arguments <i>init</i>
and <i>function</i> are functions. The remaining arguments (if any) are all
series. Let these series be S1, <span class="math">…</span>, <i>Sn</i> and suppose that <i>Si</i> has the type
<tt>(series <span class="math"><i>s</i><sub>i</sub></span>)</tt>.
<!--l. 641--><p class="indent" >   The <i>init</i> must be of type <tt>(function () (values <span class="math"><i>t</i><sub>1</sub></span>  ... <span class="math"><i>t</i><sub>m</sub></span>))</tt>.
                                                                          

                                                                          
<!--l. 644--><p class="indent" >   The <i>function</i> must be of type <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(function (<span class="math"><i>t</i><sub>1</sub></span> ... <span class="math"><i>t</i><sub>m</sub></span> <span class="math"><i>s</i><sub>1</sub></span> ... <span class="math"><i>s</i><sub>n</sub></span>) (values <span class="math"><i>t</i><sub>1</sub></span> ... <span class="math"><i>t</i><sub>m</sub></span>))
</td></tr></table>
<!--l. 647--><p class="indent" >
</div>
</div>
<!--l. 649--><p class="indent" >   The length of each output is the same as the length of the shortest input. If
there are no bounded series inputs, the outputs are unbounded. The elements of
the <i>Ti</i> are computed as follows: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values <i>T1</i><span class="math"><sub>0</sub></span> ... <i>Tm</i><span class="math"><sub>0</sub></span>) <span class="math"> ≡</span>
</td></tr></table>
<!--l. 653--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-call <i>function</i> (funcall <i>init</i>) <i>S1</i><span class="math"><sub>0</sub></span> ... <i>Sn</i><span class="math"><sub>0</sub></span>)</td></tr></table>
<!--l. 654--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 655--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(values <i>T1</i><span class="math"><sub>j</sub></span> ... <i>Tm</i><span class="math"><sub>j</sub></span>) <span class="math"> ≡</span></td></tr></table>
<!--l. 656--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (funcall <i>function</i> <i>T1</i><span class="math"><sub>(j−1)</sub></span> ... <i>Tm</i><span class="math"><sub>(j−1)</sub></span> <i>S1</i><span class="math"><sub>j</sub></span> ... <i>Sn</i><span class="math"><sub>j</sub></span>)</td></tr></table>
<!--l. 658--><p class="indent" >
</div>
</div>
<!--l. 660--><p class="indent" >   If <i>init</i> or <i>function</i> has side eﬀects, it can count on being called in the order
indicated by the equations above. However, given the lazy evaluation nature of
series, these functions will not be called until their outputs are actually used (if
ever). In addition, no assumptions can be made about the relative order of
evaluation of these calls with regard to execution in other parts of a given series
expression. The second example below computes a series of partial sums of the
numbers in an input series. The third example computes two output series: the
partial sums of its ﬁrst input and the partial products of its second input.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun running-averages (ﬂoat-list)
</td></tr></table>
<!--l. 671--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-call #&#x2019;map-fn</td></tr></table>
<!--l. 672--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    &#x2019;ﬂoat #&#x2019;/</td></tr></table>
<!--l. 673--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (collecting-fn &#x2019;(values ﬂoat integer)</td></tr></table>
                                                                          

                                                                          
<!--l. 674--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   #&#x2019;(lambda () (values 0.0 0)</td></tr></table>
<!--l. 675--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   #&#x2019;(lambda (s n x) (values (+ s x) (+ n 1))))</td></tr></table>
<!--l. 676--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   ﬂoat-list)))</td></tr></table>
<!--l. 678--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collecting-fn &#x2019;integer #&#x2019;(lambda () 0) #&#x2019;+ #Z(1 2 3))
</td></tr></table>
<!--l. 680--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(1 3 6)</td></tr></table>
<!--l. 681--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 682--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collecting-fn &#x2019;(values integer integer)</td></tr></table>
<!--l. 683--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #&#x2019;(lambda () (values 0 1))</td></tr></table>
<!--l. 684--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #&#x2019;(lambda (sum prod x y)</td></tr></table>
<!--l. 685--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   (values (+ sum x) (* prod y)))</td></tr></table>
<!--l. 686--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #Z(4 6 8)</td></tr></table>
<!--l. 687--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               #Z(1 2 3))</td></tr></table>
<!--l. 688--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(4 10 18) and #Z(1 2 6)</td></tr></table>
<!--l. 690--><p class="indent" >
</div>
</div>
</div>
<!--l. 693--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.4   </span> <a 
href="clmli1.html#QQ2-181-510" id="x181-468000A.2.4">Conditional and Other Complex Transducers</a></h4>
<!--l. 696--><p class="noindent" >This section presents a number of complex transducers, including ones that
support conditional computation.
<div class=defun>
<!--l. 700--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-468001"></a><a 
 id="x181-468002r997"></a><b> choose</b>  <i>bools</i> &#x0026;optional  (<i>items</i> bools)<br 
class="newline" /><i>[Function]</i><a 
 id="dx181-468003"></a><a 
 id="x181-468004r998"></a><b> choose-if</b>  <i>pred</i> <i>items</i>
<!--l. 703--><p class="noindent" >Each of these functions takes in a series of elements (<i>items</i>) and returns a series
containing the same elements in the same order, but with some elements removed.
                                                                          

                                                                          
<tt><a 
href="#x181-468002r997">choose</a></tt> removes <i>items</i><span class="math"><sub>j</sub></span> if bools<span class="math"><sub>j</sub></span> is <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> or <span class="math"><i>j</i></span> is beyond the end of <i>bools</i>. If items is
omitted, <tt><a 
href="#x181-468002r997">choose</a></tt> returns the non-null elements of bools. <tt><a 
href="#x181-468004r998">choose-if</a></tt> removes <i>items</i><span class="math"><sub>j</sub></span>
if <tt>(<i>pred</i> <i>items</i><span class="math"><sub>j</sub></span>)</tt> is <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(choose #Z(t nil t nil) #Z(a b c d)) <span class="math"> ⇒</span> #Z(a c)
</td></tr></table>
<!--l. 712--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-sum (choose-if #&#x2019;plusp #Z(-1 2 -3 4))) <span class="math"> ⇒</span> 6</td></tr></table>
<!--l. 714--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 717--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-468005"></a><a 
 id="x181-468006r999"></a><b> expand</b>  <i>bools</i> <i>items</i> &#x0026;optional  (<i>default</i> nil)
<!--l. 719--><p class="noindent" ><tt><a 
href="#x181-468006r999">expand</a></tt> is a quasi-inverse of <tt><a 
href="#x181-468002r997">choose</a></tt>. The output contains the elements of the
input series <i>items</i> spread out into the positions speciﬁed by the non-null elements
in <i>bools</i>—that is, <i>items</i><span class="math"><sub>j</sub></span> is in the position occupied by the <i>j</i>th non-null element in
<i>bools</i>. The other positions in the output are occupied by <i>default</i>. The
output stops as soon as <i>bools</i> runs out of elements or a non-null element in
<i>bools</i> is encountered for which there is no corresponding element in <i>items</i>.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(expand #Z(nil t nil t t) #Z(a b c)) <span class="math"> ⇒</span> #Z(nil a nil b c)
</td></tr></table>
<!--l. 730--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(expand #Z(nil t nil t t) #Z(a)) <span class="math"> ⇒</span> #Z(nil a nil)</td></tr></table>
<!--l. 732--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 735--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-468007"></a><a 
 id="x181-468008r1000"></a><b> split</b>  <i>items</i> &#x0026;rest  <i>test-series-inputs</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-468009"></a><a 
 id="x181-468010r1001"></a><b> split-if</b>  <i>items</i> &#x0026;rest  <i>test-predicates</i>
<!--l. 738--><p class="noindent" >These functions are like <tt><a 
href="#x181-468002r997">choose</a></tt> and <tt><a 
href="#x181-468004r998">choose-if</a></tt> except that instead of producing
one restricted output, they partition the input series <i>items</i> between several
outputs. If there are <span class="math"><i>n</i></span> test inputs following <i>items</i>, then there are <span class="math"><i>n</i> + 1</span> outputs.
Each input element is placed in exactly one output series, depending on the
                                                                          

                                                                          
outcome of a sequence of tests. If the element <i>items</i><span class="math"><sub>j</sub></span> fails the ﬁrst <span class="math"><i>k</i> − 1</span> tests and
passes the <i>k</i>h test, it is put in the <i>k</i>th output. If <i>items</i><span class="math"><sub>j</sub></span> fails every test, it is
placed in the last output. In addition, all output stops as soon as any series
input runs out of elements. The test inputs to <tt><a 
href="#x181-468008r1000">split</a></tt> are series of values;
<i>items</i><span class="math"><sub>j</sub></span> passes the <i>k</i>th test if the <i>j</i>th element of the <i>k</i>th test series is not
<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. The test inputs to <tt><a 
href="#x181-468010r1001">split-if</a></tt> are predicates; <i>items</i><span class="math"><sub>j</sub></span> passes the <i>k</i>th
test if the <i>k</i>th test predicate returns non-null when applied to items<span class="math"><sub>j</sub></span>.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(split #Z(-1 2 3 -4) #Z(t nil nil t))
</td></tr></table>
<!--l. 755--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(-1 -4) and #Z(2 3)</td></tr></table>
<!--l. 756--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(multiple-value-bind (+x -x) (split-if #Z(-1 2 3 -4) #&#x2019;plusp)</td></tr></table>
<!--l. 757--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (values (collect-sum +x) (collect-sum -x)))</td></tr></table>
<!--l. 758--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> 5 and -5</td></tr></table>
<!--l. 760--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 763--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-468011"></a><a 
 id="x181-468012r1002"></a><b> catenate</b>  &#x0026;rest  <i>series-inputs</i>
<!--l. 765--><p class="noindent" ><tt><a 
href="#x181-468012r1002">catenate</a></tt> combines two or more series into one long series by appending them end
to end. The length of the output is the sum of the lengths of the inputs.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(catenate #Z(b c) #Z() #Z(d)) <span class="math"> ⇒</span> #Z(b c d)
</td></tr></table>
<!--l. 771--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 774--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-468013"></a><a 
 id="x181-468014r1003"></a><b> subseries</b>  <i>items</i> <i>start</i> &#x0026;optional  <i>below</i>
<!--l. 776--><p class="noindent" ><tt><a 
href="#x181-468014r1003">subseries</a></tt> returns a series containing the elements of the input series <i>items</i>
indexed by the non-negative integers from <i>start</i> up to, but not including, <i>below</i>. If
                                                                          

                                                                          
<i>below</i> is omitted or greater than the length of <i>items</i>, the output goes all the way
to the end of <i>items</i>. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subseries #Z(a b c d) 1) <span class="math"> ⇒</span> #Z(b c d)
</td></tr></table>
<!--l. 783--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subseries #Z(a b c d) 1 3) <span class="math"> ⇒</span> #Z(b c)</td></tr></table>
<!--l. 785--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 788--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-468015"></a><a 
 id="x181-468016r1004"></a><b> positions</b>  <i>bools</i>
<!--l. 790--><p class="noindent" ><tt><a 
href="#x181-468016r1004">positions</a></tt> returns a series of the indices of the non-null elements in the series
input <i>bools</i>. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(positions #Z(t nil t 44)) <span class="math"> ⇒</span> #Z(0 2 3)
</td></tr></table>
<!--l. 795--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 798--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-468017"></a><a 
 id="x181-468018r1005"></a><b> mask</b>  <i>monotonic-indices</i>
<!--l. 800--><p class="noindent" ><tt><a 
href="#x181-468018r1005">mask</a></tt> is a quasi-inverse of <tt><a 
href="#x181-468016r1004">positions</a></tt>. The series input monotonic-indices must be
a strictly increasing series of non-negative integers. The output, which is always
unbounded, contains <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> in the positions speciﬁed by <i>monotonic-indices</i> and <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>
everywhere else. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask #Z(0 2 3)) <span class="math"> ⇒</span> #Z(t nil t t nil nil ...)
</td></tr></table>
<!--l. 806--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask #Z()) <span class="math"> ⇒</span> #Z(nil nil ...)</td></tr></table>
<!--l. 807--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mask (positions #Z(nil a nil b nil)))</td></tr></table>
<!--l. 808--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(nil t nil t nil ...)</td></tr></table>
<!--l. 810--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 814--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-468019"></a><a 
 id="x181-468020r1006"></a><b> mingle</b>  <i>items1</i> <i>items2</i> <i>comparator</i>
<!--l. 816--><p class="noindent" >The series returned by <tt><a 
href="#x181-468020r1006">mingle</a></tt> contains all and only the elements of the two input
series. The length of the output is the sum of the lengths of the inputs and is
unbounded if either input is unbounded. The order of the elements remains
unchanged; however, the elements from the two inputs are stably intermixed
under the control of the <i>comparator</i>.
<!--l. 823--><p class="indent" >   The <i>comparator</i> must accept two arguments and return non-null if and only if
its ﬁrst argument is strictly less than its second argument (in some appropriate
sense). At each step, the <i>comparator</i> is used to compare the current elements in
the two series. If the current element from items2 is strictly less than the current
element from <i>items1</i>, the current element is removed from <i>items2</i> and transferred
to the output. Otherwise, the next output element comes from <i>items1</i>.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mingle #Z(1 3 7 9) #Z(4 5 8) #&#x2019;&#x003C;) <span class="math"> ⇒</span> #Z(1 3 4 5 7 8 9)
</td></tr></table>
<!--l. 831--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mingle #Z(1 7 3 9) #Z(4 5 8) #&#x2019;&#x003C;) <span class="math"> ⇒</span> #Z(1 4 5 7 3 8 9)</td></tr></table>
<!--l. 833--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 836--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-468021"></a><a 
 id="x181-468022r1007"></a><b> chunk</b>  <i>m</i> <i>n</i> <i>items</i>
<!--l. 838--><p class="noindent" >This function has the eﬀect of breaking up the input series <i>items</i> into (possibly
overlapping) chunks of length <i>m</i>. The starting positions of successive chunks diﬀer
by <i>n</i>. The inputs <i>m</i> and <i>n</i> must both be positive integers.
<tt>
<!--l. 843--><p class="indent" >   <a 
href="#x181-468022r1007">chunk</a></tt> produces <i>m</i> output series. The <i>i</i>th chunk provides the <i>i</i>th element for
each of the <i>m</i> outputs. Suppose that the length of <i>items</i> is <i>l</i>. The length of each
output is <span class="math">⌊1 + (<i>l</i> −<i>m</i>)∕<i>n</i>⌋</span>. The <i>i</i>th element of the <i>k</i>th output is the <span class="math">(<i>i</i> ∗<i>n</i> + <i>k</i>)</span>th
element of <i>items</i> (<i>i</i> and <span class="math"><i>k</i></span> counting from zero).
<!--l. 851--><p class="indent" >   Note that if <span class="math"><i>l</i> &#x003C; <i>m</i></span>, there will be no output elements, and if <span class="math"><i>l</i> −<i>m</i></span> is not a
                                                                          

                                                                          
multiple of <i>n</i>, the last few input elements will not appear in the output. If <span class="math"><i>m</i> ≥<i>n</i></span>,
one can guarantee that the last chunk will contain the last element of <i>items</i> by
catenating <span class="math"><i>n</i> − 1</span> copies of an appropriate padding value to the end of
<i>items</i>.
<!--l. 859--><p class="indent" >   The ﬁrst example below shows <tt><a 
href="#x181-468022r1007">chunk</a></tt> being used to compute a moving
average. The second example shows <tt><a 
href="#x181-468022r1007">chunk</a></tt> being used to convert a property list
into an association list. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(mapping (((xi xi+1 xi+2) (chunk 3 1 #Z(1 5 3 4 5 6))))
</td></tr></table>
<!--l. 863--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (/ (+ xi xi+1 xi+2) 3))</td></tr></table>
<!--l. 864--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> #Z(3 4 4 5)</td></tr></table>
<!--l. 866--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect</td></tr></table>
<!--l. 867--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (mapping (((prop val) (chunk 2 2 (scan &#x2019;(a 2 b 5 c 8)))))</td></tr></table>
<!--l. 868--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (cons prop val)))</td></tr></table>
<!--l. 869--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> ((a . 2) (b . 5) (c . 8))</td></tr></table>
<!--l. 871--><p class="indent" >
</div>
</div>
</div>
<!--l. 874--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.5   </span> <a 
href="clmli1.html#QQ2-181-511" id="x181-469000A.2.5">Collectors</a></h4>
<!--l. 876--><p class="noindent" >Collectors produce non-series outputs based on series inputs. They either
create a summary value based on some formula (the sum, for example) or
collect the elements of a series in an aggregate data structure (such as a
list).
<div class=defun>
<!--l. 880--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469001"></a><a 
 id="x181-469002r1008"></a><b> collect-ﬁrst</b>  <i>items</i> &#x0026;optional  (<i>default</i> nil)<br 
class="newline" /><i>[Function]</i><a 
 id="dx181-469003"></a><a 
 id="x181-469004r1009"></a><b> collect-last</b>  <i>items</i> &#x0026;optional  (<i>default</i> nil)<br 
class="newline" /><i>[Function]</i><a 
 id="dx181-469005"></a><a 
 id="x181-469006r1010"></a><b> collect-nth</b>  <i>n</i> <i>items</i> &#x0026;optional  (<i>default</i> nil)
<!--l. 884--><p class="noindent" >Given a series <i>items</i>, these functions return the ﬁrst element, the last element,
and the <i>n</i>th element, respectively. If <i>items</i> has no elements (or no <i>n</i>th element),
<i>default</i> is returned. If <i>default</i> is not speciﬁed, then <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> is used for <i>default</i>.
<div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-ﬁrst #Z() &#x2019;z) <span class="math"> ⇒</span> z
</td></tr></table>
<!--l. 890--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-last #Z(a b c)) <span class="math"> ⇒</span> c</td></tr></table>
<!--l. 891--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-nth 1 #Z(a b c)) <span class="math"> ⇒</span> b</td></tr></table>
<!--l. 893--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 896--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469007"></a><a 
 id="x181-469008r1011"></a><b> collect-length</b>  <i>items</i>
<!--l. 898--><p class="noindent" ><tt><a 
href="#x181-469008r1011">collect-length</a></tt> returns the number of elements in a series. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-length #Z(a b c)) <span class="math"> ⇒</span> 3
</td></tr></table>
<!--l. 902--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 906--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469009"></a><a 
 id="x181-469010r1012"></a><b> collect-sum</b>  <i>numbers</i> &#x0026;optional  (<i>type</i> &#x2019;number)
<!--l. 908--><p class="noindent" ><tt><a 
href="#x181-469010r1012">collect-sum</a></tt> returns the sum of the elements in a series of numbers. The <i>type</i> is a
type speciﬁer that indicates the type of sum to be created. If <i>type</i> is not speciﬁed,
then <tt>number</tt> is used for the <i>type</i>. If there are no elements in the input, a zero (of
the appropriate type) is returned. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-sum #Z(1.1 1.2 1.3)) <span class="math"> ⇒</span> 3.6
</td></tr></table>
<!--l. 916--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-sum #Z() &#x2019;complex) <span class="math"> ⇒</span> #C(0 0)</td></tr></table>
<!--l. 918--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 922--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469011"></a><a 
 id="x181-469012r1013"></a><b> collect-max</b>  <i>numbers</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-469013"></a><a 
 id="x181-469014r1014"></a><b> collect-min</b>  <i>numbers</i>
<!--l. 925--><p class="noindent" >Given a series of non-complex numbers, these functions compute the maximum
element and the minimum element, respectively. If there are no elements in the
input, <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> is returned. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-max #Z(2 1 4 3)) <span class="math"> ⇒</span> 4
</td></tr></table>
<!--l. 930--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-min #Z(1.2 1.1 1.4 1.3)) <span class="math"> ⇒</span> 1.1</td></tr></table>
<!--l. 931--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-min #Z()) <span class="math"> ⇒</span> nil</td></tr></table>
<!--l. 933--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 937--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469015"></a><a 
 id="x181-469016r1015"></a><b> collect-and</b>  <i>bools</i>
<!--l. 939--><p class="noindent" ><tt><a 
href="#x181-469016r1015">collect-and</a></tt> returns the <tt><a 
href="clmse33.html#x44-78004r49">and</a></tt> of the elements in a series. As with the macro <tt><a 
href="clmse33.html#x44-78004r49">and</a></tt>,
<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> is returned if any element of bools is <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. Otherwise, the last element of <i>bools</i>
is returned. The value <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> is returned if there are no elements in bools.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-and #Z(a b c)) <span class="math"> ⇒</span> c
</td></tr></table>
<!--l. 946--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-and #Z(a nil c)) <span class="math"> ⇒</span> nil</td></tr></table>
<!--l. 948--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 951--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469017"></a><a 
 id="x181-469018r1016"></a><b> collect-or</b>  <i>bools</i>
<!--l. 953--><p class="noindent" ><tt><a 
href="#x181-469018r1016">collect-or</a></tt> returns the <tt><a 
href="clmse33.html#x44-79002r50">or</a></tt> of the elements in a series. As with the macro <tt><a 
href="clmse33.html#x44-79002r50">or</a></tt>, <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>
is returned if every element of bools is <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. Otherwise, the ﬁrst non-null element of
<i>bools</i> is returned. The value <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> is returned if there are no elements in <i>bools</i>.
<div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-or #Z(nil b c)) <span class="math"> ⇒</span> b
</td></tr></table>
<!--l. 960--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-or #Z()) <span class="math"> ⇒</span> nil</td></tr></table>
<!--l. 962--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 965--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469019"></a><a 
 id="x181-469020r1017"></a><b> collect</b>  <i>items</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-469021"></a><a 
 id="x181-469022r1018"></a><b> collect</b>  <i>type</i> <i>items</i>
<!--l. 968--><p class="noindent" ><tt><a 
href="#x181-469022r1018">collect</a></tt> returns a sequence containing the elements of the series items. The <i>type</i>
is a type speciﬁer indicating the type of sequence to be created. It must be either
a proper subtype of <tt>sequence</tt> or the symbol <tt>bag</tt>. If <i>type</i> is omitted, it defaults to
<tt><a 
href="clmse80.html#x100-201034r441">list</a></tt>. (This function exhibits an argument pattern that is unusual for
Common Lisp: an “optional” argument preceding a required argument. This
pattern cannot be expressed in the usual manner with <tt>&#x0026;optional</tt>. It is
indicated above by two deﬁnition lines, showing the two possible argument
patterns.)
<!--l. 979--><p class="indent" >   If the <i>type</i> is <tt>bag</tt>, a list is created with the elements in whatever order can be
most eﬃciently obtained. Otherwise, the order of the elements in the
sequence is the same as the order in <i>items</i>. If <i>type</i> speciﬁes a length (that is,
of a vector) this length must be greater than or equal to the length of
<i>items</i>.
<!--l. 985--><p class="indent" >   The <i>n</i>th element of <i>items</i> is placed in the <i>n</i>th slot of the sequence produced.
Any unneeded slots are left in their initial state. Collecting is signiﬁcantly
more eﬃcient if it can be determined at compile time whether <i>type</i> is a
subtype of <tt><a 
href="clmse80.html#x100-201034r441">list</a></tt> or <tt><a 
href="clmse87.html#x109-213010r505">vector</a></tt> and for vectors what the length of the vector is.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect #Z(a b c)) <span class="math"> ⇒</span> (a b c)
</td></tr></table>
<!--l. 991--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect &#x2019;bag #Z(a b c)) <span class="math"> ⇒</span> (c a b) or (b a c) or <span class="math">…</span></td></tr></table>
<!--l. 992--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect &#x2019;(vector integer 3) #Z(1 2 3)) <span class="math"> ⇒</span> #(1 2 3)</td></tr></table>
<!--l. 994--><p class="indent" >
</div>
                                                                          

                                                                          
</div>
</div>
<div class=defun>
<!--l. 997--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469023"></a><a 
 id="x181-469024r1019"></a><b> collect-append</b>  <i>sequences</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-469025"></a><a 
 id="x181-469026r1020"></a><b> collect-append</b>  <i>type</i> <i>sequences</i>
<!--l. 1000--><p class="noindent" >Given a series of sequences, <tt><a 
href="#x181-469026r1020">collect-append</a></tt> returns a new sequence by
concatenating these sequences together in order. The <i>type</i> is a type speciﬁer
indicating the type of sequence created and must be a proper subtype of
<tt>sequence</tt>. If <i>type</i> is omitted, it defaults to <tt><a 
href="clmse80.html#x100-201034r441">list</a></tt>. (This function exhibits an
argument pattern that is unusual for Common Lisp: an “optional” argument
preceding a required argument. This pattern cannot be expressed in the usual
manner with <tt>&#x0026;optional</tt>. It is indicated above by two deﬁnition lines, showing the
two possible argument patterns.)
<!--l. 1011--><p class="indent" >   It must be possible for every element of every sequence in the input series to
be an element of a sequence of type <i>type</i>. The result does not share any structure
with the sequences in the input. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-append #Z((a b) nil (c d))) <span class="math"> ⇒</span> (a b c d)
</td></tr></table>
<!--l. 1015--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-append &#x2019;string #Z(&#x0022;a &#x0022; &#x0022;big &#x0022; &#x0022;cat&#x0022;)) <span class="math"> ⇒</span> &#x0022;a big cat&#x0022;</td></tr></table>
<!--l. 1017--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 1020--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469027"></a><a 
 id="x181-469028r1021"></a><b> collect-nconc</b>  <i>lists</i>
<!--l. 1022--><p class="noindent" ><tt><a 
href="#x181-469028r1021">collect-nconc</a></tt> <tt><a 
href="clmse128.html#x158-320006r782">nconc</a></tt>s the elements of the series lists together in order and
returns the result. This is the same as <tt><a 
href="#x181-469026r1020">collect-append</a></tt> except that the input
must be a series of lists, the output is always a list, the concatenation is done
rapidly by destructively modifying the input elements, and therefore the output
shares all of its structure with the input elements.
</div>
<div class=defun>
<!--l. 1031--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469029"></a><a 
 id="x181-469030r1022"></a><b> collect-alist</b>  <i>keys</i> <i>values</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-469031"></a><a 
 id="x181-469032r1023"></a><b> collect-plist</b>  <i>keys</i> <i>values</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx181-469033"></a><a 
 id="x181-469034r1024"></a><b> collect-hash</b>  <i>keys</i> <i>values</i> &#x0026;key  <i>:test</i> <i>:size</i> <i>:rehash-size</i>
                                                                          

                                                                          
<i>:rehash-threshold</i>
<!--l. 1035--><p class="noindent" >Given a series of keys and a series of corresponding values, these functions return
an association list, a property list, and a hash table, respectively. Following the
order of the input, each <i>keys</i><span class="math"><sub>j</sub></span>-values<span class="math"><sub>j</sub></span> pair is entered into the output so that it
overrides all earlier associations. If one of the input series is longer than the other,
the extra elements are ignored. The keyword arguments of <tt><a 
href="#x181-469034r1024">collect-hash</a></tt> specify
attributes of the hash table produced and have the same meanings as the
arguments to <tt><a 
href="clmse85.html#x106-210002r489">make-hash-table</a></tt>. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-alist #Z(a b c) #Z(1 2)) <span class="math"> ⇒</span> ((b . 2) (a . 1))
</td></tr></table>
<!--l. 1045--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-plist #Z(a b c) #Z(1 2)) <span class="math"> ⇒</span> (b 2 a 1)</td></tr></table>
<!--l. 1046--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-hash #Z() #Z(1 2) :test #&#x2019;eq) <span class="math"> ⇒</span><span class="math">⟨</span>an empty hash table<span class="math">⟩</span></td></tr></table>
<!--l. 1048--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 1051--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469035"></a><a 
 id="x181-469036r1025"></a><b> collect-ﬁle</b>  <i>ﬁle-name</i> <i>items</i> &#x0026;optional  (<i>printer</i> #&#x2019;print)
<!--l. 1053--><p class="noindent" >This creates a ﬁle named <i>ﬁle-name</i> and writes the elements of the series <i>items</i>
into it using the function printer. <i>Printer</i> must accept two inputs: an object and
an output stream. (For instance, <i>printer</i> can be <tt><a 
href="clmse110.html#x137-258008r650">print</a></tt>, <tt>prin1</tt>, <tt><a 
href="clmse110.html#x137-258012r652">princ</a></tt>, <tt><a 
href="clmse110.html#x137-258010r651">pprint</a></tt>,
<tt><a 
href="clmse110.html#x137-258024r656">write-char</a></tt>, <tt><a 
href="clmse110.html#x137-258026r657">write-string</a></tt>, or <tt><a 
href="clmse110.html#x137-258028r658">write-line</a></tt>.) If omitted, <i>printer</i> defaults to
<tt><a 
href="clmse110.html#x137-258008r650">print</a></tt>. The value <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> is returned. The ﬁle is correctly closed, even if an abort
occurs.
</div>
<div class=defun>
<!--l. 1065--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-469037"></a><a 
 id="x181-469038r1026"></a><b> collect-fn</b>  <i>type</i> <i>init</i> <i>function</i> &#x0026;rest  <i>series-inputs</i>
<!--l. 1067--><p class="noindent" >The higher-order function <tt><a 
href="#x181-469038r1026">collect-fn</a></tt> supports the general concept of collecting.
It is identical to <tt><a 
href="#x181-467012r996">collecting-fn</a></tt> except that it returns only the last element of
each series computed. If there are no elements in these series, the values
returned by <i>init</i> are passed on directly as the output of <tt><a 
href="#x181-469038r1026">collect-fn</a></tt>.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-fn &#x2019;integer #&#x2019;(lambda () 0) #&#x2019;+ #Z(1 2 3)) <span class="math"> ⇒</span> 6
</td></tr></table>
                                                                          

                                                                          
<!--l. 1074--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-fn &#x2019;integer #&#x2019;(lambda () 0) #&#x2019;+ #Z()) <span class="math"> ⇒</span> 0</td></tr></table>
<!--l. 1075--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(collect-fn &#x2019;integer #&#x2019;(lambda () 1) #&#x2019;* #Z(1 2 3 4 5)) <span class="math"> ⇒</span> 120</td></tr></table>
<!--l. 1077--><p class="indent" >
</div>
</div>
</div>
<!--l. 1080--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.2.6   </span> <a 
href="clmli1.html#QQ2-181-512" id="x181-470000A.2.6">Alteration of Series</a></h4>
<!--l. 1082--><p class="noindent" >Series that come from scanning data structures such as lists and vectors are
closely linked to these structures. The function <tt><a 
href="#x181-470002r1027">alter</a></tt> can be used to modify the
underlying data structure with reference to the series derived from it. (Conversely,
it is possible to modify a series by destructively modifying the data structure it is
derived from. However, given the lazy evaluation nature of series, the eﬀects of
such modiﬁcations can be very hard to predict. As a result, this kind of
modiﬁcation is inadvisable.)
<div class=defun>
<!--l. 1091--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-470001"></a><a 
 id="x181-470002r1027"></a><b> alter</b>  <i>destinations</i> <i>items</i>
<!--l. 1093--><p class="noindent" ><tt><a 
href="#x181-470002r1027">alter</a></tt> changes the series <i>destinations</i> so that it contains the elements in the series
<i>items</i>. More importantly, in the manner of <tt><a 
href="clmse35.html#x47-89002r64">setf</a></tt>, the data structure that underlies
destinations is changed so that if the series <i>destinations</i> were to be regenerated,
the new values would be obtained. The alteration process stops as soon as
either input runs out of elements. The value <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> is always returned. In the
example below each negative element in a list is replaced with its square.
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let* ((data (list 1 -2 3 4 -5 6))
</td></tr></table>
<!--l. 1103--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (x (choose-if #&#x2019;minusp (scan data))))</td></tr></table>
<!--l. 1104--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (alter x (#M* x x))</td></tr></table>
<!--l. 1105--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  data)</td></tr></table>
<!--l. 1106--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <span class="math"> ⇒</span> (1 4 3 4 25 6)</td></tr></table>
<!--l. 1108--><p class="indent" >
</div>
                                                                          

                                                                          
</div>
<tt>
<!--l. 1110--><p class="indent" >   <a 
href="#x181-470002r1027">alter</a></tt> can be applied only to series that are <i>alterable</i>. <tt><a 
href="#x181-463006r976">scan</a></tt>, <tt><a 
href="#x181-463016r981">scan-alist</a></tt>,
<tt><a 
href="#x181-463010r978">scan-multiple</a></tt>, <tt><a 
href="#x181-463018r982">scan-plist</a></tt>, and <tt><a 
href="#x181-463014r980">scan-lists-of-lists-fringe</a></tt> produce alterable
series. However, the alterability of the output of <tt><a 
href="#x181-463014r980">scan-lists-of-lists-fringe</a></tt> is
incomplete. If <tt><a 
href="#x181-463014r980">scan-lists-of-lists-fringe</a></tt> is applied to an object that is a
leaf, altering the output series does not change the object.
<!--l. 1121--><p class="indent" >   In general, the output of a transducer is alterable as long as the elements of
the output come directly from the elements of an input that is alterable. In
particular, the outputs of <tt><a 
href="#x181-468002r997">choose</a></tt>, <tt><a 
href="#x181-468004r998">choose-if</a></tt>, <tt><a 
href="#x181-468008r1000">split</a></tt>, <tt><a 
href="#x181-468010r1001">split-if</a></tt>, <tt><a 
href="#x181-467002r991">cotruncate</a></tt>,
<tt><a 
href="#x181-467004r992">until</a></tt>, <tt><a 
href="#x181-467006r993">until-if</a></tt>, and <tt><a 
href="#x181-468014r1003">subseries</a></tt> are alterable as long as the corresponding
inputs are alterable.
</div>
<div class=defun>
<!--l. 1130--><p class="noindent" ><i>[Function]</i><a 
 id="dx181-470003"></a><a 
 id="x181-470004r1028"></a><b> to-alter</b>  <i>items</i> <i>alter-fn</i> &#x0026;rest  <i>args</i>
<!--l. 1132--><p class="noindent" >Given a series <i>items</i>, <tt><a 
href="#x181-470004r1028">to-alter</a></tt> returns an alterable series A containing the same
elements. The argument <i>alter-fn</i> is a function. The remaining arguments are all
series. Let these series be <i>S1</i>, <span class="math">…</span>, <i>Sn</i>. If there are <span class="math"><i>n</i></span> arguments after <i>alter-fn</i>,
<i>alter-fn</i> must accept <span class="math"><i>n</i> + 1</span> inputs. If <tt>(alter <i>A</i> <i>B</i>)</tt> is later encountered, the
expression <tt>(map-fn t <i>alter-fn</i> <i>B</i> <i>S1</i> ... <i>Sn</i>)</tt> is implicitly evaluated. For each
element in <i>B</i>, <i>alter-fn</i> should make appropriate changes in the data structure
underlying <i>A</i>.
<!--l. 1144--><p class="indent" >   As an example, consider the following deﬁnition of a series function that scans
the elements of a list. Alteration is performed by changing cons cells in the list
being scanned. <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun scan-list (list)
</td></tr></table>
<!--l. 1148--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (optimizable-series-function))</td></tr></table>
<!--l. 1149--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((sublists (scan-sublists list)))</td></tr></table>
<!--l. 1150--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (to-alter (#Mcar sublists)</td></tr></table>
<!--l. 1151--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              #&#x2019;(lambda (new parent) (setf (car parent) new))</td></tr></table>
<!--l. 1152--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              sublists)))</td></tr></table>
<!--l. 1154--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
</div>
                                                                          

                                                                          
   <!--l. 1157--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse148.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse146.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse146.html#tailclmse146.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse147.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmap1.html#clmse147.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 1157--><p class="indent" >   <a 
 id="tailclmse147.html"></a>  
</body></html> 
