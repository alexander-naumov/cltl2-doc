<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Programmer Interface Concepts</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 50--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse151.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html#tailclmch28.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse150.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html#clmse150.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">28.1   </span> <a 
 id="x183-26100028.1"></a>Programmer Interface Concepts</h3>
<!--l. 52--><p class="noindent" >The Common Lisp Object System (CLOS) is an object-oriented extension to
Common Lisp. It is based on generic functions, multiple inheritance, declarative
method combination, and a meta-object protocol.
<!--l. 56--><p class="indent" >   The ﬁrst two parts of this speciﬁcation describe the standard Programmer
Interface for the Common Lisp Object System. The ﬁrst part, Programmer
Interface Concepts, contains a description of the concepts of the Common Lisp
Object System, and the second part, Functions in the Programmer Interface,
contains a description of the functions and macros in the Common Lisp Object
System Programmer Interface. The third part, The Common Lisp Object
System Meta-Object Protocol, explains how the Common Lisp Object
System can be customized. [The third part has not yet been approved by X3J13
for inclusion in the forthcoming Common Lisp standard and is not included in
this book.—GLS]
<!--l. 67--><p class="indent" >   The fundamental objects of the Common Lisp Object System are classes,
instances, generic functions, and methods.
<!--l. 70--><p class="indent" >   A class object determines the structure and behavior of a set of other objects,
which are called its instances. Every Common Lisp object is an instance of a class.
The class of an object determines the set of operations that can be performed on
the object.
<!--l. 76--><p class="indent" >   A generic function is a function whose behavior depends on the classes or
identities of the arguments supplied to it. A generic function object contains a set
of methods, a lambda-list, a method combination type, and other information.
The methods deﬁne the class-speciﬁc behavior and operations of the generic
function; a method is said to specialize a generic function. When invoked, a
generic function executes a subset of its methods based on the classes of its
arguments.
<!--l. 85--><p class="indent" >   A generic function can be used in the same ways as an ordinary function in
Common Lisp; in particular, a generic function can be used as an argument to
<i>funcall</i> and <i>apply</i> and can be given a global or a local name.
<!--l. 90--><p class="indent" >   A method is an object that contains a method function, a sequence of
parameter specializers that specify when the given method is applicable, and a
sequence of qualiﬁers that is used by the method combination facility to
distinguish among methods. Each required formal parameter of each method has
                                                                          

                                                                          
an associated parameter specializer, and the method will be invoked only on
arguments that satisfy its parameter specializers.
<!--l. 98--><p class="indent" >   The method combination facility controls the selection of methods, the
order in which they are run, and the values that are returned by the
generic function. The Common Lisp Object System oﬀers a default method
combination type and provides a facility for declaring new types of method
combination.
<!--l. 104--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.1   </span> <a 
 id="x183-26200028.1.1"></a>Error Terminology</h4>
<!--l. 107--><p class="noindent" >The terminology used in this chapter to describe erroneous situations diﬀers from
the terminology used in the ﬁrst edition. The new terminology involves situations;
a situation is the evaluation of an expression in some speciﬁc context. For
example, a situation might be the invocation of a function on arguments that fail
to satisfy some speciﬁed constraints.
<!--l. 115--><p class="indent" >   In the speciﬁcation of the Common Lisp Object System, the behavior of
programs in all situations is described, and the options available to the
implementor are deﬁned. No implementation is allowed to extend the syntax
or semantics of the Object System except as explicitly deﬁned in the
Object System speciﬁcation. In particular, no implementation is allowed to
extend the syntax of the Object System in such a way that ambiguity
between the speciﬁed syntax of the Object System and those extensions is
possible.
<div class=flushdesc>
<!--l. 124--><p class="indent" >
  <div><br /><b>
“When situation S occurs, an error is signaled.”                            </b>
<!--l. 126--><p class="indent" >  This terminology has the following meaning:
     <ul class="itemize1">
     <li class="itemize">If this situation occurs, an error will be signaled in the interpreter and
     in code compiled under all compiler safety optimization levels.
     </li>
     <li class="itemize">Valid programs may rely on the fact that an error will be signaled in the
     interpreter and in code compiled under all compiler safety optimization
                                                                          

                                                                          
     levels.
     </li>
     <li class="itemize">Every  implementation  is  required  to  detect  such  an  error  in  the
     interpreter and in code compiled under all compiler safety optimization
     levels.
     </li></ul>
  <br /><b>
“When situation S occurs, an error should be signaled.”                    </b>
<!--l. 146--><p class="indent" >  This terminology has the following meaning:
     <ul class="itemize1">
     <li class="itemize">If  this  situation  occurs,  an  error  will  be  signaled  at  least  in  the
     interpreter  and  in  code  compiled  under  the  safest  compiler  safety
     optimization level.
     </li>
     <li class="itemize">Valid programs may not rely on the fact that an error will be signaled.
     </li>
     <li class="itemize">Every implementation is required to detect such an error at least in
     the interpreter and in code compiled under the safest compiler safety
     optimization level.
     </li>
     <li class="itemize">When an error is not signaled, the results are undeﬁned (see below).
     </li></ul>
  <br /><b>
“When situation S occurs, the results are undeﬁned.”                       </b>
<!--l. 168--><p class="indent" >  This terminology has the following meaning:
     <ul class="itemize1">
     <li class="itemize">If this situation occurs, the results are unpredictable. The results may
     range from harmless to fatal.
     </li>
     <li class="itemize">Implementations are allowed to detect this situation and signal an error,
     but no implementation is required to detect the situation.
                                                                          

                                                                          
     </li>
     <li class="itemize">No valid program may depend on the eﬀects of this situation, and all
     valid  programs  are  required  to  treat  the  eﬀects  of  this  situation  as
     unpredictable.
     </li></ul>
  <br /><b>
“When situation S occurs, the results are unspeciﬁed.”                     </b>
<!--l. 187--><p class="indent" >  This terminology has the following meaning:
     <ul class="itemize1">
     <li class="itemize">The eﬀects of this situation are not speciﬁed in the Object System, but
     the eﬀects are harmless.
     </li>
     <li class="itemize">Implementations are allowed to specify the eﬀects of this situation.
     </li>
     <li class="itemize">No portable program can depend on the eﬀects of this situation, and all
     portable programs are required to treat the situation as unpredictable
     but harmless.
     </li></ul>
  <br /><b>
“The Common Lisp Object System may be extended to cover situation S.” </b>
<!--l. 206--><p class="indent" >  The meaning of this terminology is that an implementation is free to treat
situation S in one of three ways:
     <ul class="itemize1">
     <li class="itemize">When situation S occurs, an error is signaled at least in the interpreter
     and in code compiled under the safest compiler safety optimization level.
     </li>
     <li class="itemize">When situation S occurs, the results are undeﬁned.
     </li>
     <li class="itemize">When situation S occurs, the results are deﬁned and speciﬁed.
     </li></ul>
<!--l. 222--><p class="noindent" >In addition, this terminology has the following meaning:
                                                                          

                                                                          
     <ul class="itemize1">
     <li class="itemize">No portable program can depend on the eﬀects of this situation, and all
     portable programs are required to treat the situation as undeﬁned.
     </li></ul>
  <br /><b>
“Implementations are free to extend the syntax S.”                         </b>
<!--l. 235--><p class="indent" >  This terminology has the following meaning:
     <ul class="itemize1">
     <li class="itemize">Implementations  are  allowed  to  deﬁne  unambiguous  extensions  to
     syntax S.
     </li>
     <li class="itemize">No portable program can depend on this extension, and all portable
     programs are required to treat the syntax as meaningless.
     </li></ul>
</div>
</div>
<!--l. 249--><p class="indent" >   The Common Lisp Object System speciﬁcation may disallow certain
extensions while allowing others.
<!--l. 252--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.2   </span> <a 
 id="x183-26300028.1.2"></a>Classes</h4>
<!--l. 255--><p class="noindent" >A class is an object that determines the structure and behavior of a set of other
objects, which are called its instances.
<!--l. 258--><p class="indent" >   A class can inherit structure and behavior from other classes. A class whose
deﬁnition refers to other classes for the purpose of inheriting from them is said to
be a subclass of each of those classes. The classes that are designated
for purposes of inheritance are said to be superclasses of the inheriting
class.
<!--l. 265--><p class="indent" >   A class can have a name. The function <i>class-name</i> takes a class object and
returns its name. The name of an anonymous class is <i>nil</i>. A symbol can name a
class. The function <i>ﬁnd-class</i> takes a symbol and returns the class that the
symbol names. A class has a proper name if the name is a symbol and if the name
of the class names that class. That is, a class C has the proper name S if S  =
                                                                          

                                                                          
<i>(class-name C)</i> and C  = <i>(ﬁnd-class S)</i>. Notice that it is possible for <i>(ﬁnd-class
S<sub>1</sub>)</i>  = <i>(ﬁnd-class S<sub>2</sub>)</i> and S<sub>1</sub>≠S<sub>2</sub>. If C  = <i>(ﬁnd-class S)</i>, we say that C is the
class named S.
<!--l. 278--><p class="indent" >   A class C<sub>1</sub> is a direct superclass of a class C<sub>2</sub> if C<sub>2</sub> explicitly designates C<sub>1</sub> as
a superclass in its deﬁnition. In this case, C<sub>2</sub> is a direct subclass of C<sub>1</sub>. A class C<sub>n</sub>
is a superclass of a class C<sub>1</sub> if there exists a series of classes C<sub>2</sub>,…,C<sub>n−1</sub> such that
C<sub>i+1</sub> is a direct superclass of C<sub>i</sub> for 1 ≤ i &#x003C; n. In this case, C<sub>1</sub> is a subclass of C<sub>n</sub>.
A class is considered neither a superclass nor a subclass of itself. That is, if
C<sub>1</sub> is a superclass of C<sub>2</sub>, then C<sub>1</sub>≠C<sub>2</sub>. The set of classes consisting of
some given class C along with all of its superclasses is called “C and its
superclasses.”
<!--l. 293--><p class="indent" >   Each class has a class precedence list, which is a total ordering on the set of
the given class and its superclasses. The total ordering is expressed as a list
ordered from most speciﬁc to least speciﬁc. The class precedence list is used in
several ways. In general, more speciﬁc classes can shadow, or override, features
that would otherwise be inherited from less speciﬁc classes. The method selection
and combination process uses the class precedence list to order methods from
most speciﬁc to least speciﬁc.
<!--l. 302--><p class="indent" >   When a class is deﬁned, the order in which its direct superclasses are
mentioned in the deﬁning form is important. Each class has a local precedence
order, which is a list consisting of the class followed by its direct superclasses in
the order mentioned in the deﬁning form.
<!--l. 308--><p class="indent" >   A class precedence list is always consistent with the local precedence order of
each class in the list. The classes in each local precedence order appear within the
class precedence list in the same order. If the local precedence orders are
inconsistent with each other, no class precedence list can be constructed, and an
error is signaled. The class precedence list and its computation is discussed in
section <a 
href="#x183-27400028.1.5">28.1.5<!--tex4ht:ref: Determining-the-Class-Precedence-List-SECTION --></a>.
<!--l. 316--><p class="indent" >   Classes are organized into a directed acyclic graph. There are two distinguished
classes, named <i>t</i> and <i>standard-object</i>. The class named <i>t</i> has no superclasses. It is
a superclass of every class except itself. The class named <i>standard-object</i> is an
instance of the class <i>standard-class</i> and is a superclass of every class that is an
instance of <i>standard-class</i> except itself.
<!--l. 323--><p class="indent" >   There is a mapping from the Common Lisp Object System class space into the
Common Lisp type space. Many of the standard Common Lisp types have a
corresponding class that has the same name as the type. Some Common Lisp
types do not have a corresponding class. The integration of the type and class
systems is discussed in section <a 
href="#x183-27300028.1.4">28.1.4<!--tex4ht:ref: Integrating-Types-and-Classes-SECTION --></a>.
                                                                          

                                                                          
<!--l. 330--><p class="indent" >   Classes are represented by objects that are themselves instances of classes. The
class of the class of an object is termed the metaclass of that object. When no
misinterpretation is possible, the term metaclass will be used to refer to a class
that has instances that are themselves classes. The metaclass determines the form
of inheritance used by the classes that are its instances and the representation of
the instances of those classes. The Common Lisp Object System provides a
default metaclass, <i>standard-class</i>, that is appropriate for most programs. The
meta-object protocol provides mechanisms for deﬁning and using new
metaclasses.
<!--l. 341--><p class="indent" >   Except where otherwise speciﬁed, all classes mentioned in this chapter are
instances of the class <i>standard-class</i>, all generic functions are instances of the
class <i>standard-generic-function</i>, and all methods are instances of the class
<i>standard-method</i>.
<!--l. 346--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-26400028.1.2"></a>Deﬁning Classes</h5>
<!--l. 348--><p class="noindent" >The macro <i>defclass</i> is used to deﬁne a new named class. The deﬁnition of a class
includes the following:
      <ul class="itemize1">
      <li class="itemize">The name of the new class. For newly deﬁned classes this is a proper
      name.
      </li>
      <li class="itemize">The list of the direct superclasses of the new class.
      </li>
      <li class="itemize">A set of slot speciﬁers. Each slot speciﬁer includes the name of the slot
      and zero or more slot options. A slot option pertains only to a single
      slot. If a class deﬁnition contains two slot speciﬁers with the same name,
      an error is signaled.
      </li>
      <li class="itemize">A set of class options. Each class option pertains to the class as a whole.</li></ul>
<!--l. 366--><p class="noindent" >The slot options and class options of the <i>defclass</i> form provide mechanisms for the
following:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">Supplying a default initial value form for a given slot.
      </li>
      <li class="itemize">Requesting  that  methods  for  generic  functions  be  automatically
      generated for reading or writing slots.
      </li>
      <li class="itemize">Controlling whether a given slot is shared by instances of the class or
      whether each instance of the class has its own slot.
      </li>
      <li class="itemize">Supplying a set of initialization arguments and initialization argument
      defaults to be used in instance creation.
      </li>
      <li class="itemize">Indicating that the metaclass is to be other than the default.
      </li>
      <li class="itemize">Indicating the expected type for the value stored in the slot.
      </li>
      <li class="itemize">Indicating the documentation string for the slot.
      </li></ul>
<!--l. 393--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-26500028.1.2"></a>Creating Instances of Classes</h5>
<!--l. 395--><p class="noindent" >The generic function <i>make-instance</i> creates and returns a new instance of a class.
The Object System provides several mechanisms for specifying how a new
instance is to be initialized. For example, it is possible to specify the initial values
for slots in newly created instances either by giving arguments to <i>make-instance</i>
or by providing default initial values.
<!--l. 402--><p class="indent" >   Further initialization activities can be performed by methods written for
generic functions that are part of the initialization protocol. The complete
initialization protocol is described in section <a 
href="#x183-29200028.1.9">28.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
                                                                          

                                                                          
<!--l. 407--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-26600028.1.2"></a>Slots</h5>
<!--l. 409--><p class="noindent" >An object that has <i>standard-class</i> as its metaclass has zero or more named slots.
The slots of an object are determined by the class of the object. Each slot can
hold one value. The name of a slot is a symbol that is syntactically valid for use as
a variable name.
<!--l. 415--><p class="indent" >   When a slot does not have a value, the slot is said to be unbound. When an
unbound slot is read, the generic function <i>slot-unbound</i> is invoked. The
system-supplied primary method for <i>slot-unbound</i> signals an error.
<!--l. 420--><p class="indent" >   The default initial value form for a slot is deﬁned by the  <i>:initform</i> slot option.
When the <i>:initform</i> form is used to supply a value, it is evaluated in the lexical
environment in which the <i>defclass</i> form was evaluated. The <i>:initform</i> along with
the lexical environment in which the <i>defclass</i> form was evaluated is called a
captured <i>:initform</i>. See section <a 
href="#x183-29200028.1.9">28.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<!--l. 428--><p class="indent" >   A local slot is deﬁned to be a slot that is visible to exactly one instance,
namely the one in which the slot is allocated. A shared slot is deﬁned to be
a slot that is visible to more than one instance of a given class and its
subclasses.
<!--l. 433--><p class="indent" >   A class is said to deﬁne a slot with a given name when the <i>defclass</i> form for
that class contains a slot speciﬁer with that name. Deﬁning a local slot does not
immediately create a slot; it causes a slot to be created each time an
instance of the class is created. Deﬁning a shared slot immediately creates a
slot.
<!--l. 439--><p class="indent" >   The <i>:allocation</i> slot option to <i>defclass</i> controls the kind of slot that is deﬁned.
If the value of the <i>:allocation</i> slot option is <i>:instance</i>, a local slot is created. If the
value of <i>:allocation</i> is <i>:class</i>, a shared slot is created.
<!--l. 444--><p class="indent" >   A slot is said to be accessible in an instance of a class if the slot is deﬁned by
the class of the instance or is inherited from a superclass of that class. At most
                                                                          

                                                                          
one slot of a given name can be accessible in an instance. A shared slot deﬁned by
a class is accessible in all instances of that class. A detailed explanation of the
inheritance of slots is given in section <a 
href="#x183-27000028.1.3">28.1.3<!--tex4ht:ref: Inheritance-of-Slots-and-Slot-Options-SECTION --></a>.
<!--l. 452--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-26700028.1.2"></a>Accessing Slots</h5>
<!--l. 454--><p class="noindent" >Slots can be accessed in two ways: by use of the primitive function <i>slot-value</i> and
by use of generic functions generated by the <i>defclass</i> form.
<!--l. 458--><p class="indent" >   The function <i>slot-value</i> can be used with any slot name speciﬁed in the
<i>defclass</i> form to access a speciﬁc slot accessible in an instance of the given
class.
<!--l. 462--><p class="indent" >   The macro <i>defclass</i> provides syntax for generating methods to read and write
slots. If a reader is requested, a method is automatically generated for reading the
value of the slot, but no method for storing a value into it is generated. If a writer
is requested, a method is automatically generated for storing a value into the slot,
but no method for reading its value is generated. If an accessor is requested, a
method for reading the value of the slot and a method for storing a value into the
slot are automatically generated. Reader and writer methods are implemented
using <i>slot-value</i>.
<!--l. 473--><p class="indent" >   When a reader or writer is speciﬁed for a slot, the name of the generic
function to which the generated method belongs is directly speciﬁed. If the
name speciﬁed for the writer option is the symbol name, the name of the
generic function for writing the slot is the symbol name, and the generic
function takes two arguments: the new value and the instance, in that order.
If the name speciﬁed for the accessor option is the symbol name, the
name of the generic function for reading the slot is the symbol name,
and the name of the generic function for writing the slot is the list <i>(setf
name)</i>.
<!--l. 484--><p class="indent" >   A generic function created or modiﬁed by supplying reader, writer,
or accessor slot options can be treated exactly as an ordinary generic
function.
<!--l. 488--><p class="indent" >   Note that <i>slot-value</i> can be used to read or write the value of a slot whether or
not reader or writer methods exist for that slot. When <i>slot-value</i> is used, no
reader or writer methods are invoked.
<!--l. 493--><p class="indent" >   The macro <i>with-slots</i> can be used to establish a lexical environment in
which speciﬁed slots are lexically available as if they were variables. The
                                                                          

                                                                          
macro <i>with-slots</i> invokes the function <i>slot-value</i> to access the speciﬁed
slots.
<!--l. 498--><p class="indent" >   The macro <i>with-accessors</i> can be used to establish a lexical environment in
which speciﬁed slots are lexically available through their accessors as if they were
variables. The macro <i>with-accessors</i> invokes the appropriate accessors to access
the speciﬁed slots. Any accessors speciﬁed by <i>with-accessors</i> must already have
been deﬁned before they are used.
                                                                          

                                                                          
<!--l. 507--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.3   </span> <a 
 id="x183-26800028.1.3"></a>Inheritance</h4>
<!--l. 510--><p class="noindent" >A class can inherit methods, slots, and some <i>defclass</i> options from its
superclasses. The following sections describe the inheritance of methods, the
inheritance of slots and slot options, and the inheritance of class options.
<!--l. 515--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-26900028.1.3"></a>Inheritance of Methods</h5>
<!--l. 518--><p class="noindent" >A subclass inherits methods in the sense that any method applicable to all
instances of a class is also applicable to all instances of any subclass of that
class.
<!--l. 522--><p class="indent" >   The inheritance of methods acts the same way regardless of whether the
method was created by using one of the method-deﬁning forms or by
using one of the <i>defclass</i> options that causes methods to be generated
automatically.
<!--l. 527--><p class="indent" >   The inheritance of methods is described in detail in section <a 
href="#x183-28300028.1.7">28.1.7<!--tex4ht:ref: Method-Selection-and-Combination-SECTION --></a>.
<!--l. 531--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-27000028.1.3"></a>Inheritance of Slots and Slot Options</h5>
<!--l. 534--><p class="noindent" >The set of names of all slots accessible in an instance of a class C is the union of
the sets of names of slots deﬁned by C and its superclasses. The structure of an
instance is the set of names of local slots in that instance.
<!--l. 539--><p class="indent" >   In the simplest case, only one class among C and its superclasses deﬁnes a slot
with a given slot name. If a slot is deﬁned by a superclass of C, the slot is said to
be inherited. The characteristics of the slot are determined by the slot
speciﬁer of the deﬁning class. Consider the deﬁning class for a slot S. If the
value of the <i>:allocation</i> slot option is <i>:instance</i>, then S is a local slot and
each instance of C has its own slot named S that stores its own value.
If the value of the <i>:allocation</i> slot option is <i>:class</i>, then S is a shared
slot, the class that deﬁned S stores the value, and all instances of C can
access that single slot. If the <i>:allocation</i> slot option is omitted, <i>:instance</i> is
used.
                                                                          

                                                                          
<!--l. 552--><p class="indent" >   In general, more than one class among C and its superclasses can
deﬁne a slot with a given name. In such cases, only one slot with the
given name is accessible in an instance of C, and the characteristics of
that slot are a combination of the several slot speciﬁers, computed as
follows:
      <ul class="itemize1">
      <li class="itemize">All the slot speciﬁers for a given slot name are ordered from most
      speciﬁc to least speciﬁc, according to the order in C&#x2019;s class precedence
      list of the classes that deﬁne them. All references to the speciﬁcity of
      slot speciﬁers immediately following refer to this ordering.
      </li>
      <li class="itemize">The allocation of a slot is controlled by the most speciﬁc slot speciﬁer.
      If the most speciﬁc slot speciﬁer does not contain an <i>:allocation</i> slot
      option, <i>:instance</i> is used. Less speciﬁc slot speciﬁers do not aﬀect the
      allocation.
      </li>
      <li class="itemize">The default initial value form for a slot is the value of the <i>:initform</i>
      slot option in the most speciﬁc slot speciﬁer that contains one. If no
      slot speciﬁer contains an <i>:initform</i> slot option, the slot has no default
      initial value form.
      </li>
      <li class="itemize">The contents of a slot will always be of type <i>(and T<sub>1</sub>  … T<sub>n</sub>)</i> where
      T<sub>1</sub>,…,T<sub>n</sub> are the values of the <i>:type</i> slot options contained in all of the
      slot speciﬁers. If no slot speciﬁer contains the <i>:type</i> slot option, the
      contents of the slot will always be of type <i>t</i>. The result of attempting
      to store in a slot a value that does not satisfy the type of the slot is
      undeﬁned.
      </li>
      <li class="itemize">The set of initialization arguments that initialize a given slot is the
      union  of  the  initialization  arguments  declared  in  the  <i>:initarg</i>  slot
      options in all the slot speciﬁers.
      </li>
      <li class="itemize">The documentation string for a slot is the value of the <i>:documentation</i>
                                                                          

                                                                          
      slot option in the most speciﬁc slot speciﬁer that contains one. If no
      slot speciﬁer contains a <i>:documentation</i> slot option, the slot has no
      documentation string.</li></ul>
<!--l. 596--><p class="indent" >   A consequence of the allocation rule is that a shared slot can be shadowed. For
example, if a class C<sub>1</sub> deﬁnes a slot named S whose value for the <i>:allocation</i> slot
option is <i>:class</i>, that slot is accessible in instances of C<sub>1</sub> and all of its subclasses.
However, if C<sub>2</sub> is a subclass of C<sub>1</sub> and also deﬁnes a slot named S, C<sub>1</sub>&#x2019;s slot is not
shared by instances of C<sub>2</sub> and its subclasses. When a class C<sub>1</sub> deﬁnes a shared
slot, any subclass C<sub>2</sub> of C<sub>1</sub> will share this single slot unless the <i>defclass</i> form for
C<sub>2</sub> speciﬁes a slot of the same name or there is a superclass of C<sub>2</sub> that
precedes C<sub>1</sub> in the class precedence list of C<sub>2</sub> that deﬁnes a slot of the same
name.
<!--l. 609--><p class="indent" >   A consequence of the type rule is that the value of a slot satisﬁes the type
constraint of each slot speciﬁer that contributes to that slot. Because the result of
attempting to store in a slot a value that does not satisfy the type constraint
for the slot is undeﬁned, the value in a slot might fail to satisfy its type
constraint.
<!--l. 615--><p class="indent" >   The <i>:reader</i>, <i>:writer</i>, and <i>:accessor</i> slot options create methods rather than
deﬁne the characteristics of a slot. Reader and writer methods are inherited in the
sense described in section <a 
href="#x183-26900028.1.3">28.1.3<!--tex4ht:ref: Inheritance-of-Methods-SECTION --></a>.
<!--l. 620--><p class="indent" >   Methods that access slots use only the name of the slot and the type of the
slot&#x2019;s value. Suppose a superclass provides a method that expects to access a
shared slot of a given name, and a subclass deﬁnes a local slot with the same
name. If the method provided by the superclass is used on an instance of the
subclass, the method accesses the local slot.
<!--l. 627--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-27100028.1.3"></a>Inheritance of Class Options</h5>
<!--l. 629--><p class="noindent" >The <i>:default-initargs</i> class option is inherited. The set of defaulted initialization
arguments for a class is the union of the sets of initialization arguments
speciﬁed in the <i>:default-initargs</i> class options of the class and its superclasses.
When more than one default initial value form is supplied for a given
initialization argument, the default initial value form that is used is the one
supplied by the class that is most speciﬁc according to the class precedence
list.
<!--l. 639--><p class="indent" >   If a given <i>:default-initargs</i> class option speciﬁes an initialization argument of
                                                                          

                                                                          
the same name more than once, an error is signaled.
<!--l. 643--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-27200028.1.3"></a>Examples</h5>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass C1 ()
</td></tr></table>
<!--l. 646--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ((S1 :initform 5.4 :type number)</td></tr></table>
<!--l. 647--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (S2 :allocation :class)))</td></tr></table>
<!--l. 648--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 649--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass C2 (C1)</td></tr></table>
<!--l. 650--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ((S1 :initform 5 :type integer)</td></tr></table>
<!--l. 651--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (S2 :allocation :instance)</td></tr></table>
<!--l. 652--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (S3 :accessor C2-S3)))</td></tr></table>
<!--l. 654--><p class="indent" >
</div>
</div>
<!--l. 656--><p class="noindent" >Instances of the class <i>C1</i> have a local slot named <i>S1</i>, whose default initial value is
5.4 and whose value should always be a number. The class <i>C1</i> also has a shared
slot named <i>S2</i>.
<!--l. 660--><p class="indent" >   There is a local slot named <i>S1</i> in instances of <i>C2</i>. The default initial value of
<i>S1</i> is 5. The value of <i>S1</i> will be of type <i>(and integer number)</i>. There are also local
slots named <i>S2</i> and <i>S3</i> in instances of <i>C2</i>. The class <i>C2</i> has a method for <i>C2-S3</i>
for reading the value of slot <i>S3</i>; there is also a method for <i>(setf C2-S3)</i> that writes
the value of <i>S3</i>.
<!--l. 669--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.4   </span> <a 
 id="x183-27300028.1.4"></a>Integrating Types and Classes</h4>
<!--l. 672--><p class="noindent" >The Common Lisp Object System maps the space of classes into the Common
Lisp type space. Every class that has a proper name has a corresponding type
with the same name.
                                                                          

                                                                          
<!--l. 676--><p class="indent" >   The proper name of every class is a valid type speciﬁer. In addition, every class
object is a valid type speciﬁer. Thus the expression <i>(typep object class)</i>
evaluates to true if the class of object is class itself or a subclass of class.
The evaluation of the expression <i>(subtypep class1 class2)</i> returns the
values <i>t</i> and <i>t</i> if class1 is a subclass of class2 or if they are the same
class; otherwise it returns the values <i>nil</i> and <i>t</i>. If I is an instance of some
class C named S and C is an instance of <i>standard-class</i>, the evaluation of
the expression <i>(type-of I)</i> will return S if S is the proper name of C;
if S is not the proper name of C, the expression <i>(type-of I)</i> will return
C.
<!--l. 690--><p class="indent" >   Because the names of classes and class objects are type speciﬁers, they may be
used in the special form <i>the</i> and in type declarations.
<!--l. 693--><p class="indent" >   Many but not all of the predeﬁned Common Lisp type speciﬁers have a
corresponding class with the same proper name as the type. These type speciﬁers
are listed in table <a 
href="#x183-2730011">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a>. For example, the type <i>array</i> has a corresponding class
named <i>array</i>. No type speciﬁer that is a list, such as <i>(vector double-ﬂoat
100)</i>, has a corresponding class. The form <i>deftype</i> does not create any
classes.
<!--l. 700--><p class="indent" >   Each class that corresponds to a predeﬁned Common Lisp type speciﬁer can
be implemented in one of three ways, at the discretion of each implementation. It
can be a standard class (of the kind deﬁned by <i>defclass</i>), a structure class (deﬁned
by <i>defstruct</i>), or a built-in class (implemented in a special, non-extensible
way).
<!--l. 707--><p class="indent" >   A built-in class is one whose instances have restricted capabilities or special
representations. Attempting to use <i>defclass</i> to deﬁne subclasses of a built-in
class signals an error. Calling <i>make-instance</i> to create an instance of a
built-in class signals an error. Calling <i>slot-value</i> on an instance of a built-in
class signals an error. Redeﬁning a built-in class or using <i>change-class</i>
to change the class of an instance to or from a built-in class signals an
error. However, built-in classes can be used as parameter specializers in
methods.
<!--l. 722--><p class="indent" >   It is possible to determine whether a class is a built-in class by checking the
metaclass. A standard class is an instance of <i>standard-class</i>, a built-in class
is an instance of <i>built-in-class</i>, and a structure class is an instance of
<i>structure-class</i>.
<!--l. 728--><p class="indent" >   Each structure type created by <i>defstruct</i> without using the <i>:type</i> option has a
corresponding class. This class is an instance of <i>structure-class</i>. The <i>:include</i>
option of <i>defstruct</i> creates a direct subclass of the class that corresponds to the
                                                                          

                                                                          
included structure.
<!--l. 739--><p class="indent" >   The purpose of specifying that many of the standard Common Lisp type
speciﬁers have a corresponding class is to enable users to write methods that
discriminate on these types. Method selection requires that a class precedence list
can be determined for each class.
<!--l. 745--><p class="indent" >   The hierarchical relationships among the Common Lisp type speciﬁers are
mirrored by relationships among the classes corresponding to those types. The
existing type hierarchy is used for determining the class precedence list for each
class that corresponds to a predeﬁned Common Lisp type. In some cases, the ﬁrst
edition did not specify a local precedence order for two supertypes of a given type
speciﬁer. For example, <i>null</i> is a subtype of both <i>symbol</i> and <i>list</i>, but the ﬁrst
edition did not specify whether <i>symbol</i> is more speciﬁc or less speciﬁc
than <i>list</i>. The CLOS speciﬁcation deﬁnes those relationships for all such
classes.
<!--l. 757--><p class="indent" >   Table <a 
href="#x183-2730011">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a> lists the set of classes required by the Object System that
correspond to predeﬁned Common Lisp type speciﬁers. The superclasses of each
such class are presented in order from most speciﬁc to most general, thereby
deﬁning the class precedence list for the class. The local precedence order for each
class that corresponds to a Common Lisp type speciﬁer can be derived from this
table.
<!--l. 765--><p class="indent" >   Individual implementations may be extended to deﬁne other type speciﬁers to
have a corresponding class. Individual implementations can be extended to
add other subclass relationships and to add other elements to the class
precedence lists in the above table as long as they do not violate the type
relationships and disjointness requirements speciﬁed in section <a 
href="clmse17.html#x24-420002.15">2.15<!--tex4ht:ref: DATA-TYPE-RELATIONSHIPS --></a>. A
standard class deﬁned with no direct superclasses is guaranteed to be
disjoint from all of the classes in the table, except for the class named
<i>t</i>.
<!--l. 775--><p class="indent" >   [At this point the original CLOS report speciﬁed that certain Common
Lisp types were to appear in table <a 
href="#x183-2730011">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a> if and only if X3J13 voted to
make them disjoint from <i>cons</i>, <i>symbol</i>, <i>array</i>, <i>number</i>, and <i>character</i>.
X3J13 voted to do so in June 1988 ⟨<b>?</b>⟩. I have added these types and
their class precedence lists to the table; the new types are indicated by
asterisks.—GLS]
   <div class="table">
                                                                          

                                                                          
<!--l. 785--><p class="indent" >   <a 
 id="x183-2730011"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 28.1: </span><span  
class="content">Class Precedence Lists for Predeﬁned Types</span></div><!--tex4ht:label?: x183-2730011 -->
<div class="flushleft" 
>
<!--l. 788--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Predeﬁned Common Lisp Type</td><td align="left" >Class Precedence List for Corresponding Class</td>
</tr><tr><td align="left" >array                                  </td><td align="left" >(array t)                                                  </td>
</tr><tr><td align="left" >bit-vector                            </td><td align="left" >(bit-vector vector array sequence t)               </td>
</tr><tr><td align="left" >character                             </td><td align="left" >(character t)                                            </td>
</tr><tr><td align="left" >complex                              </td><td align="left" >(complex number t)                                   </td>
</tr><tr><td align="left" >cons                                   </td><td align="left" >(cons list sequence t)                                 </td>
</tr><tr><td align="left" >ﬂoat                                   </td><td align="left" >(ﬂoat number t)                                        </td>
</tr><tr><td align="left" >function *                            </td><td align="left" >(function t)                                              </td>
</tr><tr><td align="left" >hash-table *                         </td><td align="left" >(hash-table t)                                           </td>
</tr><tr><td align="left" >integer                                </td><td align="left" >(integer rational number t)                          </td>
</tr><tr><td align="left" >list                                     </td><td align="left" >(list sequence t)                                        </td>
</tr><tr><td align="left" >null                                    </td><td align="left" >(null symbol list sequence t)                        </td>
</tr><tr><td align="left" >number                               </td><td align="left" >(number t)                                               </td>
</tr><tr><td align="left" >package *                            </td><td align="left" >(package t)                                              </td>
</tr><tr><td align="left" >pathname *                          </td><td align="left" >(pathname t)                                            </td>
</tr><tr><td align="left" >random-state *                     </td><td align="left" >(random-state t)                                       </td>
</tr><tr><td align="left" >ratio                                   </td><td align="left" >(ratio rational number t)                            </td>
</tr><tr><td align="left" >rational                               </td><td align="left" >(rational number t)                                   </td>
</tr><tr><td align="left" >readtable *                          </td><td align="left" >(readtable t)                                            </td>
</tr><tr><td align="left" >sequence                              </td><td align="left" >(sequence t)                                             </td>
</tr><tr><td align="left" >stream *                              </td><td align="left" >(stream t)                                                </td>
</tr><tr><td align="left" >string                                 </td><td align="left" >(string vector array sequence t)                    </td>
</tr><tr><td align="left" >symbol                                </td><td align="left" >(symbol t)                                               </td>
</tr><tr><td align="left" >t                                        </td><td align="left" >(t)                                                          </td>
</tr><tr><td align="left" >vector                                 </td><td align="left" >(vector array sequence t)                            </td></tr></table>
</div></div>
<!--l. 819--><p class="noindent" >[An asterisk indicates a type added to this table as a consequence of a portion of
the CLOS speciﬁcation that was conditional on X3J13 voting to make that type
disjoint from certain other built-in types ⟨<b>?</b>⟩.—GLS]
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
   <h4 class="subsectionHead"><span class="titlemark">28.1.5   </span> <a 
 id="x183-27400028.1.5"></a>Determining the Class Precedence List</h4>
<!--l. 829--><p class="noindent" >The <i>defclass</i> form for a class provides a total ordering on that class and its direct
superclasses. This ordering is called the local precedence order. It is an ordered list
of the class and its direct superclasses. The class precedence list for a class C is a
total ordering on C and its superclasses that is consistent with the local
precedence orders for C and its superclasses.
<!--l. 836--><p class="indent" >   A class precedes its direct superclasses, and a direct superclass precedes all
other direct superclasses speciﬁed to its right in the superclasses list of the
<i>defclass</i> form. For every class C, deﬁne
   <center class="math-display" >
<img 
src="clm43x.png" alt="RC  =  {(C,C1 ),(C1, C2),...,(Cn −1,Cn )} " class="math-display" ></center>
where C<sub>1</sub>,…,C<sub>n</sub> are the direct superclasses of C in the order in which they are
mentioned in the <i>defclass</i> form. These ordered pairs generate the total ordering on
the class C and its direct superclasses.
<!--l. 847--><p class="indent" >   Let S<sub>C</sub> be the set of C and its superclasses. Let R be
   <center class="math-display" >
<img 
src="clm44x.png" alt="       ⋃
R =        Rc
     c ∈ SC
" class="math-display" ></center>
                                                                          

                                                                          
<!--l. 850--><p class="indent" >   The set R may or may not generate a partial ordering, depending on whether
the R<sub>c</sub>, c ∈ S<sub>C</sub>, are consistent; it is assumed that they are consistent and that R
generates a partial ordering. When the R<sub>c</sub> are not consistent, it is said that R is
inconsistent.
<!--l. 857--><p class="indent" >   To compute the class precedence list for C, topologically sort the elements
of S<sub>C</sub> with respect to the partial ordering generated by R. When the
topological sort must select a class from a set of two or more classes, none of
which are preceded by other classes with respect to R, the class selected is
chosen deterministically, as described below. If R is inconsistent, an error is
signaled.
                                                                          

                                                                          
<!--l. 868--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-27500028.1.5"></a>Topological Sorting</h5>
<!--l. 870--><p class="noindent" >Topological sorting proceeds by ﬁnding a class C in S<sub>C</sub> such that no other class
precedes that element according to the elements in R. The class C is placed ﬁrst
in the result. Remove C from S<sub>C</sub>, and remove all pairs of the form (C,D),
D ∈ S<sub>C</sub>, from R. Repeat the process, adding classes with no predecessors to
the end of the result. Stop when no element can be found that has no
predecessor.
<!--l. 879--><p class="indent" >   If S<sub>C</sub> is not empty and the process has stopped, the set R is inconsistent. If
every class in the ﬁnite set of classes is preceded by another, then R contains a
loop. That is, there is a chain of classes C<sub>1</sub>,…,C<sub>n</sub> such that C<sub>i</sub> precedes C<sub>i+1</sub>,
1 ≤ i &#x003C; n, and C<sub>n</sub> precedes C<sub>1</sub>.
<!--l. 887--><p class="indent" >   Sometimes there are several classes from S<sub>C</sub> with no predecessors. In this case
select the one that has a direct subclass rightmost in the class precedence list
computed so far. If there is no such candidate class, R does not generate a partial
ordering—the R<sub>c</sub>, c ∈ S<sub>C</sub>, are inconsistent.
<!--l. 897--><p class="indent" >   In more precise terms, let {N<sub>1</sub>,…,N<sub>m</sub>}, m ≥ 2, be the classes from S<sub>C</sub> with no
predecessors. Let (C<sub>1</sub>…C<sub>n</sub>), n ≥ 1, be the class precedence list constructed so far.
C<sub>1</sub> is the most speciﬁc class, and C<sub>n</sub> is the least speciﬁc. Let 1 ≤ j ≤ n be the
largest number such that there exists an i where 1 ≤ i ≤ m and N<sub>i</sub> is a direct
superclass of C<sub>j</sub>; N<sub>i</sub> is placed next.
<!--l. 908--><p class="indent" >   The eﬀect of this rule for selecting from a set of classes with no predecessors is
that classes in a simple superclass chain are adjacent in the class precedence
list and that classes in each relatively separated subgraph are adjacent
in the class precedence list. For example, let T<sub>1</sub> and T<sub>2</sub> be subgraphs
whose only element in common is the class J. Suppose that no superclass
of J appears in either T<sub>1</sub> or T<sub>2</sub>. Let C<sub>1</sub> be the bottom of T<sub>1</sub>; and let
C<sub>2</sub> be the bottom of T<sub>2</sub>. Suppose C is a class whose direct superclasses
are C<sub>1</sub> and C<sub>2</sub> in that order; then the class precedence list for C will
start with C and will be followed by all classes in T<sub>1</sub> except J. All the
classes of T<sub>2</sub> will be next. The class J and its superclasses will appear
last.
<!--l. 923--><p class="noindent" >
                                                                          

                                                                          
   <h5 class="subsubsectionHead"><a 
 id="x183-27600028.1.5"></a>Examples</h5>
<!--l. 925--><p class="noindent" >This example determines a class precedence list for the class <i>pie</i>. The following
classes are deﬁned:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass pie (apple cinnamon) ())
</td></tr></table>
<!--l. 929--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass apple (fruit) ())</td></tr></table>
<!--l. 930--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass cinnamon (spice) ())</td></tr></table>
<!--l. 931--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass fruit (food) ())</td></tr></table>
<!--l. 932--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass spice (food) ())</td></tr></table>
<!--l. 933--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass food () ())</td></tr></table>
<!--l. 935--><p class="indent" >
</div>
</div>
<div class="flushleft" 
>
<!--l. 937--><p class="noindent" >
<!--l. 944--><p class="indent" >                                                                             The set  S = {<i>pie </i> , <i> apple </i> , <i> cinnamon </i> , <i> fruit </i> , <i> spice </i> , <i> food </i> , <i> standard<i>-</i> object </i> , <i> t </i> }.
The set R =
{(<i>pie</i>,<i>apple</i>), (<i>apple</i>,<i>cinnamon</i>), (<i>cinnamon</i>,<i>standard<i>-</i>object</i>), (<i>apple</i>,<i>fruit</i>), (<i>fruit</i>,<i>standard<i>-</i>object</i>), (<i>cinnamon</i>,<i>spice</i>), (<i>spice</i>,<i>standard<i>-</i>object</i>), (<i>fruit</i>,<i>food</i>), (<i>food</i>,<i>standard<i>-</i>object</i>), (<i>spice</i>,<i>food</i>), (<i>standard<i>-</i>object</i>,<i>t</i>)}.
<!--l. 976--><p class="indent" >  [The original CLOS speciﬁcation <span class="cite">[<a 
href="clmli5.html#XSIGPLAN-CLOS">5</a>, <a 
href="clmli5.html#XLASC-CLOS-PART-1">6</a>]</span> contained a minor error in this
example: the pairs (<i>cinnamon</i>,<i>standard<i>-</i>object</i>), (<i>fruit</i>,<i>standard<i>-</i>object</i>), and
(<i>spice</i>,<i>standard<i>-</i>object</i>) were inadvertently omitted from R in the preceding
paragraph. It is important to understand that <i>defclass</i> implicitly appends
the class <i>standard-object</i> to the list of superclasses when the metaclass is
<i>standard-class</i> (the normal situation), in order to insure that
<i>standard-object</i> will be a superclass of every instance of <i>standard-class</i>
except <i>standard-object</i> itself (see section <a 
href="#x183-26300028.1.2">28.1.2<!--tex4ht:ref: Classes-SECTION --></a>). R<sub>c</sub> is then generated from
this augmented list of superclasses; this is where the extra pairs come from.
I have corrected the example by adding these pairs as appropriate
throughout the example. The ﬁnal result, the class precedence list for <i>pie</i>,
is unchanged.—GLS]
                                                                          

                                                                          
<!--l. 997--><p class="indent" >  The class <i>pie</i> is not preceded by anything, so it comes ﬁrst; the result so
far is <i>(pie)</i>. Remove <i>pie</i> from S and pairs mentioning <i>pie</i> from R to get
S = {<i>apple</i>,<i>cinnamon</i>,<i>fruit</i>,<i>spice</i>,<i>food</i>,<i>standard<i>-</i>object</i>,<i>t</i>} and R =
{(<i>apple</i>,<i>cinnamon</i>), (<i>cinnamon</i>,<i>standard<i>-</i>object</i>), (<i>apple</i>,<i>fruit</i>), (<i>fruit</i>,<i>standard<i>-</i>object</i>), (<i>cinnamon</i>,<i>spice</i>), (<i>spice</i>,<i>standard<i>-</i>object</i>), (<i>fruit</i>,<i>food</i>), (<i>food</i>,<i>standard<i>-</i>object</i>), (<i>spice</i>,<i>food</i>), (<i>standard<i>-</i>object</i>,<i>t</i>)}.
<!--l. 1028--><p class="indent" >  The class <i>apple</i> is not preceded by anything, so it is next; the result is
<i>(pie apple)</i>. Removing <i>apple</i> and the relevant pairs results in
S = {<i>cinnamon</i>,<i>fruit</i>,<i>spice</i>,<i>food</i>,<i>standard<i>-</i>object</i>,<i>t</i>} and R =
{(<i>cinnamon</i>,<i>standard<i>-</i>object</i>), (<i>fruit</i>,<i>standard<i>-</i>object</i>), (<i>cinnamon</i>,<i>spice</i>), (<i>spice</i>,<i>standard<i>-</i>object</i>), (<i>fruit</i>,<i>food</i>), (<i>food</i>,<i>standard<i>-</i>object</i>), (<i>spice</i>,<i>food</i>), (<i>standard<i>-</i>object</i>,<i>t</i>)}.
<!--l. 1052--><p class="indent" >  The classes <i>cinnamon</i> and <i>fruit</i> are not preceded by anything, so the one
with a direct subclass rightmost in the class precedence list computed so far
goes next. The class <i>apple</i> is a direct subclass of <i>fruit</i>, and the class <i>pie</i> is a
direct subclass of <i>cinnamon</i>. Because <i>apple</i> appears to the right of <i>pie</i> in
the precedence list, <i>fruit</i> goes next, and the result so far is <i>(pie apple fruit)</i>.
S = {<i>cinnamon</i>,<i>spice</i>,<i>food</i>,<i>standard<i>-</i>object</i>,<i>t</i>}; R =
{(<i>cinnamon</i>,<i>standard<i>-</i>object</i>), (<i>cinnamon</i>,<i>spice</i>), (<i>spice</i>,<i>standard<i>-</i>object</i>), (<i>food</i>,<i>standard<i>-</i>object</i>), (<i>spice</i>,<i>food</i>), (<i>standard<i>-</i>object</i>,<i>t</i>)}.
<!--l. 1075--><p class="indent" >  The class <i>cinnamon</i> is next, giving the result so far as <i>(pie apple fruit
cinnamon)</i>. At this point S = {<i>spice</i>,<i>food</i>,<i>standard<i>-</i>object</i>,<i>t</i>}; R =
{(<i>spice</i>,<i>standard<i>-</i>object</i>), (<i>food</i>,<i>standard<i>-</i>object</i>), (<i>spice</i>,<i>food</i>), (<i>standard<i>-</i>object</i>,<i>t</i>)}.</div>
<!--l. 1089--><p class="indent" >   The classes <i>spice</i>, <i>food</i>, <i>standard-object</i>, and <i>t</i> are then added in that order,
and the ﬁnal class precedence list for <i>pie</i> is <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pie apple fruit cinnamon spice food standard-object t)
</td></tr></table>
<!--l. 1093--><p class="indent" >
</div>
</div>
<!--l. 1095--><p class="indent" >   It is possible to write a set of class deﬁnitions that cannot be ordered. For
example:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass new-class (fruit apple) ())
</td></tr></table>
<!--l. 1099--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass apple (fruit) ())</td></tr></table>
<!--l. 1101--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1103--><p class="indent" >   The class <i>fruit</i> must precede <i>apple</i> because the local ordering of superclasses
must be preserved. The class <i>apple</i> must precede <i>fruit</i> because a class always
precedes its own superclasses. When this situation occurs, an error is signaled
when the system tries to compute the class precedence list.
<!--l. 1109--><p class="indent" >   The following might appear to be a conﬂicting set of deﬁnitions:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass pie (apple cinnamon) ())
</td></tr></table>
<!--l. 1112--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass pastry (cinnamon apple) ())</td></tr></table>
<!--l. 1113--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass apple () ())</td></tr></table>
<!--l. 1114--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass cinnamon () ())</td></tr></table>
<!--l. 1116--><p class="indent" >
</div>
</div>
<!--l. 1118--><p class="indent" >   The class precedence list for <i>pie</i> is <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pie apple cinnamon standard-object t)
</td></tr></table>
<!--l. 1121--><p class="indent" >
</div>
</div>
<!--l. 1123--><p class="indent" >   The class precedence list for <i>pastry</i> is <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pastry cinnamon apple standard-object t)
</td></tr></table>
<!--l. 1126--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 1128--><p class="indent" >   It is not a problem for <i>apple</i> to precede <i>cinnamon</i> in the ordering
of the superclasses of <i>pie</i> but not in the ordering for <i>pastry</i>. However,
it is not possible to build a new class that has both <i>pie</i> and <i>pastry</i> as
superclasses.
<!--l. 1134--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.6   </span> <a 
 id="x183-27700028.1.6"></a>Generic Functions and Methods</h4>
<!--l. 1136--><p class="noindent" >A generic function is a function whose behavior depends on the classes or
identities of the arguments supplied to it. The methods deﬁne the class-speciﬁc
behavior and operations of the generic function. The following sections describe
generic functions and methods.
<!--l. 1142--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-27800028.1.6"></a>Introduction to Generic Functions</h5>
<!--l. 1144--><p class="noindent" >A generic function object contains a set of methods, a lambda-list, a method
combination type, and other information.
<!--l. 1147--><p class="indent" >   Like an ordinary Lisp function, a generic function takes arguments, performs a
series of operations, and perhaps returns useful values. An ordinary function
has a single body of code that is always executed when the function is
called. A generic function has a set of bodies of code of which a subset is
selected for execution. The selected bodies of code and the manner of their
combination are determined by the classes or identities of one or more of
the arguments to the generic function and by its method combination
type.
<!--l. 1156--><p class="indent" >   Ordinary functions and generic functions are called with identical function-call
syntax.
<!--l. 1159--><p class="indent" >   Generic functions are true functions that can be passed as arguments, returned
as values, used as the ﬁrst argument to <i>funcall</i> and <i>apply</i>, and otherwise used in
all the ways an ordinary function may be used.
<!--l. 1163--><p class="indent" >   A name can be given to an ordinary function in one of two ways: a global name
can be given to a function using the <i>defun</i> construct; a local name can be given
using the <i>ﬂet</i> or <i>labels</i> special forms. A generic function can be given a global
name using the <i>defmethod</i> or <i>defgeneric</i> construct. A generic function can be
given a local name using the <i>generic-ﬂet</i>, <i>generic-labels</i>, or <i>with-added-methods</i>
special forms. The name of a generic function, like the name of an ordinary
                                                                          

                                                                          
function, can be either a symbol or a two-element list whose ﬁrst element is <i>setf </i>
and whose second element is a symbol. This is true for both local and global
names.
<!--l. 1175--><p class="indent" >   The <i>generic-ﬂet</i> special form creates new local generic functions using the set
of methods speciﬁed by the method deﬁnitions in the <i>generic-ﬂet</i> form. The
scoping of generic function names within a <i>generic-ﬂet</i> form is the same as for
<i>ﬂet</i>.
<!--l. 1180--><p class="indent" >   The <i>generic-labels</i> special form creates a set of new mutually recursive local
generic functions using the set of methods speciﬁed by the method deﬁnitions in
the <i>generic-labels</i> form. The scoping of generic function names within a
<i>generic-labels</i> form is the same as for <i>labels</i>.
<!--l. 1186--><p class="indent" >   The <i>with-added-methods</i> special form creates new local generic functions by
adding the set of methods speciﬁed by the method deﬁnitions with a given name
in the <i>with-added-methods</i> form to copies of the methods of the lexically visible
generic function of the same name. If there is a lexically visible ordinary function
of the same name as one of the speciﬁed generic functions, that function becomes
the method function of the default method for the new generic function of that
name.
<!--l. 1195--><p class="indent" >   The <i>generic-function</i> macro creates an anonymous generic function with the
set of methods speciﬁed by the method deﬁnitions that appear in the
<i>generic-function</i> form.
<!--l. 1199--><p class="indent" >   When a <i>defgeneric</i> form is evaluated, one of three actions is taken:
      <ul class="itemize1">
      <li class="itemize">If a generic function of the given name already exists, the existing
      generic function object is modiﬁed. Methods speciﬁed by the current
      <i>defgeneric</i> form are added, and any methods in the existing generic
      function that were deﬁned by a previous <i>defgeneric</i> form are removed.
      Methods added by the current <i>defgeneric</i> form might replace methods
      deﬁned by <i>defmethod</i> or <i>defclass</i>. No other methods in the generic
      function are aﬀected or replaced.
      </li>
      <li class="itemize">If the given name names a non-generic function, a macro, or a special
      form, an error is signaled.
      </li>
      <li class="itemize">Otherwise a generic function is created with the methods speciﬁed by
                                                                          

                                                                          
      the method deﬁnitions in the <i>defgeneric</i> form.
      </li></ul>
<!--l. 1222--><p class="indent" >   Some forms specify the options of a generic function, such as the type of
method combination it uses or its argument precedence order. They will
be referred to as “forms that specify generic function options.” These
forms are <i>defgeneric</i>, <i>generic-function</i>, <i>generic-ﬂet</i>, <i>generic-labels</i>, and
<i>with-added-methods</i>.
<!--l. 1229--><p class="indent" >   Some forms deﬁne methods for a generic function. They will be referred to as
“method-deﬁning forms.” These forms are <i>defgeneric</i>, <i>defmethod</i>, <i>generic-function</i>,
<i>generic-ﬂet</i>, <i>generic-labels</i>, <i>with-added-methods</i>, and <i>defclass</i>. Note that all the
method-deﬁning forms except <i>defclass</i> and <i>defmethod</i> are also forms that specify
generic function options.
<!--l. 1237--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-27900028.1.6"></a>Introduction to Methods</h5>
<!--l. 1240--><p class="noindent" >A method object contains a method function, a sequence of parameter specializers
that specify when the given method is applicable, a lambda-list, and a sequence of
qualiﬁers that are used by the method combination facility to distinguish among
methods.
<!--l. 1246--><p class="indent" >   A method object is not a function and cannot be invoked as a function.
Various mechanisms in the Object System take a method object and invoke its
method function, as is the case when a generic function is invoked. When this
occurs it is said that the method is invoked or called.
<!--l. 1251--><p class="indent" >   A method-deﬁning form contains the code that is to be run when the
arguments to the generic function cause the method that it deﬁnes to be invoked.
When a method-deﬁning form is evaluated, a method object is created and one of
four actions is taken:
      <ul class="itemize1">
      <li class="itemize">If a generic function of the given name already exists and if a method
      object  already  exists  that  agrees  with  the  new  one  on  parameter
      specializers and qualiﬁers, the new method object replaces the old one.
      For a deﬁnition of one method agreeing with another on parameter
      specializers and qualiﬁers, see section <a 
href="#x183-28000028.1.6">28.1.6<!--tex4ht:ref: Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION --></a>.
                                                                          

                                                                          
      </li>
      <li class="itemize">If a generic function of the given name already exists and if there is no
      method object that agrees with the new one on parameter specializers
      and qualiﬁers, the existing generic function object is modiﬁed to contain
      the new method object.
      </li>
      <li class="itemize">If the given name names a non-generic function, a macro, or a special
      form, an error is signaled.
      </li>
      <li class="itemize">Otherwise a generic function is created with the methods speciﬁed by
      the method-deﬁning form.
      </li></ul>
<!--l. 1278--><p class="indent" >   If the lambda-list of a new method is not congruent with the lambda-list of the
generic function, an error is signaled. If a method-deﬁning form that cannot
specify generic function options creates a new generic function, a lambda-list for
that generic function is derived from the lambda-lists of the methods in the
method-deﬁning form in such a way as to be congruent with them. For a
discussion of congruence, see section <a 
href="#x183-28100028.1.6">28.1.6<!--tex4ht:ref: Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION --></a>.
<!--l. 1287--><p class="indent" >   Each method has a specialized lambda-list, which determines when that
method can be applied. A specialized lambda-list is like an ordinary lambda-list
except that a specialized parameter may occur instead of the name of
a required parameter. A specialized parameter is a list <i>(variable-name
parameter-specializer-name)</i>, where parameter-specializer-name is either a name
that names a class or a list <i>(<i>eql</i> form)</i>. A parameter specializer name denotes a
parameter specializer as follows:
      <ul class="itemize1">
      <li class="itemize">A name that names a class denotes that class.
      </li>
      <li class="itemize">The list <i>(<i>eql</i> form)</i> denotes the type speciﬁer <i>(<i>eql</i> object)</i>, where object is
      the result of evaluating form. The form form is evaluated in the lexical
      environment in which the method-deﬁning form is evaluated. Note that
      form is evaluated only once, at the time the method is deﬁned, not
      each time the generic function is called.</li></ul>
                                                                          

                                                                          
<!--l. 1307--><p class="indent" >   Parameter specializer names are used in macros intended as the user-level
interface (<i>defmethod</i>), while parameter specializers are used in the functional
interface.
<!--l. 1311--><p class="indent" >   [It is very important to understand clearly the distinction made in the
preceding paragraph. A parameter specializer name has the form of a type
speciﬁer but is semantically quite diﬀerent from a type speciﬁer: a parameter
specializer name of the form <i>(<i>eql</i> form)</i> is not a type speciﬁer, for it contains a
form to be evaluated. Type speciﬁers never contain forms to be evaluated.
All parameter specializers (as opposed to parameter specializer names)
are valid type speciﬁers, but not all type speciﬁers are valid parameter
specializers. Macros such as <i>defmethod</i> take parameter specializer names
and treat them as speciﬁcations for constructing certain type speciﬁers
(parameter specializers) that may then be used with such functions as
<i>ﬁnd-method</i>.—GLS]
<!--l. 1325--><p class="indent" >   Only required parameters may be specialized, and there must be a parameter
specializer for each required parameter. For notational simplicity, if some required
parameter in a specialized lambda-list in a method-deﬁning form is simply
a variable name, its parameter specializer defaults to the class named
<i>t</i>.
<!--l. 1331--><p class="indent" >   Given a generic function and a set of arguments, an applicable method is a
method for that generic function whose parameter specializers are satisﬁed by
their corresponding arguments. The following deﬁnition speciﬁes what it means
for a method to be applicable and for an argument to satisfy a parameter
specializer.
<!--l. 1337--><p class="indent" >   Let ⟨A<sub>1</sub>,…,A<sub>n</sub>⟩ be the required arguments to a generic function in order. Let
⟨P<sub>1</sub>,…,P<sub>n</sub>⟩ be the parameter specializers corresponding to the required parameters
of the method M in order. The method M is applicable when each A<sub>i</sub> satisﬁes P<sub>i</sub>.
If P<sub>i</sub> is a class, and if A<sub>i</sub> is an instance of a class C, then it is said that A<sub>i</sub> satisﬁes
P<sub>i</sub> when C = P<sub>i</sub> or when C is a subclass of P<sub>i</sub>. If P<sub>i</sub> is of the form <i>(<i>eql</i> object)</i>,
then it is said that A<sub>i</sub> satisﬁes P<sub>i</sub> when the function <i>eql</i> applied to A<sub>i</sub> and object is
true.
<!--l. 1353--><p class="indent" >   Because a parameter specializer is a type speciﬁer, the function <i>typep</i> can be
used during method selection to determine whether an argument satisﬁes a
parameter specializer. In general a parameter specializer cannot be a type speciﬁer
list, such as <i>(<i>vector single-ﬂoat</i>)</i>. The only parameter specializer that can be a list
is <i>(<i>eql</i> object)</i>. This requires that Common Lisp deﬁne the type speciﬁer <i>eql</i> as if
the following were evaluated:
<div class=lisp>
                                                                          

                                                                          
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deftype eql (object) <tt>‘</tt>(member ,object))
</td></tr></table>
<!--l. 1364--><p class="indent" >
</div>
</div>
<!--l. 1365--><p class="noindent" >[See section <a 
href="clmse20.html#x29-470004.3">4.3<!--tex4ht:ref: PREDICATING-TYPE-SPECIFIERS-SECTION --></a>.—GLS]
<!--l. 1367--><p class="indent" >   A method all of whose parameter specializers are the class named <i>t</i> is called a
default method; it is always applicable but may be shadowed by a more speciﬁc
method.
<!--l. 1371--><p class="indent" >   Methods can have qualiﬁers, which give the method combination procedure a
way to distinguish among methods. A method that has one or more qualiﬁers is
called a qualiﬁed method. A method with no qualiﬁers is called an unqualiﬁed
method. A qualiﬁer is any object other than a list, that is, any non-<i>nil</i> atom. The
qualiﬁers deﬁned by standard method combination and by the built-in method
combination types are symbols.
<!--l. 1379--><p class="indent" >   In this speciﬁcation, the terms primary method and auxiliary method are used
to partition methods within a method combination type according to their
intended use. In standard method combination, primary methods are unqualiﬁed
methods, and auxiliary methods are methods with a single qualiﬁer that is one of
<i>:around</i>, <i>:before</i>, or <i>:after</i>. When a method combination type is deﬁned using the
short form of <i>deﬁne-method-combination</i>, primary methods are methods qualiﬁed
with the name of the type of method combination, and auxiliary methods
have the qualiﬁer <i>:around</i>. Thus the terms primary method and auxiliary
method have only a relative deﬁnition within a given method combination
type.
<!--l. 1392--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-28000028.1.6"></a>Agreement on Parameter Specializers and Qualiﬁers</h5>
<!--l. 1395--><p class="noindent" >Two methods are said to agree with each other on parameter specializers and
qualiﬁers if the following conditions hold:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">Both methods have the same number of required parameters. Suppose
      the  parameter  specializers  of  the  two  methods  are  P<sub>1,1</sub>…P<sub>1,n</sub>  and
      P<sub>2,1</sub>…P<sub>2,n</sub>.
      </li>
      <li class="itemize">For each 1 ≤ i ≤ n, P<sub>1,i</sub>  agrees with P<sub>2,i</sub>. The parameter specializer
      P<sub>1,i</sub>   agrees  with  P<sub>2,i</sub>   if  P<sub>1,i</sub>   and  P<sub>2,i</sub>   are  the  same  class  or  if
      P<sub>1,i</sub> = (<i>eql</i> object<sub>1</sub>), P<sub>2,i</sub> = (<i>eql</i> object<sub>2</sub>), and <i>(<i>eql</i> object<sub>1</sub>  object<sub>2</sub>)</i>.
      Otherwise P<sub>1,i</sub> and P<sub>2,i</sub> do not agree.
      </li>
      <li class="itemize">The lists of qualiﬁers of both methods contain the same non-<i>nil</i> atoms
      in the same order. That is, the lists are <i>equal</i>.
      </li></ul>
<!--l. 1422--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-28100028.1.6"></a>Congruent Lambda-Lists for All Methods of a
Generic Function</h5>
<!--l. 1425--><p class="noindent" >These rules deﬁne the congruence of a set of lambda-lists, including the
lambda-list of each method for a given generic function and the lambda-list
speciﬁed for the generic function itself, if given.
      <ul class="itemize1">
      <li class="itemize">Each lambda-list must have the same number of required parameters.
      </li>
      <li class="itemize">Each lambda-list must have the same number of optional parameters.
      Each method can supply its own default for an optional parameter.
      </li>
      <li class="itemize">If  any  lambda-list  mentions  <i>&#x0026;rest</i>  or  <i>&#x0026;key</i>,  each  lambda-list  must
      mention one or both of them.
      </li>
      <li class="itemize">If  the  generic  function  lambda-list  mentions  <i>&#x0026;key</i>,  each  method
      must accept all of the keyword names mentioned after <i>&#x0026;key</i>, either
                                                                          

                                                                          
      by accepting them explicitly, by specifying <i>&#x0026;allow-other-keys</i>, or by
      specifying <i>&#x0026;rest</i> but not <i>&#x0026;key</i>. Each method can accept additional
      keyword arguments of its own. The checking of the validity of keyword
      names  is  done  in  the  generic  function,  not  in  each  method.  A
      method is invoked as if the keyword argument pair whose keyword is
      <i>:allow-other-keys</i> and whose value is <i>t</i> were supplied, though no such
      argument pair will be passed.
      </li>
      <li class="itemize">The   use   of   <i>&#x0026;allow-other-keys</i>   need   not   be   consistent   across
      lambda-lists.  If  <i>&#x0026;allow-other-keys</i>  is  mentioned  in  the  lambda-list
      of  any  applicable  method  or  of  the  generic  function,  any  keyword
      arguments may be mentioned in the call to the generic function.
      </li>
      <li class="itemize">The use of <i>&#x0026;aux</i> need not be consistent across methods.</li></ul>
<!--l. 1461--><p class="indent" >   If a method-deﬁning form that cannot specify generic function options creates
a generic function, and if the lambda-list for the method mentions keyword
arguments, the lambda-list of the generic function will mention <i>&#x0026;key</i> (but no
keyword arguments).
<!--l. 1467--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-28200028.1.6"></a>Keyword Arguments in Generic Functions and Methods</h5>
<!--l. 1469--><p class="noindent" >When a generic function or any of its methods mentions <i>&#x0026;key</i> in a lambda-list,
the speciﬁc set of keyword arguments accepted by the generic function varies
according to the applicable methods. The set of keyword arguments accepted by
the generic function for a particular call is the union of the keyword arguments
accepted by all applicable methods and the keyword arguments mentioned after
<i>&#x0026;key</i> in the generic function deﬁnition, if any. A method that has <i>&#x0026;rest</i> but not
<i>&#x0026;key</i> does not aﬀect the set of acceptable keyword arguments. If the lambda-list
of any applicable method or of the generic function deﬁnition contains
<i>&#x0026;allow-other-keys</i>, all keyword arguments are accepted by the generic
function.
<!--l. 1481--><p class="indent" >   The lambda-list congruence rules require that each method accept all of the
keyword arguments mentioned after <i>&#x0026;key</i> in the generic function deﬁnition, by
accepting them explicitly, by specifying <i>&#x0026;allow-other-keys</i>, or by specifying <i>&#x0026;rest</i>
but not <i>&#x0026;key</i>. Each method can accept additional keyword arguments of its own,
                                                                          

                                                                          
in addition to the keyword arguments mentioned in the generic function
deﬁnition.
                                                                          

                                                                          
<!--l. 1491--><p class="indent" >   If a generic function is passed a keyword argument that no applicable method
accepts, an error is signaled.
<!--l. 1494--><p class="indent" >   For example, suppose there are two methods deﬁned for <i>width</i> as follows:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod width ((c character-class) &#x0026;key font) ...)
</td></tr></table>
<!--l. 1498--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1499--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod width ((p picture-class) &#x0026;key pixel-size) ...)</td></tr></table>
<!--l. 1501--><p class="indent" >
</div>
</div>
<!--l. 1503--><p class="noindent" >Assume that there are no other methods and no generic function deﬁnition for
<i>width</i>. The evaluation of the following form will signal an error because the
keyword argument <i>:pixel-size</i> is not accepted by the applicable method.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(width (make-instance &#x2019;character-class :char #<tt>\</tt>Q)
</td></tr></table>
<!--l. 1509--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :font &#x2019;baskerville :pixel-size 10)</td></tr></table>
<!--l. 1511--><p class="indent" >
</div>
</div>
<!--l. 1513--><p class="indent" >   The evaluation of the following form will signal an error.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(width (make-instance &#x2019;picture-class :glyph (glyph #<tt>\</tt>Q))
</td></tr></table>
<!--l. 1516--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :font &#x2019;baskerville :pixel-size 10)</td></tr></table>
<!--l. 1518--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1520--><p class="indent" >   The evaluation of the following form will not signal an error if the
class named <i>character-picture-class</i> is a subclass of both <i>picture-class</i> and
<i>character-class</i>.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(width (make-instance &#x2019;character-picture-class :char #<tt>\</tt>Q)
</td></tr></table>
<!--l. 1525--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       :font &#x2019;baskerville :pixel-size 10)</td></tr></table>
<!--l. 1527--><p class="indent" >
</div>
</div>
<!--l. 1530--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.7   </span> <a 
 id="x183-28300028.1.7"></a>Method Selection and Combination</h4>
<!--l. 1533--><p class="noindent" >When a generic function is called with particular arguments, it must determine
the code to execute. This code is called the eﬀective method for those
arguments. The eﬀective method is a combination of the applicable methods
in the generic function. A combination of methods is a Lisp expression
that contains calls to some or all of the methods. If a generic function is
called and no methods apply, the generic function <i>no-applicable-method</i> is
invoked.
<!--l. 1542--><p class="indent" >   When the eﬀective method has been determined, it is invoked with the same
arguments that were passed to the generic function. Whatever values it returns
are returned as the values of the generic function.
<!--l. 1546--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-28400028.1.7"></a>Determining the Eﬀective Method</h5>
<!--l. 1549--><p class="noindent" >The eﬀective method for a set of arguments is determined by the following
three-step procedure:
<!--l. 1552--><p class="indent" >
                                                                          

                                                                          
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x183-284002x1">Select the applicable methods.
      </li>
      <li 
  class="enumerate" id="x183-284004x2">Sort the applicable methods by precedence order, putting the most
      speciﬁc method ﬁrst.
      </li>
      <li 
  class="enumerate" id="x183-284006x3">Apply method combination to the sorted list of applicable methods,
      producing the eﬀective method.
      </li></ol>
<!--l. 1564--><p class="indent" >   Selecting the Applicable Methods. This step is described in
section <a 
href="#x183-27900028.1.6">28.1.6<!--tex4ht:ref: Introduction-to-Methods-SECTION --></a>.
<!--l. 1568--><p class="indent" >   Sorting the Applicable Methods by Precedence Order. To
compare the precedence of two methods, their parameter specializers are
examined in order. The default examination order is from left to right, but an
alternative order may be speciﬁed by the <i>:argument-precedence-order</i> option
to <i>defgeneric</i> or to any of the other forms that specify generic function
options.
<!--l. 1575--><p class="indent" >   The corresponding parameter specializers from each method are compared.
When a pair of parameter specializers are equal, the next pair are compared for
equality. If all corresponding parameter specializers are equal, the two methods
must have diﬀerent qualiﬁers; in this case, either method can be selected to
precede the other.
<!--l. 1582--><p class="indent" >   If some corresponding parameter specializers are not equal, the ﬁrst pair of
parameter specializers that are not equal determines the precedence. If both
parameter specializers are classes, the more speciﬁc of the two methods
is the method whose parameter specializer appears earlier in the class
precedence list of the corresponding argument. Because of the way in which
the set of applicable methods is chosen, the parameter specializers are
guaranteed to be present in the class precedence list of the class of the
argument.
<!--l. 1591--><p class="indent" >   If just one parameter specializer is <i>(<i>eql</i> object)</i>, the method with that
parameter specializer precedes the other method. If both parameter specializers
are <i>eql</i> forms, the specializers must be the same (otherwise the two methods
would not both have been applicable to this argument).
<!--l. 1598--><p class="indent" >   The resulting list of applicable methods has the most speciﬁc method ﬁrst and
the least speciﬁc method last.
                                                                          

                                                                          
<!--l. 1601--><p class="indent" >   Applying Method Combination to the Sorted List of Applicable
Methods. In the simple case—if standard method combination is used and all
applicable methods are primary methods—the eﬀective method is the most
speciﬁc method. That method can call the next most speciﬁc method by using
the function <i>call-next-method</i>. The method that <i>call-next-method</i> will
call is referred to as the next method. The predicate <i>next-method-p</i> tests
whether a next method exists. If <i>call-next-method</i> is called and there is
no next most speciﬁc method, the generic function <i>no-next-method</i> is
invoked.
<!--l. 1612--><p class="indent" >   In general, the eﬀective method is some combination of the applicable
methods. It is deﬁned by a Lisp form that contains calls to some or all of the
applicable methods, returns the value or values that will be returned as the value
or values of the generic function, and optionally makes some of the methods
accessible by means of <i>call-next-method</i>. This Lisp form is the body of the
eﬀective method; it is augmented with an appropriate lambda-list to make it a
function.
<!--l. 1620--><p class="indent" >   The role of each method in the eﬀective method is determined by its method
qualiﬁers and the speciﬁcity of the method. A qualiﬁer serves to mark a method,
and the meaning of a qualiﬁer is determined by the way that these marks are used
by this step of the procedure. If an applicable method has an unrecognized
qualiﬁer, this step signals an error and does not include that method in the
eﬀective method.
<!--l. 1628--><p class="indent" >   When standard method combination is used together with qualiﬁed methods,
the eﬀective method is produced as described in section <a 
href="#x183-28500028.1.7">28.1.7<!--tex4ht:ref: Standard-Method-Combination-SECTION --></a>.
<!--l. 1632--><p class="indent" >   Another type of method combination can be speciﬁed by using the
<i>:method-combination</i> option of <i>defgeneric</i> or of any of the other forms that specify
generic function options. In this way this step of the procedure can be
customized.
<!--l. 1637--><p class="indent" >   New types of method combination can be deﬁned by using the
<i>deﬁne-method-combination</i> macro.
<!--l. 1641--><p class="indent" >   The meta-object level also oﬀers a mechanism for deﬁning new types of
method combination. The generic function <i>compute-eﬀective-method</i> receives as
arguments the generic function, the method combination object, and the sorted
list of applicable methods. It returns the Lisp form that deﬁnes the eﬀective
method. A method for <i>compute-eﬀective-method</i> can be deﬁned directly by using
<i>defmethod</i> or indirectly by using <i>deﬁne-method-combination</i>. A method
combination object is an object that encapsulates the method combination type
and options speciﬁed by the <i>:method-combination</i> option to forms that specify
                                                                          

                                                                          
generic function options.
<div class=implementation>
<!--l. 1657--><p class="noindent" ><b>Implementation note:</b> In the simplest implementation, the generic function would
compute the eﬀective method each time it was called. In practice, this will be too
ineﬃcient for some implementations. Instead, these implementations might employ a
variety of optimizations of the three-step procedure. Some illustrative examples of such
optimizations are the following:
      <ul class="itemize1">
      <li class="itemize">Use a hash table keyed by the class of the arguments to store the eﬀective
      method.
      </li>
      <li class="itemize">Compile the eﬀective method and save the resulting compiled function in a
      table.
      </li>
      <li class="itemize">Recognize the Lisp form as an instance of a pattern of control structure and
      substitute a closure that implements that structure.
      </li>
      <li class="itemize">Examine the parameter specializers of all methods for the generic function
      and enumerate all possible eﬀective methods. Combine the eﬀective methods,
      together with code to select from among them, into a single function and
      compile that function. Call that function whenever the generic function is
      called.</li></ul>
</div>
<!--l. 1687--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-28500028.1.7"></a>Standard Method Combination</h5>
<!--l. 1690--><p class="noindent" >Standard method combination is supported by the class <i>standard-generic-function</i>. It
is used if no other type of method combination is speciﬁed or if the built-in
method combination type <i>standard</i> is speciﬁed.
<!--l. 1696--><p class="indent" >   Primary methods deﬁne the main action of the eﬀective method, while
auxiliary methods modify that action in one of three ways. A primary method has
no method qualiﬁers.
<!--l. 1700--><p class="indent" >   An auxiliary method is a method whose method qualiﬁer is <i>:before</i>, <i>:after</i>, or
<i>:around</i>. Standard method combination allows no more than one qualiﬁer per
                                                                          

                                                                          
method; if a method deﬁnition speciﬁes more than one qualiﬁer per method, an
error is signaled.
      <ul class="itemize1">
      <li class="itemize">A <i>:before</i> method has the keyword <i>:before</i> as its only qualiﬁer. A <i>:before</i>
      method speciﬁes code that is to be run before any primary method.
      </li>
      <li class="itemize">An <i>:after</i> method has the keyword <i>:after</i> as its only qualiﬁer. An <i>:after</i>
      method speciﬁes code that is to be run after primary methods.
      </li>
      <li class="itemize">An  <i>:around</i> method  has  the  keyword  <i>:around</i> as  its  only  qualiﬁer.
      An <i>:around</i> method speciﬁes code that is to be run instead of other
      applicable methods but that is able to cause some of them to be run.
      </li></ul>
<!--l. 1724--><p class="noindent" >The semantics of standard method combination are as follows:
      <ul class="itemize1">
      <li class="itemize">If there are any <i>:around</i> methods, the most speciﬁc <i>:around</i> method is
      called. It supplies the value or values of the generic function.
      </li>
      <li class="itemize">Inside  the  body  of  an  <i>:around</i>  method,  <i>call-next-method</i>  can  be
      used to call the next method. When the next method returns, the
      <i>:around</i> method can execute more code, perhaps based on the returned
      value  or  values.  The  generic  function  <i>no-next-method</i>  is  invoked  if
      <i>call-next-method</i> is used and there is no applicable method to call.
      The function <i>next-method-p</i> may be used to determine whether a next
      method exists.
      </li>
      <li class="itemize">If an <i>:around</i> method invokes <i>call-next-method</i>, the next most speciﬁc
      <i>:around</i> method is called, if one is applicable. If there are no <i>:around</i>
      methods or if <i>call-next-method</i> is called by the least speciﬁc <i>:around</i>
      method, the other methods are called as follows:
                                                                          

                                                                          
           <ul class="itemize2">
           <li class="itemize">All  the  <i>:before</i> methods  are  called,  in  most-speciﬁc-ﬁrst  order.
           Their values are ignored. An error is signaled if <i>call-next-method</i>
           is used in a <i>:before</i> method.
           </li>
           <li class="itemize">The  most  speciﬁc  primary  method  is  called.  Inside  the  body
           of a primary method, <i>call-next-method</i> may be used to call the
           next most speciﬁc primary method. When that method returns,
           the  previous  primary  method  can  execute  more  code,  perhaps
           based  on  the  returned  value  or  values.  The  generic  function
           <i>no-next-method</i> is invoked if <i>call-next-method</i> is used and there are
           no more applicable primary methods. The function <i>next-method-p</i>
           may  be  used  to  determine  whether  a  next  method  exists.  If
           <i>call-next-method</i>  is  not  used,  only  the  most  speciﬁc  primary
           method is called.
           </li>
           <li class="itemize">All the <i>:after</i> methods are called in most-speciﬁc-last order. Their
           values are ignored. An error is signaled if <i>call-next-method</i> is used
           in an <i>:after</i> method.</li></ul>
      </li>
      <li class="itemize">If no <i>:around</i> methods were invoked, the most speciﬁc primary method
      supplies the value or values returned by the generic function. The value or
      values returned by the invocation of <i>call-next-method</i> in the least speciﬁc
      <i>:around</i> method are those returned by the most speciﬁc primary
      method.
      </li></ul>
<!--l. 1779--><p class="indent" >   In standard method combination, if there is an applicable method but no
applicable primary method, an error is signaled.
<!--l. 1782--><p class="indent" >   The <i>:before</i> methods are run in most-speciﬁc-ﬁrst order and the <i>:after</i> methods
are run in least-speciﬁc-ﬁrst order. The design rationale for this diﬀerence can be
illustrated with an example. Suppose class C<sub>1</sub> modiﬁes the behavior of its
superclass, C<sub>2</sub>, by adding <i>:before</i> and <i>:after</i> methods. Whether the behavior of the
class C<sub>2</sub> is deﬁned directly by methods on C<sub>2</sub> or is inherited from its
superclasses does not aﬀect the relative order of invocation of methods on
instances of the class C<sub>1</sub>. Class C<sub>1</sub>&#x2019;s <i>:before</i> method runs before all of
class C<sub>2</sub>&#x2019;s methods. Class C<sub>1</sub>&#x2019;s <i>:after</i> method runs after all of class C<sub>2</sub>&#x2019;s
                                                                          

                                                                          
methods.
<!--l. 1794--><p class="indent" >   By contrast, all <i>:around</i> methods run before any other methods run.
Thus a less speciﬁc <i>:around</i> method runs before a more speciﬁc primary
method.
<!--l. 1798--><p class="indent" >   If only primary methods are used and if <i>call-next-method</i> is not used, only the
most speciﬁc method is invoked; that is, more speciﬁc methods shadow more
general ones.
<!--l. 1802--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-28600028.1.7"></a>Declarative Method Combination</h5>
<!--l. 1804--><p class="noindent" >The macro <i>deﬁne-method-combination</i> deﬁnes new forms of method combination.
It provides a mechanism for customizing the production of the eﬀective method.
The default procedure for producing an eﬀective method is described in
section <a 
href="#x183-28400028.1.7">28.1.7<!--tex4ht:ref: Determining-the-Effective-Method-SECTION --></a>. There are two forms of <i>deﬁne-method-combination</i>. The short form
is a simple facility; the long form is more powerful and more verbose. The long
form resembles <i>defmacro</i> in that the body is an expression that computes a Lisp
form; it provides mechanisms for implementing arbitrary control structures within
method combination and for arbitrary processing of method qualiﬁers. The
syntax and use of both forms of <i>deﬁne-method-combination</i> are explained in
section <a 
href="clmse151.html#x184-31100028.2">28.2<!--tex4ht:ref: Functions-in-the-Programmer-Interface-SECTION --></a>.
<!--l. 1820--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-28700028.1.7"></a>Built-in Method Combination Types</h5>
<!--l. 1823--><p class="noindent" >The Common Lisp Object System provides a set of built-in method combination
types. To specify that a generic function is to use one of these method
combination types, the name of the method combination type is given as
the argument to the <i>:method-combination</i> option to <i>defgeneric</i> or to the
<i>:method-combination</i> option to any of the other forms that specify generic
function options.
<!--l. 1830--><p class="indent" >   The names of the built-in method combination types are <i>+</i>, <i>and</i>, <i>append</i>, <i>list</i>,
<i>max</i>, <i>min</i>, <i>nconc</i>, <i>or</i>, <i>progn</i>, and <i>standard</i>.
<!--l. 1834--><p class="indent" >   The semantics of the <i>standard</i> built-in method combination type were
described in section <a 
href="#x183-28500028.1.7">28.1.7<!--tex4ht:ref: Standard-Method-Combination-SECTION --></a>. The other built-in method combination types are
called simple built-in method combination types.
<!--l. 1839--><p class="indent" >   The simple built-in method combination types act as though they were deﬁned
                                                                          

                                                                          
by the short form of <i>deﬁne-method-combination</i>. They recognize two roles for
methods:
      <ul class="itemize1">
      <li class="itemize">An  <i>:around</i>  method  has  the  keyword  symbol  <i>:around</i>  as  its  sole
      qualiﬁer. The meaning of <i>:around</i> methods is the same as in standard
      method  combination.  Use  of  the  functions  <i>call-next-method</i>  and
      <i>next-method-p</i> is supported in <i>:around</i> methods.
      </li>
      <li class="itemize">A primary method has the name of the method combination type as
      its sole qualiﬁer. For example, the built-in method combination type
      <i>and</i> recognizes methods whose sole qualiﬁer is <i>and</i>; these are primary
      methods. Use of the functions <i>call-next-method</i> and <i>next-method-p</i> is
      not supported in primary methods.
      </li></ul>
<!--l. 1859--><p class="noindent" >The semantics of the simple built-in method combination types are as follows:
      <ul class="itemize1">
      <li class="itemize">If there are any <i>:around</i> methods, the most speciﬁc <i>:around</i> method is
      called. It supplies the value or values of the generic function.
      </li>
      <li class="itemize">Inside the body of an <i>:around</i> method, the function <i>call-next-method</i>
      can   be   used   to   call   the   next   method.   The   generic   function
      <i>no-next-method</i> is invoked if <i>call-next-method</i> is used and there is no
      applicable method to call. The function <i>next-method-p</i> may be used
      to determine whether a next method exists. When the next method
      returns, the <i>:around</i> method can execute more code, perhaps based on
      the returned value or values.
      </li>
      <li class="itemize">If an <i>:around</i> method invokes <i>call-next-method</i>, the next most speciﬁc
      <i>:around</i> method is called, if one is applicable. If there are no <i>:around</i>
      methods or if <i>call-next-method</i> is called by the least speciﬁc <i>:around</i>
      method, a Lisp form derived from the name of the built-in method
                                                                          

                                                                          
      combination type and from the list of applicable primary methods is
      evaluated to produce the value of the generic function. Suppose the name of
      the method combination type is operator and the call to the generic function
      is of the form <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(generic-function a<sub>1</sub> ... a<sub>n</sub>)
</td></tr></table>
      <!--l. 1887--><p class="noindent" >
</div>
</div>
      <!--l. 1888--><p class="noindent" >Let M<sub>1</sub>,…,M<sub>k</sub> be the applicable primary methods in order; then the derived
      Lisp form is <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(operator ⟨M<sub>1</sub> a<sub>1</sub>…a<sub>n</sub>⟩ ... ⟨M<sub>k</sub> a<sub>1</sub>…a<sub>n</sub>⟩)
</td></tr></table>
      <!--l. 1893--><p class="noindent" >
</div>
</div>
      <!--l. 1894--><p class="noindent" >If the expression ⟨M<sub>i</sub> a<sub>1</sub>…a<sub>n</sub>⟩ is evaluated, the method M<sub>i</sub> will be applied to
      the arguments a<sub>1</sub>…a<sub>n</sub>. For example, if operator is <i>or</i>, the expression
      ⟨M<sub>i</sub> a<sub>1</sub>…a<sub>n</sub>⟩ is evaluated only if ⟨M<sub>j</sub> a<sub>1</sub>…a<sub>n</sub>⟩, 1 ≤ j &#x003C; i, returned
      <i>nil</i>.
      <!--l. 1904--><p class="noindent" >The default order for the primary methods is <i>:most-speciﬁc-ﬁrst</i>. However,
      the order can be reversed by supplying <i>:most-speciﬁc-last</i> as the second
      argument to the <i>:method-combination</i> option.
      </li></ul>
<!--l. 1911--><p class="indent" >   The simple built-in method combination types require exactly one qualiﬁer per
method. An error is signaled if there are applicable methods with no qualiﬁers or
with qualiﬁers that are not supported by the method combination type. An error
is signaled if there are applicable <i>:around</i> methods and no applicable primary
methods.
                                                                          

                                                                          
<!--l. 1918--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.8   </span> <a 
 id="x183-28800028.1.8"></a>Meta-objects</h4>
<!--l. 1920--><p class="noindent" >The implementation of the Object System manipulates classes, methods, and
generic functions. The meta-object protocol speciﬁes a set of generic functions
deﬁned by methods on classes; the behavior of those generic functions deﬁnes the
behavior of the Object System. The instances of the classes on which those
methods are deﬁned are called meta-objects. Programming at the meta-object
protocol level involves deﬁning new classes of meta-objects along with methods
specialized on these classes.
                                                                          

                                                                          
<!--l. 1930--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-28900028.1.8"></a>Metaclasses</h5>
<!--l. 1932--><p class="noindent" >The metaclass of an object is the class of its class. The metaclass determines the
representation of instances of its instances and the forms of inheritance used by its
instances for slot descriptions and method inheritance. The metaclass mechanism
can be used to provide particular forms of optimization or to tailor the Common
Lisp Object System for particular uses. The protocol for deﬁning metaclasses is
discussed in the third part of the CLOS speciﬁcation, The Common Lisp Object
System Meta-Object Protocol. [The third part has not yet been approved by
X3J13 for inclusion in the forthcoming Common Lisp standard and is not
included in this book.—GLS]
<!--l. 1944--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-29000028.1.8"></a>Standard Metaclasses</h5>
<!--l. 1946--><p class="noindent" >The Common Lisp Object System provides a number of predeﬁned metaclasses.
These include the classes <i>standard-class</i>, <i>built-in-class</i>, and <i>structure-class</i>:
      <ul class="itemize1">
      <li class="itemize">The  class  <i>standard-class</i>  is  the  default  class  of  classes  deﬁned  by
      <i>defclass</i>.
      </li>
      <li class="itemize">The class <i>built-in-class</i> is the class whose instances are classes that
      have  special  implementations  with  restricted  capabilities.  Any  class
      that corresponds to a standard Common Lisp type might be an instance
      of  <i>built-in-class</i>.  The  predeﬁned  Common  Lisp  type  speciﬁers  that
      are  required  to  have  corresponding  classes  are  listed  in  table <a 
href="#x183-2730011">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a>.
      It  is  implementation-dependent  whether  each  of  these  classes  is
      implemented as a built-in class.
      </li>
      <li class="itemize">All classes deﬁned by means of <i>defstruct</i> are instances of <i>structure-class</i>.</li></ul>
                                                                          

                                                                          
<!--l. 1971--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-29100028.1.8"></a>Standard Meta-objects</h5>
<!--l. 1973--><p class="noindent" >The Object System supplies a standard set of meta-objects, called standard
meta-objects. These include the class <i>standard-object</i> and instances of the classes
<i>standard-method</i>, <i>standard-generic-function</i>, and <i>method-combination</i>.
      <ul class="itemize1">
      <li class="itemize">The  class  <i>standard-method</i>  is  the  default  class  of  methods  that
      are  deﬁned  by  the  forms  <i>defmethod</i>,  <i>defgeneric</i>,  <i>generic-function</i>,
      <i>generic-ﬂet</i>, <i>generic-labels</i>, and <i>with-added-methods</i>.
      </li>
      <li class="itemize">The  class  <i>standard-generic-function</i>  is  the  default  class  of  generic
      functions deﬁned by the forms <i>defmethod</i>, <i>defgeneric</i>, <i>generic-function</i>,
      <i>generic-ﬂet</i>, <i>generic-labels</i>, <i>with-added-methods</i>, and <i>defclass</i>.
      </li>
      <li class="itemize">The   class   named   <i>standard-object</i>  is   an   instance   of   the   class
      <i>standard-class</i> and is a superclass of every class that is an instance of
      <i>standard-class</i> except itself.
      </li>
      <li class="itemize">Every method combination object is an instance of a subclass of the
      class <i>method-combination</i>.
      </li></ul>
<!--l. 2002--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.9   </span> <a 
 id="x183-29200028.1.9"></a>Object Creation and Initialization</h4>
<!--l. 2005--><p class="noindent" >The generic function <i>make-instance</i> creates and returns a new instance of a class.
The ﬁrst argument is a class or the name of a class, and the remaining arguments
form an initialization argument list.
<!--l. 2010--><p class="indent" >   The initialization of a new instance consists of several distinct steps, including
the following: combining the explicitly supplied initialization arguments with
default values for the unsupplied initialization arguments, checking the
validity of the initialization arguments, allocating storage for the instance,
ﬁlling slots with values, and executing user-supplied methods that perform
                                                                          

                                                                          
additional initialization. Each step of <i>make-instance</i> is implemented by a
generic function to provide a mechanism for customizing that step. In
addition, <i>make-instance</i> is itself a generic function and thus also can be
customized.
<!--l. 2021--><p class="indent" >   The Object System speciﬁes system-supplied primary methods for each step
and thus speciﬁes a well-deﬁned standard behavior for the entire initialization
process. The standard behavior provides four simple mechanisms for controlling
initialization:
      <ul class="itemize1">
      <li class="itemize">Declaring  a  symbol  to  be  an  initialization  argument  for  a  slot.  An
      initialization argument is declared by using the <i>:initarg</i> slot option to
      <i>defclass</i>. This provides a mechanism for supplying a value for a slot in
      a call to <i>make-instance</i>.
      </li>
      <li class="itemize">Supplying a default value form for an initialization argument. Default
      value  forms  for  initialization  arguments  are  deﬁned  by  using  the
      <i>:default-initargs</i> class option to <i>defclass</i>. If an initialization argument
      is not explicitly provided as an argument to <i>make-instance</i>, the default
      value form is evaluated in the lexical environment of the <i>defclass</i> form
      that deﬁned it, and the resulting value is used as the value of the
      initialization argument.
      </li>
      <li class="itemize">Supplying a default initial value form for a slot. A default initial value
      form for a slot is deﬁned by using the <i>:initform</i> slot option to <i>defclass</i>.
      If no initialization argument associated with that slot is given as an
      argument to <i>make-instance</i> or is defaulted by <i>:default-initargs</i>, this
      default initial value form is evaluated in the lexical environment of the
      <i>defclass</i> form that deﬁned it, and the resulting value is stored in the
      slot. The <i>:initform</i> form for a local slot may be used when creating an
      instance, when updating an instance to conform to a redeﬁned class, or
      when updating an instance to conform to the deﬁnition of a diﬀerent
      class. The <i>:initform</i> form for a shared slot may be used when deﬁning
      or re-deﬁning the class.
      </li>
                                                                          

                                                                          
      <li class="itemize">Deﬁning
      methods  for  <i>initialize-instance</i> and  <i>shared-initialize</i>.  The  slot-ﬁlling
      behavior described above is implemented by a system-supplied primary
      method  for  <i>initialize-instance</i>  which  invokes  <i>shared-initialize</i>.  The
      generic function <i>shared-initialize</i> implements the parts of initialization
      shared  by  these  four  situations:  when  making  an  instance,  when
      re-initializing an instance, when updating an instance to conform to
      a redeﬁned class, and when updating an instance to conform to the
      deﬁnition of a diﬀerent class. The system-supplied primary method for
      <i>shared-initialize</i> directly implements the slot-ﬁlling behavior described
      above, and <i>initialize-instance</i> simply invokes <i>shared-initialize</i>.
      </li></ul>
<!--l. 2070--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-29300028.1.9"></a>Initialization Arguments</h5>
<!--l. 2072--><p class="noindent" >An initialization argument controls object creation and initialization. It is often
convenient to use keyword symbols to name initialization arguments, but the
name of an initialization argument can be any symbol, including <i>nil</i>. An
initialization argument can be used in two ways: to ﬁll a slot with a value or to
provide an argument for an initialization method. A single initialization argument
can be used for both purposes.
<!--l. 2080--><p class="indent" >   An initialization argument list is a list of alternating initialization argument
names and values. Its structure is identical to a property list and also to the
portion of an argument list processed for <i>&#x0026;key</i> parameters. As in those lists, if an
initialization argument name appears more than once in an initialization
argument list, the leftmost occurrence supplies the value and the remaining
occurrences are ignored. The arguments to <i>make-instance</i> (after the ﬁrst
argument) form an initialization argument list. Error checking of initialization
argument names is disabled if the keyword argument pair whose keyword is
<i>:allow-other-keys</i> and whose value is non-<i>nil</i> appears in the initialization
argument list.
<!--l. 2093--><p class="indent" >   An initialization argument can be associated with a slot. If the initialization
argument has a value in the initialization argument list, the value is stored into
the slot of the newly created object, overriding any <i>:initform</i> form associated with
the slot. A single initialization argument can initialize more than one slot. An
initialization argument that initializes a shared slot stores its value into the shared
                                                                          

                                                                          
slot, replacing any previous value.
<!--l. 2101--><p class="indent" >   An initialization argument can be associated with a method. When an object
is created and a particular initialization argument is supplied, the generic
functions <i>initialize-instance</i>, <i>shared-initialize</i>, and <i>allocate-instance</i> are
called with that initialization argument&#x2019;s name and value as a keyword
argument pair. If a value for the initialization argument is not supplied in the
initialization argument list, the method&#x2019;s lambda-list supplies a default
value.
<!--l. 2110--><p class="indent" >   Initialization arguments are used in four situations: when making an instance,
when re-initializing an instance, when updating an instance to conform to a
redeﬁned class, and when updating an instance to conform to the deﬁnition of a
diﬀerent class.
<!--l. 2115--><p class="indent" >   Because initialization arguments are used to control the creation and
initialization of an instance of some particular class, we say that an initialization
argument is “an initialization argument for” that class.
<!--l. 2121--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-29400028.1.9"></a>Declaring the Validity of Initialization Arguments</h5>
<!--l. 2124--><p class="noindent" >Initialization arguments are checked for validity in each of the four situations that
use them. An initialization argument may be valid in one situation and not
another. For example, the system-supplied primary method for <i>make-instance</i>
deﬁned for the class <i>standard-class</i> checks the validity of its initialization
arguments and signals an error if an initialization argument is supplied that is not
declared valid in that situation.
<!--l. 2133--><p class="indent" >   There are two means of declaring initialization arguments valid.
      <ul class="itemize1">
      <li class="itemize">Initialization arguments that ﬁll slots are declared valid by the <i>:initarg</i>
      slot  option  to  <i>defclass</i>.  The  <i>:initarg</i>  slot  option  is  inherited  from
      superclasses.  Thus  the  set  of  valid  initialization  arguments  that  ﬁll
      slots for a class is the union of the initialization arguments that ﬁll
      slots declared valid by that class and its superclasses. Initialization
      arguments that ﬁll slots are valid in all four contexts.
      </li>
      <li class="itemize">Initialization  arguments  that  supply  arguments  to  methods  are
                                                                          

                                                                          
      declared valid by deﬁning those methods. The keyword name of each
      keyword  parameter  speciﬁed  in  the  method&#x2019;s  lambda-list  becomes
      an  initialization  argument  for  all  classes  for  which  the  method
      is  applicable.  Thus  method  inheritance  controls  the  set  of  valid
      initialization arguments that supply arguments to methods. The generic
      functions for which method deﬁnitions serve to declare initialization
      arguments valid are as follows:
           <ul class="itemize2">
           <li class="itemize">Making                    an                    instance                    of
           a class: <i>allocate-instance</i>, <i>initialize-instance</i>, and <i>shared-initialize</i>.
           Initialization arguments declared valid by these methods are valid
           when making an instance of a class.
           </li>
           <li class="itemize">Re-initializing an instance: the functions <i>reinitialize-instance</i> and
           <i>shared-initialize</i>. Initialization arguments declared valid by these
           methods are valid when re-initializing an instance.
           </li>
           <li class="itemize">Updating                              an                              instance
           to conform to a redeﬁned class: <i>update-instance-for-redeﬁned-class</i>
           and <i>shared-initialize</i>. Initialization arguments declared valid by
           these methods are valid when updating an instance to conform to
           a redeﬁned class.
           </li>
           <li class="itemize">Updating an instance to conform to the deﬁnition of a diﬀerent
           class:   <i>update-instance-for-diﬀerent-class</i>  and   <i>shared-initialize</i>.
           Initialization arguments declared valid by these methods are valid
           when  updating  an  instance  to  conform  to  the  deﬁnition  of  a
           diﬀerent class.</li></ul>
      </li></ul>
<!--l. 2180--><p class="indent" >   The set of valid initialization arguments for a class is the set of valid
initialization arguments that either ﬁll slots or supply arguments to methods,
along with the predeﬁned initialization argument <i>:allow-other-keys</i>. The default
value for <i>:allow-other-keys</i> is <i>nil</i>. The meaning of <i>:allow-other-keys</i> is the same
here as when it is passed to an ordinary function.
                                                                          

                                                                          
<!--l. 2189--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-29500028.1.9"></a>Defaulting of Initialization Arguments</h5>
<!--l. 2191--><p class="noindent" >A default value form can be supplied for an initialization argument by using the
<i>:default-initargs</i> class option. If an initialization argument is declared valid by
some particular class, its default value form might be speciﬁed by a diﬀerent class.
In this case <i>:default-initargs</i> is used to supply a default value for an inherited
initialization argument.
<!--l. 2198--><p class="indent" >   The <i>:default-initargs</i> option is used only to provide default values for
initialization arguments; it does not declare a symbol as a valid initialization
argument name. Furthermore, the <i>:default-initargs</i> option is used only
to provide default values for initialization arguments when making an
instance.
<!--l. 2204--><p class="indent" >   The argument to the <i>:default-initargs</i> class option is a list of alternating
initialization argument names and forms. Each form is the default value form for
the corresponding initialization argument. The default value form of an
initialization argument is used and evaluated only if that initialization argument
does not appear in the arguments to <i>make-instance</i> and is not defaulted by a
more speciﬁc class. The default value form is evaluated in the lexical environment
of the <i>defclass</i> form that supplied it; the result is used as the initialization
argument&#x2019;s value.
<!--l. 2215--><p class="indent" >   The initialization arguments supplied to <i>make-instance</i> are combined with
defaulted initialization arguments to produce a defaulted initialization argument
list. A defaulted initialization argument list is a list of alternating initialization
argument names and values in which unsupplied initialization arguments are
defaulted and in which the explicitly supplied initialization arguments appear
earlier in the list than the defaulted initialization arguments. Defaulted
initialization arguments are ordered according to the order in the class precedence
list of the classes that supplied the default values.
<!--l. 2225--><p class="indent" >   There is a distinction between the purposes of the <i>:default-initargs</i> and the
<i>:initform</i> options with respect to the initialization of slots. The <i>:default-initargs</i>
class option provides a mechanism for the user to give a default value form for an
initialization argument without knowing whether the initialization argument
initializes a slot or is passed to a method. If that initialization argument is not
explicitly supplied in a call to <i>make-instance</i>, the default value form is used, just
as if it had been supplied in the call. In contrast, the <i>:initform</i> slot option
provides a mechanism for the user to give a default initial value form for a slot.
An <i>:initform</i> form is used to initialize a slot only if no initialization argument
associated with that slot is given as an argument to <i>make-instance</i> or is defaulted
                                                                          

                                                                          
by <i>:default-initargs</i>.
<!--l. 2240--><p class="indent" >   The order of evaluation of default value forms for initialization arguments and
the order of evaluation of <i>:initform</i> forms are undeﬁned. If the order of evaluation
matters, use <i>initialize-instance</i> or <i>shared-initialize</i> methods.
<!--l. 2246--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-29600028.1.9"></a>Rules for Initialization Arguments</h5>
<!--l. 2249--><p class="noindent" >The <i>:initarg</i> slot option may be speciﬁed more than once for a given slot. The
following rules specify when initialization arguments may be multiply
deﬁned:
      <ul class="itemize1">
      <li class="itemize">A given initialization argument can be used to initialize more than one
      slot if the same initialization argument name appears in more than one
      <i>:initarg</i> slot option.
      </li>
      <li class="itemize">A given initialization argument name can appear in the lambda-list of
      more than one initialization method.
      </li>
      <li class="itemize">A given initialization argument name can appear both in an <i>:initarg</i>
      slot option and in the lambda-list of an initialization method.
      </li></ul>
<!--l. 2269--><p class="indent" >   If two or more initialization arguments that initialize the same slot are given in
the arguments to <i>make-instance</i>, the leftmost of these initialization arguments in
the initialization argument list supplies the value, even if the initialization
arguments have diﬀerent names.
<!--l. 2275--><p class="indent" >   If two or more diﬀerent initialization arguments that initialize the same
slot have default values and none is given explicitly in the arguments to
<i>make-instance</i>, the initialization argument that appears in a <i>:default-initargs</i> class
option in the most speciﬁc of the classes supplies the value. If a single
<i>:default-initargs</i> class option speciﬁes two or more initialization arguments that
initialize the same slot and none is given explicitly in the arguments to
<i>make-instance</i>, the leftmost argument in the <i>:default-initargs</i> class option
supplies the value, and the values of the remaining default value forms are
                                                                          

                                                                          
ignored.
<!--l. 2286--><p class="indent" >   Initialization arguments given explicitly in the arguments to <i>make-instance</i>
appear to the left of defaulted initialization arguments. Suppose that the classes
C<sub>1</sub> and C<sub>2</sub> supply the values of defaulted initialization arguments for diﬀerent
slots, and suppose that C<sub>1</sub> is more speciﬁc than C<sub>2</sub>; then the defaulted
initialization argument whose value is supplied by C<sub>1</sub> is to the left of the defaulted
initialization argument whose value is supplied by C<sub>2</sub> in the defaulted
initialization argument list. If a single <i>:default-initargs</i> class option supplies the
values of initialization arguments for two diﬀerent slots, the initialization
argument whose value is speciﬁed farther to the left in the <i>default-initargs</i> class
option appears farther to the left in the defaulted initialization argument
list.
<!--l. 2300--><p class="indent" >   If a slot has both an <i>:initform</i> form and an <i>:initarg</i> slot option, and the
initialization argument is defaulted using <i>:default-initargs</i> or is supplied to
<i>make-instance</i>, the captured <i>:initform</i> form is neither used nor evaluated.
<!--l. 2305--><p class="indent" >   The following is an example of the preceding rules:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass q () ((x :initarg a)))
</td></tr></table>
<!--l. 2308--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2309--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defclass r (q) ((x :initarg b))</td></tr></table>
<!--l. 2310--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (:default-initargs a 1 b 2))</td></tr></table>
<!--l. 2312--><p class="indent" >
</div>
</div>
<div class="flushleft" 
>
<!--l. 2314--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >                                      </td><td align="left" >Defaulted Initialization</td><td align="left" >Contents</td></tr><tr><td align="left" >Form  </td> <td align="left" >Argument List </td> <td align="left" >of Slot</td>
</tr><tr><td align="left" ><i>(make-instance &#x2019;r)</i>            </td><td align="left" ><i>(a 1 b 2)</i>                 </td><td align="left" ><i>1</i>         </td>
</tr><tr><td align="left" ><i>(make-instance &#x2019;r &#x2019;a 3)</i>       </td><td align="left" ><i>(a 3 b 2)</i>                 </td><td align="left" ><i>3</i>         </td>
</tr><tr><td align="left" ><i>(make-instance &#x2019;r &#x2019;b 4)</i>       </td><td align="left" ><i>(b 4 a 1)</i>                 </td><td align="left" ><i>4</i>         </td>
</tr><tr><td align="left" ><i>(make-instance &#x2019;r &#x2019;a 1 &#x2019;a 2)</i> </td><td align="left" ><i>(a 1 a 2 b 2)</i>             </td><td align="left" ><i>1</i>         </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" >  </td></tr></table>
</div></div>
                                                                          

                                                                          
<!--l. 2327--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-29700028.1.9"></a>Shared-Initialize</h5>
<!--l. 2330--><p class="noindent" >The generic function <i>shared-initialize</i> is used to ﬁll the slots of an instance using
initialization arguments and <i>:initform</i> forms when an instance is created, when an
instance is re-initialized, when an instance is updated to conform to a redeﬁned
class, and when an instance is updated to conform to a diﬀerent class. It
uses standard method combination. It takes the following arguments:
the instance to be initialized, a speciﬁcation of a set of names of slots
accessible in that instance, and any number of initialization arguments.
The arguments after the ﬁrst two must form an initialization argument
list.
<!--l. 2341--><p class="indent" >   The second argument to <i>shared-initialize</i> may be one of the following:
      <ul class="itemize1">
      <li class="itemize">It can be a list of slot names, which speciﬁes the set of those slot names.
      </li>
      <li class="itemize">It can be <i>nil</i>, which speciﬁes the empty set of slot names.
      </li>
      <li class="itemize">It can be the symbol <i>t</i>, which speciﬁes the set of all of the slots.
      </li></ul>
<!--l. 2356--><p class="indent" >   There is a system-supplied primary method for <i>shared-initialize</i> whose ﬁrst
parameter specializer is the class <i>standard-object</i>. This method behaves as follows
on each slot, whether shared or local:
      <ul class="itemize1">
      <li class="itemize">If an initialization argument in the initialization argument list speciﬁes
      a value for that slot, that value is stored into the slot, even if a value
      has  already  been  stored  in  the  slot  before  the  method  is  run.  The
      aﬀected slots are independent of which slots are indicated by the second
      argument to <i>shared-initialize</i>.
                                                                          

                                                                          
      </li>
      <li class="itemize">Any slots indicated by the second argument that are still unbound at
      this point are initialized according to their <i>:initform</i> forms. For any
      such slot that has an <i>:initform</i> form, that form is evaluated in the
      lexical environment of its deﬁning <i>defclass</i> form and the result is stored
      into the slot. For example, if a <i>:before</i> method stores a value in the slot,
      the <i>:initform</i> form will not be used to supply a value for the slot. If
      the second argument speciﬁes a name that does not correspond to any
      slots accessible in the instance, the results are unspeciﬁed.
      </li>
      <li class="itemize">The rules mentioned in section <a 
href="#x183-29600028.1.9">28.1.9<!--tex4ht:ref: Rules-for-Initialization-Arguments-SECTION --></a> are obeyed.
      </li></ul>
<!--l. 2383--><p class="indent" >   The generic function <i>shared-initialize</i> is called by the system-supplied primary
methods for the generic functions <i>initialize-instance</i>, <i>reinitialize-instance</i>,
<i>update-instance-for-diﬀerent-class</i>, and <i>update-instance-for-redeﬁned-class</i>. Thus
methods can be written for <i>shared-initialize</i> to specify actions that should be
taken in all of these contexts.
<!--l. 2394--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-29800028.1.9"></a>Initialize-Instance</h5>
<!--l. 2396--><p class="noindent" >The generic function <i>initialize-instance</i> is called by <i>make-instance</i> to initialize a
newly created instance. It uses standard method combination. Methods for
<i>initialize-instance</i> can be deﬁned in order to perform any initialization that
cannot be achieved with the simple slot-ﬁlling mechanisms.
                                                                          

                                                                          
<!--l. 2405--><p class="indent" >   During initialization, <i>initialize-instance</i> is invoked after the following actions
have been taken:
      <ul class="itemize1">
      <li class="itemize">The  defaulted  initialization  argument  list  has  been  computed  by
      combining the supplied initialization argument list with any default
      initialization arguments for the class.
      </li>
      <li class="itemize">The  validity  of  the  defaulted  initialization  argument  list  has  been
      checked. If any of the initialization arguments has not been declared
      valid, an error is signaled.
      </li>
      <li class="itemize">A new instance whose slots are unbound has been created.
      </li></ul>
<!--l. 2422--><p class="indent" >   The generic function <i>initialize-instance</i> is called with the new instance and the
defaulted initialization arguments. There is a system-supplied primary
method for <i>initialize-instance</i> whose parameter specializer is the class
<i>standard-object</i>. This method calls the generic function <i>shared-initialize</i> to ﬁll
in the slots according to the initialization arguments and the <i>:initform</i>
forms for the slots; the generic function <i>shared-initialize</i> is called with
the following arguments: the instance, <i>t</i>, and the defaulted initialization
arguments.
<!--l. 2432--><p class="indent" >   Note that <i>initialize-instance</i> provides the defaulted initialization argument list
in its call to <i>shared-initialize</i>, so the ﬁrst step performed by the system-supplied
primary method for <i>shared-initialize</i> takes into account both the initialization
arguments provided in the call to <i>make-instance</i> and the defaulted initialization
argument list.
<!--l. 2439--><p class="indent" >   Methods for <i>initialize-instance</i> can be deﬁned to specify actions to be taken
when an instance is initialized. If only <i>:after</i> methods for <i>initialize-instance</i> are
deﬁned, they will be run after the system-supplied primary method for
initialization and therefore they will not interfere with the default behavior of
<i>initialize-instance</i>.
<!--l. 2446--><p class="indent" >   The Object System provides two functions that are useful in the bodies of
<i>initialize-instance</i> methods. The function <i>slot-boundp</i> returns a boolean value that
indicates whether a speciﬁed slot has a value; this provides a mechanism for
                                                                          

                                                                          
writing <i>:after</i> methods for <i>initialize-instance</i> that initialize slots only if they have
not already been initialized. The function <i>slot-makunbound</i> causes the slot to have
no value.
<!--l. 2455--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-29900028.1.9"></a>Deﬁnitions of Make-Instance and Initialize-Instance</h5>
<!--l. 2457--><p class="noindent" >The generic function <i>make-instance</i> behaves as if it were deﬁned as follows, except
that certain optimizations are permitted:
                                                                          

                                                                          
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod make-instance ((class standard-class) &#x0026;rest initargs)
</td></tr></table>
<!--l. 2463--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setq initargs (default-initargs class initargs))</td></tr></table>
<!--l. 2464--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 2465--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((instance (apply #&#x2019;allocate-instance class initargs)))</td></tr></table>
<!--l. 2466--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (apply #&#x2019;initialize-instance instance initargs)</td></tr></table>
<!--l. 2467--><p class="indent" >                                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    instance))</td></tr></table>
<!--l. 2468--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 2469--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod make-instance ((class-name symbol) &#x0026;rest initargs)</td></tr></table>
<!--l. 2470--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (apply #&#x2019;make-instance (ﬁnd-class class-name) initargs))</td></tr></table>
<!--l. 2472--><p class="indent" >
</div>
</div>
<!--l. 2497--><p class="indent" >   The elided code in the deﬁnition of <i>make-instance</i> checks the supplied
initialization arguments to determine whether an initialization argument
was supplied that neither ﬁlled a slot nor supplied an argument to an
applicable method. This check could be implemented using the generic
functions <i>class-prototype</i>, <i>compute-applicable-methods</i>, <i>function-keywords</i>,
and <i>class-slot-initargs</i>. See the third part of the Common Lisp Object
System speciﬁcation for a description of this initialization argument check. [The
third part has not yet been approved by X3J13 for inclusion in the forthcoming
Common Lisp standard and is not included in this book.—GLS]
<!--l. 2509--><p class="indent" >   The generic function <i>initialize-instance</i> behaves as if it were deﬁned as follows,
except that certain optimizations are permitted:
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmethod initialize-instance
</td></tr></table>
<!--l. 2513--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           ((instance standard-object) &#x0026;rest initargs)</td></tr></table>
<!--l. 2514--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (apply #&#x2019;shared-initialize instance t initargs)))</td></tr></table>
                                                                          

                                                                          
<!--l. 2516--><p class="indent" >
</div>
</div>
<!--l. 2518--><p class="indent" >   These procedures can be customized at either the Programmer Interface level,
the meta-object level, or both.
<!--l. 2521--><p class="indent" >   Customizing at the Programmer Interface level includes using the
<i>:initform</i>, <i>:initarg</i>, and <i>:default-initargs</i> options to <i>defclass</i>, as well as
deﬁning methods for <i>make-instance</i> and <i>initialize-instance</i>. It is also possible
to deﬁne methods for <i>shared-initialize</i>, which would be invoked by the
generic functions <i>reinitialize-instance</i>, <i>update-instance-for-redeﬁned-class</i>,
<i>update-instance-for-diﬀerent-class</i>, and <i>initialize-instance</i>. The meta-object level
supports additional customization by allowing methods to be deﬁned on
<i>make-instance</i>, <i>default-initargs</i>, and <i>allocate-instance</i>. Parts 2 and 3 of the
Common Lisp Object System speciﬁcation document each of these generic
functions and the system-supplied primary methods. [The third part has not yet
been approved by X3J13 for inclusion in the forthcoming Common Lisp standard
and is not included in this book.—GLS]
<!--l. 2538--><p class="indent" >   Implementations are permitted to make certain optimizations to
<i>initialize-instance</i> and <i>shared-initialize</i>. The description of <i>shared-initialize</i> in
section <a 
href="clmse151.html#x184-31100028.2">28.2<!--tex4ht:ref: Functions-in-the-Programmer-Interface-SECTION --></a> mentions the possible optimizations.
<!--l. 2545--><p class="indent" >   Because of optimization, the check for valid initialization arguments
might not be implemented using the generic functions <i>class-prototype</i>,
<i>compute-applicable-methods</i>, <i>function-keywords</i>, and <i>class-slot-initargs</i>.
In addition, methods for the generic function <i>default-initargs</i> and the
system-supplied primary methods for <i>allocate-instance</i>, <i>initialize-instance</i>, and
<i>shared-initialize</i> might not be called on every call to <i>make-instance</i> or might not
receive exactly the arguments that would be expected.
<!--l. 2557--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.10   </span> <a 
 id="x183-30000028.1.10"></a>Redeﬁning Classes</h4>
<!--l. 2560--><p class="noindent" >A class that is an instance of <i>standard-class</i> can be redeﬁned if the new class will
also be an instance of <i>standard-class</i>. Redeﬁning a class modiﬁes the existing class
object to reﬂect the new class deﬁnition; it does not create a new class
object for the class. Any method object created by a <i>:reader</i>, <i>:writer</i>, or
<i>:accessor</i> option speciﬁed by the old <i>defclass</i> form is removed from the
corresponding generic function. Methods speciﬁed by the new <i>defclass</i> form are
                                                                          

                                                                          
added.
<!--l. 2573--><p class="indent" >   When the class C is redeﬁned, changes are propagated to its instances and to
instances of any of its subclasses. Updating such an instance occurs at an
implementation-dependent time, but no later than the next time a slot of that
instance is read or written. Updating an instance does not change its identity as
deﬁned by the <i>eq</i> function. The updating process may change the slots of that
particular instance, but it does not create a new instance. Whether updating an
instance consumes storage is implementation-dependent.
<!--l. 2582--><p class="indent" >   Note that redeﬁning a class may cause slots to be added or deleted. If a class is
redeﬁned in a way that changes the set of local slots accessible in instances, the
instances will be updated. It is implementation-dependent whether instances are
updated if a class is redeﬁned in a way that does not change the set of local slots
accessible in instances.
<!--l. 2589--><p class="indent" >   The value of a slot that is speciﬁed as shared both in the old class and in the
new class is retained. If such a shared slot was unbound in the old class, it will be
unbound in the new class. Slots that were local in the old class and that
are shared in the new class are initialized. Newly added shared slots are
initialized.
<!--l. 2595--><p class="indent" >   Each newly added shared slot is set to the result of evaluating the captured
<i>:initform</i> form for the slot that was speciﬁed in the <i>defclass</i> form for the new
class. If there is no <i>:initform</i> form, the slot is unbound.
<!--l. 2600--><p class="indent" >   If a class is redeﬁned in such a way that the set of local slots accessible in an
instance of the class is changed, a two-step process of updating the instances of
the class takes place. The process may be explicitly started by invoking the
generic function <i>make-instances-obsolete</i>. This two-step process can happen
in other circumstances in some implementations. For example, in some
implementations this two-step process will be triggered if the order of slots in
storage is changed.
<!--l. 2609--><p class="indent" >   The ﬁrst step modiﬁes the structure of the instance by adding new local slots
and discarding local slots that are not deﬁned in the new version of the class. The
second step initializes the newly added local slots and performs any other
user-deﬁned actions. These steps are further speciﬁed in the next two
sections.
<!--l. 2616--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-30100028.1.10"></a>Modifying the Structure of Instances</h5>
                                                                          

                                                                          
<!--l. 2618--><p class="noindent" >The ﬁrst step modiﬁes the structure of instances of the redeﬁned class
to conform to its new class deﬁnition. Local slots speciﬁed by the new
class deﬁnition that are not speciﬁed as either local or shared by the
old class are added, and slots not speciﬁed as either local or shared by
the new class deﬁnition that are speciﬁed as local by the old class are
discarded. The names of these added and discarded slots are passed as
arguments to <i>update-instance-for-redeﬁned-class</i> as described in the next
section.
<!--l. 2627--><p class="indent" >   The values of local slots speciﬁed by both the new and old classes are retained.
If such a local slot was unbound, it remains unbound.
<!--l. 2630--><p class="indent" >   The value of a slot that is speciﬁed as shared in the old class and as local in
the new class is retained. If such a shared slot was unbound, the local slot will be
unbound.
<!--l. 2635--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-30200028.1.10"></a>Initializing Newly Added Local Slots</h5>
<!--l. 2637--><p class="noindent" >The second step initializes the newly added local slots and performs any other
user-deﬁned actions. This step is implemented by the generic function
<i>update-instance-for-redeﬁned-class</i>, which is called after completion of the ﬁrst
step of modifying the structure of the instance.
<!--l. 2643--><p class="indent" >   The generic function <i>update-instance-for-redeﬁned-class</i> takes four required
arguments: the instance being updated after it has undergone the ﬁrst step, a list
of the names of local slots that were added, a list of the names of local slots that
were discarded, and a property list containing the slot names and values of slots
that were discarded and had values. Included among the discarded slots
are slots that were local in the old class and that are shared in the new
class.
<!--l. 2652--><p class="indent" >   The generic function <i>update-instance-for-redeﬁned-class</i> also takes any number
of initialization arguments. When it is called by the system to update an
instance whose class has been redeﬁned, no initialization arguments are
provided.
<!--l. 2657--><p class="indent" >   There is a system-supplied primary method for the generic function
<i>update-instance-for-redeﬁned-class</i> whose parameter specializer for its instance
argument is the class <i>standard-object</i>. First this method checks the validity of
initialization arguments and signals an error if an initialization argument is
supplied that is not declared valid (see section <a 
href="#x183-29400028.1.9">28.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>.) Then it calls the generic
                                                                          

                                                                          
function <i>shared-initialize</i> with the following arguments: the instance, the list
of names of the newly added slots, and the initialization arguments it
received.
<!--l. 2670--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-30300028.1.10"></a>Customizing Class Redeﬁnition</h5>
<!--l. 2672--><p class="noindent" >Methods for <i>update-instance-for-redeﬁned-class</i> may be deﬁned to specify
actions to be taken when an instance is updated. If only <i>:after</i> methods for
<i>update-instance-for-redeﬁned-class</i> are deﬁned, they will be run after the
system-supplied primary method for initialization and therefore will not interfere
with the default behavior of <i>update-instance-for-redeﬁned-class</i>. Because no
initialization arguments are passed to <i>update-instance-for-redeﬁned-class</i> when it
is called by the system, the <i>:initform</i> forms for slots that are ﬁlled by <i>:before</i>
methods for <i>update-instance-for-redeﬁned-class</i> will not be evaluated by
<i>shared-initialize</i>.
<!--l. 2684--><p class="indent" >   Methods for <i>shared-initialize</i> may be deﬁned to customize class redeﬁnition
(see section <a 
href="#x183-29700028.1.9">28.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
<!--l. 2688--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-30400028.1.10"></a>Extensions</h5>
<!--l. 2690--><p class="noindent" >There are two allowed extensions to class redeﬁnition:
      <ul class="itemize1">
      <li class="itemize">The Object System may be extended to permit the new class to be an
      instance of a metaclass other than the metaclass of the old class.
      </li>
      <li class="itemize">The Object System may be extended to support an updating process
      when either the old or the new class is an instance of a class other than
      <i>standard-class</i> that is not a built-in class.
      </li></ul>
                                                                          

                                                                          
<!--l. 2705--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.11   </span> <a 
 id="x183-30500028.1.11"></a>Changing the Class of an Instance</h4>
<!--l. 2708--><p class="noindent" >The function <i>change-class</i> can be used to change the class of an instance from its
current class, C<sub>from</sub>, to a diﬀerent class, C<sub>to</sub>; it changes the structure of the
instance to conform to the deﬁnition of the class C<sub>to</sub>.
<!--l. 2714--><p class="indent" >   Note that changing the class of an instance may cause slots to be added or
deleted.
<!--l. 2717--><p class="indent" >   When <i>change-class</i> is invoked on an instance, a two-step updating process
takes place. The ﬁrst step modiﬁes the structure of the instance by adding new
local slots and discarding local slots that are not speciﬁed in the new version of
the instance. The second step initializes the newly added local slots and performs
any other user-deﬁned actions. These steps are further described in the following
two sections.
<!--l. 2725--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-30600028.1.11"></a>Modifying the Structure of an Instance</h5>
<!--l. 2727--><p class="noindent" >In order to make an instance conform to the class C<sub>to</sub>, local slots speciﬁed by the
class C<sub>to</sub> that are not speciﬁed by the class C<sub>from</sub> are added, and local slots
not speciﬁed by the class C<sub>to</sub> that are speciﬁed by the class C<sub>from</sub> are
discarded.
<!--l. 2734--><p class="indent" >   The values of local slots speciﬁed by both the class C<sub>to</sub> and the class C<sub>from</sub> are
retained. If such a local slot was unbound, it remains unbound.
<!--l. 2739--><p class="indent" >   The values of slots speciﬁed as shared in the class C<sub>from</sub> and as local in the
class C<sub>to</sub> are retained.
<!--l. 2743--><p class="indent" >   This ﬁrst step of the update does not aﬀect the values of any shared
slots.
<!--l. 2747--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-30700028.1.11"></a>Initializing Newly Added Local Slots</h5>
<!--l. 2749--><p class="noindent" >The second step of the update initializes the newly added slots and
performs any other user-deﬁned actions. This step is implemented by the
generic function <i>update-instance-for-diﬀerent-class</i>. The generic function
<i>update-instance-for-diﬀerent-class</i> is invoked by <i>change-class</i> after the ﬁrst step of
the update has been completed.
<!--l. 2756--><p class="indent" >   The generic function <i>update-instance-for-diﬀerent-class</i> is invoked on two
                                                                          

                                                                          
arguments computed by <i>change-class</i>. The ﬁrst argument passed is a copy of the
instance being updated and is an instance of the class C<sub>from</sub>; this copy has
dynamic extent within the generic function <i>change-class</i>. The second argument is
the instance as updated so far by <i>change-class</i> and is an instance of the class
C<sub>to</sub>.
<!--l. 2764--><p class="indent" >   The generic function <i>update-instance-for-diﬀerent-class</i> also takes any number
of initialization arguments. When it is called by <i>change-class</i>, no initialization
arguments are provided.
<!--l. 2768--><p class="indent" >   There is a system-supplied primary method for the generic function
<i>update-instance-for-diﬀerent-class</i> that has two parameter specializers, each of
which is the class <i>standard-object</i>. First this method checks the validity of
initialization arguments and signals an error if an initialization argument is
supplied that is not declared valid (see section <a 
href="#x183-29400028.1.9">28.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>). Then it calls the generic
function <i>shared-initialize</i> with the following arguments: the instance, a list
of names of the newly added slots, and the initialization arguments it
received.
<!--l. 2780--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-30800028.1.11"></a>Customizing the Change of Class of an Instance</h5>
<!--l. 2782--><p class="noindent" >Methods for <i>update-instance-for-diﬀerent-class</i> may be deﬁned to specify
actions to be taken when an instance is updated. If only <i>:after</i> methods for
<i>update-instance-for-diﬀerent-class</i> are deﬁned, they will be run after the
system-supplied primary method for initialization and will not interfere with the
default behavior of <i>update-instance-for-diﬀerent-class</i>. Because no initialization
arguments are passed to <i>update-instance-for-diﬀerent-class</i> when it is called
by <i>change-class</i>, the <i>:initform</i> forms for slots that are ﬁlled by <i>:before</i>
methods for <i>update-instance-for-diﬀerent-class</i> will not be evaluated by
<i>shared-initialize</i>.
<!--l. 2794--><p class="indent" >   Methods for <i>shared-initialize</i> may be deﬁned to customize class redeﬁnition
(see section <a 
href="#x183-29700028.1.9">28.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
<!--l. 2797--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.12   </span> <a 
 id="x183-30900028.1.12"></a>Reinitializing an Instance</h4>
<!--l. 2800--><p class="noindent" >The generic function <i>reinitialize-instance</i> may be used to change the values of
slots according to initialization arguments.
                                                                          

                                                                          
<!--l. 2803--><p class="indent" >   The process of reinitialization changes the values of some slots and performs
any user-deﬁned actions.
<!--l. 2806--><p class="indent" >   Reinitialization does not modify the structure of an instance to add or delete
slots, and it does not use any <i>:initform</i> forms to initialize slots.
<!--l. 2810--><p class="indent" >   The generic function <i>reinitialize-instance</i> may be called directly. It takes one
required argument, the instance. It also takes any number of initialization
arguments to be used by methods for <i>reinitialize-instance</i> or for <i>shared-initialize</i>.
The arguments after the required instance must form an initialization argument
list.
<!--l. 2817--><p class="indent" >   There is a system-supplied primary method for <i>reinitialize-instance</i> whose
parameter specializer is the class <i>standard-object</i>. First this method checks the
validity of initialization arguments and signals an error if an initialization
argument is supplied that is not declared valid (see section <a 
href="#x183-29400028.1.9">28.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>). Then it calls
the generic function <i>shared-initialize</i> with the following arguments: the instance,
<i>nil</i>, and the initialization arguments it received.
                                                                          

                                                                          
<!--l. 2829--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x183-31000028.1.12"></a>Customizing Reinitialization</h5>
<!--l. 2831--><p class="noindent" >Methods for the generic function <i>reinitialize-instance</i> may be deﬁned to specify
actions to be taken when an instance is updated. If only <i>:after</i> methods for
<i>reinitialize-instance</i> are deﬁned, they will be run after the system-supplied
primary method for initialization and therefore will not interfere with the default
behavior of <i>reinitialize-instance</i>.
<!--l. 2838--><p class="indent" >   Methods for <i>shared-initialize</i> may be deﬁned to customize class redeﬁnition
(see section <a 
href="#x183-29700028.1.9">28.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
                                                                          

                                                                          
   <!--l. 2842--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse151.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html#tailclmch28.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse150.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch28.html#clmse150.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 2842--><p class="indent" >   <a 
 id="tailclmse150.html"></a>   
</body></html> 
