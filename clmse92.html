<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Информация о массиве</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1274--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse93.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse91.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse91.html#tailclmse91.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse92.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch17.html#clmse92.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">17.3   </span> <a 
href="clm.html#QQ2-114-1488" id="x114-147900017.3">Информация о
массиве</a></h3>
<!--l. 1276--><p class="noindent" >Следующие функции извлекают интересную информацию, и это не элементы
массива.
<div class="defun">
<!--l. 1279--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx114-1479001"></a><a 
 id="x114-1479002r525"></a><b> array-element-type</b>  <i>array</i>
</div>
<!--l. 1281--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-148000017.3" id="x114-148000017.3"></a></span>
<tt>
   <a 
href="#x114-1479002r525">array-element-type</a></tt> возвращает спецификатор типа для множества
объектов, которые могут быть сохранены в массиве <i>array</i>. Это множество
может быть больше чем то, которое запрашивалось в функции <tt><a 
href="clmse90.html#x112-1460002r518">make-array</a></tt>.
Например, результат <div class="lisp"><div class="tabbing">
(array-element-type (make-array 5 :element-type &#x2019;(mod 5)))
   <br>
<!--l. 1288--><p class="noindent" ></div>
<!--l. 1288--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-148100017.3" id="x114-148100017.3"></a></span>
<!--l. 1288--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-148200017.3" id="x114-148200017.3"></a></span>
</div>
<!--l. 1289--><p class="indent" >   может быть <tt>(mod 5)</tt>, <tt>(mod 8)</tt>, <tt>fixnum</tt>, <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> или любой другой тип, для
которого <tt>(mod 5)</tt> является подтипом. Смотрите <tt><a 
href="clmse32.html#x43-319002r21">subtypep</a></tt>.
</div>
<div class="defun">
<!--l. 1293--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx114-1482001"></a><a 
 id="x114-1482002r526"></a><b> array-rank</b>  <i>array</i>
</div>
                                                                          

                                                                          
<!--l. 1295--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-148300017.3" id="x114-148300017.3"></a></span>
   Эта функция возвращает количество измерений (осей) массива <i>array</i>.
Результат будет неотрицательным целым. Смотрите <tt><a 
href="clmse90.html#x112-1465002r519">array-rank-limit</a></tt>.
</div>
<div class="defun">
<!--l. 1301--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx114-1483001"></a><a 
 id="x114-1483002r527"></a><b> array-dimension</b>  <i>array</i> <i>axis-number</i>
</div>
<!--l. 1303--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-148400017.3" id="x114-148400017.3"></a></span>
   Данная функция возвращает размер измерения <i>axis-number</i> массива <i>array</i>.
<i>array</i> может быть любым видом массива, и <i>axis-number</i> должен быть
неотрицательным целым меньшим чем ранг массива <i>array</i>. Если <i>array</i>
является вектором с указателем заполнения, <tt><a 
href="#x114-1483002r527">array-dimension</a></tt> возвращает
общий размер вектора, включая неактивные элементы, а не размер
ограниченный указателем заполнения. (Функция <tt><a 
href="clmse77.html#x96-1202002r368">length</a></tt> будет возвращать
размер ограниченный указателем заполнения.)
</div>
<div class="defun">
<!--l. 1315--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx114-1484001"></a><a 
 id="x114-1484002r528"></a><b> array-dimensions</b>  <i>array</i>
</div>
<!--l. 1317--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-148500017.3" id="x114-148500017.3"></a></span>
<tt>
   <a 
href="#x114-1484002r528">array-dimensions</a></tt> возвращает список, элементы которого являются
размерами измерений массива <i>array</i>.
</div>
<div class="defun">
<!--l. 1322--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx114-1485001"></a><a 
 id="x114-1485002r529"></a><b> array-total-size</b>  <i>array</i>
</div>
<!--l. 1324--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-148600017.3" id="x114-148600017.3"></a></span>
<tt>
   <a 
href="#x114-1485002r529">array-total-size</a></tt> возвращает общее количество элементов массива
<i>array</i>, которое вычислено как произведение размеров всех измерений.
<div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(array-total-size <i>x</i>)
   <br>                                             <span class="math"> ≡</span> (apply #&#x2019;* (array-dimensions <i>x</i>))<br>
   <span class="math"> ≡</span> (reduce #&#x2019;* (array-dimensions <i>x</i>))<br>
<!--l. 1331--><p class="noindent" ></div>
<!--l. 1331--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-148700017.3" id="x114-148700017.3"></a></span>
<!--l. 1331--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-148800017.3" id="x114-148800017.3"></a></span>
</div>
<!--l. 1332--><p class="indent" >   Следует отметить, что общий размер нульмерного (FIXME) массива равен
<tt>1</tt>. Общий размер одномерного массива вычисляется без учёта указателя
заполнения.
</div>
<div class="defun">
<!--l. 1336--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx114-1488001"></a><a 
 id="x114-1488002r530"></a><b> array-in-bounds-p</b>  <i>array</i> &#x0026;rest  <i>subscripts</i>
</div>
<!--l. 1338--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-148900017.3" id="x114-148900017.3"></a></span>
   Данный предикат проверяет, являются ли индексы <i>subscripts</i> для массива
<i>array</i> корректными. Если они корректны, предикат истинен, иначе ложен.
<i>subscripts</i> должен быть целыми числами. Количество индексов <i>subscripts</i>
должно равняться рангу массива. Как и <tt><a 
href="clmse91.html#x113-1472002r523">aref</a></tt>, <tt><a 
href="#x114-1488002r530">array-in-bounds-p</a></tt> игнорирует
указатели заполнения.
</div>
<div class="defun">
<!--l. 1347--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx114-1489001"></a><a 
 id="x114-1489002r531"></a><b> array-row-major-index</b>  <i>array</i> &#x0026;rest  <i>subscripts</i>
</div>
<!--l. 1349--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-149000017.3" id="x114-149000017.3"></a></span>
   Данная функция принимает массив и корректные для него индексы и
возвращает одиночное неотрицательное целое значение меньшее чем
общий размер массива, которое идентифицирует элемент, полагаясь на
построчный порядок хранения элементов. Количество указанных индексов
<i>subscripts</i> должно равняться рангу массива. Каждый индекс должен быть
неотрицательным целым числом меньшим чем соответствующий размер
                                                                          

                                                                          
измерения. Как и <tt><a 
href="clmse91.html#x113-1472002r523">aref</a></tt>, <tt><a 
href="#x114-1489002r531">array-row-major-index</a></tt> игнорирует указатели
заполнения.
<!--l. 1359--><p class="indent" >   Возможно определение <tt><a 
href="#x114-1489002r531">array-row-major-index</a></tt>, без проверки на ошибки,
может выглядеть так: <div class="lisp"><div class="tabbing">
(defun array-row-major-index (a <tt>&#x0026;rest</tt> subscripts)
   <br>                                            (apply #&#x2019;+ (maplist #&#x2019;(lambda (x y)<br>
                          (* (car x) (apply #&#x2019;* (cdr y))))<br>
                      subscripts<br>
                      (array-dimensions a))))<br>
<!--l. 1367--><p class="noindent" ></div>
<!--l. 1367--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-149100017.3" id="x114-149100017.3"></a></span>
<!--l. 1367--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-149200017.3" id="x114-149200017.3"></a></span>
</div>
<!--l. 1368--><p class="indent" >   Для одномерного массива, результат <tt><a 
href="#x114-1489002r531">array-row-major-index</a></tt> всегда равен
переданному индексу.
</div>
<div class="defun">
<!--l. 1372--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx114-1492001"></a><a 
 id="x114-1492002r532"></a><b> row-major-aref</b>  <i>array</i> <i>index</i>
</div>
<!--l. 1374--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-149300017.3" id="x114-149300017.3"></a></span>
   Данная функция позволяет получить доступ к элементу, как если бы
массив был одномерный. Аргумент <i>index</i> должен быть неотрицательным
целым меньшим чем общий размер массива <i>array</i>. Данная функция
индексирует массив, как если бы он был одномерный с построчным
порядком. Эту функцию можно понять в терминах <tt><a 
href="clmse91.html#x113-1472002r523">aref</a></tt>: <div class="lisp"><div class="tabbing">
(row-major-aref <i>array</i> <i>index</i>) <span class="math"> ≡</span>
                                                                          

                                                                          
   <br>                  (aref (make-array (array-total-size array))<br>
                    :displaced-to array<br>
                    :element-type (array-element-type array))<br>
        index)<br>
<!--l. 1387--><p class="noindent" ></div>
<!--l. 1387--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-149400017.3" id="x114-149400017.3"></a></span>
<!--l. 1387--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-149500017.3" id="x114-149500017.3"></a></span>
</div>
<!--l. 1388--><p class="indent" >   Другими словами, можно обработать массив как одномерный с помощью
создания нового одномерного массива, который <i>соединён</i> с исходным, и
получить доступ к новому массиву. И наоборот, <tt><a 
href="clmse91.html#x113-1472002r523">aref</a></tt> может быть описана в
терминах <tt><a 
href="#x114-1492002r532">row-major-aref</a></tt>: <div class="lisp"><div class="tabbing">
(aref <i>array</i> <span class="math"><i>i</i><sub>0</sub></span> <span class="math"><i>i</i><sub>1</sub></span> ... <span class="math"><i>i</i><sub>n−1</sub></span>) <span class="math"> ≡</span>
   <br>                             (row-major-aref array<br>
                  (array-row-major-index array <span class="math"><i>i</i><sub>0</sub></span> <span class="math"><i>i</i><sub>1</sub></span> ... <span class="math"><i>i</i><sub>n−1</sub></span>)<br>
<!--l. 1396--><p class="noindent" ></div>
<!--l. 1396--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-149600017.3" id="x114-149600017.3"></a></span>
<!--l. 1396--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-149700017.3" id="x114-149700017.3"></a></span>
</div>
<!--l. 1398--><p class="indent" >   Как и <tt><a 
href="clmse91.html#x113-1472002r523">aref</a></tt>, <tt><a 
href="#x114-1492002r532">row-major-aref</a></tt> полностью игнорирует указатели
заполнения. Для изменения элемента массива, можно комбинировать вызов
<tt><a 
href="#x114-1492002r532">row-major-aref</a></tt> с формой <tt><a 
href="clmse36.html#x48-474002r64">setf</a></tt>.
<!--l. 1403--><p class="indent" >   Эта операция облегчает написание кода, который обрабатывает массивы
различных рангов. Предположим, что необходимо обнулить содержимое
массива <tt>tennis-scores</tt>. Можно решить это так: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(ﬁll (make-array (array-total-size tennis-scores)
   <br>                     :element-type (array-element-type tennis-scores)<br>
                  :displaced-to tennis-scores)<br>                        0)<br>
<!--l. 1411--><p class="noindent" ></div>
<!--l. 1411--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-149800017.3" id="x114-149800017.3"></a></span>
<!--l. 1411--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-149900017.3" id="x114-149900017.3"></a></span>
</div>
<!--l. 1412--><p class="indent" >   К сожалению, так как <tt><a 
href="clmse79.html#x98-1219002r380">fill</a></tt> не может принимать многомерные массивы, в
данном примере создаётся <i>соединённый</i> массив, что является лишней
операцией. Другим способом является отдельная обработка каждого
измерения многомерного массива: <div class="lisp"><div class="tabbing">
(ecase (array-rank tennis-scores)
   <br>                                                      (0 (setf (aref tennis-scores) 0))<br>
  (1 (dotimes (i0 (array-dimension tennis-scores 0))<br>
       (setf (aref tennis-scores i0) 0)))<br>  (2 (dotimes (i0 (array-dimension tennis-scores 0))<br>
       (dotimes (i1 (array-dimension tennis-scores 1))<br>
         (setf (aref tennis-scores i0 i1) 0))))<br>                            ...<br>
  (7 (dotimes (i0 (array-dimension tennis-scores 0))<br>
       (dotimes (i1 (array-dimension tennis-scores 1))<br>
         (dotimes (i2 (array-dimension tennis-scores 1))<br>
           (dotimes (i3 (array-dimension tennis-scores 1))<br>
             (dotimes (i4 (array-dimension tennis-scores 1))<br>
               (dotimes (i5 (array-dimension tennis-scores 1))<br>
                 (dotimes (i6 (array-dimension tennis-scores 1))<br>
                   (setf (aref tennis-scores i0 i1 i2 i3 i4 i5 i6)<br>
                         0)))))))))<br>                                   )<br>
<!--l. 1435--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1435--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-150000017.3" id="x114-150000017.3"></a></span>
<!--l. 1435--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-150100017.3" id="x114-150100017.3"></a></span>
</div>
<!--l. 1436--><p class="indent" >   От такого кода быстро приходит усталость. Кроме того, данный подход
не желателен, так как некоторые реализации Common Lisp&#x2019;а будут
фактически поддерживать не более 7 измерений. Рекурсивно вложенные
циклы справляются с задачей лучше, но код всё ещё выглядит как лапша:
<div class="lisp"><div class="tabbing">
(labels
   <br>                                                     ((grok-any-rank (&#x0026;rest indices)<br>
     (let ((d (- (array-rank tennis-scores) (length indices)))<br>
       (if (= d 0)<br>              (setf (apply #&#x2019;row-major-aref indices) 0)<br>
           (dotimes (i (array-dimension tennis-scores (- d 1)))<br>
             (apply #&#x2019;grok-any-rank i indices))))))<br>     (grok-any-rank))<br>
<!--l. 1449--><p class="noindent" ></div>
<!--l. 1449--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-150200017.3" id="x114-150200017.3"></a></span>
<!--l. 1449--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-150300017.3" id="x114-150300017.3"></a></span>
</div>
<!--l. 1450--><p class="indent" >   Является ли этот код эффективным зависит от многих параметров
реализации, таких как способ обработки <tt>&#x0026;rest</tt> аргументов и компиляции
<tt><a 
href="clmse37.html#x49-568002r73">apply</a></tt> вызовов. Только посмотрите как просто использовать для задачи
<tt><a 
href="#x114-1492002r532">row-major-aref</a></tt>! <div class="lisp"><div class="tabbing">
(dotimes (i (array-total-size tennis-scores))
   <br>                                         (setf (row-major-aref tennis-scores i) 0))<br>
<!--l. 1456--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1456--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-150400017.3" id="x114-150400017.3"></a></span>
<!--l. 1456--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-150500017.3" id="x114-150500017.3"></a></span>
</div>
<!--l. 1457--><p class="indent" >   Нет сомнения, что этот код, слаще любых медовых сот.
</div>
<div class="defun">
<!--l. 1460--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx114-1505001"></a><a 
 id="x114-1505002r533"></a><b> adjustable-array-p</b>  <i>array</i>
</div>
<!--l. 1462--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-150600017.3" id="x114-150600017.3"></a></span>
   Если аргумент, который должен быть массивом, может быть расширен,
данный предикат истинен, иначе ложен.
</div>
<div class="defun">
<!--l. 1467--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx114-1506001"></a><a 
 id="x114-1506002r534"></a><b> array-displacement</b>  <i>array</i>
</div>
<!--l. 1469--><p class="noindent" ><span class="paragraphHead"><a 
href="#x114-150700017.3" id="x114-150700017.3"></a></span>
   функция возвращает два значение. Первое значение является массивом
соединенным с данным, и второе значение обозначает смещение соединения.
Если массив не был соединен ни с одним массивом возвращаются значения
<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> и <tt>0</tt>.
</div>
                                                                          

                                                                          
<!--l. 1475--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse93.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse91.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse91.html#tailclmse91.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse92.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch17.html#clmse92.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse92.html"></a>  </div> </div> 
</body></html> 
