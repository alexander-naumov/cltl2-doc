<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Optimization</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 23:44:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1157--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse153.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse151.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse151.html#tailclmse151.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse152.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmap1.html#clmse152.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">A.3   </span> <a 
href="clm.html#QQ2-186-3357" id="x186-3311000A.3">Optimization</a></h3>
<!--l. 1159--><p class="noindent" >Series expressions are transformed into loops by pipelining them—the
computation is converted from a form where entire series are computed one
after the other to a form where the series are incrementally computed in
parallel. In the resulting loop, each individual element is computed just once,
used, and then discarded before the next element is computed. For this
pipelining to be possible, a number of restrictions have to be satisﬁed. Before
these restrictions are explained, it will be useful to consider a related
issue.
<!--l. 1168--><p class="indent" >   The composition of two series functions cannot be pipelined unless the
destination function consumes series elements in the same order that
the source function produces them. Taken together, the series functions
guarantee that this will always be true, because they all follow the same
ﬁxed processing order. In particular, they are all <i>preorder</i> functions—they
process the elements of their series inputs and outputs in ascending order
starting with the ﬁrst element. Further, while it is easy for users to deﬁne
new series functions, it is impossible to deﬁne one that is not a preorder
function.
<!--l. 1178--><p class="indent" >   It turns out that most series operations can easily be implemented in a
preorder fashion, the most notable exceptions being reversal and sorting. As a
result, little is lost by outlawing non-preorder series functions. If some
non-preorder operation has to be applied to a series, the series can be collected
into a list or vector and the operation applied to this new data structure. (This is
ineﬃcient, but no less eﬃcient than what would be required if non-preorder series
functions were supported.)
<!--l. 1186--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.3.1   </span> <a 
href="clmli1.html#QQ2-186-3358" id="x186-3312000A.3.1">Basic Restrictions</a></h4>
<!--l. 1188--><p class="noindent" >The transformation of series expressions into loops is required to occur at some
time before compiled code is actually run. Optimization may or may not be
applied to interpreted code. If any of the restrictions described below are violated,
                                                                          

                                                                          
optimization is not possible. In this situation, a warning message is issued at the
time optimization is attempted and the code is left unoptimized. This
is not a fatal error and does not prevent the correct results from being
computed. However, given the large improvements in eﬃciency to be gained,
it is well worth ﬁxing any violations that occur. This is usually easy to
do.
<div class="defun">
<!--l. 1198--><p class="noindent" ><div class="defunheader"> <i>[Variable]</i><a 
 id="dx186-3312001"></a><a 
 id="x186-3312002r1059"></a><b> *suppress-series-warnings*</b>
</div>
<!--l. 1200--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3313000A.3.1" id="x186-3313000A.3.1"></a></span>
   If this variable is set (or bound) to anything other than its default value of
<tt><a 
href="clmli7.html#x196-3479650r650">nil</a></tt>, warnings about conditions that block the optimization of series expressions
are suppressed.
</div>
<!--l. 1206--><p class="indent" >   Before the restrictions on series expressions are discussed, it will be useful to
deﬁne precisely what is meant by the term <i>series expression</i>. This term is
semantic rather than syntactic in nature. Imagine a program converted from
Lisp code into a data ﬂow graph. In a data ﬂow graph, functions are
represented as boxes, and both control ﬂow and data ﬂow are represented as
arrows between the boxes. Constructs such as <tt><a 
href="clmli7.html#x196-3479524r524">let</a></tt> and <tt><a 
href="clmli7.html#x196-3479841r841">setq</a></tt> are converted
into patterns of data ﬂow arcs. Control constructs such as <tt><a 
href="clmli7.html#x196-3479469r469">if</a></tt> and <tt><a 
href="clmli7.html#x196-3479558r558">loop</a></tt>
are converted into patterns of control ﬂow arcs. Suppose further that
all loops have been converted into tail recursions so that the graph is
acyclic.
<!--l. 1217--><p class="indent" >   A series expression is a subgraph of the data ﬂow graph for a program that
contains a group of interacting series functions. More speciﬁcally, given a call <i>f </i> on
a series function, the series expression <i>E</i> containing it is deﬁned as follows. <i>E</i>
contains <i>f </i>. Every function using a series created by a function in <i>E</i> is in <i>E</i>.
Every function computing a series used by a function in <i>E</i> is in <i>E</i>. Finally,
suppose that two functions <i>g</i> and <i>h</i> are in <i>E</i> and that there is a data ﬂow
path consisting of series and/or non-series data ﬂow arcs from <i>g</i> to <i>h</i>.
Every function touched by this path (be it a series function or not) is
in <i>E</i>.
<!--l. 1227--><p class="indent" >   For optimization to be possible, series expressions have to be
statically analyzable. As with most other optimization processes, a series
expression cannot be transformed into a loop at compile time, unless it can be
                                                                          

                                                                          
determined at compile time exactly what computation is being performed. This
places a number of relatively minor limits on what can be written. For example,
for optimization to be possible the type arguments to higher-order functions such
as <tt><a 
href="clmli7.html#x196-3479593r593">map-fn</a></tt> and <tt><a 
href="clmli7.html#x196-3479257r257">collecting-fn</a></tt> have to be quoted constants. Similarly, the
numeric arguments to <tt><a 
href="clmli7.html#x196-3479227r227">chunk</a></tt> have to be constants. In addition, if <tt><a 
href="clmli7.html#x196-3479429r429">funcall</a></tt> is
used to call a series function, the function called has to be of the form
<tt>(function ...)</tt>.
<!--l. 1239--><p class="indent" >   For optimization to be possible, every series created within a series
expression must be used solely inside the expression. If a series is
transmitted outside of the expression that creates it, it has to be physically
represented as a whole. This is incompatible with the transformations
required to pipeline the creating expression. To avoid this problem, a
series must not be returned as a result of a series expression as a whole,
assigned to a free variable, assigned to a special variable, or stored in a
data structure. A corollary of the last point is that when deﬁning new
optimizable series functions, series cannot be passed into <tt>&#x0026;rest</tt> arguments.
Further, optimization is blocked if a series is passed as an argument to an
ordinary Lisp function. Series can be passed only to the series functions in
section <a 
href="clmse151.html#x185-3170000A.2">A.2<!--tex4ht:ref: SERIES-F-SECTION --></a> and to new series functions deﬁned using the declaration
<tt><a 
href="clmli7.html#x196-3479684r684">optimizable-series-function</a></tt>.
<!--l. 1253--><p class="indent" >   For optimization to be possible, series expressions must correspond
to straight-line computations. That is to say, the data ﬂow graph
corresponding to a series expression cannot contain any conditional branches.
(Complex control ﬂow is incompatible with pipelining.) Optimization is possible
in the presence of standard straight-line forms such as <tt><a 
href="clmli7.html#x196-3479745r745">progn</a></tt>, <tt><a 
href="clmli7.html#x196-3479429r429">funcall</a></tt>, <tt><a 
href="clmli7.html#x196-3479841r841">setq</a></tt>,
<tt><a 
href="clmli7.html#x196-3479497r497">lambda</a></tt>, <tt><a 
href="clmli7.html#x196-3479524r524">let</a></tt>, <tt><a 
href="clmli7.html#x196-3479525r525">let*</a></tt>, and <tt>multiple-value-bind</tt> as long as none of the variables
bound are special. There is also no problem with macros as long as they expand
into series functions and straight-line forms. However, optimization is blocked by
forms that specify complex control ﬂow (i.e., conditionals <tt><a 
href="clmli7.html#x196-3479469r469">if</a></tt>, <tt><a 
href="clmli7.html#x196-3479273r273">cond</a></tt>, etc., looping
constructs <tt><a 
href="clmli7.html#x196-3479558r558">loop</a></tt>, <tt><a 
href="clmli7.html#x196-3479339r339">do</a></tt>, etc., or branching constructs <tt><a 
href="clmli7.html#x196-3479936r936">tagbody</a></tt>, <tt><a 
href="clmli7.html#x196-3479457r457">go</a></tt>, <tt>catch</tt>,
etc.).
<!--l. 1267--><p class="indent" >   In the ﬁrst example below, optimization is blocked, because the <tt><a 
href="clmli7.html#x196-3479469r469">if</a></tt> form is
inside the series expression. In the second example, however, optimization is
possible, because although the <tt><a 
href="clmli7.html#x196-3479469r469">if</a></tt> feeds data to the series expression, it is not
inside the corresponding subgraph. Both of the expressions below produce the
same value, but the second one is much more eﬃcient. <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(collect (if ﬂag (scan x) (scan y)))  ;Warning message issued
   <br>                                                           (collect (scan (if ﬂag x y)))<br>
<!--l. 1276--><p class="noindent" ></div>
<!--l. 1276--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3314000A.3.1" id="x186-3314000A.3.1"></a></span>
<!--l. 1276--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3315000A.3.1" id="x186-3315000A.3.1"></a></span>
</div>
<!--l. 1278--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.3.2   </span> <a 
href="clmli1.html#QQ2-186-3362" id="x186-3316000A.3.2">Constraint Cycles</a></h4>
<!--l. 1280--><p class="noindent" >Even if a series expression satisﬁes all of the restrictions above, it still may not
be possible to transform the expression into a loop. The sole remaining
problem is that if a series is used in two places, the two uses may place
incompatible constraints on the times at which series elements should be
produced.
<!--l. 1286--><p class="indent" >   The series expression below shows a situation where this problem arises. The
expression creates a series <tt>x</tt> of the elements in a list. It then creates a normalized
series by dividing each element of <tt>x</tt> by the sum of the elements in <tt>x</tt>.
Finally, the expression returns the maximum of the normalized elements.
<div class="lisp"><div class="tabbing">
(let ((x (scan &#x2019;(1 2 5 2))))           ;Warning message issued
   <br>                     (collect-max (#M/ x (series (collect-sum x))))) <span class="math"> ⇒</span> 1/2<br>
<!--l. 1294--><p class="noindent" ></div>
<!--l. 1294--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3317000A.3.2" id="x186-3317000A.3.2"></a></span>
                                                                          

                                                                          
<!--l. 1294--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3318000A.3.2" id="x186-3318000A.3.2"></a></span>
</div>
<!--l. 1296--><p class="indent" >   The two uses of <tt>x</tt> in the expression place contradictory constraints on the way
pipelined evaluation must proceed; <tt><a 
href="clmli7.html#x196-3479255r255">collect-sum</a></tt> requires that all of the elements
of <tt>x</tt> be produced before the sum can be returned, and <tt><a 
href="clmli7.html#x196-3479830r830">series</a></tt> requires that its
input be available before it can start to produce its output. However, <tt>#M/</tt> requires
that the ﬁrst element of <tt>x</tt> be available at the same time as the ﬁrst element of
the output of <tt><a 
href="clmli7.html#x196-3479830r830">series</a></tt>. For pipelining to work, the ﬁrst element of the
output of <tt><a 
href="clmli7.html#x196-3479830r830">series</a></tt> (and therefore the output of <tt><a 
href="clmli7.html#x196-3479255r255">collect-sum</a></tt>) must be
available before the second element of <tt>x</tt> is produced. Unfortunately, this is
impossible.
<!--l. 1307--><p class="indent" >   The essence of the inconsistency above is the cycle of constraints used in
the argument. This in turn stems from a cycle in the data ﬂow graph
underlying the expression. In ﬁgure <a 
href="#x186-33180011">A.1<!--tex4ht:ref: SERIES-F1-FIGURE --></a> function calls are represented by boxes
and data ﬂow is represented by arrows. Simple arrows indicate the ﬂow
of series values and cross-hatched arrows indicate the ﬂow of non-series
values.
<!--l. 1314--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x186-33180011"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение A.1: </span><span  
class="content">A Constraint Cycle in a Series Expression</span></div><!--tex4ht:label?: x186-33180011 -->
    scan
                  sum       series       #M/         max
                                                                          

                                                                          
<!--l. 1326--><p class="indent" >   </div><hr class="endfigure">
<!--l. 1328--><p class="indent" >   Given a data ﬂow graph corresponding to a series expression, a constraint
cycle is a closed oriented loop of data ﬂow arcs such that each arc is traversed
exactly once and no non-series arc is traversed backward. (Series data ﬂow arcs
can be traversed in either direction.) A constraint cycle is said to <i>pass through</i> an
input or output port when exactly one of the arcs in the cycle touches the port.
In ﬁgure <a 
href="#x186-33180011">A.1<!--tex4ht:ref: SERIES-F1-FIGURE --></a> the data ﬂow arcs touching <tt><a 
href="clmli7.html#x196-3479814r814">scan</a></tt>, <tt><a 
href="clmli7.html#x196-3479923r923">sum</a></tt>, <tt><a 
href="clmli7.html#x196-3479830r830">series</a></tt>, and <tt>#M/</tt>
form a constraint cycle. Note that if the output of <tt><a 
href="clmli7.html#x196-3479814r814">scan</a></tt> were not a series,
this loop would not be a constraint cycle, because there would be no
valid way to traverse it. Also note that while the constraint cycle passes
through all the other ports it touches, it does not pass through the output of
<tt><a 
href="clmli7.html#x196-3479814r814">scan</a></tt>.
<!--l. 1341--><p class="indent" >   Whenever a constraint cycle passes through a non-series output, an argument
analogous to the one above can be constructed and therefore pipelining will be
impossible. When this situation arises, a warning message is issued identifying the
problematical port and the cycle passing through it. For instance, the warning
triggered by the example above states that the constraint cycle associated with
<tt><a 
href="clmli7.html#x196-3479814r814">scan</a></tt>, <tt><a 
href="clmli7.html#x196-3479255r255">collect-sum</a></tt>, <tt><a 
href="clmli7.html#x196-3479830r830">series</a></tt>, and <tt>#M/</tt> passes through the non-series output of
<tt><a 
href="clmli7.html#x196-3479255r255">collect-sum</a></tt>.
<!--l. 1350--><p class="indent" >   Given this kind of detailed information, it is easy to alleviate the problem.
To start with, every cycle must contain at least one function that has
two series data ﬂows leaving it. At worst, the cycle can be broken by
duplicating this function (and any functions computing series used by
it). For instance, the example above can be rewritten as shown below.
<div class="lisp"><div class="tabbing">
(let ((x (scan &#x2019;(1 2 5 2)))
   <br>                                           (sum (collect-sum (scan &#x2019;(1 2 5 2)))))<br>
  (collect-max (#M/ x (series sum))))<br>                             <span class="math"> ⇒</span> 1/2<br>
<!--l. 1361--><p class="noindent" ></div>
<!--l. 1361--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3319000A.3.2" id="x186-3319000A.3.2"></a></span>
<!--l. 1361--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3320000A.3.2" id="x186-3320000A.3.2"></a></span>
                                                                          

                                                                          
</div>
<!--l. 1363--><p class="indent" >   It would be easy enough to automatically apply code copying to break
problematical constraint cycles. However, this is not done for two reasons.
First, there is considerable virtue in maintaining the property that each
function in a series expression turns into one piece of computation in
the loop produced. Users can be conﬁdent that series expressions that
look simple and eﬃcient actually are simple and eﬃcient. Second, with a
little creativity, constraint problems can often be resolved in ways that
are much more eﬃcient than copying code. In the example above, the
conﬂict can be eliminated eﬃciently by interchanging the operation of
computing the maximum with the operation of normalizing an element.
<div class="lisp"><div class="tabbing">
(let ((x (scan &#x2019;(1 2 5 2))))
   <br>                                     (/ (collect-max x) (collect-sum x))) <span class="math"> ⇒</span> 1/2<br>
<!--l. 1377--><p class="noindent" ></div>
<!--l. 1377--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3321000A.3.2" id="x186-3321000A.3.2"></a></span>
<!--l. 1377--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3322000A.3.2" id="x186-3322000A.3.2"></a></span>
</div>
<!--l. 1379--><p class="indent" >   The restriction that optimizable series expressions cannot contain constraint
cycles that pass through non-series outputs places limitations on the qualitative
character of optimizable series expressions. In particular, they all must have the
general form of creating some number of series using scanners, computing various
intermediate series using transducers, and then computing one or more
summary results using collectors. The output of a collector cannot be used
in the intermediate computation unless it is the output of a separate
subexpression.
<!--l. 1388--><p class="indent" >   It is worthy of note that the last expression above ﬁxes the constraint conﬂict
by moving the non-series output out of the cycle, rather than by breaking the
cycle. This illustrates the fact that constraint cycles that do not pass through
non-series outputs do not necessarily cause problems. They cause problems only if
they pass through <i>oﬀ-line</i> ports.
                                                                          

                                                                          
<!--l. 1394--><p class="indent" >   A series input port or series output port of a series function is <i>on-line</i> if
and only if it is processed in lockstep with all the other on-line ports as
follows: the initial element of each on-line input is read, then the initial
element of each on-line output is written, then the second element of each
on-line input is read, then the second element of each on-line output is
written, and so on. Ports that are not on-line are oﬀ-line. If all of the
series ports of a function are on-line, the function is said to be on-line;
otherwise, it is oﬀ-line. (The above extends the standard deﬁnition of
the term <i>on-line</i> so that it applies to individual ports as well as whole
functions.)
<!--l. 1405--><p class="indent" >   If all of the ports a cycle passes through are on-line, the lockstep processing of
these ports guarantees that there cannot be any conﬂicts between the
constraints associated with the cycle. However, passing through an oﬀ-line
port leads to the same kinds of problems as passing through a non-series
output.
<!--l. 1411--><p class="indent" >   Most of the series functions are on-line. In particular, scanners and collectors
are all on-line as are many transducers. However, the transducers in section <a 
href="clmse151.html#x185-3243000A.2.4">A.2.4<!--tex4ht:ref: SERIES-OL-SECTION --></a>
are oﬀ-line. In particular, the series inputs of <tt><a 
href="clmli7.html#x196-3479181r181">catenate</a></tt>, <tt><a 
href="clmli7.html#x196-3479226r226">choose-if</a></tt>, <tt><a 
href="clmli7.html#x196-3479227r227">chunk</a></tt>,
<tt><a 
href="clmli7.html#x196-3479379r379">expand</a></tt>, <tt><a 
href="clmli7.html#x196-3479603r603">mask</a></tt>, <tt><a 
href="clmli7.html#x196-3479616r616">mingle</a></tt>, <tt><a 
href="clmli7.html#x196-3479717r717">positions</a></tt>, and <tt><a 
href="clmli7.html#x196-3479913r913">subseries</a></tt> along with the series outputs
of <tt><a 
href="clmli7.html#x196-3479225r225">choose</a></tt>, <tt><a 
href="clmli7.html#x196-3479878r878">split</a></tt>, and <tt><a 
href="clmli7.html#x196-3479879r879">split-if</a></tt> are oﬀ-line.
<!--l. 1418--><p class="indent" >   In summary, the fourth and ﬁnal restriction is that for optimization to be
possible, a series expression cannot contain a constraint cycle that
passes through a non-series output or an oﬀ-line port. Whenever this
restriction is violated a warning message is issued. Violations can be ﬁxed either
by breaking the cycle or restructuring the computation so that the oﬀending port
is removed from the cycle.
<!--l. 1425--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.3.3   </span> <a 
href="clmli1.html#QQ2-186-3370" id="x186-3323000A.3.3">Deﬁning New Series Functions</a></h4>
<!--l. 1427--><p class="noindent" >New functions operating on series can be deﬁned just as easily as new
functions operating on any other data type. However, expressions containing
these new functions cannot be transformed into loops unless a complete
analysis of the functions is available. Among other things, this implies
that the deﬁnition of a new series function must appear before its ﬁrst
use.
<div class="defun">
                                                                          

                                                                          
<!--l. 1435--><p class="noindent" ><div class="defunheader"> <i>[Declaration speciﬁer]</i><a 
 id="dx186-3323001"></a><a 
 id="x186-3323002r1060"></a><b> optimizable-series-function</b>
</div>
<!--l. 1437--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3324000A.3.3" id="x186-3324000A.3.3"></a></span>
   The declaration speciﬁer <tt>(optimizable-series-function <i>integer</i>)</tt>
indicates that the function being deﬁned is a series function that needs to be
analyzed so that it can be optimized when it appears in series expressions. (A
warning is issued if the function being deﬁned neither takes a series as input nor
produces a series as output.) <i>Integer</i> (default 1) speciﬁes the number of values
returned by the function being deﬁned. (This cannot necessarily be determined by
local analysis.) The only place <tt><a 
href="clmli7.html#x196-3479684r684">optimizable-series-function</a></tt> is allowed to
appear is in a declaration immediately inside a <tt><a 
href="clmli7.html#x196-3479320r320">defun</a></tt>. As an example, the
following shows how a simpliﬁed version of <tt><a 
href="clmli7.html#x196-3479255r255">collect-sum</a></tt> could be deﬁned.
<div class="lisp"><div class="tabbing">
(defun simple-collect-sum (numbers)
   <br>                                          (declare (optimizable-series-function 1))<br>
  (collect-fn &#x2019;number #&#x2019;(lambda () 0) #&#x2019;+ numbers))<br>
<!--l. 1452--><p class="noindent" ></div>
<!--l. 1452--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3325000A.3.3" id="x186-3325000A.3.3"></a></span>
<!--l. 1452--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3326000A.3.3" id="x186-3326000A.3.3"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1455--><p class="noindent" ><div class="defunheader"> <i>[Declaration speciﬁer]</i><a 
 id="dx186-3326001"></a><a 
 id="x186-3326002r1061"></a><b> oﬀ-line-port</b>
</div>
<!--l. 1457--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3327000A.3.3" id="x186-3327000A.3.3"></a></span>
   The declaration speciﬁer <tt>(off-line-port <i>port-spec1</i> <i>port-spec2</i> ...)</tt>
speciﬁes that the indicated inputs and outputs are oﬀ-line. This declaration
speciﬁer is only allowed in a <tt><a 
href="clmli7.html#x196-3479320r320">defun</a></tt> that contains the declaration
<tt><a 
href="clmli7.html#x196-3479684r684">optimizable-series-function</a></tt>. Each <i>port-spec</i> must either be a symbol that is
                                                                          

                                                                          
one of the inputs of the function or an integer <i>j</i> indicating the <i>j</i>th output
(counting from zero). For example, <tt>(off-line-port x 1)</tt> indicates that the
input <tt>x</tt> and the second output are oﬀ-line. Every port that is not mentioned in an
<tt><a 
href="clmli7.html#x196-3479681r681">off-line-port</a></tt> declaration is assumed to be on-line. A warning is issued
whenever a port&#x2019;s actual on-line/oﬀ-line status does not agree with its declared
status. This makes it easier to keep track of which ports are oﬀ-line and which are
not. Note that oﬀ-line ports virtually never arise when deﬁning scanners or
reducers.
</div>
<!--l. 1474--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">A.3.4   </span> <a 
href="clmli1.html#QQ2-186-3375" id="x186-3328000A.3.4">Declarations</a></h4>
<!--l. 1476--><p class="noindent" >A key feature of Lisp is that variable declarations are strictly optional.
Nevertheless, it is often the case that they are necessary in situations where
eﬃciency matters. Therefore, it is important that it be possible for programmers
to provide declarations for every variable in a program. The transformation of
series expressions into loops presents certain problems in this regard,
because the loops created contain variables not evident in the original
code. However, if the information described below is supplied by the user,
appropriate declarations can be generated for all of the loop variables
created.
<!--l. 1486--><p class="indent" >   All the explicit variables that are bound in a series expression (for
example, by a <tt><a 
href="clmli7.html#x196-3479524r524">let</a></tt> that is part of the expression) should be given informative
declarations making use of the type speciﬁer <tt>(series <i>element-type</i>)</tt> where
appropriate.
<!--l. 1491--><p class="indent" >   Informative types should be supplied to series functions (such as <tt><a 
href="clmli7.html#x196-3479814r814">scan</a></tt> and
<tt><a 
href="clmli7.html#x196-3479593r593">map-fn</a></tt>) that have type arguments. When using <tt><a 
href="clmli7.html#x196-3479814r814">scan</a></tt> it is important to specify
the type of element in the sequence as well as the sequence itself (for example, by
using <tt>(vector * integer)</tt> as opposed to merely <tt><a 
href="clmli7.html#x196-3479987r987">vector</a></tt>). The form
<tt>(list <i>element-type</i>)</tt> can be used to specify the type of elements in a
list.
<!--l. 1498--><p class="indent" >   If it is appropriate to have a type more speciﬁc than <tt>(series t)</tt>
associated with the output of <tt>#M</tt>, <tt>#Z</tt>, <tt><a 
href="clmli7.html#x196-3479815r815">scan-alist</a></tt>, <tt><a 
href="clmli7.html#x196-3479816r816">scan-file</a></tt>, <tt><a 
href="clmli7.html#x196-3479819r819">scan-hash</a></tt>,
<tt><a 
href="clmli7.html#x196-3479821r821">scan-lists-of-lists-fringe</a></tt>, <tt><a 
href="clmli7.html#x196-3479820r820">scan-lists-of-lists</a></tt>, <tt><a 
href="clmli7.html#x196-3479823r823">scan-plist</a></tt>,
<tt><a 
href="clmli7.html#x196-3479830r830">series</a></tt>, <tt><a 
href="clmli7.html#x196-3479502r502">latch</a></tt>, or <tt><a 
href="clmli7.html#x196-3479181r181">catenate</a></tt>, then the form <tt><a 
href="clmli7.html#x196-3479943r943">the</a></tt> must be used to specify this
type.
                                                                          

                                                                          
<!--l. 1505--><p class="indent" >   Finally, if the expression computing a non-series argument to a series variable
is neither a variable nor a constant, <tt><a 
href="clmli7.html#x196-3479943r943">the</a></tt> must be used to specify the type of its
result.
<!--l. 1509--><p class="indent" >   For example, the declarations in the series expressions below are suﬃcient to
ensure that every loop variable will have an accurate declaration. <div class="lisp"><div class="tabbing">
(collect-last (choose-if #&#x2019;plusp (scan &#x2019;(list integer) data)))
   <br>                                                                                               <br>
(collect &#x2019;(vector * ﬂoat)<br>                                (map-fn &#x2019;ﬂoat #&#x2019;/<br>
                 (series (the integer (car data)))<br>
                 (the (series integer) (scan-ﬁle f))))<br>
<!--l. 1519--><p class="noindent" ></div>
<!--l. 1519--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3329000A.3.4" id="x186-3329000A.3.4"></a></span>
<!--l. 1519--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3330000A.3.4" id="x186-3330000A.3.4"></a></span>
</div>
<!--l. 1521--><p class="indent" >   The amount of information the user has to provide is reduced by the fact that
this information can be propagated from place to place. For instance, the
variable holding the output of <tt><a 
href="clmli7.html#x196-3479226r226">choose-if</a></tt> holds a subset of the elements
held by the input variable. As a result, it is appropriate for it to have
the same type. When deﬁning a new series function, the type speciﬁer
<tt><a 
href="clmli7.html#x196-3479831r831">series-element-type</a></tt> can be used to indicate where type propagation should
occur.
<div class="defun">
<!--l. 1529--><p class="noindent" ><div class="defunheader"> <i>[Type speciﬁer]</i><a 
 id="dx186-3330001"></a><a 
 id="x186-3330002r1062"></a><b> series-element-type</b>
</div>
<!--l. 1531--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3331000A.3.4" id="x186-3331000A.3.4"></a></span>
   The type speciﬁer <tt>(series-element-type <i>variable</i>)</tt> denotes the type
of elements in the series held in <i>variable</i>. <i>Variable</i> must be a variable
carrying a series value (for example, a series argument of a series function).
<tt><a 
href="clmli7.html#x196-3479831r831">series-element-type</a></tt> can be used only in three places: in a declaration in a <tt><a 
href="clmli7.html#x196-3479524r524">let</a></tt>,
<tt>mapping</tt>, <tt><a 
href="clmli7.html#x196-3479740r740">producing</a></tt>, or other binding form in a series expression; in a declaration
                                                                          

                                                                          
in a <tt><a 
href="clmli7.html#x196-3479320r320">defun</a></tt> being used to deﬁne a series function; or in a type argument to a series
function. As an example, consider that <tt><a 
href="clmli7.html#x196-3479247r247">collect-last</a></tt> could have been
deﬁned as follows. The use of <tt><a 
href="clmli7.html#x196-3479831r831">series-element-type</a></tt> ensures that the
internal variable keeping track of the most recent item has the correct type.
<div class="lisp"><div class="tabbing">
(defun collect-last (items &#x0026;optional (default nil))
   <br>                                            (declare (optimizable-series-function))<br>
  (collect-fn &#x2019;(series-element-type items)<br>
              #&#x2019;(lambda () default)<br>
              #&#x2019;(lambda (old new) new)<br>                      items))<br>
<!--l. 1550--><p class="noindent" ></div>
<!--l. 1550--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3332000A.3.4" id="x186-3332000A.3.4"></a></span>
<!--l. 1550--><p class="noindent" ><span class="paragraphHead"><a 
href="#x186-3333000A.3.4" id="x186-3333000A.3.4"></a></span>
</div>
</div>
                                                                          

                                                                          
<!--l. 1553--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse153.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse151.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse151.html#tailclmse151.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse152.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmap1.html#clmse152.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse152.html"></a>   </div> </div> 
</body></html> 
