<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Macro Deﬁnition</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-22 01:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 60--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse47.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html#tailclmch8.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse46.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html#clmse46.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">8.1   </span> <a 
 id="x59-980008.1"></a>Macro Deﬁnition</h3>
<!--l. 62--><p class="noindent" >The function <a 
href="#x59-98004r134">macro-function</a> determines whether a given symbol is the name of a
macro. The <a 
href="#x59-98006r135">defmacro</a> construct provides a convenient way to deﬁne new
macros.
<div class=obsolete>
<div class=defun>
<!--l. 67--><p class="noindent" > <i>[Function]</i>   <b>macro-function</b> <a 
 id="dx59-98001"></a><a 
 id="x59-98002r133"></a>   <i>symbol</i>
<!--l. 69--><p class="noindent" >The argument must be a symbol. If the symbol has a global function deﬁnition
that is a macro deﬁnition, then the expansion function (a function of
two arguments, the macro-call form and an environment) is returned. If
the symbol has no global function deﬁnition, or has a deﬁnition as an
ordinary function or as a special form but not as a macro, then <a 
href="clmse31.html#x42-70002r19">nil</a> is
returned. The function <a 
href="clmse47.html#x60-99002r136">macroexpand</a> is the best way to invoke the expansion
function.
<!--l. 79--><p class="indent" >   It is possible for both <a 
href="#x59-98004r134">macro-function</a> and <a 
href="clmse35.html#x47-78017r60">special-form-p</a> to be true of a
symbol. This is possible because an implementation is permitted to implement
any macro also as a special form for speed. On the other hand, the macro
deﬁnition must be available for use by programs that understand only the
standard special forms listed in table <a 
href="clmse28.html#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>.
<!--l. 86--><p class="indent" >   <a 
href="#x59-98004r134">macro-function</a> cannot be used to determine whether a symbol names a locally
deﬁned macro established by macrolet; <a 
href="#x59-98004r134">macro-function</a> can examine only global
deﬁnitions.
<!--l. 91--><p class="indent" >   <a 
href="clmse36.html#x48-80002r66">setf</a> may be used with <a 
href="#x59-98004r134">macro-function</a> to install a macro as a symbol&#x2019;s global
function deﬁnition: <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (macro-function symbol) fn)
</td></tr></table>
<!--l. 95--><p class="indent" >
</div>
</div>
<!--l. 96--><p class="noindent" >The value installed must be a function that accepts two arguments, an entire macro
call and an environment, and computes the expansion for that call. Performing
this operation causes the symbol to have only that macro deﬁnition as its global
function deﬁnition; any previous deﬁnition, whether as a macro or as a
function, is lost. It is an error to attempt to redeﬁne the name of a special
form.
</div>
</div>
<div class=newer>
<!--l. 107--><p class="indent" >   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to add an optional environment argument to
<a 
href="#x59-98004r134">macro-function</a>.
<div class=defun>
<!--l. 110--><p class="noindent" > <i>[Function]</i>   <b>macro-function</b> <a 
 id="dx59-98003"></a><a 
 id="x59-98004r134"></a>   <i>symbol</i>  <b>&#x0026;optional</b>  <i>env</i>
<!--l. 112--><p class="noindent" >The ﬁrst argument must be a symbol. If the symbol has a function deﬁnition that
is a macro deﬁnition, whether a local one established in the environment env by
macrolet or a global one established as if by <a 
href="#x59-98006r135">defmacro</a>, then the expansion
function (a function of two arguments, the macro-call form and an environment)
is returned. If the symbol has no function deﬁnition, or has a deﬁnition as an
ordinary function or as a special form but not as a macro, then <a 
href="clmse31.html#x42-70002r19">nil</a> is returned.
The function <a 
href="clmse47.html#x60-99002r136">macroexpand</a> or <i>macroexpand-1</i> is the best way to invoke the
expansion function.
<!--l. 125--><p class="indent" >   It is possible for both <a 
href="#x59-98004r134">macro-function</a> and <a 
href="clmse35.html#x47-78017r60">special-form-p</a> to be true of a
symbol. This is possible because an implementation is permitted to implement
any macro also as a special form for speed. On the other hand, the macro
deﬁnition must be available for use by programs that understand only the
standard special forms listed in table <a 
href="clmse28.html#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>.
<!--l. 132--><p class="indent" >   <a 
href="clmse36.html#x48-80002r66">setf</a> may be used with <a 
href="#x59-98004r134">macro-function</a> to install a macro as a symbol&#x2019;s global
function deﬁnition: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (macro-function symbol) fn)
</td></tr></table>
                                                                          

                                                                          
<!--l. 136--><p class="indent" >
</div>
</div>
<!--l. 137--><p class="noindent" >The value installed must be a function that accepts two arguments, an entire macro
call and an environment, and computes the expansion for that call. Performing
this operation causes the symbol to have only that macro deﬁnition as its global
function deﬁnition; any previous deﬁnition, whether as a macro or as a
function, is lost. One cannot use <a 
href="clmse36.html#x48-80002r66">setf</a> to establish a local macro deﬁnition; it
is an error to supply a second argument to <a 
href="#x59-98004r134">macro-function</a> when using
it with <a 
href="clmse36.html#x48-80002r66">setf</a>. It is an error to attempt to redeﬁne the name of a special
form.
<!--l. 147--><p class="indent" >   See also <a 
href="clmse49.html#x62-101004r141">compiler-macro-function</a>.
</div>
</div>
<div class=defmac>
<!--l. 152--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> defmacro </b> <a 
 id="dx59-98005"></a><a 
 id="x59-98006r135"></a>   name lambda-list  [[ <i> {<i>declaration</i>}∗  | doc-string</i>]]   {<i>form</i>}∗
</td></tr></table>
<!--l. 153--><p class="indent" >
</div>
   <a 
href="#x59-98006r135">defmacro</a> is a macro-deﬁning macro that arranges to decompose the
macro-call form in an elegant and useful way. <a 
href="#x59-98006r135">defmacro</a> has essentially the
same syntax as <a 
href="clmse30.html#x40-66002r13">defun</a>: name is the symbol whose macro deﬁnition we are
creating, lambda-list is similar in form to a lambda-list, and the forms
constitute the body of the expander function. The <a 
href="#x59-98006r135">defmacro</a> construct
arranges to install this expander function, as the global macro deﬁnition of
name.
<div class=obsolete>
   The expander function is eﬀectively deﬁned in the global environment; lexically
scoped entities established outside the <a 
href="#x59-98006r135">defmacro</a> form that would ordinarily
be lexically apparent are not visible within the body of the expansion
function.
</div>
<div class=newer>
                                                                          

                                                                          
   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that, while deﬁning forms normally
appear at top level, it is meaningful to place them in non-top-level contexts.
Furthermore, <a 
href="#x59-98006r135">defmacro</a> should deﬁne the expander function within the enclosing
lexical environment, not within the global environment.
</div>
<div class=newer>
   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to specify that the body of the expander
function deﬁned by <a 
href="#x59-98006r135">defmacro</a> is implicitly enclosed in a <a 
href="clmse41.html#x53-85002r101">block</a> construct whose
name is the same as the name of the deﬁned macro. Therefore <a 
href="clmse41.html#x53-85004r102">return-from</a> may be
used to exit from the function.
</div>
   The name is returned as the value of the <a 
href="#x59-98006r135">defmacro</a> form.
   If we view the macro call as a list containing a function name and some
argument forms, in eﬀect the expander function and the list of (unevaluated)
argument forms is given to <a 
href="clmse37.html#x49-81002r77">apply</a>. The parameter speciﬁers are processed
as for any lambda-expression, using the macro-call argument forms as
the arguments. Then the body forms are evaluated as an implicit <a 
href="clmse38.html#x50-82002r80">progn</a>,
and the value of the last form is returned as the expansion of the macro
call.
   If the optional documentation string doc-string is present (if not followed by a
declaration, it may be present only if at least one form is also speciﬁed, as it is
otherwise taken to be a form), then it is attached to the name as a documentation
string of type <a 
href="clmse35.html#x47-78004r54">function</a>; see <a 
href="clmse151.html#x184-311056r930">documentation</a>.
<div class=obsolete>
   Like the lambda-list in a <a 
href="clmse30.html#x40-66002r13">defun</a>, a <a 
href="#x59-98006r135">defmacro</a> lambda-list may contain the
lambda-list keywords <i>&#x0026;optional</i>, <i>&#x0026;rest</i>, <i>&#x0026;key</i>, <i>&#x0026;allow-other-keys</i>, and <i>&#x0026;aux</i>. For
<i>&#x0026;optional</i> and <i>&#x0026;key</i> parameters, initialization forms and supplied-p parameters
may be speciﬁed, just as for <a 
href="clmse30.html#x40-66002r13">defun</a>. Three additional markers are allowed in
<a 
href="#x59-98006r135">defmacro</a> variable lists only.
</div> <div class=new> These three markers are now allowed in other constructs as well.
</div> <div class=indentdesc>
              <div><br /><b>
<i>&#x0026;body</i>        </b>This is identical in function to <i>&#x0026;rest</i>, but it informs certain
              output-formatting and editing functions that the remainder
              of  the  form  is  treated  as  a  body  and  should  be  indented
              accordingly. (Only one of <i>&#x0026;body</i> or <i>&#x0026;rest</i> may be used.)
              <br /><b>
                                                                          

                                                                          
<i>&#x0026;whole</i>      </b>This is followed by a single variable that is bound to the entire
              macro-call form; this is the value that the macro deﬁnition
              function  receives  as  its  single  argument.  <i>&#x0026;whole</i>  and  the
              following variable should appear ﬁrst in the lambda-list, before
              any other parameter or lambda-list keyword.
              <br /><b>
<i>&#x0026;environment</i></b>This  is  followed  by  a  single  variable  that  is  bound  to  an
              environment representing the lexical environment in which the
              macro  call  is  to  be  interpreted.  This  environment  may  not
              be the complete lexical environment; it should be used only
              with the function <a 
href="clmse47.html#x60-99002r136">macroexpand</a> for the sake of any local macro
              deﬁnitions that the macrolet construct may have established
              within that lexical environment. This is useful primarily in the
              rare cases where a macro deﬁnition must explicitly expand any
              macros in a subform of the macro call before computing its
              own expansion.</div>
</div>
<!--l. 244--><p class="noindent" >See <a 
href="clmse29.html#x39-64003r11">lambda-list-keywords</a>.
<div class=new>
<!--l. 247--><p class="indent" >   Notice of correction. In the ﬁrst edition, the symbol <i>&#x0026;environment</i> at the left
margin above was inadvertently omitted.
</div>
<div class=newer>
<!--l. 253--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to specify that macro environment objects
received with the <i>&#x0026;environment</i> argument of a macro function have only dynamic
extent. The consequences are undeﬁned if such objects are referred to outside the
dynamic extent of that particular invocation of the macro function. This allows
implementations to use somewhat more eﬃcient techniques for representing
environment objects.
</div>
<div class=newer>
<!--l. 264--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify the permitted uses of <i>&#x0026;body</i>,
<i>&#x0026;whole</i>, and <i>&#x0026;environment</i>:
      <ul class="itemize1">
      <li class="itemize"><i>&#x0026;body</i> may appear at any level of a <a 
href="#x59-98006r135">defmacro</a> lambda-list.
                                                                          

                                                                          
      </li>
      <li class="itemize"><i>&#x0026;whole</i> may appear at any level of a <a 
href="#x59-98006r135">defmacro</a> lambda-list. At inner
      levels a <i>&#x0026;whole</i> variable is bound to that part of the argument that
      matches the sub-lambda-list in which <i>&#x0026;whole</i> appears. No matter where
      <i>&#x0026;whole</i> is used, other parameters or lambda-list keywords may follow
      it.
      </li>
      <li class="itemize"><i>&#x0026;environment</i> may occur only at the outermost level of a <a 
href="#x59-98006r135">defmacro</a>
      lambda-list, and it may occur at most once, but it may occur anywhere
      within that lambda-list, even before an occurrence of <i>&#x0026;whole</i>.</li></ul>
</div>
<!--l. 278--><p class="indent" >   <a 
href="#x59-98006r135">defmacro</a>, unlike any other Common Lisp construct that has a lambda-list as
part of its syntax, provides an additional facility known as destructuring. <div class=newer> See
<a 
href="clmse48.html#x61-100002r139">destructuring-bind</a>, which provides the destructuring facility separately.
</div> Anywhere in the lambda-list where a parameter name may appear, and where
ordinary lambda-list syntax (as described in section <a 
href="clmse29.html#x39-640005.2.2">5.2.2<!--tex4ht:ref: LAMBDA-EXPRESSIONS-SECTION --></a>) does not otherwise
allow a list, a lambda-list may appear in place of the parameter name. When
this is done, then the argument form that would match the parameter
is treated as a (possibly dotted) list, to be used as an argument forms
list for satisfying the parameters in the embedded lambda-list. As an
example, one could write the macro deﬁnition for <a 
href="clmse42.html#x54-89002r109">dolist</a> in this manner: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro dolist ((var listform <i>&#x0026;optional</i> resultform)
</td></tr></table>
<!--l. 295--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  &#x0026;rest body)</td></tr></table>
<!--l. 296--><p class="indent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...)</td></tr></table>
<!--l. 298--><p class="indent" >
</div>
</div>
<!--l. 299--><p class="noindent" >More examples of embedded lambda-lists in <a 
href="#x59-98006r135">defmacro</a> are shown below.
<!--l. 301--><p class="indent" >   Another destructuring rule is that <a 
href="#x59-98006r135">defmacro</a> allows any lambda-list (whether
top-level or embedded) to be dotted, ending in a parameter name. This situation
is treated exactly as if the parameter name that ends the list had appeared
preceded by <i>&#x0026;rest</i>. For example, the deﬁnition skeleton for <a 
href="clmse42.html#x54-89002r109">dolist</a> shown above
could instead have been written <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro dolist ((var listform &#x0026;optional resultform)
</td></tr></table>
<!--l. 308--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                  . body)</td></tr></table>
<!--l. 309--><p class="indent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...)</td></tr></table>
<!--l. 311--><p class="indent" >
</div>
</div>
<!--l. 313--><p class="indent" >   If the compiler encounters a <a 
href="#x59-98006r135">defmacro</a>, the new macro is added to the
compilation environment, and a compiled form of the expansion function is also
added to the output ﬁle so that the new macro will be operative at run time. If
this is not the desired eﬀect, the <a 
href="#x59-98006r135">defmacro</a> form can be wrapped in an <a 
href="clmse30.html#x40-68004r18">eval-when</a>
construct.
<!--l. 320--><p class="indent" >   It is permissible to use <a 
href="#x59-98006r135">defmacro</a> to redeﬁne a macro (for example, to install a
corrected version of an incorrect deﬁnition), or to redeﬁne a function as a macro.
It is an error to attempt to redeﬁne the name of a special form (see table <a 
href="clmse28.html#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>) as a
macro. See macrolet, which establishes macro deﬁnitions over a restricted lexical
scope.
<div class=newer>
<!--l. 330--><p class="indent" >   See also <a 
href="clmse49.html#x62-101002r140">deﬁne-compiler-macro</a>.
</div>
<!--l. 333--><p class="indent" >   Suppose, for the sake of example, that it were desirable to implement a
conditional construct analogous to the Fortran arithmetic IF statement. (This of
course requires a certain stretching of the imagination and suspension of
disbelief.) The construct should accept four forms: a test-value, a neg-form, a
zero-form, and a pos-form. One of the last three forms is chosen to be executed
according to whether the value of the test-form is positive, negative, or zero.
Using <a 
href="#x59-98006r135">defmacro</a>, a deﬁnition for such a construct might look like this: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro arithmetic-if (test neg-form zero-form pos-form)
</td></tr></table>
<!--l. 345--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((var (gensym)))</td></tr></table>
<!--l. 346--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    <tt>‘</tt>(let ((,var ,test))</td></tr></table>
<!--l. 347--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (cond ((&#x003C; ,var 0) ,neg-form)</td></tr></table>
<!--l. 348--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             ((= ,var 0) ,zero-form)</td></tr></table>
                                                                          

                                                                          
<!--l. 349--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (t ,pos-form)))))</td></tr></table>
<!--l. 351--><p class="indent" >
</div>
</div>
<!--l. 352--><p class="noindent" >Note the use of the backquote facility in this deﬁnition (see section <a 
href="clmse115.html#x142-19000022.1.3">22.1.3<!--tex4ht:ref: MACRO-CHARACTERS-SECTION --></a>). Also note
the use of <a 
href="clmse56.html#x71-110006r166">gensym</a> to generate a new variable name. This is necessary to avoid
conﬂict with any variables that might be referred to in neg-form, zero-form, or
pos-form.
<!--l. 358--><p class="indent" >   If the form is executed by the interpreter, it will cause the function deﬁnition
of the symbol arithmetic-if to be a macro associated with which is a two-argument
expansion function roughly equivalent to <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(lambda (calling-form environment)
</td></tr></table>
<!--l. 363--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (declare (ignore environment))</td></tr></table>
<!--l. 364--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((var (gensym)))</td></tr></table>
<!--l. 365--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (list &#x2019;let</td></tr></table>
<!--l. 366--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (list (list &#x2019;var (cadr calling-form)))</td></tr></table>
<!--l. 367--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (list &#x2019;cond</td></tr></table>
<!--l. 368--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                (list (list &#x2019;&#x003C; var &#x2019;0) (caddr calling-form))</td></tr></table>
<!--l. 369--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                (list (list &#x2019;= var &#x2019;0) (cadddr calling-form))</td></tr></table>
<!--l. 370--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                (list &#x2019;t (ﬁfth calling-form))))))</td></tr></table>
<!--l. 372--><p class="indent" >
</div>
</div>
<!--l. 373--><p class="noindent" >The lambda-expression is produced by the <a 
href="#x59-98006r135">defmacro</a> declaration. The calls to
<a 
href="clmse87.html#x107-149036r491">list</a> are the (hypothetical) result of the backquote (<i><tt>`</tt></i>) macro character
and its associated commas. The precise macro expansion function may
depend on the implementation, for example providing some degree of
explicit error checking on the number of argument forms in the macro
call.
<!--l. 380--><p class="indent" >   Now, if <a 
href="clmse110.html#x135-180002r618">eval</a> encounters <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(arithmetic-if (- x 4.0)
</td></tr></table>
                                                                          

                                                                          
<!--l. 382--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               (- x)</td></tr></table>
<!--l. 383--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               (error &#x0022;Strange zero&#x0022;)</td></tr></table>
<!--l. 384--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               x)</td></tr></table>
<!--l. 386--><p class="indent" >
</div>
</div>
<!--l. 387--><p class="noindent" >this will be expanded into something like <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((g407 (- x 4.0)))
</td></tr></table>
<!--l. 389--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (cond ((&#x003C; g407 0) (- x))</td></tr></table>
<!--l. 390--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        ((= g407 0) (error &#x0022;Strange zero&#x0022;))</td></tr></table>
<!--l. 391--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (t x)))</td></tr></table>
<!--l. 393--><p class="indent" >
</div>
</div>
<!--l. 394--><p class="noindent" >and <a 
href="clmse110.html#x135-180002r618">eval</a> tries again on this new form. (It should be clear now that the backquote
facility is very useful in writing macros, since the form to be returned is normally
a complex list structure, typically consisting of a mostly constant template with a
few evaluated forms here and there. The backquote template provides a “picture”
of the resulting code, with places to be ﬁlled in indicated by preceding
commas.)
<!--l. 402--><p class="indent" >   To expand on this example, stretching credibility to its limit, we might allow
the pos-form and zero-form to be omitted, allowing their values to default to <a 
href="clmse31.html#x42-70002r19">nil</a>,
in much the same way that the else form of a Common Lisp <a 
href="clmse141.html#x172-248002r876">if</a> construct may be
omitted: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro arithmetic-if (test neg-form
</td></tr></table>
<!--l. 408--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                         <i>&#x0026;optional</i> zero-form pos-form)</td></tr></table>
<!--l. 409--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((var (gensym)))</td></tr></table>
<!--l. 410--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    <tt>‘</tt>(let ((,var ,test))</td></tr></table>
<!--l. 411--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (cond ((&#x003C; ,var 0) ,neg-form)</td></tr></table>
<!--l. 412--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             ((= ,var 0) ,zero-form)</td></tr></table>
<!--l. 413--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (t ,pos-form)))))</td></tr></table>
<!--l. 415--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 416--><p class="noindent" >Then one could write <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(arithmetic-if (- x 4.0) (print x))
</td></tr></table>
<!--l. 419--><p class="indent" >
</div>
</div>
<!--l. 420--><p class="noindent" >which would be expanded into something like <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((g408 (- x 4.0)))
</td></tr></table>
<!--l. 422--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (cond ((&#x003C; g408 0) (print x))</td></tr></table>
<!--l. 423--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        ((= g408 0) nil)</td></tr></table>
<!--l. 424--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (t nil)))</td></tr></table>
<!--l. 426--><p class="indent" >
</div>
</div>
<!--l. 427--><p class="noindent" >The resulting code is correct but rather silly-looking. One might rewrite the macro
deﬁnition to produce better code when pos-form and possibly zero-form are
omitted, or one might simply rely on the Common Lisp implementation to provide
a compiler smart enough to improve the code itself.
<!--l. 433--><p class="indent" >   Destructuring is a very powerful facility that allows the <a 
href="#x59-98006r135">defmacro</a> lambda-list
to express the structure of a complicated macro-call syntax. If no lambda-list
keywords appear, then the <a 
href="#x59-98006r135">defmacro</a> lambda-list is simply a list, nested to some
extent, containing parameter names at the leaves. The macro-call form must
have the same list structure. For example, consider this macro deﬁnition: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro halibut ((mouth eye1 eye2)
</td></tr></table>
<!--l. 441--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   ((ﬁn1 length1) (ﬁn2 length2))</td></tr></table>
<!--l. 442--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   tail)</td></tr></table>
<!--l. 443--><p class="indent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...)</td></tr></table>
<!--l. 445--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 446--><p class="noindent" >Now consider this macro call: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(halibut (m (car eyes) (cdr eyes))
</td></tr></table>
<!--l. 448--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         ((f1 (count-scales f1)) (f2 (count-scales f2)))</td></tr></table>
<!--l. 449--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         my-favorite-tail)</td></tr></table>
<!--l. 451--><p class="indent" >
</div>
</div>
<!--l. 452--><p class="noindent" >This would cause the expansion function to receive the following values for its
parameters:
<div class="flushleft" 
>
<!--l. 454--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Parameter</td><td align="left" >Value              </td></tr><tr><td align="left" >mouth </td> <td align="left" >m</td>
</tr><tr><td align="left" >eye1        </td><td align="left" >(car eyes)         </td>
</tr><tr><td align="left" >eye2        </td><td align="left" >(cdr eyes)         </td>
</tr><tr><td align="left" >ﬁn1         </td><td align="left" >f1                   </td>
</tr><tr><td align="left" >length1    </td><td align="left" >(count-scales f1)</td>
</tr><tr><td align="left" >ﬁn2         </td><td align="left" >f2                   </td>
</tr><tr><td align="left" >length2    </td><td align="left" >(count-scales f2)</td>
</tr><tr><td align="left" >tail         </td><td align="left" >my-favorite-tail </td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table></div></div>
<!--l. 470--><p class="noindent" >The following macro call would be in error because there would be no argument form
to match the parameter <i>length1</i>: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(halibut (m (car eyes) (cdr eyes))
</td></tr></table>
<!--l. 473--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         ((f1) (f2 (count-scales f2)))</td></tr></table>
<!--l. 474--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         my-favorite-tail)</td></tr></table>
<!--l. 476--><p class="indent" >
</div>
</div>
<!--l. 477--><p class="noindent" >The following macro call would be in error because a symbol appears in the call
where the structure of the lambda-list requires a list. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(halibut my-favorite-head
</td></tr></table>
<!--l. 480--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         ((f1 (count-scales f1)) (f2 (count-scales f2)))</td></tr></table>
<!--l. 481--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         my-favorite-tail)</td></tr></table>
<!--l. 483--><p class="indent" >
</div>
</div>
<!--l. 484--><p class="noindent" >The fact that the value of the variable my-favorite-head might happen to be a list is
irrelevant here. It is the macro call itself whose structure must match that of the
<a 
href="#x59-98006r135">defmacro</a> lambda-list.
<!--l. 488--><p class="indent" >   The use of lambda-list keywords adds even greater ﬂexibility. For example,
suppose it is convenient within the expansion function for halibut to be able to
refer to the list whose components are called mouth, <i>eye1</i>, and <i>eye2</i> as head. One
may write this: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro halibut ((<i>&#x0026;whole</i> head mouth eye1 eye2)
</td></tr></table>
<!--l. 494--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   ((ﬁn1 length1) (ﬁn2 length2))</td></tr></table>
<!--l. 495--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   tail)</td></tr></table>
<!--l. 497--><p class="indent" >
</div>
</div>
<!--l. 498--><p class="noindent" >Now consider the same valid macro call as before: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(halibut (m (car eyes) (cdr eyes))
</td></tr></table>
<!--l. 500--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         ((f1 (count-scales f1)) (f2 (count-scales f2)))</td></tr></table>
<!--l. 501--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         my-favorite-tail)</td></tr></table>
<!--l. 503--><p class="indent" >
</div>
</div>
<!--l. 504--><p class="noindent" >This would cause the expansion function to receive the same values for its parameters
and also a value for the parameter head:
                                                                          

                                                                          
<div class="flushleft" 
>
<!--l. 506--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Parameter</td><td align="left" >Value                         </td></tr><tr><td align="left" >head </td> <td align="left" >(m (car eyes) (cdr eyes))</td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
<!--l. 516--><p class="indent" >   The stipulation that an embedded lambda-list is permitted only where
ordinary lambda-list syntax would permit a parameter name but not
a list is made to prevent ambiguity. For example, one may not write <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro loser (x <i>&#x0026;optional</i> (a b <i>&#x0026;rest</i> c) <i>&#x0026;rest</i> z)
</td></tr></table>
<!--l. 522--><p class="indent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...)</td></tr></table>
<!--l. 524--><p class="indent" >
</div>
</div>
<!--l. 525--><p class="noindent" >because ordinary lambda-list syntax does permit a list following <i>&#x0026;optional</i>; the list <i>(a
b <i>&#x0026;rest</i> c)</i> would be interpreted as describing an optional parameter named a
whose default value is that of the form b, with a supplied-p parameter named
<i>&#x0026;rest</i> (not legal), and an extraneous symbol c in the list (also not legal). An
almost correct way to express this is <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro loser (x <i>&#x0026;optional</i> ((a b <i>&#x0026;rest</i> c)) <i>&#x0026;rest</i> z)
</td></tr></table>
<!--l. 532--><p class="indent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...)</td></tr></table>
<!--l. 534--><p class="indent" >
</div>
</div>
<!--l. 535--><p class="noindent" >The extra set of parentheses removes the ambiguity. However, the deﬁnition is now
incorrect because a macro call such as <i>(loser (car pool))</i> would not provide any
argument form for the lambda-list <i>(a b <i>&#x0026;rest</i> c)</i>, and so the default value against
which to match the lambda-list would be <a 
href="clmse31.html#x42-70002r19">nil</a> because no explicit default value was
speciﬁed. This is in error because <a 
href="clmse31.html#x42-70002r19">nil</a> is an empty list; it does not have forms to
satisfy the parameters a and b. The fully correct deﬁnition would be either <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro loser (x <i>&#x0026;optional</i> ((a b <i>&#x0026;rest</i> c) &#x2019;(nil nil)) <i>&#x0026;rest</i> z)
</td></tr></table>
<!--l. 543--><p class="indent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...)</td></tr></table>
<!--l. 545--><p class="indent" >
</div>
</div>
<!--l. 546--><p class="noindent" >or <div class=lisp>  <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro loser (x <i>&#x0026;optional</i> ((<i>&#x0026;optional</i> a b <i>&#x0026;rest</i> c)) <i>&#x0026;rest</i> z)
</td></tr></table>
<!--l. 548--><p class="indent" >                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...)</td></tr></table>
<!--l. 550--><p class="indent" >
</div>
</div>
<!--l. 551--><p class="noindent" >These diﬀer slightly: the ﬁrst requires that if the macro call speciﬁes a explicitly then
it must also specify b explicitly, whereas the second does not have this
requirement. For example, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(loser (car pool) ((+ x 1)))
</td></tr></table>
<!--l. 556--><p class="indent" >
</div>
</div>
<!--l. 557--><p class="noindent" >would be a valid call for the second deﬁnition but not for the ﬁrst.
</div>
                                                                          

                                                                          
   <!--l. 560--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse47.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html#tailclmch8.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse46.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch8.html#clmse46.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 560--><p class="indent" >   <a 
 id="tailclmse46.html"></a>  
</body></html> 
