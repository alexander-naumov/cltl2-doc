<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Модификация последовательностей</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-20 19:35:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 1831--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse79.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse77.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse77.html#tailclmse77.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse78.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch14.html#clmse78.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">14.3   </span> <a 
href="clm.html#QQ2-97-226" id="x97-19800014.3">Модификация последовательностей</a></h3>
<!--l. 1833--><p class="noindent" >Каждая из этих функций или модифицирует последовательность, или
возвращает модифицированную копию.
<div class=defun>
<!--l. 1836--><p class="noindent" ><i>[Function]</i><a 
 id="dx97-198001"></a><a 
 id="x97-198002r376"></a><b> ﬁll</b>  <i>sequence</i> <i>item</i> &#x0026;key  <i>:start</i> <i>:end</i>
<!--l. 1838--><p class="noindent" >Функция модифицирует последовательность, заменяя каждый элемент
подпоследовательности, обозначенной с помощью параметров :start и :end,
объектом <i>item</i>. <i>item</i> может быть любым Lisp&#x2019;овыми объектом, подходящим
для типа элементов последовательности <i>sequence</i>. Объект <i>item</i> сохраняется в
всех указанных компонентах последовательности <i>sequence</i>, начиная с позиции
:start (по-умолчанию равна 0) и заканчивая невключительно позицией :end
(по-умолчанию равна длине последовательности). ﬁll возвращает изменённую
последовательность. Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x (vector &#x2019;a &#x2019;b &#x2019;c &#x2019;d &#x2019;e)) <span class="math"> ⇒</span> #(a b c d e)
</td></tr></table>
<!--l. 1849--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬁll x &#x2019;z :start 1 :end 3) <span class="math"> ⇒</span> #(a z z d e)</td></tr></table>
<!--l. 1850--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  and now x <span class="math"> ⇒</span> #(a z z d e)</td></tr></table>
<!--l. 1851--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬁll x &#x2019;p) <span class="math"> ⇒</span> #(p p p p p)</td></tr></table>
<!--l. 1852--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  and now x <span class="math"> ⇒</span> #(p p p p p)</td></tr></table>
<!--l. 1854--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 1857--><p class="noindent" ><i>[Function]</i><a 
 id="dx97-198003"></a><a 
 id="x97-198004r377"></a><b> replace</b>  <i>sequence1</i> <i>sequence2</i> &#x0026;key  <i>:start1</i> <i>:end1</i> <i>:start2 :end2</i>
<!--l. 1859--><p class="noindent" >Функция модифицирует последовательность <i>sequence1</i> копируя в
неё элементы из последовательности <i>sequence2</i>. Элементы <i>sequence2</i>
для принадлежать типу элементов <i>sequence1</i>. Подпоследовательность
<i>sequence2</i>, указанная с помощью параметров :start2 и :end2, копируется в
                                                                          

                                                                          
подпоследовательность <i>sequence2</i>, указанную с помощью параметров :start1 и
:end1. Аргументы :start1 и :start2 по-умолчанию равны нулю. Аргументы
:end1 и :end2 по-умолчанию <a 
href="clmse31.html#x42-74002r18">nil</a>, что означает длины соответствующих
последовательностей. Если указанные подпоследовательности имеют
не равные длины, тогда для наиболее короткая из них определяет
копируемые элементы. Лишние элементы последовательностей функцией не
обрабатываются. Количество копируемых элементов можно вычислить так:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(min (- <i>end1</i> <i>start1</i>) (- <i>end2</i> <i>start2</i>))
</td></tr></table>
<!--l. 1874--><p class="indent" >
</div>
</div>
<!--l. 1875--><p class="noindent" >Значением функции <a 
href="#x97-198004r377">replace</a> является модифицированная последовательность
<i>sequence1</i>.
<!--l. 1878--><p class="indent" >   Если обе последовательности равны (<a 
href="clmse33.html#x44-78002r44">eq</a>), и интервал для модификации
перекрывается с исходным интервалом, тогда поведение такое, как если бы
все исходные данные сохранялись во временном месте, а затем сохранялись в
итоговый интервал. Однако, если последовательности не равны, но итоговый
интервал пересекается с исходным (возможно, при использовании
<i>соединённых</i> массивов), тогда после выполнения <a 
href="#x97-198004r377">replace</a>, итоговое
содержимое не определено.
</div>
<div class=defun>
<!--l. 1887--><p class="noindent" ><i>[Function]</i><a 
 id="dx97-198005"></a><a 
 id="x97-198006r378"></a><b> remove</b>  <i>item</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i> <i>:test-not</i> <i>:start</i> <i>:end</i>
<i>:count</i> <i>:key</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx97-198007"></a><a 
 id="x97-198008r379"></a><b> remove-if</b>  <i>predicate</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start</i> <i>:end</i> <i>:count</i>
<i>:key</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx97-198009"></a><a 
 id="x97-198010r380"></a><b> remove-if-not</b>  <i>predicate</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start</i> <i>:end</i>
<i>:count</i> <i>:key</i>
<!--l. 1891--><p class="noindent" >Результатом является последовательность того же типа, что и
последовательность <i>sequence</i>. Однако, итоговая последовательность не будет
содержать элементы в интервале :start-:end, которые удовлетворяли условию.
Результат является копией входящей последовательности <i>sequence</i> без
исключённых элементов. Неудалённые элементы сохраняются в таком же
порядке.
                                                                          

                                                                          
<!--l. 1898--><p class="indent" >   Если указан аргумент :count, то удаляться будет только это количество.
Если количество удаляемых элементов превышает параметр, тогда будут
удалены только самые левые в количестве равном :count.
<!--l. 1902--><p class="indent" >   Если при использовании :count для параметра :from-end указано не-<a 
href="clmse31.html#x42-74002r18">nil</a>
значение, тогда удаление элементов будет происходить справа в количестве
:count. Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove 4 &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (1 2 1 3 5)
</td></tr></table>
<!--l. 1907--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove 4 &#x2019;(1 2 4 1 3 4 5) :count 1) <span class="math"> ⇒</span> (1 2 1 3 4 5)</td></tr></table>
<!--l. 1908--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove 4 &#x2019;(1 2 4 1 3 4 5) :count 1 :from-end t)</td></tr></table>
<!--l. 1909--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (1 2 4 1 3 5)</td></tr></table>
<!--l. 1910--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove 3 &#x2019;(1 2 4 1 3 4 5) :test #&#x2019;&#x003E;) <span class="math"> ⇒</span> (4 3 4 5)</td></tr></table>
<!--l. 1911--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-if #&#x2019;oddp &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (2 4 4)</td></tr></table>
<!--l. 1912--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-if #&#x2019;evenp &#x2019;(1 2 4 1 3 4 5) :count 1 :from-end t)</td></tr></table>
<!--l. 1913--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (1 2 4 1 3 5)</td></tr></table>
<!--l. 1915--><p class="indent" >
</div>
</div>
<!--l. 1916--><p class="noindent" >Результат <a 
href="#x97-198006r378">remove</a> может быть <i>соединён</i> с исходной последовательностью. Также
результат может быть равен <a 
href="clmse33.html#x44-78002r44">eq</a> исходной последовательности, если ни одного
элементы не было удалено.
</div>
<div class=defun>
<!--l. 1921--><p class="noindent" ><i>[Function]</i><a 
 id="dx97-198011"></a><a 
 id="x97-198012r381"></a><b> delete</b>  <i>item</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i> <i>:test-not</i>
<i>:start :end :count :key</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx97-198013"></a><a 
 id="x97-198014r382"></a><b> delete-if</b>  <i>predicate</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start :end :count :key</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx97-198015"></a><a 
 id="x97-198016r383"></a><b> delete-if-not</b>  <i>predicate</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start :end :count :key</i>
<!--l. 1925--><p class="noindent" >Данная функция в отличие от <a 
href="#x97-198006r378">remove</a> модифицирует исходную
последовательность. Результатом является последовательность того же типа,
что и последовательность <i>sequence</i>. Однако, итоговая последовательность не
будет содержать элементы в интервале :start-:end, которые удовлетворяли
условию. Результат является копией входящей последовательности <i>sequence</i>
без исключённых элементов. Неудалённые элементы сохраняются в таком же
порядке. Последовательность <i>sequence</i> может быть модифицирована, поэтому
результат может быть равен <a 
href="clmse33.html#x44-78002r44">eq</a> или нет исходной последовательности.
                                                                          

                                                                          
<!--l. 1935--><p class="indent" >   Если указан аргумент :count, то удаляться будет только это количество.
Если количество удаляемых элементов превышает параметр, тогда будут
удалены только самые левые в количестве равном :count.
<!--l. 1939--><p class="indent" >   Если при использовании :count для параметра :from-end указано не-<a 
href="clmse31.html#x42-74002r18">nil</a>
значение, тогда удаление элементов будет происходить справа в количестве
:count. Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(delete 4 &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (1 2 1 3 5)
</td></tr></table>
<!--l. 1944--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(delete 4 &#x2019;(1 2 4 1 3 4 5) :count 1) <span class="math"> ⇒</span> (1 2 1 3 4 5)</td></tr></table>
<!--l. 1945--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(delete 4 &#x2019;(1 2 4 1 3 4 5) :count 1 :from-end t)</td></tr></table>
<!--l. 1946--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (1 2 4 1 3 5)</td></tr></table>
<!--l. 1947--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(delete 3 &#x2019;(1 2 4 1 3 4 5) :test #&#x2019;&#x003E;) <span class="math"> ⇒</span> (4 3 4 5)</td></tr></table>
<!--l. 1948--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(delete-if #&#x2019;oddp &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (2 4 4)</td></tr></table>
<!--l. 1949--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(delete-if #&#x2019;evenp &#x2019;(1 2 4 1 3 4 5) :count 1 :from-end t)</td></tr></table>
<!--l. 1950--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (1 2 4 1 3 5)</td></tr></table>
<!--l. 1952--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 1955--><p class="noindent" ><i>[Function]</i><a 
 id="dx97-198017"></a><a 
 id="x97-198018r384"></a><b> remove-duplicates</b>  <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i> <i>:test-not</i> <i>:start</i>
<i>:end</i> <i>:key</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx97-198019"></a><a 
 id="x97-198020r385"></a><b> delete-duplicates</b>  <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i> <i>:test-not</i> <i>:start</i>
<i>:end</i> <i>:key</i>
<!--l. 1958--><p class="noindent" >Функция попарно сравнивает элементы последовательности <i>sequence</i>,
и если они равны, тогда первый из них удаляется (если параметр
:from-end равен истине, то удаляется последний). Результат является
последовательностью того же типа, что и исходная, с удалёнными
повторяющимися элементами. Порядок следования элементов в итоге такой
же как в исходной последовательности.
<!--l. 1966--><p class="indent" >   <a 
href="#x97-198018r384">remove-duplicates</a> является не модифицирующей версией этой
операции. Результат <a 
href="#x97-198018r384">remove-duplicates</a> может быть <i>соединён</i> с исходной
последовательностью. Также результат может быть равен <a 
href="clmse33.html#x44-78002r44">eq</a> исходной
последовательности, если ни одного элементы не было удалено.
<!--l. 1971--><p class="indent" >   <a 
href="#x97-198020r385">delete-duplicates</a> может модифицировать аргумент <i>sequence</i>.
<!--l. 1973--><p class="indent" >   Например: <div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-duplicates &#x2019;(a b c b d d e)) <span class="math"> ⇒</span> (a c b d e)
</td></tr></table>
<!--l. 1975--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-duplicates &#x2019;(a b c b d d e) :from-end t) <span class="math"> ⇒</span> (a b c d e)</td></tr></table>
<!--l. 1976--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-duplicates &#x2019;((foo #\a) (bar #\%) (baz #\A))</td></tr></table>
<!--l. 1977--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   :test #&#x2019;char-equal :key #&#x2019;cadr)</td></tr></table>
<!--l. 1978--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> ((bar #\%) (baz #\A))</td></tr></table>
<!--l. 1979--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(remove-duplicates &#x2019;((foo #\a) (bar #\%) (baz #\A))</td></tr></table>
<!--l. 1980--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   :test #&#x2019;char-equal :key #&#x2019;cadr :from-end t)</td></tr></table>
<!--l. 1981--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> ((foo #\a) (bar #\%))</td></tr></table>
<!--l. 1983--><p class="indent" >
</div>
</div>
<!--l. 1985--><p class="indent" >   Эти функции полезны для преобразования последовательности в
каноническую форму представления множества.
</div>
<div class=defun>
<!--l. 1989--><p class="noindent" ><i>[Function]</i><a 
 id="dx97-198021"></a><a 
 id="x97-198022r386"></a><b> substitute</b>  <i>newitem</i> <i>olditem</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i> <i>:test-not</i>
<i>:start</i> <i>:end</i> <i>:count</i> <i>:key</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx97-198023"></a><a 
 id="x97-198024r387"></a><b> substitute-if</b>  <i>newitem</i> <i>test</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start :end</i>
<i>:count</i> <i>:key</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx97-198025"></a><a 
 id="x97-198026r388"></a><b> substitute-if-not</b>  <i>newitem</i> <i>test</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start</i>
<i>:end</i> <i>:count</i> <i>:key</i>
<!--l. 1993--><p class="noindent" >Результатом является последовательность такого же типа что и исходная
<i>sequence</i> за исключением того, что удовлетворяющие условию элементы в
интервале :start-:end будут заменены на объект <i>newitem</i>. Эта операция
создаёт копию исходной последовательности с некоторыми изменёнными
элементами.
<!--l. 2000--><p class="indent" >   Если указан аргумент :count, то изменяться будет только это количество
элементов. Если количество изменяемых элементов превышает параметр,
тогда будут удалены только самые левые в количестве равном :count.
<!--l. 2005--><p class="indent" >   Если при использовании :count для параметра :from-end указано не-<a 
href="clmse31.html#x42-74002r18">nil</a>
значение, тогда изменение элементов будет происходить справа в количестве
:count. Например: <div class=lisp><div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(substitute 9 4 &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (1 2 9 1 3 9 5)
</td></tr></table>
<!--l. 2010--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(substitute 9 4 &#x2019;(1 2 4 1 3 4 5) :count 1) <span class="math"> ⇒</span> (1 2 9 1 3 4 5)</td></tr></table>
<!--l. 2011--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(substitute 9 4 &#x2019;(1 2 4 1 3 4 5) :count 1 :from-end t)</td></tr></table>
<!--l. 2012--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (1 2 4 1 3 9 5)</td></tr></table>
<!--l. 2013--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(substitute 9 3 &#x2019;(1 2 4 1 3 4 5) :test #&#x2019;&#x003E;) <span class="math"> ⇒</span> (9 9 4 9 3 4 5)</td></tr></table>
<!--l. 2014--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(substitute-if 9 #&#x2019;oddp &#x2019;(1 2 4 1 3 4 5)) <span class="math"> ⇒</span> (9 2 4 9 9 4 9)</td></tr></table>
<!--l. 2015--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(substitute-if 9 #&#x2019;evenp &#x2019;(1 2 4 1 3 4 5) :count 1 :from-end t)</td></tr></table>
<!--l. 2016--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   <span class="math"> ⇒</span> (1 2 4 1 3 9 5)</td></tr></table>
<!--l. 2018--><p class="indent" >
</div>
</div>
<!--l. 2019--><p class="noindent" >Результат <a 
href="#x97-198022r386">substitute</a> может быть <i>соединён</i> с исходной последовательностью.
Также результат может быть равен <a 
href="clmse33.html#x44-78002r44">eq</a> исходной последовательности, если ни
одного элементы не было изменено.
<!--l. 2023--><p class="indent" >   Смотрите также <a 
href="clmse84.html#x104-208003r473">subst</a>, которая осуществляет замену в древовидной
структуре.
</div>
<div class=defun>
<!--l. 2027--><p class="noindent" ><i>[Function]</i><a 
 id="dx97-198027"></a><a 
 id="x97-198028r389"></a><b> nsubstitute</b>  <i>newitem</i> <i>olditem</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:test</i>
<i>:test-not</i> <i>:start</i> <i>:end</i> <i>:count</i> <i>:key</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx97-198029"></a><a 
 id="x97-198030r390"></a><b> nsubstitute-if</b>  <i>newitem</i> <i>test</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start :end</i>
<i>:count</i> <i>:key</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx97-198031"></a><a 
 id="x97-198032r391"></a><b> nsubstitute-if-not</b>  <i>newitem</i> <i>test</i> <i>sequence</i> &#x0026;key  <i>:from-end</i> <i>:start</i>
<i>:end</i> <i>:count</i> <i>:key</i>
<!--l. 2031--><p class="noindent" >Эта функция является деструктивным аналогом для <a 
href="#x97-198022r386">substitute</a>. Это
значит, что они модифицирует свой аргумент. Результатом является
последовательность такого же типа что и исходная <i>sequence</i> за исключением
того, что удовлетворяющие условию элементы в интервале :start-:end будут
заменены на объект <i>newitem</i>. Последовательность <i>sequence</i> может быть
модифицирована, поэтому результат может быть равен <a 
href="clmse33.html#x44-78002r44">eq</a> или нет исходной
последовательности.
<!--l. 2041--><p class="indent" >   Смотрите также <a 
href="clmse84.html#x104-208010r476">nsubst</a>, которая осуществляет деструктивную замену в
древовидной структуре.
</div>
                                                                          

                                                                          
   <!--l. 2045--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse79.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse77.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse77.html#tailclmse77.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse78.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch14.html#clmse78.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 2045--><p class="indent" >   <a 
 id="tailclmse78.html"></a>  
</body></html> 
