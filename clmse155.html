<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Gatherers</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 87--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse156.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse154.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse154.html#tailclmse154.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse155.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmap2.html#clmse155.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">B.3   </span> <a 
href="clm.html#QQ2-190-3186" id="x190-3160000B.3">Gatherers</a></h3>
<!--l. 89--><p class="noindent" >These functions create and process gatherers.
<div class="defun">
<!--l. 91--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx190-3160001"></a><a 
 id="x190-3160002r1063"></a><b> gatherer</b>  <i>collector</i>
</div>
<!--l. 93--><p class="noindent" ><span class="paragraphHead"><a 
href="#x190-3161000B.3" id="x190-3161000B.3"></a></span>
   The collector must be a function of type <tt>(function ((series <span class="math">t<sub>1</sub></span>)) <span class="math">t<sub>2</sub></span>)</tt>.
Given this function, <tt><a 
href="#x190-3160002r1063">gatherer</a></tt> returns a gatherer that accepts elements of type <span class="math">t<sub>1</sub></span>
and returns a ﬁnal result of type <span class="math">t<sub>2</sub></span>. The method for combining elements used by
the gatherer is the same as the one used by the collector.
</div>
<div class="defun">
<!--l. 102--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx190-3161001"></a><a 
 id="x190-3161002r1064"></a><b> next-out</b>  <i>gatherer</i> <i>item</i>
</div>
<!--l. 104--><p class="noindent" ><span class="paragraphHead"><a 
href="#x190-3162000B.3" id="x190-3162000B.3"></a></span>
   Given a gatherer and a value, <tt><a 
href="#x190-3161002r1064">next-out</a></tt> enters the value into the gatherer.
</div>
<div class="defun">
<!--l. 110--><p class="noindent" ><div class="defunheader"> <i>[Function]</i><a 
 id="dx190-3162001"></a><a 
 id="x190-3162002r1065"></a><b> result-of</b>  <i>gatherer</i>
</div>
<!--l. 112--><p class="noindent" ><span class="paragraphHead"><a 
href="#x190-3163000B.3" id="x190-3163000B.3"></a></span>
<tt>
   <a 
href="#x190-3162002r1065">result-of</a></tt> retrieves the net result from a gatherer. <tt><a 
href="#x190-3162002r1065">result-of</a></tt> can be applied
at any time. However, it is an error to apply <tt><a 
href="#x190-3162002r1065">result-of</a></tt> twice to the same
gatherer or to apply <tt><a 
href="#x190-3161002r1064">next-out</a></tt> to a gatherer once <tt><a 
href="#x190-3162002r1065">result-of</a></tt> has been applied.
<div class="lisp"><div class="tabbing">
(let ((g (gatherer #&#x2019;collect-sum)))
                                                                          

                                                                          
   <br>                       (dolist (i &#x2019;(1 2 3 4))<br>                         (next-out g i)<br>
    (if (evenp i) (next-out g (* 10 i))))<br>                       (result-of g))<br>
 <span class="math"> ⇒</span> 70<br>
<!--l. 124--><p class="noindent" ></div>
<!--l. 124--><p class="noindent" ><span class="paragraphHead"><a 
href="#x190-3164000B.3" id="x190-3164000B.3"></a></span>
<!--l. 124--><p class="noindent" ><span class="paragraphHead"><a 
href="#x190-3165000B.3" id="x190-3165000B.3"></a></span>
</div>
</div>
<div class="defmac">
<div class="defmacheader">
<!--l. 128--><p class="indent" >   <div class="tabbing">
 <i>[Макрос]</i><b> gathering </b><a 
 id="dx190-3165001"></a><a 
 id="x190-3165002r1066"></a> ({(var fn)}*) {form}*
   <br>
<!--l. 129--><p class="noindent" ></div>
<!--l. 129--><p class="noindent" ><span class="paragraphHead"><a 
href="#x190-3166000B.3" id="x190-3166000B.3"></a></span>
</div>
<!--l. 130--><p class="indent" >   The ﬁrst subform must be a list of pairs. The ﬁrst element of each pair, var,
must be a variable name. The second element of each pair, fn, must be a form
that when wrapped in <tt>(function ...)</tt> is acceptable as an argument
to <tt><a 
href="#x190-3160002r1063">gatherer</a></tt>. Each symbol is bound to a gatherer constructed from the
corresponding collector. The body (consisting of the forms) is evaluated in the
scope of these bindings. When this evaluation is complete, <tt><a 
href="#x190-3165002r1066">gathering</a></tt> returns the
<tt><a 
href="#x190-3162002r1065">result-of</a></tt> each gatherer. If there are <span class="math">n</span> pairs in the binding list, <tt><a 
href="#x190-3165002r1066">gathering</a></tt>
returns <span class="math">n</span> values. For example: <div class="lisp"><div class="tabbing">
(defun examp (data)
                                                                          

                                                                          
   <br>   (gathering ((x collect) (y collect-sum))<br>     (iterate ((i (scan data)))<br>
      (case (ﬁrst i)<br>                        (:slot (next-out x (second i)))<br>
        (:part (dolist (j (second i)) (next-out x j))))<br>
      (next-out y (third i)))))<br>                                            <br>
(examp &#x2019;((:slot a 10) (:part (c d) 40))) <span class="math"> ⇒</span> (a c d) and 50<br>
<!--l. 150--><p class="noindent" ></div>
<!--l. 150--><p class="noindent" ><span class="paragraphHead"><a 
href="#x190-3167000B.3" id="x190-3167000B.3"></a></span>
<!--l. 150--><p class="noindent" ><span class="paragraphHead"><a 
href="#x190-3168000B.3" id="x190-3168000B.3"></a></span>
</div>
<!--l. 152--><p class="indent" >   As a further illustration of gatherers, consider the following deﬁnition for
a simpliﬁed version of <tt><a 
href="#x190-3165002r1066">gathering</a></tt> that handles only one binding pair.
<div class="lisp"><div class="tabbing">
(defmacro simple-gathering (((var collector)) &#x0026;body body)
   <br>           ‘(let ((,var (gatherer (function ,collector))))<br>              ,@body<br>
     (result-of ,var)))<br>
<!--l. 159--><p class="noindent" ></div>
<!--l. 159--><p class="noindent" ><span class="paragraphHead"><a 
href="#x190-3169000B.3" id="x190-3169000B.3"></a></span>
<!--l. 159--><p class="noindent" ><span class="paragraphHead"><a 
href="#x190-3170000B.3" id="x190-3170000B.3"></a></span>
</div>
<!--l. 160--><p class="indent" >   The full capabilities of <tt><a 
href="#x190-3165002r1066">gathering</a></tt> can be supported in much the same
way.
</div>
                                                                          

                                                                          
<!--l. 164--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse156.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse154.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse154.html#tailclmse154.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse155.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmap2.html#clmse155.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse155.html"></a>   </div> </div> 
</body></html> 
