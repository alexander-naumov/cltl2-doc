<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Arrays Массивы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-10 13:43:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 1965--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse8.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html#tailclmse6.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse7.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch2.html#clmse7.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">2.5   </span> <a 
 id="x14-310002.5"></a>Arrays Массивы</h3>
<a 
 id="dx14-31001"></a>
<!--l. 1969--><p class="noindent" >An array is an object with components arranged according to a Cartesian
coordinate system. In general, these components may be any Lisp data
objects.
<!--l. 1973--><p class="indent" >   Массив является объектом с элементами расположенными в соответсвии с
Декартовой системой координат.
<!--l. 1976--><p class="indent" >   The number of dimensions of an array is called its <i>rank</i> (this terminology is
borrowed from APL); the rank is a non-negative integer. Likewise, each dimension
is itself a non-negative integer. The total number of elements in the array is the
product of all the dimensions.
<!--l. 1983--><p class="indent" >   Количество измерений массива называется <i>ранг</i> (это терминология взята
из APL); ранг является неотрицательных целым. Также каждое измерение
само по себе является неотрицательным целым. Общее количество элементов
в массиве является произведением всех измерений.
<!--l. 1988--><p class="indent" >   An implementation of Common Lisp may impose a limit on the rank of an
array, but this limit may not be smaller than 7. Therefore, any Common Lisp
program may assume the use of arrays of rank 7 or less. (A program may
determine the actual limit on array ranks for a given implementation by
examining the constant <a 
href="clmse94.html#x116-238007r559">array-rank-limit</a>.)
<!--l. 1994--><p class="indent" >   Реализация Common Lisp&#x2019;а может налагать ограничение на ранг
массива, но данное ограничение не может быть менее 7. Таким образом,
любая Common Lisp программа может использователь массивы с
семью и менее измеренеиями. (Программа может получить текущее
ограничение для ранга для заданной реализации с помощью константы
<a 
href="clmse94.html#x116-238007r559">array-rank-limit</a>.)
<!--l. 2000--><p class="indent" >   It is permissible for a dimension to be zero. In this case, the array has no
elements, and any attempt to access an element is in error. However, other
properties of the array, such as the dimensions themselves, may be used. If
the rank is zero, then there are no dimensions, and the product of the
dimensions is then by deﬁnition 1. A zero-rank array therefore has a single
                                                                          

                                                                          
element.
<!--l. 2008--><p class="indent" >   Существование нулевого ранга допускается. В этом случае, массив не
содержит элементов, и любой доступ к элементам является ошибкой. Тогда
как другие свойства массива могут использоваться. Если ранг равен нулю,
тогда массив не имеет измерений, и их произведение приравнивается к 1
(FIXME). Таким образом массив с нулевым рангом содержит один
элемент.
<!--l. 2014--><p class="indent" >   An array element is speciﬁed by a sequence of indices. The length of
the sequence must equal the rank of the array. Each index must be a
non-negative integer strictly less than the corresponding array dimension. Array
indexing is therefore zero-origin, not one-origin as in (the default case of)
Fortran.
<!--l. 2021--><p class="indent" >   Элемент массива задается последовательностью индексов. Длина данной
последовательности должна равнятся рангу массива. Каждый индекс должен
быть неотрицательным целым строго меньшим размеру соотвествующего
измерения. Также индексация массива начинается с нуля, а не с единицы,
как в по умолчанию Fortran&#x2019;е.
<!--l. 2027--><p class="indent" >   As an example, suppose that the variable foo names a 3-by-5 array. Then the
ﬁrst index may be 0, 1, or 2, and the second index may be 0, 1, 2, 3, or 4. One
may refer to array elements using the function <a 
href="clmse95.html#x117-239002r563">aref</a>; for example, (aref foo 2
1) refers to element (2, 1) of the array. Note that <a 
href="clmse95.html#x117-239002r563">aref</a> takes a variable
number of arguments: an array, and as many indices as the array has
dimensions. A zero-rank array has no dimensions, and therefore <a 
href="clmse95.html#x117-239002r563">aref</a> would
take such an array and no indices, and return the sole element of the
array.
<!--l. 2038--><p class="indent" >   В качестве примера, предположим, что переменная foo обозначает
двумерный массив с размерами измерений 3 и 5. Первый индекс может быть
0, 1 или 2, и второй индекс может быть 0, 1, 2, 3 или 4. Обращение к
элементам массива может быть осуществлено с помощью функции <a 
href="clmse95.html#x117-239002r563">aref</a>;
например, (aref foo 2 1) ссылается на элемент массива (2, 1). Следует
отметить, что <a 
href="clmse95.html#x117-239002r563">aref</a> принимает переменное число аргументов: массив, и
столько индексов, сколько измерений у массива. Массив с нулевым рангом не
имеет измерений, и в таком случае <a 
href="clmse95.html#x117-239002r563">aref</a> принимает только один параметр –
массив, и не принимает индексы, и возвращает одиночный элемент
массива.
<!--l. 2049--><p class="indent" >   In general, arrays can be multidimensional, can share their contents with other
array objects, and can have their size altered dynamically (either enlarging or
shrinking) after creation. A one-dimensional array may also have a <i>ﬁll
                                                                          

                                                                          
pointer</i>.
<!--l. 2054--><p class="indent" >   В общем случае, Массивы могут быть многомерными, могут иметь общее
содержимое с другими массивами. и могут динамически менять свой размер
после создания (и увеличивать, и уменьшать). Одномерный массив может
также иметь <i>указатель заполнения</i>.
<!--l. 2059--><p class="indent" >   Multidimensional arrays store their components in row-major order; that is,
internally a multidimensional array is stored as a one-dimensional array, with the
multidimensional index sets ordered lexicographically, last index varying fastest.
This is important in two situations: (1) when arrays with diﬀerent dimensions
share their contents, and (2) when accessing very large arrays in a virtual-memory
implementation. (The ﬁrst situation is a matter of semantics; the second, a matter
of eﬃciency.)
<!--l. 2068--><p class="indent" >   Многомерные массивы сохраняют элементы построчно; это значит, что
внутренне многомерный массив хранится как одномерный массив с порядком
элементов, соответствующим лексикографическому порядку их индексов. Это
важно в двух ситуациях: (1) когда массивы с разными измерениями имеют
общее содержимое, и (2) когда осуществляется доступ к очень большому
массиву в виртуальной памяти. (Первая ситуация касается семантики; вторая
– эффективности)
<!--l. 2076--><p class="indent" >   An array that is not displaced to another array, has no ﬁll pointer, and is not
to have its size adjusted dynamically after creation is called a <i>simple</i> array. The
user may provide declarations that certain arrays will be simple. Some
implementations can handle simple arrays in an especially eﬃcient manner; for
example, simple arrays may have a more compact representation than non-simple
arrays.
<!--l. 2083--><p class="indent" >   Массив, что не указывает на другой массив, не имеет указателя
заполнения и не имеет динамически расширяемого размера после создания
называется <i>простым</i> массивом. Пользователи могут декларировать то, что
конкретный массив будет простым. Некоторые реализации могут
обрабатывать простые массивы более эффективным способом; например,
простые массивы могут храниться более компактно, что непростые
массивы.
<div class=newer>
<!--l. 2091--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx14-31002"></a>to clarify that if one or more of the :adjustable,
:ﬁll-pointer, and :displaced-to arguments is true when <a 
href="clmse94.html#x116-238002r558">make-array</a> is called, then
whether the resulting array is simple is unspeciﬁed; but if all three arguments are
false, then the resulting array is guaranteed to be simple.
<!--l. 2099--><p class="indent" >   Если один или более из :adjustable, :ﬁll-pointer и :displaced-to аргументов
                                                                          

                                                                          
равен true, когда вызывается <a 
href="clmse94.html#x116-238002r558">make-array</a>, тогда является ли результат
простым массивом не определено; однако если все три аргумента равны false,
тогда результат гарантированно будет простым массивом.
</div>
<!--l. 2105--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.1   </span> <a 
 id="x14-320002.5.1"></a>Vectors Векторы</h4>
<!--l. 2107--><p class="noindent" >One-dimensional arrays are called <i>vectors</i> in Common Lisp and constitute the
type <a 
href="clmse94.html#x116-238014r562">vector</a> (which is therefore a subtype of array). Vectors and lists are
collectively considered to be <i>sequences</i>. They diﬀer in that any component of a
one-dimensional array can be accessed in constant time, whereas the average
component access time for a list is linear in the length of the list; on the other
hand, adding a new element to the front of a list takes constant time, whereas
the same operation on an array takes time linear in the length of the
array.
<!--l. 2117--><p class="indent" >   В Common Lisp&#x2019;е одномерные массивы называется <i>векторами</i>, и
составляют тип вектор (который в свою очередь является подтипом массива).
Вектора и списки вместе являются <i>последовательностями</i>. Они отличаются
тем, что любой элемент одномерного массива может быть получен за
константное время, тогда как среднее время доступа к компоненту для
списка линейно зависит от длины списка, с другой стороны, добавление
нового элемента в начала списка занимает константное время, тогда как эта
же операция для массива занимает время линейно зависящее от длины
массива.
<!--l. 2126--><p class="indent" >   A general vector (a one-dimensional array that can have any data object as an
element but that has no additional paraphernalia) can be notated by notating the
components in order, separated by whitespace and surrounded by #( and ). For
example:
<!--l. 2133--><p class="indent" >   Обычный вектор (одномерный массив, который может содержать любой
тип объектов, но не имеющий дополнительных атрибутов) может быть
записан с помощью перечисления элементов разделенных пробелом и
окруженных #( и ). Например: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#(a b c)                    ;A vector of length 3
</td></tr></table>
<!--l. 2139--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#()                         ;An empty vector</td></tr></table>
                                                                          

                                                                          
<!--l. 2140--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)</td></tr></table>
<!--l. 2141--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                            ;A vector containing the primes below 50</td></tr></table>
<!--l. 2143--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#(a b c)                    ;Вектор из трех элементов
</td></tr></table>
<!--l. 2146--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#()                         ;Путой вектор</td></tr></table>
<!--l. 2147--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)</td></tr></table>
<!--l. 2148--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                            ;Вектор содержит простые числа меньшие пятидесяти</td></tr></table>
<!--l. 2150--><p class="indent" >
</div>
</div>
<!--l. 2151--><p class="noindent" >Note that when the function <a 
href="clmse116.html#x143-281003r696">read</a> parses this syntax, it always constructs a <i>simple</i>
general vector.
<!--l. 2154--><p class="indent" >   Следует отметить, что когда функция <a 
href="clmse116.html#x143-281003r696">read</a> парсит данный синтаксис, она
всегда создает <i>простой</i> массив.
<div class=rationale>
<!--l. 2158--><p class="noindent" ><b>Rationale:</b> Many people have suggested that brackets be used to notate vectors, as [a b
c] instead of #(a b c). This notation would be shorter, perhaps more readable, and
certainly in accord with cultural conventions in other parts of computer science and
mathematics. However, to preserve the usefulness of the user-deﬁnable macro-character
feature of the function <a 
href="clmse116.html#x143-281003r696">read</a>, it is necessary to leave some characters to the user for this
purpose. Experience in MacLisp has shown that users, especially implementors of
languages for use in artiﬁcial intelligence research, often want to deﬁne special kinds of
brackets. Therefore Common Lisp avoids using brackets and braces for any syntactic
purpose.
<!--l. 2172--><p class="indent" >   Многие люди рекомендовали использовать квадратные скобки для задания
векторов так: [a b c] вместо #(a b c). Данная запись короче, возможно более
читаема, и безусловно совпадает с культурными традициями в других частях
компьютерных наук и математики. Однако, для достижения предельной
полезности от пользовательских макросимволов, что расширяют возможности
                                                                          

                                                                          
функции <a 
href="clmse116.html#x143-281003r696">read</a>, необходимо было оставить некоторые строковые символы для этих
пользовательских целей. Опыт использования MacLisp&#x2019;а показывает, что
пользователи, особенно разработчики языков для использования в исследованиях
искусственного интеллекта, часто хотят определять специальные значения для
квадратных скобос. Таким образом Common Lisp не использует квадратных и
фигурных скобок в своем синтаксисе.
</div>
<!--l. 2186--><p class="indent" >   Implementations may provide certain specialized representations of arrays for
eﬃciency in the case where all the components are of the same specialized
(typically numeric) type. All implementations provide specialized arrays for the
cases when the components are characters (or rather, a special subset of the
characters); the one-dimensional instances of this specialization are called <i>strings</i>.
All implementations are also required to provide specialized arrays of bits, that is,
arrays of type (array bit); the one-dimensional instances of this specialization are
called <i>bit-vectors</i>.
<!--l. 2198--><p class="indent" >   Реализации могут предоставлять специализированные представления
массивов для достижения эффективности в случаях, когда все элементы
принадлежат одному определенному типу (например, числовому). Все
реализации предоставляют специальные массивы в случаях, когда все
элементы являются строковыми символами (или специализированное
подмножество строковых символов); такие одномерные массивы называются
<i>строки</i>. Все реализации также должны предоставлять специализированные
битовые массивы, которые принадлежат типу (array bit); такие одномерные
массивы назваются <i>битовые векторы</i>.
<!--l. 2208--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.2   </span> <a 
 id="x14-330002.5.2"></a>Strings Строки</h4>
<div class=obsolete>
<!--l. 2212--><p class="noindent" >A string is simply a vector of characters. More precisely, a string is a specialized
vector whose elements are of type string-char.
</div> <div class=newer> X3J13 voted in March 1989 <a 
 id="dx14-33001"></a>to eliminate the type string-char and to redeﬁne the
type <a 
href="clmse102.html#x125-247028r618">string</a> to be the union of one or more specialized vector types, the types of
whose elements are subtypes of the type <a 
href="clmse79.html#x97-215002r384">character</a>. Subtypes of <a 
href="clmse102.html#x125-247028r618">string</a> include
simple-string, base-string, and simple-base-string.
<div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">base-string  ≡ (vector base-character)
</td></tr></table>
<!--l. 2226--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">simple-base-string  ≡ (simple-array base-character (*))</td></tr></table>
<!--l. 2228--><p class="indent" >
</div>
</div>
<!--l. 2229--><p class="noindent" >An implementation may support other string subtypes as well. All Common Lisp
functions that operate on strings treat all strings uniformly; note, however,
that it is an error to attempt to insert an extended character into a base
string.
</div>
<!--l. 2236--><p class="noindent" >
                                                                          

                                                                          
<!--l. 2238--><p class="indent" >   The type <a 
href="clmse102.html#x125-247028r618">string</a> is therefore a subtype of the type <a 
href="clmse94.html#x116-238014r562">vector</a>.
<!--l. 2240--><p class="indent" >   Строковый тип является подтипом векторного типа.
<!--l. 2242--><p class="indent" >   A string can be written as the sequence of characters contained in the
string, preceded and followed by a &#x0022; (double quote) character. Any &#x0022; or \
character in the sequence must additionally have a \ character before
it.
<!--l. 2247--><p class="indent" >   Строка может быть записана как последовательность символов
содержащихся в строке, с предшествующим и последующим символом
двойной кавычки &#x0022;. Любой символ &#x0022; или \ в данной последовательности
должен иметь предшествующий символ \.
<!--l. 2252--><p class="indent" >   For example:
<!--l. 2254--><p class="indent" >   Например: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;Foo&#x0022;                         ;A string with three characters in it
</td></tr></table>
<!--l. 2256--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;&#x0022;                            ;An empty string</td></tr></table>
<!--l. 2257--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;\&#x0022;APL\\360?\&#x0022; he cried.&#x0022;     ;A string with twenty characters</td></tr></table>
<!--l. 2258--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;|x| = |-x|&#x0022;                  ;A ten-character string</td></tr></table>
<!--l. 2260--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;Foo&#x0022;                         ;Строка из трех символов
</td></tr></table>
<!--l. 2263--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;&#x0022;                            ;Пустая строка</td></tr></table>
<!--l. 2264--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;\&#x0022;APL\\360?\&#x0022; he cried.&#x0022;     ;Строка из двенадцати символов</td></tr></table>
<!--l. 2266--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;|x| = |-x|&#x0022;                  ;Строка из десяти символов</td></tr></table>
<!--l. 2268--><p class="indent" >
</div>
</div>
<!--l. 2269--><p class="noindent" >Notice that any vertical bar | in a string need not be preceded by a \. Similarly, any
double quote in the name of a symbol written using vertical-bar notation need not
be preceded by a \. The double-quote and vertical-bar notations are similar but
                                                                          

                                                                          
distinct: double quotes indicate a character string containing the sequence of
characters, whereas vertical bars indicate a symbol whose name is the contained
sequence of characters.
<!--l. 2278--><p class="indent" >   Необходимо отметить, что символ вертикальной черты | в строке не
должен быть экранирован с помощью \. Также как и любая двойная
кавычка в имени символа, записанного с использованием вертикальных черт,
не нуждается в экранировании. Записи с помощью двойной кавычки и
вертикальной черты похожи, но используются для разных целей: двойная
кавычка указывает на строку, содержающую строковые символы, тогда как
вертикальная черта указывает на символ, имя которого содержит
последовательность строковых символов.
<!--l. 2286--><p class="indent" >   The characters contained by the double quotes, taken from left to right,
occupy locations within the string with increasing indices. The leftmost character
is string element number 0, the next one is element number 1, the next one is
element number 2, and so on.
<!--l. 2291--><p class="indent" >   Строковые символы обрамленные двойными кавычками, считываются
слева направо. Индекс символа больше индекса предыдущего символа на 1.
Самый левый символ строки имеет индекс 0, следующий 1, следующий 2, и
т.д.
<!--l. 2295--><p class="indent" >   Note that the function prin1 will print any character vector (not just a simple
one) using this syntax, but the function <a 
href="clmse116.html#x143-281003r696">read</a> will always construct a simple string
when it reads this syntax.
<!--l. 2300--><p class="indent" >   Следует отметить, что функция prin1 будет выводить на печать любой
вектор строковых символов (не только простой), используя данный
синтаксис, но функция <a 
href="clmse116.html#x143-281003r696">read</a> будет всегда создавать простую строку, при
разборе данного синтаксиса.
   <h4 class="subsectionHead"><span class="titlemark">2.5.3   </span> <a 
 id="x14-340002.5.3"></a>Bit-Vectors</h4>
<!--l. 2306--><p class="noindent" >A bit-vector can be written as the sequence of bits contained in the string,
preceded by #*; any delimiter character, such as whitespace, will terminate the
bit-vector syntax. For example:
<!--l. 2311--><p class="indent" >   Битовый вектор может быть записан в виде последовательности битов
заключенных в строку с предшествующей #*; любой разделитится,
например, как пробел завершает синаксис битового вектора. Например: <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#*10110     ;A ﬁve-bit bit-vector; bit 0 is a 1
</td></tr></table>
<!--l. 2316--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#*          ;An empty bit-vector</td></tr></table>
<!--l. 2318--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#*10110     ;Пятибитный битовый вектор; нулевой бит 1
</td></tr></table>
<!--l. 2321--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#*          ;Пустой битовый вектор</td></tr></table>
<!--l. 2323--><p class="indent" >
</div>
</div>
<!--l. 2325--><p class="indent" >   The bits notated following the #*, taken from left to right, occupy locations
within the bit-vector with increasing indices. The leftmost notated bit is
bit-vector element number 0, the next one is element number 1, and so
on.
<!--l. 2330--><p class="indent" >   Биты записанные после #*, читаются слева направо. Индекс каждого
бита больше индекса предыдущего бита на 1. Индекс самого левого бита 0,
следующего 1 и т.д.
<!--l. 2334--><p class="indent" >   The function prin1 will print any bit-vector (not just a simple one) using this
syntax, but the function <a 
href="clmse116.html#x143-281003r696">read</a> will always construct a simple bit-vector when it
reads this syntax.
<!--l. 2338--><p class="indent" >   Функция prin1 распечатывают любой битовый вектор (не только простой)
используя этот синтаксис, однако функция <a 
href="clmse116.html#x143-281003r696">read</a> будет всегда создавать
простой битовый веткор, когда разбирает данный синтаксис.
                                                                          

                                                                          
   <!--l. 2342--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse8.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html#tailclmse6.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse7.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch2.html#clmse7.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 2342--><p class="indent" >   <a 
 id="tailclmse7.html"></a>  
</body></html> 
