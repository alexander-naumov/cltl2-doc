<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Массивы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-28 14:08:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 2654--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse8.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html#tailclmse6.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse7.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch2.html#clmse7.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">2.5   </span> <a 
href="clm.html#QQ2-14-35" id="x14-290002.5">Массивы</a></h3>
<a 
 id="dx14-29001"></a>
<!--l. 2658--><p class="noindent" >Массив является объектом с элементами расположенными в соответствие с
Декартовой системой координат.
<!--l. 2661--><p class="indent" >   Количество измерений массива называется <i>ранг</i> (это терминология взята
из APL); ранг является неотрицательных целым. Также каждое измерение
само по себе является неотрицательным целым. Общее количество элементов
в массиве является произведением всех измерений.
<!--l. 2666--><p class="indent" >   Реализация Common Lisp&#x2019;а может налагать ограничение на ранг массива,
но данное ограничение не может быть менее 7. Таким образом, любая
Common Lisp программа может использовать массивы с семью и менее
измерениями. (Программа может получить текущее ограничение для ранга
для заданной реализации с помощью константы <a 
href="clmse88.html#x110-214004r502">array-rank-limit</a>.)
<!--l. 2672--><p class="indent" >   Существование нулевого ранга допускается. В этом случае, массив не
содержит элементов, и любой доступ к элементам является ошибкой. Тогда
как другие свойства массива могут использоваться. Если ранг равен нулю,
тогда массив не имеет измерений, и их произведение приравнивается к 1
(FIXME). Таким образом массив с нулевым рангом содержит один
элемент.
<!--l. 2678--><p class="indent" >   Элемент массива задаётся последовательностью индексов. Длина
данной последовательности должна равняется рангу массива. Каждый
индекс должен быть неотрицательным целым строго меньшим размеру
соответствующего измерения. Также индексация массива начинается с нуля,
а не с единицы, как в по умолчанию Fortran&#x2019;е.
<!--l. 2684--><p class="indent" >   В качестве примера, предположим, что переменная foo обозначает
двумерный массив с размерами измерений 3 и 5. Первый индекс может быть
0, 1 или 2, и второй индекс может быть 0, 1, 2, 3 или 4. Обращение к
элементам массива может быть осуществлено с помощью функции <a 
href="clmse89.html#x111-215002r506">aref</a>;
например, (aref foo 2 1) ссылается на элемент массива (2, 1). Следует
отметить, что <a 
href="clmse89.html#x111-215002r506">aref</a> принимает переменное число аргументов: массив, и
столько индексов, сколько измерений у массива. Массив с нулевым рангом не
                                                                          

                                                                          
имеет измерений, и в таком случае <a 
href="clmse89.html#x111-215002r506">aref</a> принимает только один параметр –
массив, и не принимает индексы, и возвращает одиночный элемент
массива.
<!--l. 2695--><p class="indent" >   В общем случае, Массивы могут быть многомерными, могут иметь общее
содержимое с другими массивами. и могут динамически менять свой размер
после создания (и увеличивать, и уменьшать). Одномерный массив может
также иметь <i>указатель заполнения</i>.
<!--l. 2700--><p class="indent" >   Многомерные массивы сохраняют элементы построчно; это значит, что
внутренне многомерный массив хранится как одномерный массив с порядком
элементов, соответствующим лексикографическому порядку их индексов. Это
важно в двух ситуациях: (1) когда массивы с разными измерениями имеют
общее содержимое, и (2) когда осуществляется доступ к очень большому
массиву в виртуальной памяти. (Первая ситуация касается семантики; вторая
– эффективности)
<!--l. 2708--><p class="indent" >   Массив, что не указывает на другой массив, не имеет указателя
заполнения и не имеет динамически расширяемого размера после создания
называется <i>простым</i> массивом. Пользователи могут декларировать то, что
конкретный массив будет простым. Некоторые реализации могут
обрабатывать простые массивы более эффективным способом; например,
простые массивы могут храниться более компактно, что непростые
массивы.
<div class=newer>
<!--l. 2716--><p class="indent" >   X3J13 проголосовал в июне 1989 <a 
 id="dx14-29002"></a>пояснить, что один или более из
:adjustable, :ﬁll-pointer и :displaced-to аргументов равен true, когда
вызывается <a 
href="clmse88.html#x110-214002r501">make-array</a>, тогда является ли результат простым массивом не
определено; однако если все три аргумента равны false, тогда результат
гарантированно будет простым массивом.
</div>
<!--l. 2724--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.1   </span> <a 
href="clmli1.html#QQ2-14-36" id="x14-300002.5.1">Векторы</a></h4>
<!--l. 2726--><p class="noindent" >В Common Lisp&#x2019;е одномерные массивы называется <i>векторами</i>, и составляют
тип вектор (который в свою очередь является подтипом массива). Вектора и
списки вместе являются <i>последовательностями</i>. Они отличаются тем, что
любой элемент одномерного массива может быть получен за константное
время, тогда как среднее время доступа к компоненту для списка
                                                                          

                                                                          
линейно зависит от длины списка, с другой стороны, добавление нового
элемента в начала списка занимает константное время, тогда как эта же
операция для массива занимает время линейно зависящее от длины
массива.
<!--l. 2735--><p class="indent" >   Обычный вектор (одномерный массив, который может содержать любой
тип объектов, но не имеющий дополнительных атрибутов) может быть
записан с помощью перечисления элементов разделённых пробелом и
окружённых #( и ). Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#(a b c)                    ;Вектор из трёх элементов
</td></tr></table>
<!--l. 2741--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#()                         ;Пустой вектор</td></tr></table>
<!--l. 2742--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)</td></tr></table>
<!--l. 2743--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                            ;Вектор содержит простые числа меньшие пятидесяти</td></tr></table>
<!--l. 2745--><p class="indent" >
</div>
</div>
<!--l. 2747--><p class="indent" >   Следует отметить, что когда функция <a 
href="clmse110.html#x137-256003r634">read</a> парсит данный синтаксис, она
всегда создаёт <i>простой</i> массив.
<div class=rationale>
<!--l. 2751--><p class="noindent" ><b>Обоснование:</b> Многие люди рекомендовали использовать квадратные
скобки для задания векторов так: [a b c] вместо #(a b c). Данная запись
короче, возможно более читаема, и безусловно совпадает с культурными
традициями в других частях компьютерных наук и математики. Однако, для
достижения предельной полезности от пользовательских макросимволов,
что расширяют возможности функции <a 
href="clmse110.html#x137-256003r634">read</a>, необходимо было оставить
некоторые строковые символы для этих пользовательских целей. Опыт
использования MacLisp&#x2019;а показывает, что пользователи, особенно разработчики
языков для использования в исследованиях искусственного интеллекта, часто
хотят определять специальные значения для квадратных скобок. Таким
образом Common Lisp не использует квадратных и фигурных скобок в своём
синтаксисе.
</div>
<!--l. 2766--><p class="indent" >   Реализации могут предоставлять специализированные представления
массивов для достижения эффективности в случаях, когда все элементы
принадлежат одному определённому типу (например, числовому). Все
реализации предоставляют специальные массивы в случаях, когда все
                                                                          

                                                                          
элементы являются строковыми символами (или специализированное
подмножество строковых символов); такие одномерные массивы называются
<i>строки</i>. Все реализации также должны предоставлять специализированные
битовые массивы, которые принадлежат типу (array bit); такие одномерные
массивы называются <i>битовые векторы</i>.
<!--l. 2776--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.2   </span> <a 
href="clmli1.html#QQ2-14-37" id="x14-310002.5.2">Строки</a></h4>
<!--l. 2779--><p class="noindent" >Строковый тип является подтипом векторного типа.
<!--l. 2781--><p class="indent" >   Строка может быть записана как последовательность символов
содержащихся в строке, с предшествующим и последующим символом
двойной кавычки &#x0022;. Любой символ &#x0022; или \ в данной последовательности
должен иметь предшествующий символ \.
<!--l. 2786--><p class="indent" >   Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;Foo&#x0022;                         ;Строка из трёх символов
</td></tr></table>
<!--l. 2788--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;&#x0022;                            ;Пустая строка</td></tr></table>
<!--l. 2789--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;\&#x0022;APL\\360?\&#x0022; he cried.&#x0022;     ;Строка из двенадцати символов</td></tr></table>
<!--l. 2791--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;|x| = |-x|&#x0022;                  ;Строка из десяти символов</td></tr></table>
<!--l. 2793--><p class="indent" >
</div>
</div>
<!--l. 2795--><p class="indent" >   Необходимо отметить, что символ вертикальной черты | в строке не
должен быть экранирован с помощью \. Также как и любая двойная
кавычка в имени символа, записанного с использованием вертикальных черт,
не нуждается в экранировании. Записи с помощью двойной кавычки и
вертикальной черты похожи, но используются для разных целей: двойная
кавычка указывает на строку, содержащую строковые символы, тогда как
вертикальная черта указывает на символ, имя которого содержит
последовательность строковых символов.
<!--l. 2803--><p class="indent" >   Строковые символы обрамленные двойными кавычками, считываются
слева направо. Индекс символа больше индекса предыдущего символа на 1.
Самый левый символ строки имеет индекс 0, следующий 1, следующий 2, и
т.д.
                                                                          

                                                                          
<!--l. 2807--><p class="indent" >   Следует отметить, что функция prin1 будет выводить на печать любой
вектор строковых символов (не только простой), используя данный
синтаксис, но функция <a 
href="clmse110.html#x137-256003r634">read</a> будет всегда создавать простую строку, при
разборе данного синтаксиса.
<!--l. 2811--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.3   </span> <a 
href="clmli1.html#QQ2-14-38" id="x14-320002.5.3">Битовые векторы</a></h4>
<!--l. 2813--><p class="noindent" >Битовый вектор может быть записан в виде последовательности битов
заключённых в строку с предшествующей #*; любой разделитель,
например, как пробел завершает синтаксис битового вектора. Например:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#*10110     ;Пятибитный битовый вектор; нулевой бит 1
</td></tr></table>
<!--l. 2818--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#*          ;Пустой битовый вектор</td></tr></table>
<!--l. 2820--><p class="indent" >
</div>
</div>
<!--l. 2822--><p class="indent" >   Биты записанные после #*, читаются слева направо. Индекс каждого
бита больше индекса предыдущего бита на 1. Индекс самого левого бита 0,
следующего 1 и т.д.
<!--l. 2826--><p class="indent" >   Функция prin1 распечатывают любой битовый вектор (не только простой)
используя этот синтаксис, однако функция <a 
href="clmse110.html#x137-256003r634">read</a> будет всегда создавать
простой битовый вектор, когда разбирает данный синтаксис.
                                                                          

                                                                          
   <!--l. 2830--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse8.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html#tailclmse6.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse7.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch2.html#clmse7.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 2830--><p class="indent" >   <a 
 id="tailclmse7.html"></a>  
</body></html> 
