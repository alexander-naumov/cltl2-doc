<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Массивы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-30 23:01:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 2531--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse8.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html#tailclmse6.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse7.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch2.html#clmse7.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">2.5   </span> <a 
href="clm.html#QQ2-14-35" id="x14-290002.5">Массивы</a></h3>
<a 
 id="dx14-29001"></a>
<tt>
<!--l. 2535--><p class="noindent" >Массив</tt> является объектом с элементами расположенными в соответствие с
декартовой системой координат.
<!--l. 2538--><p class="indent" >   Количество измерений массива называется <i>ранг</i> (это терминология
взята из APL). Ранг является неотрицательных целым. Также каждое
измерение само по себе является неотрицательным целым. Общее
количество элементов в массиве является произведением размеров всех
измерений.
<!--l. 2544--><p class="indent" >   Реализация Common Lisp&#x2019;а может налагать ограничение на ранг массива,
но данное ограничение не может быть менее 7. Таким образом, любая
Common Lisp программа может использовать массивы с семью и менее
измерениями. (Программа может получить текущее ограничение для ранга
для используемой системы с помощью константы <tt><a 
href="clmse87.html#x109-213004r502">array-rank-limit</a></tt>.)
<!--l. 2550--><p class="indent" >   Допускается существование нулевого ранга. В этом случае, массив не
содержит элементов, и любой доступ к элементам является ошибкой. При
этом другие свойства массива использоваться могут. Если ранг равен нулю,
тогда массив не имеет измерений, и их произведение приравнивается к 1
(FIXME). Таким образом массив с нулевым рангом содержит один
элемент.
<!--l. 2556--><p class="indent" >   Элемент массива задаётся последовательностью индексов. Длина
данной последовательности должна равняется рангу массива. Каждый
индекс должен быть неотрицательным целым строго меньшим размеру
соответствующего измерения. Также индексация массива начинается с нуля,
а не с единицы, как в по умолчанию Fortran&#x2019;е.
<!--l. 2562--><p class="indent" >   В качестве примера, предположим, что переменная <tt>foo</tt> обозначает
двумерный массив с размерами измерений 3 и 5. Первый индекс может быть
0, 1 или 2, и второй индекс может быть 0, 1, 2, 3 или 4. Обращение к
элементам массива может быть осуществлено с помощью функции <tt><a 
href="clmse88.html#x110-214002r506">aref</a></tt>,
например, <tt>(aref foo 2 1)</tt> ссылается на элемент массива (2, 1). Следует
                                                                          

                                                                          
отметить, что <tt><a 
href="clmse88.html#x110-214002r506">aref</a></tt> принимает переменное число аргументов: массив, и
столько индексов, сколько измерений у массива. Массив с нулевым рангом не
имеет измерений, и в таком случае <tt><a 
href="clmse88.html#x110-214002r506">aref</a></tt> принимает только один параметр –
массив, и не принимает индексы, и возвращает одиночный элемент
массива.
<!--l. 2573--><p class="indent" >   В целом, массивы могут быть многомерными, могут иметь общее
содержимое с другими массивами. и могут динамически менять свой размер
после создания (и увеличивать, и уменьшать). Одномерный массив может
также иметь <i>указатель заполнения</i>.
<!--l. 2578--><p class="indent" >   Многомерные массивы хранят элементы построчно. Это значит, что
внутренне многомерный массив хранится как одномерный массив с порядком
элементов, соответствующим лексикографическому порядку их индексов. Это
важно в двух ситуациях: (1) когда массивы с разными измерениями имеют
общее содержимое, и (2) когда осуществляется доступ к очень большому
массиву в виртуальной памяти. (Первая ситуация касается семантики; вторая
— эффективности)
<!--l. 2586--><p class="indent" >   Массив, что не указывает на другой массив, не имеет указателя
заполнения и не имеет динамически расширяемого размера после создания
называется <i>простым</i> массивом. Пользователи могут декларировать
то, что конкретный массив будет простым. Некоторые реализации
могут обрабатывать простые массивы более эффективным способом,
например, простые массивы могут храниться более компактно, чем
непростые.
<!--l. 2593--><p class="indent" >   Когда вызывается <tt><a 
href="clmse87.html#x109-213002r501">make-array</a></tt>, если один или более из <tt>:adjustable</tt>,
<tt>:fill-pointer</tt> и <tt>:displaced-to</tt> аргументов равен истине, тогда является ли
результат простым массивом не определено. Однако если все три
аргумента равны лжи, тогда результат гарантированно будет простым
массивом.
<!--l. 2598--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.1   </span> <a 
href="clmli1.html#QQ2-14-36" id="x14-300002.5.1">Векторы</a></h4>
<!--l. 2600--><p class="noindent" >В Common Lisp&#x2019;е одномерные массивы называется <i>векторами</i>, и составляют
тип <tt>vector</tt> (который в свою очередь является подтипом <tt>array</tt>). Вектора и
списки вместе являются <i>последовательностями</i>. Они отличаются тем, что
любой элемент одномерного массива может быть получен за константное
время, тогда как среднее время доступа к компоненту для списка
                                                                          

                                                                          
линейно зависит от длины списка, с другой стороны, добавление нового
элемента в начала списка занимает константное время, тогда как эта же
операция для массива занимает время линейно зависящее от длины
массива.
<!--l. 2609--><p class="indent" >   Обычный вектор (одномерный массив, который может содержать любой
тип объектов, но не имеющий дополнительных атрибутов) может быть
записан с помощью перечисления элементов разделённых пробелом и
окружённых <tt>#(</tt> и <tt>)</tt>. Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#(a b c)                    ;Вектор из трёх элементов
</td></tr></table>
<!--l. 2615--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#()                         ;Пустой вектор</td></tr></table>
<!--l. 2616--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)</td></tr></table>
<!--l. 2617--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                            ;Вектор содержит простые числа меньшие пятидесяти</td></tr></table>
<!--l. 2619--><p class="indent" >
</div>
</div>
<!--l. 2621--><p class="indent" >   Следует отметить, что когда функция <tt><a 
href="clmse109.html#x136-255003r634">read</a></tt> парсит данный синтаксис, она
всегда создаёт <i>простой</i> массив.
<div class=rationale>
<!--l. 2625--><p class="noindent" ><b>Обоснование:</b> Многие люди рекомендовали использовать квадратные
скобки для задания векторов так: <tt>[a b c]</tt> вместо <tt>#(a b c)</tt>. Данная запись
короче, возможно более читаема, и безусловно совпадает с культурными
традициями в других областях компьютерных наук и математики. Однако, для
достижения предельной полезности от пользовательских макросимволов,
что расширяют возможности функции <tt><a 
href="clmse109.html#x136-255003r634">read</a></tt>, необходимо было оставить
некоторые строковые символы для этих пользовательских целей. Опыт
использования MacLisp&#x2019;а показывает, что пользователи, особенно разработчики
языков для использования в исследованиях искусственного интеллекта, часто
хотят определять специальные значения для квадратных скобок. Таким
образом Common Lisp не использует квадратных и фигурных скобок в своём
синтаксисе.
</div>
<!--l. 2640--><p class="indent" >   Реализации могут содержать специализированные представления
массивов для достижения эффективности в случаях, когда все элементы
принадлежат одному определённому типу (например, числовому). Все
реализации содержат специальные массивы в случаях, когда все элементы
                                                                          

                                                                          
являются строковыми символами (или специализированное подмножество
строковых символов). Такие одномерные массивы называются <i>строки</i>. Все
реализации также должны содержать специализированные битовые массивы,
которые принадлежат типу <tt>(array bit)</tt>. Такие одномерные массивы
называются <i>битовые векторы</i>.
<!--l. 2650--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.2   </span> <a 
href="clmli1.html#QQ2-14-37" id="x14-310002.5.2">Строки</a></h4>
<tt>
<!--l. 2653--><p class="noindent" >Строковый</tt> тип является подтипом <tt>векторного</tt> типа.
<!--l. 2655--><p class="indent" >   Строка может быть записана как последовательность символов, с
предшествующим и последующим символом двойной кавычки <tt>&#x0022;</tt>. Любой
символ <tt>&#x0022;</tt> или <tt>\</tt> в данной последовательности должен иметь предшествующий
символ <tt>\</tt>.
<!--l. 2660--><p class="indent" >   Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;Foo&#x0022;                         ;Строка из трёх символов
</td></tr></table>
<!--l. 2662--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;&#x0022;                            ;Пустая строка</td></tr></table>
<!--l. 2663--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;\&#x0022;APL\\360?\&#x0022; he cried.&#x0022;     ;Строка из двенадцати символов</td></tr></table>
<!--l. 2665--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">&#x0022;|x| = |-x|&#x0022;                  ;Строка из десяти символов</td></tr></table>
<!--l. 2667--><p class="indent" >
</div>
</div>
<!--l. 2669--><p class="indent" >   Необходимо отметить, что символ вертикальной черты <tt>|</tt> в строке не
должен быть экранирован с помощью <tt>\</tt>. Также как и любая двойная
кавычка в имени символа, записанного с использованием вертикальных черт,
не нуждается в экранировании. Записи с помощью двойной кавычки и
вертикальной черты похожи, но используются для разных целей: двойная
кавычка указывает на строку, содержащую строковые символы, тогда как
вертикальная черта указывает на символ, имя которого содержит
последовательность строковых символов.
<!--l. 2677--><p class="indent" >   Строковые символы обрамленные двойными кавычками, считываются
слева направо. Индекс символа больше индекса предыдущего символа на 1.
Самый левый символ строки имеет индекс 0, следующий 1, следующий 2, и
                                                                          

                                                                          
т.д.
<!--l. 2681--><p class="indent" >   Следует отметить, что функция <tt>prin1</tt> будет выводить на печать в данном
синтаксисе любой вектор строковых символов (не только простой), но
функция <tt><a 
href="clmse109.html#x136-255003r634">read</a></tt> при разборе данного синтаксиса будет всегда создавать
простую строку.
<!--l. 2686--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.3   </span> <a 
href="clmli1.html#QQ2-14-38" id="x14-320002.5.3">Битовые векторы</a></h4>
<!--l. 2688--><p class="noindent" >Битовый вектор может быть записан в виде последовательности битов
заключённых в строку с предшествующей <tt>#*</tt>; любой разделитель,
например, как пробел завершает синтаксис битового вектора. Например:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#*10110     ;Пятибитный битовый вектор; нулевой бит 1
</td></tr></table>
<!--l. 2693--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">#*          ;Пустой битовый вектор</td></tr></table>
<!--l. 2695--><p class="indent" >
</div>
</div>
<!--l. 2697--><p class="indent" >   Биты записанные после <tt>#*</tt>, читаются слева направо. Индекс каждого бита
больше индекса предыдущего бита на 1. Индекс самого левого бита 0,
следующего 1 и т.д.
<!--l. 2701--><p class="indent" >   Функция <tt>prin1</tt> выводит любой битовый вектор (не только простой) в
этом синтаксисе, однако функция <tt><a 
href="clmse109.html#x136-255003r634">read</a></tt> при разборе этого синтаксиса будет
всегда создавать простой битовый вектор.
                                                                          

                                                                          
   <!--l. 2705--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse8.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html#tailclmse6.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse7.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch2.html#clmse7.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 2705--><p class="indent" >   <a 
 id="tailclmse7.html"></a>  
</body></html> 
