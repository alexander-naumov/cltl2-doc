<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Массивы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 2479--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse8.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html#tailclmse6.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse7.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch2.html#clmse7.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">2.5   </span> <a 
href="clm.html#QQ2-14-101" id="x14-950002.5">Массивы</a></h3>
<a 
 id="dx14-95001"></a>
<tt>
<!--l. 2483--><p class="noindent" >Массив (<tt>array</tt>)</tt> является объектом с элементами расположенными в
соответствие с декартовой системой координат.
<!--l. 2486--><p class="indent" >   Количество измерений массива называется <i>ранг</i> (это терминология
взята из APL). Ранг является неотрицательных целым. Также каждое
измерение само по себе является неотрицательным целым. Общее
количество элементов в массиве является произведением размеров всех
измерений.
<!--l. 2492--><p class="indent" >   Реализация Common Lisp&#x2019;а может налагать ограничение на ранг массива,
но данное ограничение не может быть менее 7. Таким образом, любая
Common Lisp программа может использовать массивы с семью и менее
измерениями. (Программа может получить текущее ограничение для ранга
для используемой системы с помощью константы <tt><a 
href="clmse90.html#x112-1465002r519">array-rank-limit</a></tt>.)
<!--l. 2498--><p class="indent" >   Допускается существование нулевого ранга. В этом случае, массив не
содержит элементов, и любой доступ к элементам является ошибкой. При
этом другие свойства массива использоваться могут. Если ранг равен нулю,
тогда массив не имеет измерений, и их произведение приравнивается к 1
(FIXME). Таким образом массив с нулевым рангом содержит один
элемент.
<!--l. 2504--><p class="indent" >   Элемент массива задаётся последовательностью индексов. Длина
данной последовательности должна равняется рангу массива. Каждый
индекс должен быть неотрицательным целым строго меньшим размеру
соответствующего измерения. Также индексация массива начинается с нуля,
а не с единицы, как в по умолчанию Fortran&#x2019;е.
<!--l. 2510--><p class="indent" >   В качестве примера, предположим, что переменная <tt>foo</tt> обозначает
двумерный массив с размерами измерений 3 и 5. Первый индекс может быть
0, 1 или 2, и второй индекс может быть 0, 1, 2, 3 или 4. Обращение к
элементам массива может быть осуществлено с помощью функции <tt><a 
href="clmse91.html#x113-1472002r523">aref</a></tt>,
например, <tt>(aref foo 2 1)</tt> ссылается на элемент массива (2, 1). Следует
отметить, что <tt><a 
href="clmse91.html#x113-1472002r523">aref</a></tt> принимает переменное число аргументов: массив, и
столько индексов, сколько измерений у массива. Массив с нулевым рангом не
                                                                          

                                                                          
имеет измерений, и в таком случае <tt><a 
href="clmse91.html#x113-1472002r523">aref</a></tt> принимает только один параметр –
массив, и не принимает индексы, и возвращает одиночный элемент
массива.
<!--l. 2521--><p class="indent" >   В целом, массивы могут быть многомерными, могут иметь общее
содержимое с другими массивами. и могут динамически менять свой размер
после создания (и увеличивать, и уменьшать). Одномерный массив может
также иметь <i>указатель заполнения</i>.
<!--l. 2526--><p class="indent" >   Многомерные массивы хранят элементы построчно. Это значит, что
внутренне многомерный массив хранится как одномерный массив с порядком
элементов, соответствующим лексикографическому порядку их индексов. Это
важно в двух ситуациях: (1) когда массивы с разными измерениями имеют
общее содержимое, и (2) когда осуществляется доступ к очень большому
массиву в виртуальной памяти. (Первая ситуация касается семантики; вторая
— эффективности)
<!--l. 2534--><p class="indent" >   Массив, что не указывает на другой массив, не имеет указателя
заполнения и не имеет динамически расширяемого размера после создания
называется <i>простым</i> массивом. Пользователи могут декларировать
то, что конкретный массив будет простым. Некоторые реализации
могут обрабатывать простые массивы более эффективным способом,
например, простые массивы могут храниться более компактно, чем
непростые.
<!--l. 2541--><p class="indent" >   Когда вызывается <tt><a 
href="clmse90.html#x112-1460002r518">make-array</a></tt>, если один или более из <tt>:adjustable</tt>,
<tt>:fill-pointer</tt> и <tt>:displaced-to</tt> аргументов равен истине, тогда является ли
результат простым массивом не определено. Однако если все три
аргумента равны лжи, тогда результат гарантированно будет простым
массивом.
<!--l. 2546--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.1   </span> <a 
href="clmli1.html#QQ2-14-102" id="x14-960002.5.1">Векторы</a></h4>
<!--l. 2548--><p class="noindent" >В Common Lisp&#x2019;е одномерные массивы называется <i>векторами</i>, и составляют
тип <tt>vector</tt> (который в свою очередь является подтипом <tt>array</tt>). Вектора и
списки вместе являются <i>последовательностями</i>. Они отличаются тем, что
любой элемент одномерного массива может быть получен за константное
время, тогда как среднее время доступа к компоненту для списка
линейно зависит от длины списка, с другой стороны, добавление нового
элемента в начала списка занимает константное время, тогда как эта же
                                                                          

                                                                          
операция для массива занимает время линейно зависящее от длины
массива.
<!--l. 2557--><p class="indent" >   Обычный вектор (одномерный массив, который может содержать любой
тип объектов, но не имеющий дополнительных атрибутов) может быть
записан с помощью перечисления элементов разделённых пробелом и
окружённых <tt>#(</tt> и <tt>)</tt>. Например: <div class="lisp"><div class="tabbing">
#(a b c)                    ;Вектор из трёх элементов
   <br>                              #()                         ;Пустой вектор<br>
#(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47)<br>                            ;Вектор содержит простые числа меньшие пятидесяти<br>
<!--l. 2567--><p class="noindent" ></div>
<!--l. 2567--><p class="noindent" ><span class="paragraphHead"><a 
href="#x14-970002.5.1" id="x14-970002.5.1"></a></span>
<!--l. 2567--><p class="noindent" ><span class="paragraphHead"><a 
href="#x14-980002.5.1" id="x14-980002.5.1"></a></span>
</div>
<!--l. 2569--><p class="indent" >   Следует отметить, что когда функция <tt><a 
href="clmse112.html#x139-1882002r652">read</a></tt> парсит данный синтаксис, она
всегда создаёт <i>простой</i> массив.
<div class="rationale">
<!--l. 2573--><p class="noindent" ><b>Обоснование:</b> Многие люди рекомендовали использовать квадратные
скобки для задания векторов так: <tt>[a b c]</tt> вместо <tt>#(a b c)</tt>. Данная запись
короче, возможно более читаема, и безусловно совпадает с культурными
традициями в других областях компьютерных наук и математики. Однако, для
достижения предельной полезности от пользовательских макросимволов,
что расширяют возможности функции <tt><a 
href="clmse112.html#x139-1882002r652">read</a></tt>, необходимо было оставить
некоторые строковые символы для этих пользовательских целей. Опыт
использования MacLisp&#x2019;а показывает, что пользователи, особенно разработчики
языков для использования в исследованиях искусственного интеллекта, часто
хотят определять специальные значения для квадратных скобок. Таким
образом Common Lisp не использует квадратных и фигурных скобок в своём
синтаксисе.
</div>
<!--l. 2588--><p class="indent" >   Реализации могут содержать специализированные представления
массивов для достижения эффективности в случаях, когда все элементы
принадлежат одному определённому типу (например, числовому). Все
                                                                          

                                                                          
реализации содержат специальные массивы в случаях, когда все элементы
являются строковыми символами (или специализированное подмножество
строковых символов). Такие одномерные массивы называются <i>строки</i>. Все
реализации также должны содержать специализированные битовые массивы,
которые принадлежат типу <tt>(array bit)</tt>. Такие одномерные массивы
называются <i>битовые векторы</i>.
<!--l. 2598--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.2   </span> <a 
href="clmli1.html#QQ2-14-105" id="x14-990002.5.2">Строки</a></h4>
<div class="lisp">
<!--l. 2601--><p class="noindent" ><div class="tabbing">
base-string <span class="math"> ≡</span> (vector base-char)
   <br>                             simple-base-string <span class="math"> ≡</span> (simple-array base-char (*))<br>
<!--l. 2604--><p class="noindent" ></div>
<!--l. 2604--><p class="noindent" ><span class="paragraphHead"><a 
href="#x14-1000002.5.2" id="x14-1000002.5.2"></a></span>
<!--l. 2604--><p class="noindent" ><span class="paragraphHead"><a 
href="#x14-1010002.5.2" id="x14-1010002.5.2"></a></span>
</div>
<!--l. 2606--><p class="noindent" >Реализация может поддерживать другие типы строк. Все функции
Common Lisp&#x2019;а взаимодействуют со строками одинаково. Однако
следует отметить, вставка extended character в base string является
ошибкой.
<tt>
<!--l. 2610--><p class="indent" >   Строковый (<tt><a 
href="clmse98.html#x121-1556002r578">string</a></tt>)</tt> тип является подтипом <tt>векторного (<tt><a 
href="clmse90.html#x112-1468002r522">vector</a></tt>)</tt>
типа.
<!--l. 2612--><p class="indent" >   Строка может быть записана как последовательность символов, с
предшествующим и последующим символом двойной кавычки <tt>&#x0022;</tt>. Любой
символ <tt>&#x0022;</tt> или <tt>\</tt> в данной последовательности должен иметь предшествующий
символ <tt>\</tt>.
<!--l. 2617--><p class="indent" >   Например: <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
&#x0022;Foo&#x0022;                         ;Строка из трёх символов
   <br>                           &#x0022;&#x0022;                            ;Пустая строка<br>
&#x0022;\&#x0022;APL\\360?\&#x0022; he cried.&#x0022;     ;Строка из двенадцати символов<br>
&#x0022;|x| = |-x|&#x0022;                  ;Строка из десяти символов<br>
<!--l. 2624--><p class="noindent" ></div>
<!--l. 2624--><p class="noindent" ><span class="paragraphHead"><a 
href="#x14-1020002.5.2" id="x14-1020002.5.2"></a></span>
<!--l. 2624--><p class="noindent" ><span class="paragraphHead"><a 
href="#x14-1030002.5.2" id="x14-1030002.5.2"></a></span>
</div>
<!--l. 2626--><p class="indent" >   Необходимо отметить, что символ вертикальной черты <tt>|</tt> в строке не
должен быть экранирован с помощью <tt>\</tt>. Также как и любая двойная
кавычка в имени символа, записанного с использованием вертикальных черт,
не нуждается в экранировании. Записи с помощью двойной кавычки и
вертикальной черты похожи, но используются для разных целей: двойная
кавычка указывает на строку, содержащую строковые символы, тогда как
вертикальная черта указывает на символ, имя которого содержит
последовательность строковых символов.
<!--l. 2634--><p class="indent" >   Строковые символы обрамленные двойными кавычками, считываются
слева направо. Индекс символа больше индекса предыдущего символа на 1.
Самый левый символ строки имеет индекс 0, следующий 1, следующий 2, и
т.д.
<!--l. 2638--><p class="indent" >   Следует отметить, что функция <tt>prin1</tt> будет выводить на печать в данном
синтаксисе любой вектор строковых символов (не только простой), но
функция <tt><a 
href="clmse112.html#x139-1882002r652">read</a></tt> при разборе данного синтаксиса будет всегда создавать
простую строку.
<!--l. 2643--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">2.5.3   </span> <a 
href="clmli1.html#QQ2-14-110" id="x14-1040002.5.3">Битовые векторы</a></h4>
<!--l. 2645--><p class="noindent" >Битовый вектор может быть записан в виде последовательности битов
заключённых в строку с предшествующей <tt>#*</tt>; любой разделитель,
например, как пробел завершает синтаксис битового вектора. Например:
<div class="lisp"><div class="tabbing">
                                                                          

                                                                          
#*10110     ;Пятибитный битовый вектор; нулевой бит 1
   <br>                                          #*          ;Пустой битовый вектор<br>
<!--l. 2652--><p class="noindent" ></div>
<!--l. 2652--><p class="noindent" ><span class="paragraphHead"><a 
href="#x14-1050002.5.3" id="x14-1050002.5.3"></a></span>
<!--l. 2652--><p class="noindent" ><span class="paragraphHead"><a 
href="#x14-1060002.5.3" id="x14-1060002.5.3"></a></span>
</div>
<!--l. 2654--><p class="indent" >   Биты записанные после <tt>#*</tt>, читаются слева направо. Индекс каждого бита
больше индекса предыдущего бита на 1. Индекс самого левого бита 0,
следующего 1 и т.д.
<!--l. 2658--><p class="indent" >   Функция <tt>prin1</tt> выводит любой битовый вектор (не только простой) в
этом синтаксисе, однако функция <tt><a 
href="clmse112.html#x139-1882002r652">read</a></tt> при разборе этого синтаксиса будет
всегда создавать простой битовый вектор.
                                                                          

                                                                          
<!--l. 2662--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse8.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse6.html#tailclmse6.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse7.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch2.html#clmse7.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse7.html"></a>   </div> </div> 
</body></html> 
