<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Translating Strings to Symbols Преобразование строк в символы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-14 15:35:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 360--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse57.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse55.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse55.html#tailclmse55.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse56.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch11.html#clmse56.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">11.3   </span> <a 
 id="x72-16400011.3"></a>Translating Strings to Symbols Преобразование строк в символы</h3>
<!--l. 363--><p class="noindent" >The value of the special variable <a 
href="clmse60.html#x76-168003r141">*package*</a> must always be a package object (not
a name). Whatever package object is currently the value of <a 
href="clmse60.html#x76-168003r141">*package*</a> is referred
to as the <i>current package</i>.
<!--l. 367--><p class="indent" >   Значение специальной переменной <a 
href="clmse60.html#x76-168003r141">*package*</a> должно всегда быть
объектом пакета (не именем). Вне зависимости от объекта пакета в
<a 
href="clmse60.html#x76-168003r141">*package*</a>, он называется <i>текущим пакетом</i>.
<!--l. 371--><p class="indent" >   When the Lisp reader has, by parsing, obtained a string of characters thought
to name a symbol, that name is looked up in the current package. This lookup
may involve looking in other packages whose external symbols are inherited by the
current package. If the name is found, the corresponding symbol is returned. If the
name is not found (that is, there is no symbol of that name accessible in the
current package), a new symbol is created for it and is placed in the current
package as an internal symbol. Moreover, the current package becomes
the owner (home package) of the symbol, and so the symbol becomes
interned in the current package. If the name is later read again while
this same package is current, the same symbol will then be found and
returned.
<!--l. 384--><p class="indent" >   Когда Lisp&#x2019;овый считыватель получает строку для символа, он ищет его
имя в текущем пакете. Данный поиск может привести к поиску в
других пакетах, экспортированные символы которых унаследованы
текущим пакетом. Если имя найдено, то возвращается соответствующий
символ. Если имя не найдено (то есть, в текущем пакете не существует
соответствующего доступного символа), то создается новый символ и
помещается в текущий пакет. Если точнее, то текущий пакет становится
владельцем (домашним пакетом) символа. Если это имя будет прочитано еще
раз позже и в этом же пакете, то этот уже созданный символ будет
возвращен.
<!--l. 395--><p class="indent" >   Often it is desirable to refer to an external symbol in some package other than
the current one. This is done through the use of a <i>qualiﬁed name</i>, consisting of a
package name, then a colon, then the name of the symbol. This causes the
                                                                          

                                                                          
symbol&#x2019;s name to be looked up in the speciﬁed package, rather than in the current
one. For example, editor:buﬀer refers to the external symbol named buﬀer
accessible in the package named editor, regardless of whether there is a symbol
named buﬀer in the current package. If there is no package named editor, or if no
symbol named buﬀer is accessible in editor, or if buﬀer is an internal symbol in
editor, the Lisp reader will signal a correctable error to ask the user for
instructions.
<!--l. 408--><p class="indent" >   Часто необходимо сослаться на внешний символ в некотором другом,
нетекущем пакете. Это может быть сделано с помощью <i>полного имени</i>,
включающем имя пакета, затем двоеточение, и наконец имя символа.
Это приводит к поиску символа в указанном, а не текущем пакете.
Например, editor:buﬀer ссылается на внешний символ с именем buﬀer
доступный из пакета с именем editor, вне зависимости от того, если в
текущем пакете символ с таким же именем. Если пакета с именем
editor или символа с именем buﬀer в указанном пакете, Lisp&#x2019;овые
считыватель сгенерирует сигнал с ошибкой и возможностью исправить
ошибку.
<!--l. 418--><p class="indent" >   On rare occasions, a user may need to refer to an <i>internal</i> symbol of some
package other than the current one. It is illegal to do this with the colon qualiﬁer,
since accessing an internal symbol of some other package is usually a mistake.
However, this operation is legal if a doubled colon :: is used as the separator in
place of the usual single colon. If editor::buﬀer is seen, the eﬀect is exactly the
same as reading buﬀer with <a 
href="clmse60.html#x76-168003r141">*package*</a> temporarily rebound to the package
whose name is editor. This special-purpose qualiﬁer should be used with
caution.
<!--l. 429--><p class="indent" >   В редких случаях, пользователь может нуждаться в ссылке на
<i>внутренний</i> символ некоторого нетекущего пакета. Это нельзя сделать с
помощью двоеточего, так как данная запись позволяет ссылаться только на
внешние символы. Однако, это можно сделать с помощью двойного
двоеточего ::, указанного вместо одинарного. Если используется editor::buﬀer,
то эффект такой же, как если бы произошла попытка найти символ с именем
buﬀer и <a 
href="clmse60.html#x76-168003r141">*package*</a> была связана с объетом с именем editor. Двойное двоеточие
должно использоваться с осторожностью.
<!--l. 438--><p class="indent" >   The package named keyword contains all keyword symbols used by the
Lisp system itself and by user-written code. Such symbols must be easily
accessible from any package, and name conﬂicts are not an issue because
these symbols are used only as labels and never to carry package-speciﬁc
values or properties. Because keyword symbols are used so frequently,
                                                                          

                                                                          
Common Lisp provides a special reader syntax for them. Any symbol
preceded by a colon but no package name (for example :foo) is added to (or
looked up in) the keyword package as an <i>external</i> symbol. The keyword
package is also treated specially in that whenever a symbol is added to the
keyword package the symbol is always made external; the symbol is also
automatically declared to be a constant (see <a 
href="clmse30.html#x40-69006r16">defconstant</a>) and made to have
itself as its value. This is why every keyword evaluates to itself. As a
matter of style, keywords should always be accessed using the leading-colon
convention; the user should never import or inherit keywords into any
other package. It is an error to try to apply <a 
href="clmse60.html#x76-169057r162">use-package</a> to the keyword
package.
<!--l. 457--><p class="indent" >   Пакет с именем keyword содержит все ключевые символы используемые
Lisp&#x2019;овой системой и пользовательским кодом. Такие символы должны быть
легко доступны из любого пакета, и конфликт имен не является проблемой,
так как эти символы используются только в качестве меток и не содержат
значений. Так как ключевые символы используются часто, то Common
Lisp для них предоставляет специальный синтаксис. Любой символ с
двоеточием в начале и без имени пакета (например :foo) добавляется
(или ищется) в пакете keyword как <i>внешний</i> символ. Пакет keyword
также отличается тем, что при добавлении в него символа, последний
автоматически становится внешним. Символ также автоматически
декларируется как константа (смотрите <a 
href="clmse30.html#x40-69006r16">defconstant</a>) и его значением
становится он сам. В целях стиля, ключевые символы должны всегда быть
доступны с помощью двоеточего в начале имени. Пользователь никогда не
должен импортировать или наследовать ключевые символы в другие
пакета. Попытка использовать <a 
href="clmse60.html#x76-169057r162">use-package</a> для keyword пакета является
ошибкой.
<!--l. 473--><p class="indent" >   Each symbol contains a package cell that is used to record the home package of
the symbol, or <a 
href="clmse31.html#x42-74002r18">nil</a> if the symbol is uninterned. This cell may be accessed by using
the function <a 
href="clmse53.html#x68-160012r139">symbol-package</a>. When an interned symbol is printed, if it is a
symbol in the keyword package, then it is printed with a preceding colon;
otherwise, if it is accessible (directly or by inheritance) in the current package, it
is printed without any qualiﬁcation; otherwise, it is printed with the name of the
home package as the qualiﬁer, using : as the separator if the symbol is external
and :: if not.
<!--l. 484--><p class="indent" >   Каждый символ содержит ячейку пакета, которая используется для
записи домашнего пакета символа, или <a 
href="clmse31.html#x42-74002r18">nil</a>, если пакет неинтернированный.
Эта ячейка доступна с помощью функции <a 
href="clmse53.html#x68-160012r139">symbol-package</a>. Когда
                                                                          

                                                                          
интернированный символ печатается, если это символ в пакете ключевых
символов, тогда он выводится с двоеточием в начале, иначе, если он доступен
(напрямую или отнаследованно) в текущем пакете, он печатается без имени
пакета, иначе он печатается полностью, с именем пакета, именем
символа и : в качестестве разделителя для внешнего символа, и :: для
внутреннего.
<!--l. 493--><p class="indent" >   A symbol whose package slot contains <a 
href="clmse31.html#x42-74002r18">nil</a> (that is, has no home package) is
printed preceded by #:. It is possible, by the use of <a 
href="clmse60.html#x76-169046r159">import</a> and <a 
href="clmse60.html#x76-169037r156">unintern</a>, to create
a symbol that has no recorded home package but that in fact is accessible in some
package. The system does not check for this pathological case, and such symbols
will always be printed preceded by #:.
<!--l. 501--><p class="indent" >   Символ, у которого слот (ячейка) пакета содержит <a 
href="clmse31.html#x42-74002r18">nil</a> (то есть, домашний
пакет отсутствует) печатается с #: вначале. С использованием <a 
href="clmse60.html#x76-169046r159">import</a> и
uninter возможно создать символ, который не имеет домашнего пакета, но
фактически доступен в некоторых пакетах. Lisp система не проверяет такие
патологические случаи, и такие символы будут всегда печататься с
предшевствующими #:.
<!--l. 508--><p class="indent" >   In summary, the following four uses of symbol qualiﬁer syntax are
deﬁned.
<!--l. 510--><p class="indent" >   В целом, синтаксис имен символов может быть выражен в следующих
четырех примерах.
<div class=flushdesc>
<!--l. 513--><p class="indent" >
      <ul><li><b>
foo:bar </b></li>When read, looks up BAR among the external symbols of the package
      named FOO. Printed when symbol bar is external in its home package
      foo and is not accessible in the current package.
      <!--l. 518--><p class="noindent" >При прочтении, выполняется поиск символа BAR среди внешних
      символов  пакета  FOO.  При  выводе,  когда  символ  bar  является
      внешним в домашнем пакете foo и недоступен в текущем пакете.
      <li><b>
foo::bar </b></li>When  read,  interns  BAR  as  if  FOO  were  the  current  package.
      Printed when symbol bar is internal in its home package foo and is not
      accessible in the current package.
      <!--l. 527--><p class="noindent" >При  прочтении,  интернирует  символ  BAR,  как  если  бы  пакет
      FOO являлся текущим. При выводе, когда символ bar является
                                                                          

                                                                          
      внутренним в его домашнем пакете foo и недоступен в текущем
      пакете.
      <li><b>
 :bar </b></li>When read, interns BAR as an external symbol in the keyword package
      and makes it evaluate to itself. Printed when the home package of
      symbol bar is keyword.
      <!--l. 536--><p class="noindent" >При прочтении, интернирует BAR как внешний символ в пакете
      keyword и выполняет его самого в себя. При выводе, когда keyword
      является домашним пакетом для символа.
      <li><b>
#:bar </b></li>When read, creates a new uninterned symbol named BAR. Printed
      when the symbol bar is uninterned (has no home package), even in
      the pathological case that bar is uninterned but nevertheless somehow
      accessible in the current package.
      <!--l. 546--><p class="noindent" >При  прочтении,  создает  новый  неинтернированный  символ  с
      именем BAR. При выводе, когда символ bar не имеет домашнего
      пакета.</ul>
</div>
<!--l. 550--><p class="indent" >   All other uses of colons within names of symbols are not deﬁned by Common
Lisp but are reserved for implementation-dependent use; this includes
names that end in a colon, contain two or more colons, or consist of just a
colon.
<!--l. 555--><p class="indent" >   Все другие использования двоеточего внутри имен символов не
определены Common Lisp&#x2019;ом, но зарезервированы для реализаций. Сюда
включены имена с двоеточием в конце, или содержащими два и более
двоеточих или просто состоящими из двоеточего.
                                                                          

                                                                          
   <!--l. 560--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse57.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse55.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse55.html#tailclmse55.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse56.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch11.html#clmse56.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 560--><p class="indent" >   <a 
 id="tailclmse56.html"></a>  
</body></html> 
