<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Предикаты равенства</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-13 16:31:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 1446--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse34.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse33.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse33.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
 id="x44-780006.3"></a>Предикаты равенства</h3>
<!--l. 1448--><p class="noindent" >Common Lisp предоставляет спектр предикатов для проверки равенства
двух объектов: <a 
href="#x44-78002r44">eq</a> (наиболее частный), <a 
href="#x44-78004r45">eql</a>, <a 
href="#x44-78006r46">equal</a> и <a 
href="#x44-78008r47">equalp</a> (наиболее
общий). <a 
href="#x44-78002r44">eq</a> и <a 
href="#x44-78006r46">equal</a> имеют значения традиционные в Lisp&#x2019;е. <a 
href="#x44-78004r45">eql</a> был
добавлен, потому что он часто необходим, и <a 
href="#x44-78008r47">equalp</a> был добавлен
преимущественно, как версия <a 
href="#x44-78006r46">equal</a>, которая игнорирует различия типов при
сравнении двух чисел и различия регистров при сравнении строковых
символов. Если два объекта удовлетворяют любому из этих предикатов,
то они также удовлетворяют всем тем, которые носят более общий
характер.
<div class=defun>
<!--l. 1458--><p class="noindent" ><i>[Function]</i><a 
 id="dx44-78001"></a><a 
 id="x44-78002r44"></a><b> eq</b>  <i>x</i> <i>y</i>
<!--l. 1460--><p class="noindent" >(eq <i>x</i> <i>y</i>) является истиной тогда и только тогда, когда, <i>x</i> и <i>y</i> являются
идентичными объектами. (В реализациях, <i>x</i> и <i>y</i> обычно равны <a 
href="#x44-78002r44">eq</a> тогда и
только тогда, когда обращаются к одной ячейке памяти.)
<!--l. 1466--><p class="indent" >   Необходимо отметить, что вещи, которые выводят одно и то же,
необязательно равны <a 
href="#x44-78004r45">eql</a> друг другу. Символы с одинаковым именем обычно
равны <a 
href="#x44-78002r44">eq</a> друг другу, потому что используется функция <a 
href="clmse60.html#x76-169030r154">intern</a>. Однако,
одинаковые значения чисел могут быть не равны <a 
href="#x44-78002r44">eq</a>, и два похожих списка
обычно не равны <a 
href="#x44-78002r44">eq</a>. Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;a &#x2019;b) ложь
</td></tr></table>
<!--l. 1473--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;a &#x2019;a) истина</td></tr></table>
<!--l. 1474--><p class="indent" >    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3 3) может быть истина или ложь, в зависимости от реализации</td></tr></table>
<!--l. 1475--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3 3.0) ложь</td></tr></table>
<!--l. 1476--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3.0 3.0) может быть истина или ложь, в зависимости от реализации</td></tr></table>
<!--l. 1477--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #c(3 -4) #c(3 -4))</td></tr></table>
<!--l. 1478--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  может быть истина или ложь, в зависимости от реализации</td></tr></table>
                                                                          

                                                                          
<!--l. 1479--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #c(3 -4.0) #c(3 -4)) ложь</td></tr></table>
<!--l. 1480--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь</td></tr></table>
<!--l. 1481--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) ложь</td></tr></table>
<!--l. 1482--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;(a . b) &#x2019;(a . b)) может быть истина или ложь</td></tr></table>
<!--l. 1483--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (eq x x)) истина</td></tr></table>
<!--l. 1484--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (eq x x)) истина</td></tr></table>
<!--l. 1485--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #\A #\A) может быть истина или ложь, в зависимости от реализации</td></tr></table>
<!--l. 1486--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) может быть истина или ложь</td></tr></table>
<!--l. 1487--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) ложь</td></tr></table>
<!--l. 1488--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) ложь</td></tr></table>
<!--l. 1490--><p class="indent" >
</div>
</div>
<!--l. 1492--><p class="indent" >   В Common Lisp&#x2019;е, в отличие от других деалектов, реализация в
любое время может создавать «копии» строковых символов и чисел.
(Это сделано для возможности в повышении производительности во
многих общих случаях.) Из этого следует правило, что Common Lisp
не гарантирует для строковых символов и чисел то, что <a 
href="#x44-78002r44">eq</a> будет
истинен, когда оба аргумента являются «одним и тем же». Например:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((x 5)) (eq x x)) может быть истиной или ложью
</td></tr></table>
<!--l. 1500--><p class="indent" >
</div>
</div>
<!--l. 1502--><p class="indent" >   Предикат <a 
href="#x44-78004r45">eql</a> означает то же, что и <a 
href="#x44-78002r44">eq</a>, за исключением того, что если
аргументы являются строковыми символами или числами одинакового типа,
тогда сравниваются их значения. Таким образом <a 
href="#x44-78004r45">eql</a> говорит, являются ли
два объекта «концептуально (conceptually)» одинаковыми, тогда как <a 
href="#x44-78002r44">eq</a>
указывает, являются ли два объекта «реализационно (implementationally)»
одинаковыми. По этой причине сравнительным предикатом для функций
работы с последовательностями, описанными в главе <a 
href="clmch14.html#x96-19800014">14<!--tex4ht:ref: KSEQUE --></a>, является <a 
href="#x44-78004r45">eql</a>, а не
<a 
href="#x44-78002r44">eq</a>.
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 1511--><p class="noindent" ><i>[Function]</i><a 
 id="dx44-78003"></a><a 
 id="x44-78004r45"></a><b> eql</b>  <i>x</i> <i>y</i>
<!--l. 1513--><p class="noindent" >Предикат <a 
href="#x44-78004r45">eql</a> является истиной, если его аргументы равны <a 
href="#x44-78002r44">eq</a>, или если это
числого одинакового типа и с одинаковыми значениями, или если это
одинаковые строковые символы. Например: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;a &#x2019;b) ложь
</td></tr></table>
<!--l. 1519--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;a &#x2019;a) истина</td></tr></table>
<!--l. 1520--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3 3) истина</td></tr></table>
<!--l. 1521--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3 3.0) ложь</td></tr></table>
<!--l. 1522--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3.0 3.0) истина</td></tr></table>
<!--l. 1523--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #c(3 -4) #c(3 -4)) истина</td></tr></table>
<!--l. 1524--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #c(3 -4.0) #c(3 -4)) ложь</td></tr></table>
<!--l. 1525--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь</td></tr></table>
<!--l. 1526--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) ложь</td></tr></table>
<!--l. 1527--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;(a . b) &#x2019;(a . b)) может быть истиной или ложью</td></tr></table>
<!--l. 1528--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (eql x x)) истина</td></tr></table>
<!--l. 1529--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (eql x x)) истина</td></tr></table>
<!--l. 1530--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #\A #\A) истина</td></tr></table>
<!--l. 1531--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) может быть истиной или ложью</td></tr></table>
<!--l. 1532--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) ложь</td></tr></table>
<!--l. 1533--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) ложь</td></tr></table>
<!--l. 1535--><p class="indent" >
</div>
</div>
<!--l. 1537--><p class="indent" >   Обычно (eql 1.0s0 1.0d0) будет ложью, так как 1.0s0 и 1.0d0 не
принадлежат одному типу данных. Однако реализация может не
реализовывать полный набор чисел с плавающей точкой, поэтому в такой
ситуации (eql 1.0s0 1.0d0) может быть истиной. Предикат <a 
href="clmse65.html#x82-180002r178">=</a> будет
сравнивать знчения двух чисел, даже если числа принадлежат разным
типам.
<!--l. 1543--><p class="indent" >   Если реализация поддерживает положительный и отрицательный нули,
как различные значения (так IEEE стандарт предлагает реализовывать
формат числа с плавающей точкой), тогда (eql 0.0 -0.0) будет ложью. В
противном случае, когда синтаксис -0.0 интепретируется, как значение 0.0,
тогда (eql 0.0 -0.0) будет истиной. Предикат <a 
href="clmse65.html#x82-180002r178">=</a> отличается от <a 
href="#x44-78004r45">eql</a>, в том что (=
                                                                          

                                                                          
0.0 -0.0) будет всегда истинно, потому что <a 
href="clmse65.html#x82-180002r178">=</a> сравнивает математические
значения операндов, тогда как <a 
href="#x44-78004r45">eql</a> сравнивает, так сказать, репрезентативные
(representational) значения. FIXME.
<!--l. 1552--><p class="indent" >   Два комплексных числа будут равны <a 
href="#x44-78004r45">eql</a>, если их действительные части
равны eql и мнимые части равны <a 
href="#x44-78004r45">eql</a>. Например, (eql #C(4 5) #C(4 5))
является истиной и (eql #C(4 5) #C(4.0 5.0)) является ложью. Следует
отметить, что (eql #C(5.0 0.0) 5.0) ложь, а (eql #C(5 0) 5) истина. В случае с
(eql #C(5.0 0.0) 5.0) два аргумента принадлежат разным типам и не равны
<a 
href="#x44-78004r45">eql</a>, Однако, в случае (eql #C(5 0) 5), #C(5 0) не является комплексным
числом, и автоматически преобразуется, по правилу канонизации
комплексных чисел, в целое 5, так как дробное число 20/4 всегда упрощается
до 5.
<!--l. 1565--><p class="indent" >   Cлучай (eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) обсуждался выше в описании <a 
href="#x44-78002r44">eq</a>. Тогда как <a 
href="#x44-78004r45">eql</a>
сравнивает значения чисел и строковых символов, он не сравнивает
содержимое строк. Сравнение символов двух строк может быть выполнено с
помощью <a 
href="#x44-78006r46">equal</a>, <a 
href="#x44-78008r47">equalp</a>, <a 
href="clmse98.html#x121-226002r562">string=</a> или <a 
href="clmse98.html#x121-226004r563">string-equal</a>.
<div class=defun>
<!--l. 1570--><p class="noindent" ><i>[Function]</i><a 
 id="dx44-78005"></a><a 
 id="x44-78006r46"></a><b> equal</b>  <i>x</i> <i>y</i>
<!--l. 1572--><p class="noindent" >Предикат <a 
href="#x44-78006r46">equal</a> является истиной, если его аргументы это структурно
похожие (изоморфные) объекты. Грубое правило такое, что два объекта
равны <a 
href="#x44-78006r46">equal</a> тогда и только тогда, когда одинаково их выводимое
представление.
<!--l. 1577--><p class="indent" >   Числа и строковые символы сравниваются также как и в <a 
href="#x44-78004r45">eql</a>. Символы
сравниваются как в <a 
href="#x44-78002r44">eq</a>. Этот метод сравнения символов может нарушать
правило и сравнении выводимого представления, в случае если различия
двух символов с одинаковым выводимым представлением.
<!--l. 1582--><p class="indent" >   Объекты, которые содержат другие элементы, будут равны <a 
href="#x44-78006r46">equal</a>, если
они принадлежат одному типу и содержащиеся элементы равны <a 
href="#x44-78006r46">equal</a>. Эта
проверка реализована в рекурсивном стиле и может быть зациклиться на
закольцованных структурах.
<!--l. 1587--><p class="indent" >   Для cons-ячеек, <a 
href="#x44-78006r46">equal</a> определен рекурсивно, как сравнение equal сначала
<i>car</i> элементов, а затем <i>cdr</i>.
<!--l. 1590--><p class="indent" >   Два массива равны <a 
href="#x44-78006r46">equal</a> только, если они равны <a 
href="#x44-78002r44">eq</a>, с одним
исключением: строки и битовые вектора сравниваются поэлементно. Если
какой-либо аргумент или оба содержат указатель заполнения (ﬁll pointer),
данный указатель ограничит количество проверяемых с помощью equal
элементов. Буквы верхнего и нижнего регистров в строках рацениваются
предикатом <a 
href="#x44-78006r46">equal</a> как разные. (А <a 
href="#x44-78008r47">equalp</a> игнорирует различие в регистрах в
                                                                          

                                                                          
строках.)
<!--l. 1599--><p class="indent" >   Два объекта имени файла (pathname objects) равны <a 
href="#x44-78006r46">equal</a> тогда и только
тогда, когда все элементы (хост, устройство, и т.д.) равны. (Будут
ли равны буквы разных регистров зависит от файловой системы.)
Имена файлов, которые равны <a 
href="#x44-78006r46">equal</a>, должны быть функционально
эквивалентны.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;a &#x2019;b) ложь
</td></tr></table>
<!--l. 1605--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;a &#x2019;a) истина</td></tr></table>
<!--l. 1606--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3 3) истина</td></tr></table>
<!--l. 1607--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3 3.0) ложь</td></tr></table>
<!--l. 1608--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3.0 3.0) истина</td></tr></table>
<!--l. 1609--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #c(3 -4) #c(3 -4)) истина</td></tr></table>
<!--l. 1610--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #c(3 -4.0) #c(3 -4)) ложь</td></tr></table>
<!--l. 1611--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь</td></tr></table>
<!--l. 1612--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) истина</td></tr></table>
<!--l. 1613--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;(a . b) &#x2019;(a . b)) истина</td></tr></table>
<!--l. 1614--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (equal x x)) истина</td></tr></table>
<!--l. 1615--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (equal x x)) истина</td></tr></table>
<!--l. 1616--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #\A #\A) истина</td></tr></table>
<!--l. 1617--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) истина</td></tr></table>
<!--l. 1618--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) истина</td></tr></table>
<!--l. 1619--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) ложь</td></tr></table>
<!--l. 1621--><p class="indent" >
</div>
</div>
<!--l. 1622--><p class="noindent" >Для сравнения дерева cons-ячеек применяя <a 
href="#x44-78004r45">eql</a> (или любой другой желаемый
предикат) для листьев, используйте <a 
href="clmse83.html#x103-205064r443">tree-equal</a>.
</div>
<div class=defun>
<!--l. 1627--><p class="noindent" ><i>[Function]</i><a 
 id="dx44-78007"></a><a 
 id="x44-78008r47"></a><b> equalp</b>  <i>x</i> <i>y</i>
<!--l. 1629--><p class="noindent" >Два объекта равны <a 
href="#x44-78008r47">equalp</a>, если они равны <a 
href="#x44-78006r46">equal</a>, если они строковые
                                                                          

                                                                          
символы и удовлетворяют предикату <a 
href="clmse74.html#x92-194034r341">char-equal</a>, который игнорирует регистр
и другие атрибуты символов, если они числа и имеют одинаковое значение,
даже если числа разных типов, если они включает в себя элементы, которые
также равны <a 
href="#x44-78008r47">equalp</a>.
<!--l. 1636--><p class="indent" >   Объекты, которые включают в себя элементы, равны <a 
href="#x44-78008r47">equalp</a>, если они
принадлежат одному типу и содержащиеся элементы равны <a 
href="#x44-78008r47">equalp</a>.
Проверка осуществляется в рекурсивном стиле и может не завершится на
заколцованных структурах. Для cons-ячеек, предикат <a 
href="#x44-78008r47">equalp</a> определен
рекурсивно и сравнивает сначала <i>car</i> элементы, а затем <i>cdr</i>.
<!--l. 1643--><p class="indent" >   Два массива равны <a 
href="#x44-78008r47">equalp</a> тогда и только тогда, когда они имеют
одинаковое количество измерений, и размеры измерений совпадают, и все
элементы равны <a 
href="#x44-78008r47">equalp</a>. Специализация массива не сравнивается. Например,
строка и общий массив, случилось так, имеют одинаковые строковые
символы, тогда они будут равны <a 
href="#x44-78008r47">equalp</a> (но определенно не равны <a 
href="#x44-78006r46">equal</a>).
Если какой-либо аргумент содержит указатель заполнения, этот указатель
ограничивает число сравниваемых элементов. Так как <a 
href="#x44-78008r47">equalp</a> сравнивает
строки побуквенно, и не различает разных регистров букв, то сравнение
строк регистронезависимо.
<!--l. 1652--><p class="indent" >   Два символа могут быть равны <a 
href="#x44-78008r47">equalp</a> только тогда, когда они <a 
href="#x44-78002r44">eq</a>, т.е.
являеются идентичными объектами.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;a &#x2019;b) ложь
</td></tr></table>
<!--l. 1656--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;a &#x2019;a) истина</td></tr></table>
<!--l. 1657--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3 3) истина</td></tr></table>
<!--l. 1658--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3 3.0) истина</td></tr></table>
<!--l. 1659--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3.0 3.0) истина</td></tr></table>
<!--l. 1660--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #c(3 -4) #c(3 -4)) истина</td></tr></table>
<!--l. 1661--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #c(3 -4.0) #c(3 -4)) истина</td></tr></table>
<!--l. 1662--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь</td></tr></table>
<!--l. 1663--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) истина</td></tr></table>
<!--l. 1664--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;(a . b) &#x2019;(a . b)) истина</td></tr></table>
<!--l. 1665--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (equalp x x)) истина</td></tr></table>
<!--l. 1666--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (equalp x x)) истина</td></tr></table>
                                                                          

                                                                          
<!--l. 1667--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #\A #\A) истина</td></tr></table>
<!--l. 1668--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) истина</td></tr></table>
<!--l. 1669--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) истина</td></tr></table>
<!--l. 1670--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) истина</td></tr></table>
<!--l. 1672--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
   <!--l. 1675--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse34.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse33.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 1675--><p class="indent" >   <a 
 id="tailclmse33.html"></a>  
</body></html> 
