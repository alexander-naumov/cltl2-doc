<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Equality Predicates Предикаты равенства</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-26 02:27:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 796--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse34.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse33.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse33.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
 id="x44-740006.3"></a>Equality Predicates Предикаты равенства</h3>
<!--l. 798--><p class="noindent" >Common Lisp provides a spectrum of predicates for testing for equality of two
objects: <a 
href="#x44-74002r46">eq</a> (the most speciﬁc), <a 
href="#x44-74005r47">eql</a>, <a 
href="#x44-74007r48">equal</a>, and <a 
href="#x44-74010r49">equalp</a> (the most general). <a 
href="#x44-74002r46">eq</a> and
<a 
href="#x44-74007r48">equal</a> have the meanings traditional in Lisp. <a 
href="#x44-74005r47">eql</a> was added because it is frequently
needed, and <a 
href="#x44-74010r49">equalp</a> was added primarily in order to have a version of <a 
href="#x44-74007r48">equal</a>
that would ignore type diﬀerences when comparing numbers and case
diﬀerences when comparing characters. If two objects satisfy any one of
these equality predicates, then they also satisfy all those that are more
general.
<!--l. 808--><p class="indent" >   Common Lisp предоставляет спектр предикатов для проверки равенства
двух объектов: <a 
href="#x44-74002r46">eq</a> (наиболее частный), <a 
href="#x44-74005r47">eql</a>, <a 
href="#x44-74007r48">equal</a> и <a 
href="#x44-74010r49">equalp</a> (наиболее
общий). <a 
href="#x44-74002r46">eq</a> и <a 
href="#x44-74007r48">equal</a> имеют значения традиционные в Lisp&#x2019;е. <a 
href="#x44-74005r47">eql</a> был
добавлен, потому что он часто необходим, и <a 
href="#x44-74010r49">equalp</a> был добавлен
преимущественно, как версия <a 
href="#x44-74007r48">equal</a>, которая игнорирует различия типов при
сравнении двух чисел и различия регистров при сравнении строковых
символов. Если два объекта удовлетворяют любому из этих предикатов,
то они также удовлетворяют всем тем, которые носят более общий
характер.
<div class=defun>
<!--l. 818--><p class="noindent" ><i>[Function]</i><a 
 id="dx44-74001"></a><a 
 id="x44-74002r46"></a><b> eq</b>  <i>x</i> <i>y</i>
<!--l. 820--><p class="noindent" >(eq <i>x</i> <i>y</i>) is true if and only if <i>x</i> and <i>y</i> are the same identical object.
(Implementationally, <i>x</i> and <i>y</i> are usually <a 
href="#x44-74002r46">eq</a> if and only if they address the same
identical memory location.)
<!--l. 826--><p class="indent" >   (eq <i>x</i> <i>y</i>) является истиной тогда и только тогда, когда, <i>x</i> и <i>y</i> являются
идентичными объектами. (В реализациях, <i>x</i> и <i>y</i> обычно равны <a 
href="#x44-74002r46">eq</a> тогда и
только тогда, когда обращаются к одной ячейке памяти.)
<!--l. 831--><p class="indent" >   It should be noted that things that print the same are not necessarily <a 
href="#x44-74002r46">eq</a> to
each other. Symbols with the same print name usually are <a 
href="#x44-74002r46">eq</a> to each other
because of the use of the <a 
href="clmse63.html#x79-118046r186">intern</a> function. However, numbers with the
same value need not be <a 
href="#x44-74002r46">eq</a>, and two similar lists are usually not <a 
href="#x44-74002r46">eq</a>. For
example:
                                                                          

                                                                          
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;a &#x2019;b) is false.
</td></tr></table>
<!--l. 839--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;a &#x2019;a) is true.</td></tr></table>
<!--l. 840--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3 3) might be true or false, depending on the implementation.</td></tr></table>
<!--l. 841--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3 3.0) is false.</td></tr></table>
<!--l. 842--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3.0 3.0) might be true or false, depending on the implementation.</td></tr></table>
<!--l. 843--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #c(3 -4) #c(3 -4))</td></tr></table>
<!--l. 844--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  might be true or false, depending on the implementation.</td></tr></table>
<!--l. 845--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #c(3 -4.0) #c(3 -4)) is false.</td></tr></table>
<!--l. 846--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.</td></tr></table>
<!--l. 847--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is false.</td></tr></table>
<!--l. 848--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;(a . b) &#x2019;(a . b)) might be true or false.</td></tr></table>
<!--l. 849--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (eq x x)) is true.</td></tr></table>
<!--l. 850--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (eq x x)) is true.</td></tr></table>
<!--l. 851--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #\A #\A) might be true or false, depending on the implementation.</td></tr></table>
<!--l. 852--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) might be true or false.</td></tr></table>
<!--l. 853--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is false.</td></tr></table>
<!--l. 854--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is false.</td></tr></table>
<!--l. 856--><p class="indent" >
</div>
</div>
<!--l. 858--><p class="indent" >   Необходимо отметить, что вещи, которые выводят одно и то же,
необязательно равны <a 
href="#x44-74005r47">eql</a> друг другу. Символы с одинаковым именем обычно
равны <a 
href="#x44-74002r46">eq</a> друг другу, потому что используется функция <a 
href="clmse63.html#x79-118046r186">intern</a>. Однако,
одинаковые значения чисел могут быть не равны <a 
href="#x44-74002r46">eq</a>, и два похожих списка
обычно не равны <a 
href="#x44-74002r46">eq</a>. Например:
<div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;a &#x2019;b) ложь
</td></tr></table>
<!--l. 866--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;a &#x2019;a) истина</td></tr></table>
<!--l. 867--><p class="indent" >    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3 3) может быть истина или ложь, в зависимости от реализации</td></tr></table>
<!--l. 868--><p class="indent" >                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3 3.0) ложь</td></tr></table>
<!--l. 869--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3.0 3.0) может быть истина или ложь, в зависимости от реализации</td></tr></table>
<!--l. 870--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #c(3 -4) #c(3 -4))</td></tr></table>
<!--l. 871--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  может быть истина или ложь, в зависимости от реализации</td></tr></table>
<!--l. 872--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #c(3 -4.0) #c(3 -4)) ложь</td></tr></table>
<!--l. 873--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь</td></tr></table>
<!--l. 874--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) ложь</td></tr></table>
<!--l. 875--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;(a . b) &#x2019;(a . b)) может быть истина или ложь</td></tr></table>
<!--l. 876--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (eq x x)) истина</td></tr></table>
<!--l. 877--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (eq x x)) истина</td></tr></table>
<!--l. 878--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #\A #\A) может быть истина или ложь, в зависимости от реализации</td></tr></table>
<!--l. 879--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) может быть истина или ложь</td></tr></table>
<!--l. 880--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) ложь</td></tr></table>
<!--l. 881--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) ложь</td></tr></table>
<!--l. 883--><p class="indent" >
</div>
</div>
<!--l. 885--><p class="indent" >   In Common Lisp, unlike some other Lisp dialects, the implementation
is permitted to make “copies” of characters and numbers at any time.
(This permission is granted because it allows tremendous performance
improvements in many common situations.) The net eﬀect is that Common Lisp
makes no guarantee that <a 
href="#x44-74002r46">eq</a> will be true even when both its arguments are
“the same thing” if that thing is a character or number. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((x 5)) (eq x x)) might be true or false.
</td></tr></table>
<!--l. 895--><p class="indent" >
</div>
</div>
<!--l. 897--><p class="indent" >   В Common Lisp&#x2019;е, в отличие от других деалектов, реализация в
любое время может создавать «копии» строковых символов и чисел.
                                                                          

                                                                          
(Это сделано для возможности в повышении производительности во
многих общих случаях.) Из этого следует правило, что Common Lisp
не гарантирует для строковых символов и чисел то, что <a 
href="#x44-74002r46">eq</a> будет
истенен, когда оба аргумента являются «одним и тем же». Например: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((x 5)) (eq x x)) может быть истиной или ложью
</td></tr></table>
<!--l. 905--><p class="indent" >
</div>
</div>
<!--l. 907--><p class="indent" >   The predicate <a 
href="#x44-74005r47">eql</a> is the same as <a 
href="#x44-74002r46">eq</a>, except that if the arguments are
characters or numbers of the same type then their values are compared. Thus <a 
href="#x44-74005r47">eql</a>
tells whether two objects are <i>conceptually</i> the same, whereas <a 
href="#x44-74002r46">eq</a> tells whether two
objects are <i>implementationally</i> identical. It is for this reason that <a 
href="#x44-74005r47">eql</a>, not <a 
href="#x44-74002r46">eq</a>, is
the default comparison predicate for the sequence functions deﬁned in
chapter <a 
href="clmch14.html#x99-14100014">14<!--tex4ht:ref: KSEQUE --></a>.
<!--l. 915--><p class="indent" >   Предикат <a 
href="#x44-74005r47">eql</a> означает то же, что и <a 
href="#x44-74002r46">eq</a>, за исключением того, что если
аргументы являются строковыми символами или числами одинакового типа,
тогда сравниваются их значения. Таким образом <a 
href="#x44-74005r47">eql</a> говорит, являются ли
два объекта «концептуально (conceptually)» одинаковыми, тогда как <a 
href="#x44-74002r46">eq</a>
указывает, являются ли два объекта «реализационно (implementationally)»
одинаковыми. По этой причине сравнительным предикатом для функций
работы с последовательностями, описанными в главе <a 
href="clmch14.html#x99-14100014">14<!--tex4ht:ref: KSEQUE --></a>, является <a 
href="#x44-74005r47">eql</a>, а не
<a 
href="#x44-74002r46">eq</a>.
<div class=implementation>
<!--l. 924--><p class="noindent" ><b>Implementation note:</b> <a 
href="#x44-74002r46">eq</a> simply compares the two given pointers, so any
kind of object that is represented in an “immediate” fashion will indeed have
like-valued instances satisfy <a 
href="#x44-74002r46">eq</a>. In some implementations, for example, ﬁxnums and
characters happen to “work.” However, no program should depend on this, as other
implementations of Common Lisp might not use an immediate representation for these
data types.
</div>
<div class=obsolete>
<!--l. 936--><p class="indent" >   An additional problem with <a 
href="#x44-74002r46">eq</a> is that the implementation is permitted to
“collapse” constants (or portions thereof) appearing in code to be compiled if they
are <a 
href="#x44-74007r48">equal</a>. An object is considered to be a constant in code to be compiled if it is a
                                                                          

                                                                          
self-evaluating form or is contained in a <a 
href="clmse35.html#x47-78002r53">quote</a> form. This is why (eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;)
might be true or false; in interpreted code it would normally be false, because
reading in the form (eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) would construct distinct strings for the
two arguments to <a 
href="#x44-74002r46">eq</a>, but the compiler might choose to use the same
identical string or two distinct copies as the two arguments in the call to <a 
href="#x44-74002r46">eq</a>.
Similarly, (eq &#x2019;(a . b) &#x2019;(a . b)) might be true or false, depending on whether
the constant conses appearing in the <a 
href="clmse35.html#x47-78002r53">quote</a> forms were collapsed by the
compiler. However, (eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is always false, because every
distinct call to the <a 
href="clmse86.html#x106-148062r474">cons</a> function necessarily produces a new and distinct
cons.
</div>
<div class=newer>
<!--l. 954--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx44-74003"></a>to clarify that <a 
href="clmse110.html#x135-180002r620">eval</a> and <a 
href="clmse127.html#x157-224003r797">compile</a> are not permitted
either to copy or to coalesce (“collapse”) constants (see <a 
href="#x44-74002r46">eq</a>) appearing in the
code they process; the resulting program behavior must refer to objects
that are <a 
href="#x44-74005r47">eql</a> to the corresponding objects in the source code. Only the
<a 
href="clmse127.html#x157-224011r799">compile-ﬁle</a>/<a 
href="clmse122.html#x150-217002r778">load</a> process is permitted to copy or coalesce constants (see
section <a 
href="clmse127.html#x157-22400025.1">25.1<!--tex4ht:ref: COMPILER-SECTION --></a>).
</div>
</div>
<div class=defun>
<!--l. 965--><p class="noindent" ><i>[Function]</i><a 
 id="dx44-74004"></a><a 
 id="x44-74005r47"></a><b> eql</b>  <i>x</i> <i>y</i>
<!--l. 967--><p class="noindent" >The <a 
href="#x44-74005r47">eql</a> predicate is true if its arguments are <a 
href="#x44-74002r46">eq</a>, or if they are numbers of the
same type with the same value, or if they are character objects that represent the
same character. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;a &#x2019;b) is false.
</td></tr></table>
<!--l. 974--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;a &#x2019;a) is true.</td></tr></table>
<!--l. 975--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3 3) is true.</td></tr></table>
<!--l. 976--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3 3.0) is false.</td></tr></table>
<!--l. 977--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3.0 3.0) is true.</td></tr></table>
<!--l. 978--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #c(3 -4) #c(3 -4)) is true.</td></tr></table>
<!--l. 979--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #c(3 -4.0) #c(3 -4)) is false.</td></tr></table>
<!--l. 980--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.</td></tr></table>
<!--l. 981--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is false.</td></tr></table>
<!--l. 982--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;(a . b) &#x2019;(a . b)) might be true or false.</td></tr></table>
                                                                          

                                                                          
<!--l. 983--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (eql x x)) is true.</td></tr></table>
<!--l. 984--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (eql x x)) is true.</td></tr></table>
<!--l. 985--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #\A #\A) is true.</td></tr></table>
<!--l. 986--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) might be true or false.</td></tr></table>
<!--l. 987--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is false.</td></tr></table>
<!--l. 988--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is false.</td></tr></table>
<!--l. 990--><p class="indent" >
</div>
</div>
<!--l. 992--><p class="indent" >   Предикат <a 
href="#x44-74005r47">eql</a> является истиной, если его аргументы равны <a 
href="#x44-74002r46">eq</a>, или если
это числого одинакового типа и с одинаковыми значениями, или если это
одинаковые строковые символы. Например: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;a &#x2019;b) ложь
</td></tr></table>
<!--l. 997--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;a &#x2019;a) истина</td></tr></table>
<!--l. 998--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3 3) истина</td></tr></table>
<!--l. 999--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3 3.0) ложь</td></tr></table>
<!--l. 1000--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3.0 3.0) истина</td></tr></table>
<!--l. 1001--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #c(3 -4) #c(3 -4)) истина</td></tr></table>
<!--l. 1002--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #c(3 -4.0) #c(3 -4)) ложь</td></tr></table>
<!--l. 1003--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь</td></tr></table>
<!--l. 1004--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) ложь</td></tr></table>
<!--l. 1005--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;(a . b) &#x2019;(a . b)) может быть истиной или ложью</td></tr></table>
<!--l. 1006--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (eql x x)) истина</td></tr></table>
<!--l. 1007--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (eql x x)) истина</td></tr></table>
<!--l. 1008--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #\A #\A) истина</td></tr></table>
<!--l. 1009--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) может быть истиной или ложью</td></tr></table>
<!--l. 1010--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) ложь</td></tr></table>
<!--l. 1011--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) ложь</td></tr></table>
<!--l. 1013--><p class="indent" >
</div>
</div>
<!--l. 1015--><p class="indent" >   Normally (eql 1.0s0 1.0d0) would be false, under the assumption that
1.0s0 and 1.0d0 are of distinct data types. However, implementations
that do not provide four distinct ﬂoating-point formats are permitted to
                                                                          

                                                                          
“collapse” the four formats into some smaller number of them; in such an
implementation (eql 1.0s0 1.0d0) might be true. The predicate <a 
href="clmse68.html#x85-124002r210">=</a> will
compare the values of two numbers even if the numbers are of diﬀerent
types.
<!--l. 1023--><p class="indent" >   Обычно (eql 1.0s0 1.0d0) будет ложью, так как 1.0s0 и 1.0d0 не
принадлежат одному типу данных. Однако реализация может не
реализовывать полный набор чисел с плавающей точкой, поэтому в такой
ситуации (eql 1.0s0 1.0d0) может быть истиной. Предикат <a 
href="clmse68.html#x85-124002r210">=</a> будет
сравнивать знчения двух чисел, даже если числа принадлежат разным
типам.
<!--l. 1029--><p class="indent" >   If an implementation supports positive and negative zeros as distinct values
(as in the IEEE proposed standard ﬂoating-point format), then (eql 0.0 -0.0) will
be false. Otherwise, when the syntax -0.0 is read it will be interpreted as the value
0.0, and so (eql 0.0 -0.0) will be true. The predicate <a 
href="clmse68.html#x85-124002r210">=</a> diﬀers from <a 
href="#x44-74005r47">eql</a> in that (=
0.0 -0.0) will always be true, because <a 
href="clmse68.html#x85-124002r210">=</a> compares the mathematical values of
its operands, whereas <a 
href="#x44-74005r47">eql</a> compares the representational values, so to
speak.
<!--l. 1038--><p class="indent" >   Если реализация поддерживает положительный и отрицательный нули,
как различные значения (так IEEE стандарт предлагает реализовывать
формат числа с плавающей точкой), тогда (eql 0.0 -0.0) будет ложью. В
противном случае, когда синтаксис -0.0 интепретируется, как значение 0.0,
тогда (eql 0.0 -0.0) будет истиной. Предикат <a 
href="clmse68.html#x85-124002r210">=</a> отличается от <a 
href="#x44-74005r47">eql</a>, в том что (=
0.0 -0.0) будет всегда истинно, потому что <a 
href="clmse68.html#x85-124002r210">=</a> сравнивает математические
значения операндов, тогда как <a 
href="#x44-74005r47">eql</a> сравнивает, так сказать, репрезентативные
(representational) значения. FIXME.
<!--l. 1047--><p class="indent" >   Two complex numbers are considered to be <a 
href="#x44-74005r47">eql</a> if their real parts are <a 
href="#x44-74005r47">eql</a> and
their imaginary parts are <a 
href="#x44-74005r47">eql</a>. For example, (eql #C(4 5) #C(4 5)) is true and (eql
#C(4 5) #C(4.0 5.0)) is false. Note that while (eql #C(5.0 0.0) 5.0) is false, (eql
#C(5 0) 5) is true. In the case of (eql #C(5.0 0.0) 5.0) the two arguments are of
diﬀerent types and so cannot satisfy <a 
href="#x44-74005r47">eql</a>; that&#x2019;s all there is to it. In the case
of (eql #C(5 0) 5), however, #C(5 0) is not a complex number but is
always automatically reduced by the rule of complex canonicalization
to the integer 5, just as the apparent ratio 20/4 is always simpliﬁed to
5.
<!--l. 1062--><p class="indent" >   Два комплексных числа будут равны <a 
href="#x44-74005r47">eql</a>, если их действительные части
равны eql и мнимые части равны <a 
href="#x44-74005r47">eql</a>. Например, (eql #C(4 5) #C(4 5))
является истиной и (eql #C(4 5) #C(4.0 5.0)) является ложью. Следует
отметить, что (eql #C(5.0 0.0) 5.0) ложь, а (eql #C(5 0) 5) истина. В случае с
                                                                          

                                                                          
(eql #C(5.0 0.0) 5.0) два аргумента принадлежат разным типам и не равны
<a 
href="#x44-74005r47">eql</a>, Однако, в случае (eql #C(5 0) 5), #C(5 0) не является комплексным
числом, и автоматически преобразуется, по правилу канонизации
комплексных чисел, в целое 5, так как дробное число 20/4 всегда упрощается
до 5.
<!--l. 1075--><p class="indent" >   The case of (eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) is discussed above in the description of <a 
href="#x44-74002r46">eq</a>.
While <a 
href="#x44-74005r47">eql</a> compares the values of numbers and characters, it does not compare the
contents of strings. To compare the characters of two strings, one should use
<a 
href="#x44-74007r48">equal</a>, <a 
href="#x44-74010r49">equalp</a>, string=, or <a 
href="clmse101.html#x124-166005r596">string-equal</a>.
<!--l. 1081--><p class="indent" >   Cлучай (eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) обсуждался выше в описании <a 
href="#x44-74002r46">eq</a>. Тогда как <a 
href="#x44-74005r47">eql</a>
сравнивает значения чисел и строковых символов, он не сравнивает
содержимое строк. Сравнение символов двух строк может быть выполнено с
помощью <a 
href="#x44-74007r48">equal</a>, <a 
href="#x44-74010r49">equalp</a>, <a 
href="clmse101.html#x124-166002r595">string=</a> или <a 
href="clmse101.html#x124-166005r596">string-equal</a>.
<div class=incompatibility>
<!--l. 1087--><p class="noindent" ><b>Compatibility note:</b> The Common Lisp function <a 
href="#x44-74005r47">eql</a> is similar to the Interlisp function
eqp. However, <a 
href="#x44-74005r47">eql</a> considers 3 and 3.0 to be diﬀerent, whereas eqp considers them to be
the same; eqp behaves like the Common Lisp <a 
href="clmse68.html#x85-124002r210">=</a> function, not like <a 
href="#x44-74005r47">eql</a>, when both
arguments are numbers.
</div>
</div>
<div class=defun>
<!--l. 1097--><p class="noindent" ><i>[Function]</i><a 
 id="dx44-74006"></a><a 
 id="x44-74007r48"></a><b> equal</b>  <i>x</i> <i>y</i>
<!--l. 1099--><p class="noindent" >The <a 
href="#x44-74007r48">equal</a> predicate is true if its arguments are structurally similar (isomorphic)
objects. A rough rule of thumb is that two objects are <a 
href="#x44-74007r48">equal</a> if and only if their
printed representations are the same.
<!--l. 1104--><p class="indent" >   Предикат <a 
href="#x44-74007r48">equal</a> является истиной, если его аргументы это структурно
похожие (изоморфные) объекты. Грубое правило такое, что два объекта
равны <a 
href="#x44-74007r48">equal</a> тогда и только тогда, когда одинаково их выводимое
представление.
<!--l. 1108--><p class="indent" >   Numbers and characters are compared as for <a 
href="#x44-74005r47">eql</a>. Symbols are compared as for
<a 
href="#x44-74002r46">eq</a>. This method of comparing symbols can violate the rule of thumb for <a 
href="#x44-74007r48">equal</a> and
printed representations, but only in the infrequently occurring case of two distinct
symbols with the same print name.
<!--l. 1115--><p class="indent" >   Числа и строковые символы сравниваются также как и в <a 
href="#x44-74005r47">eql</a>. Символы
сравниваются как в <a 
href="#x44-74002r46">eq</a>. Этот метод сравнения символов может нарушать
правило и сравнении выводимого представления, в случае если различия
двух символов с одинаковым выводимым представлением.
<!--l. 1120--><p class="indent" >   Certain objects that have components are <a 
href="#x44-74007r48">equal</a> if they are of the same type
                                                                          

                                                                          
and corresponding components are <a 
href="#x44-74007r48">equal</a>. This test is implemented in a recursive
manner and may fail to terminate for circular structures.
<!--l. 1125--><p class="indent" >   Объекты, которые содержат другие элементы, будут равны <a 
href="#x44-74007r48">equal</a>, если
они принадлежат одному типу и содержащиеся элементы равны <a 
href="#x44-74007r48">equal</a>. Эта
проверка реализована в рекурсивном стиле и может быть зациклиться на
закольцованных структурах.
<!--l. 1130--><p class="indent" >   For conses, <a 
href="#x44-74007r48">equal</a> is deﬁned recursively as the two <i>car</i>&#x2019;s being <a 
href="#x44-74007r48">equal</a> and the
two <i>cdr</i>&#x2019;s being <a 
href="#x44-74007r48">equal</a>.
<!--l. 1134--><p class="indent" >   Для cons-ячеек, <a 
href="#x44-74007r48">equal</a> определен рекурсивно, как сравнение equal сначала
<i>car</i> элементов, а затем <i>cdr</i>.
<!--l. 1137--><p class="indent" >   Two arrays are <a 
href="#x44-74007r48">equal</a> only if they are <a 
href="#x44-74002r46">eq</a>, with one exception: strings and
bit-vectors are compared element-by-element. If either argument has a ﬁll pointer,
the ﬁll pointer limits the number of elements examined by <a 
href="#x44-74007r48">equal</a>. Uppercase and
lowercase letters in strings are considered by <a 
href="#x44-74007r48">equal</a> to be distinct. (In contrast,
<a 
href="#x44-74010r49">equalp</a> ignores case distinctions in strings.)
<!--l. 1146--><p class="indent" >   Два массива равны <a 
href="#x44-74007r48">equal</a> только, если они равны <a 
href="#x44-74002r46">eq</a>, с одним
исключением: строки и битовые вектора сравниваются поэлементно. Если
какой-либо аргумент или оба содержат указатель заполнения (ﬁll pointer),
данный указатель ограничит количество проверяемых с помощью equal
элементов. Буквы верхнего и нижнего регистров в строках рацениваются
предикатом <a 
href="#x44-74007r48">equal</a> как разные. (А <a 
href="#x44-74010r49">equalp</a> игнорирует различие в регистрах в
строках.)
<div class=incompatibility>
<!--l. 1156--><p class="noindent" ><b>Compatibility note:</b> In Lisp Machine Lisp, <a 
href="#x44-74007r48">equal</a> ignores the diﬀerence between
uppercase and lowercase letters in strings. This violates the rule of thumb about printed
representations, however, which is very useful, especially to novices. It is also
inconsistent with the treatment of single characters, which in Lisp Machine Lisp are
represented as ﬁxnums.
</div>
<!--l. 1166--><p class="indent" >   Two pathname objects are <a 
href="#x44-74007r48">equal</a> if and only if all the corresponding
components (host, device, and so on) are equivalent. (Whether or not uppercase
and lowercase letters are considered equivalent in strings appearing in components
depends on the ﬁle name conventions of the ﬁle system.) Pathnames that are
<a 
href="#x44-74007r48">equal</a> should be functionally equivalent.
<!--l. 1174--><p class="indent" >   Два объекта имени файла (pathname objects) равны <a 
href="#x44-74007r48">equal</a> тогда и только
тогда, когда все элементы (хост, устройство, и т.д.) равны. (Будут
ли равны буквы разных регистров зависит от файловой системы.)
Имена файлов, которые равны <a 
href="#x44-74007r48">equal</a>, должны быть функционально
                                                                          

                                                                          
эквивалентны.
<div class=new>
<!--l. 1180--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx44-74008"></a>to clarify that <a 
href="#x44-74007r48">equal</a> never recursively descends any
structure or data type other than the ones explicitly described above:
conses, bit-vectors, strings, and pathnames. Numbers and characters are
compared as if by <a 
href="#x44-74005r47">eql</a>, and all other data objects are compared as if by
<a 
href="#x44-74002r46">eq</a>.
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;a &#x2019;b) is false.
</td></tr></table>
<!--l. 1190--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;a &#x2019;a) is true.</td></tr></table>
<!--l. 1191--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3 3) is true.</td></tr></table>
<!--l. 1192--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3 3.0) is false.</td></tr></table>
<!--l. 1193--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3.0 3.0) is true.</td></tr></table>
<!--l. 1194--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #c(3 -4) #c(3 -4)) is true.</td></tr></table>
<!--l. 1195--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #c(3 -4.0) #c(3 -4)) is false.</td></tr></table>
<!--l. 1196--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.</td></tr></table>
<!--l. 1197--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is true.</td></tr></table>
<!--l. 1198--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;(a . b) &#x2019;(a . b)) is true.</td></tr></table>
<!--l. 1199--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (equal x x)) is true.</td></tr></table>
<!--l. 1200--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (equal x x)) is true.</td></tr></table>
<!--l. 1201--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #\A #\A) is true.</td></tr></table>
<!--l. 1202--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) is true.</td></tr></table>
<!--l. 1203--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is true.</td></tr></table>
<!--l. 1204--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is false.</td></tr></table>
<!--l. 1206--><p class="indent" >
</div>
</div>
<!--l. 1207--><p class="noindent" >To compare a tree of conses using <a 
href="#x44-74005r47">eql</a> (or any other desired predicate) on the leaves,
use <a 
href="clmse86.html#x106-148064r475">tree-equal</a>.
<div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;a &#x2019;b) ложь
</td></tr></table>
<!--l. 1211--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;a &#x2019;a) истина</td></tr></table>
<!--l. 1212--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3 3) истина</td></tr></table>
<!--l. 1213--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3 3.0) ложь</td></tr></table>
<!--l. 1214--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3.0 3.0) истина</td></tr></table>
<!--l. 1215--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #c(3 -4) #c(3 -4)) истина</td></tr></table>
<!--l. 1216--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #c(3 -4.0) #c(3 -4)) ложь</td></tr></table>
<!--l. 1217--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь</td></tr></table>
<!--l. 1218--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) истина</td></tr></table>
<!--l. 1219--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;(a . b) &#x2019;(a . b)) истина</td></tr></table>
<!--l. 1220--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (equal x x)) истина</td></tr></table>
<!--l. 1221--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (equal x x)) истина</td></tr></table>
<!--l. 1222--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #\A #\A) истина</td></tr></table>
<!--l. 1223--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) истина</td></tr></table>
<!--l. 1224--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) истина</td></tr></table>
<!--l. 1225--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) ложь</td></tr></table>
<!--l. 1227--><p class="indent" >
</div>
</div>
<!--l. 1228--><p class="noindent" >To compare a tree of conses using <a 
href="#x44-74005r47">eql</a> (or any other desired predicate) on the
leaves, use <a 
href="clmse86.html#x106-148064r475">tree-equal</a>. Для сравнения дерева cons-ячеек применяя <a 
href="#x44-74005r47">eql</a>
(или любой другой желаемый предикат) для листьев, используйте
<a 
href="clmse86.html#x106-148064r475">tree-equal</a>.
</div>
<div class=defun>
<!--l. 1235--><p class="noindent" ><i>[Function]</i><a 
 id="dx44-74009"></a><a 
 id="x44-74010r49"></a><b> equalp</b>  <i>x</i> <i>y</i>
<!--l. 1237--><p class="noindent" >Two objects are <a 
href="#x44-74010r49">equalp</a> if they are <a 
href="#x44-74007r48">equal</a>; if they are characters and satisfy
<a 
href="clmse77.html#x95-137034r373">char-equal</a>, which ignores alphabetic case and certain other attributes
of characters; if they are numbers and have the same numerical value,
even if they are of diﬀerent types; or if they have components that are all
<a 
href="#x44-74010r49">equalp</a>.
<!--l. 1245--><p class="indent" >   Два объекта равны <a 
href="#x44-74010r49">equalp</a>, если они равны <a 
href="#x44-74007r48">equal</a>, если они строковые
символы и удовлетворяют предикату <a 
href="clmse77.html#x95-137034r373">char-equal</a>, который игнорирует регистр
и другие атрибуты символов, если они числа и имеют одинаковое значение,
даже если числа разных типов, если они включает в себя элементы, которые
                                                                          

                                                                          
также равны <a 
href="#x44-74010r49">equalp</a>.
<!--l. 1251--><p class="indent" >   Objects that have components are <a 
href="#x44-74010r49">equalp</a> if they are of the same type and
corresponding components are <a 
href="#x44-74010r49">equalp</a>. This test is implemented in a recursive
manner and may fail to terminate for circular structures. For conses, <a 
href="#x44-74010r49">equalp</a> is
deﬁned recursively as the two <i>car</i>&#x2019;s being <a 
href="#x44-74010r49">equalp</a> and the two <i>cdr</i>&#x2019;s being
<a 
href="#x44-74010r49">equalp</a>.
<!--l. 1259--><p class="indent" >   Объекты, которые включают в себя элементы, равны <a 
href="#x44-74010r49">equalp</a>, если они
принадлежат одному типу и содержащиеся элементы равны <a 
href="#x44-74010r49">equalp</a>.
Проверка осуществляется в рекурсивном стиле и может не завершится на
заколцованных структурах. Для cons-ячеек, предикат <a 
href="#x44-74010r49">equalp</a> определен
рекурсивно и сравнивает сначала <i>car</i> элементы, а затем <i>cdr</i>.
<!--l. 1266--><p class="indent" >   Two arrays are <a 
href="#x44-74010r49">equalp</a> if and only if they have the same number of dimensions,
the dimensions match, and the corresponding components are <a 
href="#x44-74010r49">equalp</a>. The
specializations need not match; for example, a string and a general array that
happens to contain the same characters will be <a 
href="#x44-74010r49">equalp</a> (though deﬁnitely
not <a 
href="#x44-74007r48">equal</a>). If either argument has a ﬁll pointer, the ﬁll pointer limits
the number of elements examined by <a 
href="#x44-74010r49">equalp</a>. Because <a 
href="#x44-74010r49">equalp</a> performs
element-by-element comparisons of strings and ignores the alphabetic case of
characters, case distinctions are therefore also ignored when <a 
href="#x44-74010r49">equalp</a> compares
strings.
<!--l. 1279--><p class="indent" >   Два массива равны <a 
href="#x44-74010r49">equalp</a> тогда и только тогда, когда они имеют
одинаковое количество измерений, и размеры измерений совпадают, и все
элементы равны <a 
href="#x44-74010r49">equalp</a>. Специализация массива не сравнивается. Например,
строка и общий массив, случилось так, имеют одинаковые строковые
символы, тогда они будут равны <a 
href="#x44-74010r49">equalp</a> (но определенно не равны <a 
href="#x44-74007r48">equal</a>).
Если какой-либо аргумент содержит указатель заполнения, этот указатель
ограничивает число сравниваемых элементов. Так как <a 
href="#x44-74010r49">equalp</a> сравнивает
строки побуквенно, и не различает разных регистров букв, то сравнение
строк регистронезависимо.
<!--l. 1288--><p class="indent" >   Two symbols can be <a 
href="#x44-74010r49">equalp</a> only if they are <a 
href="#x44-74002r46">eq</a>, that is, the same identical
object.
<!--l. 1291--><p class="indent" >   Два символа могут быть равны <a 
href="#x44-74010r49">equalp</a> только тогда, когда они <a 
href="#x44-74002r46">eq</a>, т.е.
являеются идентичными объектами.
<div class=new>
<!--l. 1295--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx44-74011"></a>to specify that <a 
href="#x44-74010r49">equalp</a> compares components of hash
tables (see below), and to clarify that otherwise <a 
href="#x44-74010r49">equalp</a> never recursively
descends any structure or data type other than the ones explicitly described
above: conses, arrays (including bit-vectors and strings), and pathnames.
                                                                          

                                                                          
Numbers are compared for numerical equality (see <a 
href="clmse68.html#x85-124002r210">=</a>), characters are
compared as if by <a 
href="clmse77.html#x95-137034r373">char-equal</a>, and all other data objects are compared as if by
<a 
href="#x44-74002r46">eq</a>.
<!--l. 1306--><p class="indent" >   Two hash tables are considered the same by <a 
href="#x44-74010r49">equalp</a> if and only if they satisfy a
four-part test:
      <ul class="itemize1">
      <li class="itemize">They must be of the same kind; that is, equivalent :test arguments were
      given to <a 
href="clmse92.html#x113-155002r545">make-hash-table</a> when the two hash tables were created.
      </li>
      <li class="itemize">They must have the same number of entries (see <a 
href="clmse92.html#x113-155020r551">hash-table-count</a>).
      </li>
      <li class="itemize">For  every  entry  (<i>key1</i>,  <i>value1</i>)  in  one  hash  table  there  must  be  a
      corresponding entry (<i>key2</i>, <i>value2</i>) in the other, such that <i>key1</i> and
      <i>key2</i> are considered to be the same by the :test function associated
      with the hash tables.
      </li>
      <li class="itemize">For every entry (<i>key1</i>, <i>value1</i>) in one hash table and its corresponding
      entry (<i>key2</i>, <i>value2</i>) in the other, such that <i>key1</i> and <i>key2</i> are the
      same, <a 
href="#x44-74010r49">equalp</a> must be true of <i>value1</i> and <i>value2</i>.</li></ul>
<!--l. 1325--><p class="noindent" >The four parts of this test are carried out in the order shown, and if some part of
the test fails, <a 
href="#x44-74010r49">equalp</a> returns <a 
href="clmse31.html#x42-70002r19">nil</a> and the other parts of the test are not
attempted.
<!--l. 1329--><p class="indent" >   If <a 
href="#x44-74010r49">equalp</a> must compare two structures and the <a 
href="clmse104.html#x128-170002r619">defstruct</a> deﬁnition for
one used the :type option and the other did not, then <a 
href="#x44-74010r49">equalp</a> returns
<a 
href="clmse31.html#x42-70002r19">nil</a>.
<!--l. 1333--><p class="indent" >   If <a 
href="#x44-74010r49">equalp</a> must compare two structures and neither <a 
href="clmse104.html#x128-170002r619">defstruct</a> deﬁnition used
the :type option, then <a 
href="#x44-74010r49">equalp</a> returns <a 
href="clmse31.html#x42-70004r20">t</a> if and only if the structures have the same
type (that is, the same <a 
href="clmse104.html#x128-170002r619">defstruct</a> name) and the values of all corresponding slots
(slots having the same name) are <a 
href="#x44-74010r49">equalp</a>.
<!--l. 1339--><p class="indent" >   As part of the X3J13 discussion of this issue the following observations were
made. Object equality is not a concept for which there is a uniquely determined
correct algorithm. The appropriateness of an equality predicate can be judged
only in the context of the needs of some particular program. Although
these functions take any type of argument and their names sound very
                                                                          

                                                                          
generic, <a 
href="#x44-74007r48">equal</a> and <a 
href="#x44-74010r49">equalp</a> are not appropriate for every application. Any
decision to use or not use them should be determined by what they are
documented to do rather than by any abstract characterization of their function.
If neither <a 
href="#x44-74007r48">equal</a> nor <a 
href="#x44-74010r49">equalp</a> is found to be appropriate in a particular
situation, programmers are encouraged to create another operator that
is appropriate rather than blame <a 
href="#x44-74007r48">equal</a> or <a 
href="#x44-74010r49">equalp</a> for “doing the wrong
thing.”
</div>
<div class=new>
<!--l. 1356--><p class="indent" >   Note that one consequence of the vote to change the rules of ﬂoating-point
contagion <a 
 id="dx44-74012"></a>(described in section <a 
href="clmse66.html#x83-12200012.1">12.1<!--tex4ht:ref: PRECISION-CONTAGION-COERCION-SECTION --></a>) is to make <a 
href="#x44-74010r49">equalp</a> a true equivalence relation
on numbers.
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;a &#x2019;b) is false.
</td></tr></table>
<!--l. 1366--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;a &#x2019;a) is true.</td></tr></table>
<!--l. 1367--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3 3) is true.</td></tr></table>
<!--l. 1368--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3 3.0) is true.</td></tr></table>
<!--l. 1369--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3.0 3.0) is true.</td></tr></table>
<!--l. 1370--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #c(3 -4) #c(3 -4)) is true.</td></tr></table>
<!--l. 1371--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #c(3 -4.0) #c(3 -4)) is true.</td></tr></table>
<!--l. 1372--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.</td></tr></table>
<!--l. 1373--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is true.</td></tr></table>
<!--l. 1374--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;(a . b) &#x2019;(a . b)) is true.</td></tr></table>
<!--l. 1375--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (equalp x x)) is true.</td></tr></table>
<!--l. 1376--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (equalp x x)) is true.</td></tr></table>
<!--l. 1377--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #\A #\A) is true.</td></tr></table>
<!--l. 1378--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) is true.</td></tr></table>
<!--l. 1379--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is true.</td></tr></table>
<!--l. 1380--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is true.</td></tr></table>
<!--l. 1382--><p class="indent" >
</div>
                                                                          

                                                                          
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;a &#x2019;b) ложь
</td></tr></table>
<!--l. 1385--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;a &#x2019;a) истина</td></tr></table>
<!--l. 1386--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3 3) истина</td></tr></table>
<!--l. 1387--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3 3.0) истина</td></tr></table>
<!--l. 1388--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3.0 3.0) истина</td></tr></table>
<!--l. 1389--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #c(3 -4) #c(3 -4)) истина</td></tr></table>
<!--l. 1390--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #c(3 -4.0) #c(3 -4)) истина</td></tr></table>
<!--l. 1391--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) ложь</td></tr></table>
<!--l. 1392--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) истина</td></tr></table>
<!--l. 1393--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;(a . b) &#x2019;(a . b)) истина</td></tr></table>
<!--l. 1394--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (equalp x x)) истина</td></tr></table>
<!--l. 1395--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (equalp x x)) истина</td></tr></table>
<!--l. 1396--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #\A #\A) истина</td></tr></table>
<!--l. 1397--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) истина</td></tr></table>
<!--l. 1398--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) истина</td></tr></table>
<!--l. 1399--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) истина</td></tr></table>
<!--l. 1401--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
   <!--l. 1404--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse34.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse33.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 1404--><p class="indent" >   <a 
 id="tailclmse33.html"></a>  
</body></html> 
