<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Логические операторы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-12 16:57:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1664--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmch7.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse33.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse33.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">6.4   </span> <a 
href="clm.html#QQ2-44-86" id="x44-780006.4">Логические
операторы</a></h3>
<!--l. 1666--><p class="noindent" >Common Lisp содержит три логических оператора для булевых значений:
<tt><a 
href="#x44-78004r49">and</a></tt>, <tt><a 
href="#x44-79002r50">or</a></tt> и <tt><a 
href="#x44-78002r48">not</a></tt> (и, или, не, соответственно). <tt><a 
href="#x44-78004r49">and</a></tt> и <tt><a 
href="#x44-79002r50">or</a></tt> являются управляющими
структурами, потому что их аргументы вычисляются в зависимости от
условия. Функции <tt><a 
href="#x44-78002r48">not</a></tt> необходимо инвертировать её один аргумент, поэтому
она может быть простой функцией.
<div class=defun>
<!--l. 1673--><p class="noindent" ><i>[Функция]</i><a 
 id="dx44-78001"></a><a 
 id="x44-78002r48"></a><b> not</b>  <i>x</i>
<!--l. 1675--><p class="noindent" ><tt><a 
href="#x44-78002r48">not</a></tt> возвращает <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>, если <i>x</i> является <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>, иначе возвращает <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>. Таким образом
она инвертирует аргумент как булево значение.
<tt>
<!--l. 1680--><p class="indent" >   <a 
href="clmse31.html#x42-76002r22">null</a></tt> то же, что и <tt><a 
href="#x44-78002r48">not</a></tt>, обе функции включены для ясности. По
соглашению принято использовать <tt><a 
href="clmse31.html#x42-76002r22">null</a></tt>, когда надо проверить пустой ли
список, и <tt><a 
href="#x44-78002r48">not</a></tt>, когда надо инвертировать булево значение.
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Макрос]</i><b> and </b><a 
 id="dx44-78003"></a><a 
 id="x44-78004r49"></a> { form}*
</td></tr></table>
<!--l. 1687--><p class="indent" >
</div>
<!--l. 1687--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-790006.4" id="x44-790006.4"></a></span>
   <tt>(and <i>form1</i> <i>form2</i> ... )</tt> последовательно слева направо вычисляет
формы. Если какая-либо форма <i>formN</i> вычислилась в <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>, тогда
немедленно возвращается значение <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> без выполнения оставшихся форм.
Если все формы кроме последней вычисляются в не-<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> значение, <tt><a 
href="#x44-78004r49">and</a></tt>
возвращает то, что вернула последняя форма. Таким образом, <tt><a 
href="#x44-78004r49">and</a></tt> может
                                                                          

                                                                          
использоваться, как для логических операций, где <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> обозначает ложь и
не-<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> значения истину, так и для условных выражений. Например:
<div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(if (and (&#x003E;= n 0)
</td></tr></table>
<!--l. 1698--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (&#x003C; n (length a-simple-vector))</td></tr></table>
<!--l. 1699--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (eq (elt a-simple-vector n) &#x2019;foo))</td></tr></table>
<!--l. 1700--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (princ &#x0022;Foo!&#x0022;))</td></tr></table>
<!--l. 1702--><p class="indent" >
</div>
</div>
<!--l. 1703--><p class="noindent" >Выражение выше выводит <tt>Foo!</tt>, если <tt>n</tt>-ый элемент вектора <tt>a-simple-vector</tt>
является символом <tt>foo</tt>, проверяя при этом вхождения <tt>n</tt> в границы вектора
<tt>a-simple-vector</tt>. <tt><a 
href="clmse74.html#x93-194002r348">elt</a></tt> не будет вызвано с аргументом <tt>n</tt> выходящим за
границы вектора, так как <tt><a 
href="#x44-78004r49">and</a></tt> гарантирует ленивую проверку аргументов
слева направо.
<!--l. 1709--><p class="indent" >   Специальная форма Lisp&#x2019;а <tt><a 
href="#x44-78004r49">and</a></tt> отличается тем, что в определённых
случаях вычисляет не все аргументы.
<!--l. 1712--><p class="indent" >   Запись предыдущего примера <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(and (&#x003E;= n 0)
</td></tr></table>
<!--l. 1714--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">     (&#x003C; n (length a-simple-vector))</td></tr></table>
<!--l. 1715--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">     (eq (elt a-simple-vector n) &#x2019;foo)</td></tr></table>
<!--l. 1716--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">     (princ &#x0022;Foo!&#x0022;))</td></tr></table>
<!--l. 1718--><p class="indent" >
</div>
</div>
<!--l. 1719--><p class="noindent" >будет выполнять ту же функцию. Разница в них только стилистическая.
Некоторые программисты никогда не используют в форме <tt><a 
href="#x44-78004r49">and</a></tt> выражения с
побочными эффектами, предпочитая для этих целей использовать <tt><a 
href="clmse130.html#x160-327002r794">if</a></tt> или
<tt><a 
href="clmse130.html#x160-327004r795">when</a></tt>.
<!--l. 1723--><p class="indent" >   Из общего определения можно сделать дедуктивный вывод о том, что
<tt>(and <i>x</i>)</tt> <span class="math"> ≡</span> <i>x</i>. Также <tt>(and)</tt> выполняется в <tt><a 
href="clmse30.html#x41-73004r19">t</a></tt>, который тождественен этой
операции.
                                                                          

                                                                          
<!--l. 1727--><p class="indent" >   Можно определить <tt><a 
href="#x44-78004r49">and</a></tt> в терминах <tt><a 
href="clmse39.html#x51-108002r84">cond</a></tt> таким образом: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:212;" 
class="tabbing">(and <i>x</i> <i>y</i> <i>z</i> ... <i>w</i>) <span class="math"> ≡</span> (cond </td><td  
class="tabbing">((not <i>x</i>) <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>)
</td></tr></table>
<!--l. 1729--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:212;" 
class="tabbing">                                    </td><td  
class="tabbing">((not <i>y</i>) <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>)</td></tr></table>
<!--l. 1730--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:212;" 
class="tabbing">                                    </td><td  
class="tabbing">((not <i>z</i>) <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>)</td></tr></table>
<!--l. 1731--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:212;" 
class="tabbing">                                    </td><td  
class="tabbing"><span class="math">…</span></td></tr></table>
<!--l. 1732--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:212;" 
class="tabbing">                               </td><td  
class="tabbing">(<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> <i>w</i>))</td></tr></table>
<!--l. 1734--><p class="indent" >
</div>
</div>
<!--l. 1736--><p class="indent" >   Смотрите <tt>id</tt> и <tt><a 
href="clmse130.html#x160-327004r795">when</a></tt>, которые иногда являются стилистически более
удобными, чем <tt><a 
href="#x44-78004r49">and</a></tt> в целях ветвления. Если необходимо проверить
истинность предиката для всех элементов списка или вектора (element 0
<i>and</i> element 1 <i>and</i> element 2 <i>and</i> <span class="math">…</span>), можно использовать функцию
<tt><a 
href="clmse75.html#x94-195010r359">every</a></tt>.
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Макрос]</i><b> or </b><a 
 id="dx44-79001"></a><a 
 id="x44-79002r50"></a> { form}*
</td></tr></table>
<!--l. 1745--><p class="indent" >
</div>
<!--l. 1745--><p class="noindent" ><span class="paragraphHead"><a 
href="#x44-800006.4" id="x44-800006.4"></a></span>
   <tt>(or <i>form1</i> <i>form2</i> ... )</tt> последовательно выполняет каждую форму
слева направо. Если какая-либо непоследняя форма выполняется в что-либо
отличное от <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>, <tt><a 
href="#x44-79002r50">or</a></tt> немедленно возвращает это не-<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> значение без
выполнения оставшихся форм. Если все формы кроме последней,
вычисляются в <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>, <tt><a 
href="#x44-79002r50">or</a></tt> возвращает то, что вернула последняя форма. Таким
образом <tt><a 
href="#x44-79002r50">or</a></tt> может быть использована как для логических операций, в
который <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> обозначает ложь, и не-<tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt> истину, так и для условного
выполнения форм.
                                                                          

                                                                          
<!--l. 1755--><p class="indent" >   Специальная форма Lisp&#x2019;а <tt><a 
href="#x44-79002r50">or</a></tt> отличается тем, что в определённых
случаях вычисляет не все аргументы.
<!--l. 1758--><p class="indent" >   Из общего определения, можно сделать дедуктивный вывод о том, что <tt>(or
<i>x</i>)</tt> <span class="math"> ≡</span> <i>x</i>. Также, <tt>(or)</tt> выполняется в <tt><a 
href="clmse30.html#x41-73002r18">nil</a></tt>, который тождественен этой
операции.
<!--l. 1762--><p class="indent" >   Можно определить <tt><a 
href="#x44-79002r50">or</a></tt> в терминах <tt><a 
href="clmse39.html#x51-108002r84">cond</a></tt> таким образом: <div class=lisp><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(or <i>x</i> <i>y</i> <i>z</i> ... <i>w</i>) <span class="math"> ≡</span> (cond (<i>x</i>) (<i>y</i>) (<i>z</i>) ... (<tt><a 
href="clmse30.html#x41-73004r19">t</a></tt> <i>w</i>))
</td></tr></table>
<!--l. 1765--><p class="indent" >
</div>
</div>
<!--l. 1767--><p class="indent" >   Смотрите <tt>id</tt> и <tt><a 
href="clmse130.html#x160-327006r796">unless</a></tt>, которые иногда являются стилистически более
удобными, чем <tt><a 
href="#x44-79002r50">or</a></tt> в целях ветвления. Если необходимо проверить истинность
предиката для всех элементов списка или вектора (element 0 <i>or</i> element 1 <i>or</i>
element 2 <i>or</i> <span class="math">…</span>), можно использовать функцию <tt><a 
href="clmse75.html#x94-195008r358">some</a></tt>.
</div>
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
                                                                          

                                                                          
<!--l. 4516--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmch7.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse33.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse33.html"></a>  </div> </div> 
</body></html> 
