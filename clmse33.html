<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Equality Predicates</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-22 01:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 635--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse34.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse33.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse33.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
 id="x44-740006.3"></a>Equality Predicates</h3>
<!--l. 637--><p class="noindent" >Common Lisp provides a spectrum of predicates for testing for equality of two
objects: <a 
href="#x44-74002r46">eq</a> (the most speciﬁc), <a 
href="#x44-74004r47">eql</a>, <a 
href="#x44-74006r48">equal</a>, and <a 
href="#x44-74008r49">equalp</a> (the most general). <a 
href="#x44-74002r46">eq</a> and
<a 
href="#x44-74006r48">equal</a> have the meanings traditional in Lisp. <a 
href="#x44-74004r47">eql</a> was added because it is frequently
needed, and <a 
href="#x44-74008r49">equalp</a> was added primarily in order to have a version of <a 
href="#x44-74006r48">equal</a>
that would ignore type diﬀerences when comparing numbers and case
diﬀerences when comparing characters. If two objects satisfy any one of
these equality predicates, then they also satisfy all those that are more
general.
<div class=defun>
<!--l. 647--><p class="noindent" > <i>[Function]</i>   <b>eq</b> <a 
 id="dx44-74001"></a><a 
 id="x44-74002r46"></a>   <i>x</i>  <i>y</i>
<!--l. 649--><p class="noindent" ><i>(eq <i>x</i> <i>y</i>)</i> is true if and only if <i>x</i> and <i>y</i> are the same identical object.
(Implementationally, <i>x</i> and <i>y</i> are usually <a 
href="#x44-74002r46">eq</a> if and only if they address the same
identical memory location.)
<!--l. 655--><p class="indent" >   It should be noted that things that print the same are not necessarily <a 
href="#x44-74002r46">eq</a> to
each other. Symbols with the same print name usually are <a 
href="#x44-74002r46">eq</a> to each other
because of the use of the <a 
href="clmse63.html#x79-118028r184">intern</a> function. However, numbers with the same value
need not be <a 
href="#x44-74002r46">eq</a>, and two similar lists are usually not <a 
href="#x44-74002r46">eq</a>. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;a &#x2019;b) is false.
</td></tr></table>
<!--l. 662--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;a &#x2019;a) is true.</td></tr></table>
<!--l. 663--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3 3) might be true or false, depending on the implementation.</td></tr></table>
<!--l. 664--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3 3.0) is false.</td></tr></table>
<!--l. 665--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq 3.0 3.0) might be true or false, depending on the implementation.</td></tr></table>
<!--l. 666--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #c(3 -4) #c(3 -4))</td></tr></table>
<!--l. 667--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  might be true or false, depending on the implementation.</td></tr></table>
<!--l. 668--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #c(3 -4.0) #c(3 -4)) is false.</td></tr></table>
<!--l. 669--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.</td></tr></table>
                                                                          

                                                                          
<!--l. 670--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is false.</td></tr></table>
<!--l. 671--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x2019;(a . b) &#x2019;(a . b)) might be true or false.</td></tr></table>
<!--l. 672--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (eq x x)) is true.</td></tr></table>
<!--l. 673--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (eq x x)) is true.</td></tr></table>
<!--l. 674--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq #<tt>\</tt>A #<tt>\</tt>A) might be true or false, depending on the implementation.</td></tr></table>
<!--l. 675--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) might be true or false.</td></tr></table>
<!--l. 676--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is false.</td></tr></table>
<!--l. 677--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eq &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is false.</td></tr></table>
<!--l. 679--><p class="indent" >
</div>
</div>
<!--l. 680--><p class="noindent" >In Common Lisp, unlike some other Lisp dialects, the implementation is permitted to
make “copies” of characters and numbers at any time. (This permission is granted
because it allows tremendous performance improvements in many common
situations.) The net eﬀect is that Common Lisp makes no guarantee that <a 
href="#x44-74002r46">eq</a> will
be true even when both its arguments are “the same thing” if that thing is a
character or number. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((x 5)) (eq x x)) might be true or false.
</td></tr></table>
<!--l. 690--><p class="indent" >
</div>
</div>
<!--l. 691--><p class="noindent" >The predicate <a 
href="#x44-74004r47">eql</a> is the same as <a 
href="#x44-74002r46">eq</a>, except that if the arguments are characters or
numbers of the same type then their values are compared. Thus <a 
href="#x44-74004r47">eql</a> tells whether
two objects are <i>conceptually</i> the same, whereas <a 
href="#x44-74002r46">eq</a> tells whether two objects
are <i>implementationally</i> identical. It is for this reason that <a 
href="#x44-74004r47">eql</a>, not <a 
href="#x44-74002r46">eq</a>, is
the default comparison predicate for the sequence functions deﬁned in
chapter <a 
href="clmch14.html#x99-14100014">14<!--tex4ht:ref: KSEQUE --></a>.
<div class=implementation>
<!--l. 700--><p class="noindent" ><b>Implementation note:</b> <a 
href="#x44-74002r46">eq</a> simply compares the two given pointers, so any
kind of object that is represented in an “immediate” fashion will indeed have
like-valued instances satisfy <a 
href="#x44-74002r46">eq</a>. In some implementations, for example, ﬁxnums and
characters happen to “work.” However, no program should depend on this, as other
implementations of Common Lisp might not use an immediate representation for these
data types.
                                                                          

                                                                          
</div>
<div class=obsolete>
<!--l. 712--><p class="indent" >   An additional problem with <a 
href="#x44-74002r46">eq</a> is that the implementation is permitted to
“collapse” constants (or portions thereof) appearing in code to be compiled if they
are <a 
href="#x44-74006r48">equal</a>. An object is considered to be a constant in code to be compiled if it is a
self-evaluating form or is contained in a <a 
href="clmse35.html#x47-78002r53">quote</a> form. This is why <i>(eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;)</i>
might be true or false; in interpreted code it would normally be false, because
reading in the form <i>(eq &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;)</i> would construct distinct strings for the
two arguments to <a 
href="#x44-74002r46">eq</a>, but the compiler might choose to use the same
identical string or two distinct copies as the two arguments in the call to <a 
href="#x44-74002r46">eq</a>.
Similarly, <i>(eq &#x2019;(a . b) &#x2019;(a . b))</i> might be true or false, depending on whether
the constant conses appearing in the <a 
href="clmse35.html#x47-78002r53">quote</a> forms were collapsed by the
compiler. However, <i>(eq (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b))</i> is always false, because every
distinct call to the <a 
href="clmse86.html#x106-148062r472">cons</a> function necessarily produces a new and distinct
cons.
</div>
<div class=newer>
<!--l. 730--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that <a 
href="clmse110.html#x135-180002r618">eval</a> and <a 
href="clmse127.html#x157-224002r795">compile</a> are not
permitted either to copy or to coalesce (“collapse”) constants (see <a 
href="#x44-74002r46">eq</a>) appearing in
the code they process; the resulting program behavior must refer to objects
that are <a 
href="#x44-74004r47">eql</a> to the corresponding objects in the source code. Only the
<a 
href="clmse127.html#x157-224006r797">compile-ﬁle</a>/<a 
href="clmse122.html#x150-217002r776">load</a> process is permitted to copy or coalesce constants (see
section <a 
href="clmse127.html#x157-22400025.1">25.1<!--tex4ht:ref: COMPILER-SECTION --></a>).
</div>
</div>
<div class=defun>
<!--l. 741--><p class="noindent" > <i>[Function]</i>   <b>eql</b> <a 
 id="dx44-74003"></a><a 
 id="x44-74004r47"></a>   <i>x</i>  <i>y</i>
<!--l. 743--><p class="noindent" >The <a 
href="#x44-74004r47">eql</a> predicate is true if its arguments are <a 
href="#x44-74002r46">eq</a>, or if they are numbers of the
same type with the same value, or if they are character objects that represent the
same character. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;a &#x2019;b) is false.
</td></tr></table>
<!--l. 750--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;a &#x2019;a) is true.</td></tr></table>
<!--l. 751--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3 3) is true.</td></tr></table>
<!--l. 752--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3 3.0) is false.</td></tr></table>
<!--l. 753--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql 3.0 3.0) is true.</td></tr></table>
                                                                          

                                                                          
<!--l. 754--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #c(3 -4) #c(3 -4)) is true.</td></tr></table>
<!--l. 755--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #c(3 -4.0) #c(3 -4)) is false.</td></tr></table>
<!--l. 756--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.</td></tr></table>
<!--l. 757--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is false.</td></tr></table>
<!--l. 758--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x2019;(a . b) &#x2019;(a . b)) might be true or false.</td></tr></table>
<!--l. 759--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (eql x x)) is true.</td></tr></table>
<!--l. 760--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (eql x x)) is true.</td></tr></table>
<!--l. 761--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql #<tt>\</tt>A #<tt>\</tt>A) is true.</td></tr></table>
<!--l. 762--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) might be true or false.</td></tr></table>
<!--l. 763--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is false.</td></tr></table>
<!--l. 764--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(eql &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is false.</td></tr></table>
<!--l. 766--><p class="indent" >
</div>
</div>
<!--l. 767--><p class="noindent" >Normally <i>(eql 1.0s0 1.0d0)</i> would be false, under the assumption that <i>1.0s0</i> and
<i>1.0d0</i> are of distinct data types. However, implementations that do not provide
four distinct ﬂoating-point formats are permitted to “collapse” the four formats
into some smaller number of them; in such an implementation <i>(eql 1.0s0 1.0d0)</i>
might be true. The predicate <i>=</i> will compare the values of two numbers even if
the numbers are of diﬀerent types.
<!--l. 775--><p class="indent" >   If an implementation supports positive and negative zeros as distinct values
(as in the IEEE proposed standard ﬂoating-point format), then <i>(eql 0.0 -0.0)</i> will
be false. Otherwise, when the syntax <i>-0.0</i> is read it will be interpreted as the
value <i>0.0</i>, and so <i>(eql 0.0 -0.0)</i> will be true. The predicate <i>=</i> diﬀers from <a 
href="#x44-74004r47">eql</a> in
that <i>(= 0.0 -0.0)</i> will always be true, because <i>=</i> compares the mathematical
values of its operands, whereas <a 
href="#x44-74004r47">eql</a> compares the representational values, so to
speak.
<!--l. 784--><p class="indent" >   Two complex numbers are considered to be <a 
href="#x44-74004r47">eql</a> if their real parts are <a 
href="#x44-74004r47">eql</a> and
their imaginary parts are <a 
href="#x44-74004r47">eql</a>. For example, <i>(eql #C(4 5) #C(4 5))</i> is true and <i>(eql
#C(4 5) #C(4.0 5.0))</i> is false. Note that while <i>(eql #C(5.0 0.0) 5.0)</i> is false, <i>(eql
#C(5 0) 5)</i> is true. In the case of <i>(eql #C(5.0 0.0) 5.0)</i> the two arguments are of
diﬀerent types and so cannot satisfy <a 
href="#x44-74004r47">eql</a>; that&#x2019;s all there is to it. In the case
of <i>(eql #C(5 0) 5)</i>, however, <i>#C(5 0)</i> is not a complex number but is
always automatically reduced by the rule of complex canonicalization
to the integer <i>5</i>, just as the apparent ratio <i>20/4</i> is always simpliﬁed to
<i>5</i>.
<!--l. 799--><p class="indent" >   The case of <i>(eql &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;)</i> is discussed above in the description of <a 
href="#x44-74002r46">eq</a>.
                                                                          

                                                                          
While <a 
href="#x44-74004r47">eql</a> compares the values of numbers and characters, it does not compare the
contents of strings. To compare the characters of two strings, one should use
<a 
href="#x44-74006r48">equal</a>, <a 
href="#x44-74008r49">equalp</a>, <i>string=</i>, or <a 
href="clmse101.html#x124-166004r594">string-equal</a>.
<div class=incompatibility>
<!--l. 806--><p class="noindent" ><b>Compatibility note:</b> The Common Lisp function <a 
href="#x44-74004r47">eql</a> is similar to the Interlisp function
eqp. However, <a 
href="#x44-74004r47">eql</a> considers <i>3</i> and <i>3.0</i> to be diﬀerent, whereas eqp considers them to be
the same; eqp behaves like the Common Lisp <i>=</i> function, not like <a 
href="#x44-74004r47">eql</a>, when both
arguments are numbers.
</div>
</div>
<div class=defun>
<!--l. 816--><p class="noindent" > <i>[Function]</i>   <b>equal</b> <a 
 id="dx44-74005"></a><a 
 id="x44-74006r48"></a>   <i>x</i>  <i>y</i>
<!--l. 818--><p class="noindent" >The <a 
href="#x44-74006r48">equal</a> predicate is true if its arguments are structurally similar (isomorphic)
objects. A rough rule of thumb is that two objects are <a 
href="#x44-74006r48">equal</a> if and only if their
printed representations are the same.
<!--l. 823--><p class="indent" >   Numbers and characters are compared as for <a 
href="#x44-74004r47">eql</a>. Symbols are compared as for
<a 
href="#x44-74002r46">eq</a>. This method of comparing symbols can violate the rule of thumb for <a 
href="#x44-74006r48">equal</a> and
printed representations, but only in the infrequently occurring case of two distinct
symbols with the same print name.
<!--l. 830--><p class="indent" >   Certain objects that have components are <a 
href="#x44-74006r48">equal</a> if they are of the same type
and corresponding components are <a 
href="#x44-74006r48">equal</a>. This test is implemented in a recursive
manner and may fail to terminate for circular structures.
<!--l. 835--><p class="indent" >   For conses, <a 
href="#x44-74006r48">equal</a> is deﬁned recursively as the two <i>car</i>&#x2019;s being <a 
href="#x44-74006r48">equal</a> and the
two <i>cdr</i>&#x2019;s being <a 
href="#x44-74006r48">equal</a>.
<!--l. 838--><p class="indent" >   Two arrays are <a 
href="#x44-74006r48">equal</a> only if they are <a 
href="#x44-74002r46">eq</a>, with one exception: strings and
bit-vectors are compared element-by-element. If either argument has a ﬁll pointer,
the ﬁll pointer limits the number of elements examined by <a 
href="#x44-74006r48">equal</a>. Uppercase and
lowercase letters in strings are considered by <a 
href="#x44-74006r48">equal</a> to be distinct. (In contrast,
<a 
href="#x44-74008r49">equalp</a> ignores case distinctions in strings.)
<div class=incompatibility>
<!--l. 848--><p class="noindent" ><b>Compatibility note:</b> In Lisp Machine Lisp, <a 
href="#x44-74006r48">equal</a> ignores the diﬀerence between
uppercase and lowercase letters in strings. This violates the rule of thumb about printed
representations, however, which is very useful, especially to novices. It is also
inconsistent with the treatment of single characters, which in Lisp Machine Lisp are
represented as ﬁxnums.
</div>
<!--l. 858--><p class="indent" >   Two pathname objects are <a 
href="#x44-74006r48">equal</a> if and only if all the corresponding
components (host, device, and so on) are equivalent. (Whether or not uppercase
                                                                          

                                                                          
and lowercase letters are considered equivalent in strings appearing in components
depends on the ﬁle name conventions of the ﬁle system.) Pathnames that are
<a 
href="#x44-74006r48">equal</a> should be functionally equivalent.
<div class=new>
<!--l. 867--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to clarify that <a 
href="#x44-74006r48">equal</a> never recursively descends
any structure or data type other than the ones explicitly described above:
conses, bit-vectors, strings, and pathnames. Numbers and characters are
compared as if by <a 
href="#x44-74004r47">eql</a>, and all other data objects are compared as if by
<a 
href="#x44-74002r46">eq</a>.
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;a &#x2019;b) is false.
</td></tr></table>
<!--l. 877--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;a &#x2019;a) is true.</td></tr></table>
<!--l. 878--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3 3) is true.</td></tr></table>
<!--l. 879--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3 3.0) is false.</td></tr></table>
<!--l. 880--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal 3.0 3.0) is true.</td></tr></table>
<!--l. 881--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #c(3 -4) #c(3 -4)) is true.</td></tr></table>
<!--l. 882--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #c(3 -4.0) #c(3 -4)) is false.</td></tr></table>
<!--l. 883--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.</td></tr></table>
<!--l. 884--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is true.</td></tr></table>
<!--l. 885--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x2019;(a . b) &#x2019;(a . b)) is true.</td></tr></table>
<!--l. 886--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (equal x x)) is true.</td></tr></table>
<!--l. 887--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (equal x x)) is true.</td></tr></table>
<!--l. 888--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal #<tt>\</tt>A #<tt>\</tt>A) is true.</td></tr></table>
<!--l. 889--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) is true.</td></tr></table>
<!--l. 890--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is true.</td></tr></table>
<!--l. 891--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equal &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is false.</td></tr></table>
<!--l. 893--><p class="indent" >
</div>
</div>
<!--l. 894--><p class="noindent" >To compare a tree of conses using <a 
href="#x44-74004r47">eql</a> (or any other desired predicate) on the leaves,
use <a 
href="clmse86.html#x106-148064r473">tree-equal</a>.
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 898--><p class="noindent" > <i>[Function]</i>   <b>equalp</b> <a 
 id="dx44-74007"></a><a 
 id="x44-74008r49"></a>   <i>x</i>  <i>y</i>
<!--l. 900--><p class="noindent" >Two objects are <a 
href="#x44-74008r49">equalp</a> if they are <a 
href="#x44-74006r48">equal</a>; if they are characters and satisfy
<a 
href="clmse77.html#x95-137032r371">char-equal</a>, which ignores alphabetic case and certain other attributes
of characters; if they are numbers and have the same numerical value,
even if they are of diﬀerent types; or if they have components that are all
<a 
href="#x44-74008r49">equalp</a>.
<!--l. 908--><p class="indent" >   Objects that have components are <a 
href="#x44-74008r49">equalp</a> if they are of the same type and
corresponding components are <a 
href="#x44-74008r49">equalp</a>. This test is implemented in a recursive
manner and may fail to terminate for circular structures. For conses, <a 
href="#x44-74008r49">equalp</a> is
deﬁned recursively as the two <i>car</i>&#x2019;s being <a 
href="#x44-74008r49">equalp</a> and the two <i>cdr</i>&#x2019;s being
<a 
href="#x44-74008r49">equalp</a>.
<!--l. 915--><p class="indent" >   Two arrays are <a 
href="#x44-74008r49">equalp</a> if and only if they have the same number of dimensions,
the dimensions match, and the corresponding components are <a 
href="#x44-74008r49">equalp</a>. The
specializations need not match; for example, a string and a general array that
happens to contain the same characters will be <a 
href="#x44-74008r49">equalp</a> (though deﬁnitely
not <a 
href="#x44-74006r48">equal</a>). If either argument has a ﬁll pointer, the ﬁll pointer limits
the number of elements examined by <a 
href="#x44-74008r49">equalp</a>. Because <a 
href="#x44-74008r49">equalp</a> performs
element-by-element comparisons of strings and ignores the alphabetic case of
characters, case distinctions are therefore also ignored when <a 
href="#x44-74008r49">equalp</a> compares
strings.
<!--l. 928--><p class="indent" >   Two symbols can be <a 
href="#x44-74008r49">equalp</a> only if they are <a 
href="#x44-74002r46">eq</a>, that is, the same identical
object.
<div class=new>
<!--l. 932--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that <a 
href="#x44-74008r49">equalp</a> compares components of
hash tables (see below), and to clarify that otherwise <a 
href="#x44-74008r49">equalp</a> never recursively
descends any structure or data type other than the ones explicitly described
above: conses, arrays (including bit-vectors and strings), and pathnames.
Numbers are compared for numerical equality (see <i>=</i>), characters are
compared as if by <a 
href="clmse77.html#x95-137032r371">char-equal</a>, and all other data objects are compared as if by
<a 
href="#x44-74002r46">eq</a>.
<!--l. 943--><p class="indent" >   Two hash tables are considered the same by <a 
href="#x44-74008r49">equalp</a> if and only if they satisfy a
four-part test:
      <ul class="itemize1">
      <li class="itemize">They must be of the same kind; that is, equivalent <i>:test</i> arguments were
      given to <a 
href="clmse92.html#x113-155002r543">make-hash-table</a> when the two hash tables were created.
                                                                          

                                                                          
      </li>
      <li class="itemize">They must have the same number of entries (see <a 
href="clmse92.html#x113-155014r549">hash-table-count</a>).
      </li>
      <li class="itemize">For  every  entry  (<i>key1</i>,  <i>value1</i>)  in  one  hash  table  there  must  be  a
      corresponding entry (<i>key2</i>, <i>value2</i>) in the other, such that <i>key1</i> and
      <i>key2</i> are considered to be the same by the <i>:test</i> function associated
      with the hash tables.
      </li>
      <li class="itemize">For every entry (<i>key1</i>, <i>value1</i>) in one hash table and its corresponding
      entry (<i>key2</i>, <i>value2</i>) in the other, such that <i>key1</i> and <i>key2</i> are the
      same, <a 
href="#x44-74008r49">equalp</a> must be true of <i>value1</i> and <i>value2</i>.</li></ul>
<!--l. 962--><p class="noindent" >The four parts of this test are carried out in the order shown, and if some part of
the test fails, <a 
href="#x44-74008r49">equalp</a> returns <a 
href="clmse31.html#x42-70002r19">nil</a> and the other parts of the test are not
attempted.
<!--l. 966--><p class="indent" >   If <a 
href="#x44-74008r49">equalp</a> must compare two structures and the <a 
href="clmse104.html#x128-170002r617">defstruct</a> deﬁnition for
one used the <i>:type</i> option and the other did not, then <a 
href="#x44-74008r49">equalp</a> returns
<a 
href="clmse31.html#x42-70002r19">nil</a>.
<!--l. 970--><p class="indent" >   If <a 
href="#x44-74008r49">equalp</a> must compare two structures and neither <a 
href="clmse104.html#x128-170002r617">defstruct</a> deﬁnition used
the <i>:type</i> option, then <a 
href="#x44-74008r49">equalp</a> returns <a 
href="clmse31.html#x42-70004r20">t</a> if and only if the structures have the same
type (that is, the same <a 
href="clmse104.html#x128-170002r617">defstruct</a> name) and the values of all corresponding slots
(slots having the same name) are <a 
href="#x44-74008r49">equalp</a>.
<!--l. 976--><p class="indent" >   As part of the X3J13 discussion of this issue the following observations were
made. Object equality is not a concept for which there is a uniquely determined
correct algorithm. The appropriateness of an equality predicate can be judged
only in the context of the needs of some particular program. Although
these functions take any type of argument and their names sound very
generic, <a 
href="#x44-74006r48">equal</a> and <a 
href="#x44-74008r49">equalp</a> are not appropriate for every application. Any
decision to use or not use them should be determined by what they are
documented to do rather than by any abstract characterization of their function.
If neither <a 
href="#x44-74006r48">equal</a> nor <a 
href="#x44-74008r49">equalp</a> is found to be appropriate in a particular
situation, programmers are encouraged to create another operator that
is appropriate rather than blame <a 
href="#x44-74006r48">equal</a> or <a 
href="#x44-74008r49">equalp</a> for “doing the wrong
thing.”
</div>
<div class=new>
                                                                          

                                                                          
<!--l. 993--><p class="indent" >   Note that one consequence of the vote to change the rules of ﬂoating-point
contagion ⟨<b>?</b>⟩ (described in section <a 
href="clmse66.html#x83-12200012.1">12.1<!--tex4ht:ref: PRECISION-CONTAGION-COERCION-SECTION --></a>) is to make <a 
href="#x44-74008r49">equalp</a> a true equivalence
relation on numbers.
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;a &#x2019;b) is false.
</td></tr></table>
<!--l. 1003--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;a &#x2019;a) is true.</td></tr></table>
<!--l. 1004--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3 3) is true.</td></tr></table>
<!--l. 1005--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3 3.0) is true.</td></tr></table>
<!--l. 1006--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp 3.0 3.0) is true.</td></tr></table>
<!--l. 1007--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #c(3 -4) #c(3 -4)) is true.</td></tr></table>
<!--l. 1008--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #c(3 -4.0) #c(3 -4)) is true.</td></tr></table>
<!--l. 1009--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;c)) is false.</td></tr></table>
<!--l. 1010--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp (cons &#x2019;a &#x2019;b) (cons &#x2019;a &#x2019;b)) is true.</td></tr></table>
<!--l. 1011--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x2019;(a . b) &#x2019;(a . b)) is true.</td></tr></table>
<!--l. 1012--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x (cons &#x2019;a &#x2019;b)) (equalp x x)) is true.</td></tr></table>
<!--l. 1013--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setq x &#x2019;(a . b)) (equalp x x)) is true.</td></tr></table>
<!--l. 1014--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp #<tt>\</tt>A #<tt>\</tt>A) is true.</td></tr></table>
<!--l. 1015--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;Foo&#x0022; &#x0022;Foo&#x0022;) is true.</td></tr></table>
<!--l. 1016--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;Foo&#x0022; (copy-seq &#x0022;Foo&#x0022;)) is true.</td></tr></table>
<!--l. 1017--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(equalp &#x0022;FOO&#x0022; &#x0022;foo&#x0022;) is true.</td></tr></table>
<!--l. 1019--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
   <!--l. 1022--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse34.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html#tailclmse32.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse33.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse33.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 1022--><p class="indent" >   <a 
 id="tailclmse33.html"></a>  
</body></html> 
