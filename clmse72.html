<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Logical Operations on Numbers</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-26 02:27:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 3271--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse73.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse71.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse71.html#tailclmse71.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse72.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse72.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">12.7   </span> <a 
 id="x89-13100012.7"></a>Logical Operations on Numbers</h3>
<!--l. 3273--><p class="noindent" >The logical operations in this section require integers as arguments; it is an error
to supply a non-integer as an argument. The functions all treat integers as if they
were represented in two&#x2019;s-complement notation.
<div class=implementation>
<!--l. 3279--><p class="noindent" ><b>Implementation note:</b> Internally, of course, an implementation of Common Lisp may
or may not use a two&#x2019;s-complement representation. All that is necessary is that the
logical operations perform calculations so as to give this appearance to the
user.
</div>
<!--l. 3287--><p class="indent" >   The logical operations provide a convenient way to represent an inﬁnite vector
of bits. Let such a conceptual vector be indexed by the non-negative integers.
Then bit j is assigned a “weight” 2<sup>j</sup>. Assume that only a ﬁnite number of
bits are 1&#x2019;s or only a ﬁnite number of bits are 0&#x2019;s. A vector with only a
ﬁnite number of one-bits is represented as the sum of the weights of the
one-bits, a positive integer. A vector with only a ﬁnite number of zero-bits is
represented as -1 minus the sum of the weights of the zero-bits, a negative
integer.
<!--l. 3298--><p class="indent" >   This method of using integers to represent bit-vectors can in turn be used to
represent sets. Suppose that some (possibly countably inﬁnite) universe of
discourse for sets is mapped into the non-negative integers. Then a set can be
represented as a bit vector; an element is in the set if the bit whose index
corresponds to that element is a one-bit. In this way all ﬁnite sets can be
represented (by positive integers), as well as all sets whose complements are ﬁnite
(by negative integers). The functions <a 
href="#x89-131002r276">logior</a>, <a 
href="#x89-131006r278">logand</a>, and <a 
href="#x89-131004r277">logxor</a> deﬁned below then
compute the union, intersection, and symmetric diﬀerence operations on sets
represented in this way.
<div class=defun>
<!--l. 3311--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131001"></a><a 
 id="x89-131002r276"></a><b> logior</b>  &#x0026;rest  <i>integers</i>
<!--l. 3313--><p class="noindent" >This returns the bit-wise logical inclusive or of its arguments. If no argument is
given, then the result is zero, which is an identity for this operation.
                                                                          

                                                                          
</div>
<div class=defun>
<!--l. 3319--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131003"></a><a 
 id="x89-131004r277"></a><b> logxor</b>  &#x0026;rest  <i>integers</i>
<!--l. 3321--><p class="noindent" >This returns the bit-wise logical exclusive or of its arguments. If no argument is
given, then the result is zero, which is an identity for this operation.
</div>
<div class=defun>
<!--l. 3327--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131005"></a><a 
 id="x89-131006r278"></a><b> logand</b>  &#x0026;rest  <i>integers</i>
<!--l. 3329--><p class="noindent" >This returns the bit-wise logical and of its arguments. If no argument is given,
then the result is -1, which is an identity for this operation.
</div>
<div class=defun>
<!--l. 3335--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131007"></a><a 
 id="x89-131008r279"></a><b> logeqv</b>  &#x0026;rest  <i>integers</i>
<!--l. 3337--><p class="noindent" >This returns the bit-wise logical equivalence (also known as exclusive nor) of its
arguments. If no argument is given, then the result is -1, which is an identity for
this operation.
</div>
<div class=defun>
<!--l. 3344--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131009"></a><a 
 id="x89-131010r280"></a><b> lognand</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx89-131011"></a><a 
 id="x89-131012r281"></a><b> lognor</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx89-131013"></a><a 
 id="x89-131014r282"></a><b> logandc1</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx89-131015"></a><a 
 id="x89-131016r283"></a><b> logandc2</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx89-131017"></a><a 
 id="x89-131018r284"></a><b> logorc1</b>  <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Function]</i><a 
 id="dx89-131019"></a><a 
 id="x89-131020r285"></a><b> logorc2</b>  <i>integer1</i> <i>integer2</i>
<!--l. 3351--><p class="noindent" >These are the other six non-trivial bit-wise logical operations on two arguments.
Because they are not associative, they take exactly two arguments rather than
any non-negative number of arguments. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(lognand n1 n2)  ≡ (lognot (logand n1 n2))
</td></tr></table>
<!--l. 3357--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(lognor n1 n2)  ≡ (lognot (logior n1 n2))
</td></tr></table>
<!--l. 3358--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logandc1 n1 n2)  ≡ (logand (lognot n1) n2)
</td></tr></table>
<!--l. 3359--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logandc2 n1 n2)  ≡ (logand n1 (lognot n2))
</td></tr></table>
<!--l. 3360--><p class="indent" >
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logorc1 n1 n2)  ≡ (logior (lognot n1) n2)
</td></tr></table>
<!--l. 3361--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logorc2 n1 n2)  ≡ (logior n1 (lognot n2))
</td></tr></table>
<!--l. 3363--><p class="indent" >
</div>
</div>
</div>
<!--l. 3366--><p class="indent" >   The ten bit-wise logical operations on two integers are summarized in the
following table:
<div class="flushleft" 
>
<!--l. 3368--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >  integer1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td>
</tr><tr><td align="left" >  integer2</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >Operation Name                                 </td>
</tr><tr><td align="left" >logand  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >and                                                  </td>
</tr><tr><td align="left" > logior  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >inclusive or                                        </td>
</tr><tr><td align="left" > logxor  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >exclusive or                                       </td>
</tr><tr><td align="left" >logeqv  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >equivalence (exclusive nor)                   </td>
</tr><tr><td align="left" >lognand </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >not-and                                            </td>
</tr><tr><td align="left" > lognor  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >not-or                                               </td>
</tr><tr><td align="left" >logandc1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >and complement of integer1 with integer2</td>
</tr><tr><td align="left" >logandc2</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >and integer1 with complement of integer2</td>
</tr><tr><td align="left" > logorc1 </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >or complement of integer1 with integer2  </td>
</tr><tr><td align="left" > logorc2 </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >or integer1 with complement of integer2  </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table></div></div>
<div class=defun>
<!--l. 3389--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131021"></a><a 
 id="x89-131022r286"></a><b> boole</b>  <i>op</i> <i>integer1</i> <i>integer2</i><br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131023"></a><a 
 id="x89-131024r287"></a><b> boole-clr</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131025"></a><a 
 id="x89-131026r288"></a><b> boole-set</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131027"></a><a 
 id="x89-131028r289"></a><b> boole-1</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131029"></a><a 
 id="x89-131030r290"></a><b> boole-2</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131031"></a><a 
 id="x89-131032r291"></a><b> boole-c1</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131033"></a><a 
 id="x89-131034r292"></a><b> boole-c2</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131035"></a><a 
 id="x89-131036r293"></a><b> boole-and</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131037"></a><a 
 id="x89-131038r294"></a><b> boole-ior</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131039"></a><a 
 id="x89-131040r295"></a><b> boole-xor</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131041"></a><a 
 id="x89-131042r296"></a><b> boole-eqv</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131043"></a><a 
 id="x89-131044r297"></a><b> boole-nand</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131045"></a><a 
 id="x89-131046r298"></a><b> boole-nor</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131047"></a><a 
 id="x89-131048r299"></a><b> boole-andc1</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131049"></a><a 
 id="x89-131050r300"></a><b> boole-andc2</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131051"></a><a 
 id="x89-131052r301"></a><b> boole-orc1</b> <br 
class="newline" /><i>[Constant]</i><a 
 id="dx89-131053"></a><a 
 id="x89-131054r302"></a><b> boole-orc2</b>
<!--l. 3407--><p class="noindent" >The function <a 
href="#x89-131022r286">boole</a> takes an operation op and two integers, and returns an integer
produced by performing the logical operation speciﬁed by op on the two integers.
The precise values of the sixteen constants are implementation-dependent, but
they are suitable for use as the ﬁrst argument to <a 
href="#x89-131022r286">boole</a>:
<div class="flushleft" 
>
<!--l. 3416--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >      integer1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td>
</tr><tr><td align="left" >      integer2</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >Operation Performed                           </td>
</tr><tr><td align="left" >  boole-clr  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >always 0                                           </td>
</tr><tr><td align="left" > boole-set  </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >always 1                                           </td>
</tr><tr><td align="left" >boole-1    </td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >integer1                                         </td>
</tr><tr><td align="left" >boole-2    </td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >integer2                                         </td>
</tr><tr><td align="left" > boole-c1   </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >complement of integer1                      </td>
</tr><tr><td align="left" > boole-c2   </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >complement of integer2                      </td>
</tr><tr><td align="left" >boole-and  </td><td align="left" >0</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >and                                                  </td></tr><tr><td align="left" > boole-ior   </td> <td align="left" >0</td> <td align="left" >1</td> <td align="left" >1</td> <td align="left" >1</td> <td align="left" >inclusive or</td>
</tr><tr><td align="left" > boole-xor  </td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >exclusive or                                       </td>
</tr><tr><td align="left" >boole-eqv  </td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >equivalence (exclusive nor)                   </td>
</tr><tr><td align="left" >boole-nand </td><td align="left" >1</td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >not-and                                            </td></tr><tr><td align="left" > boole-nor   </td> <td align="left" >1</td> <td align="left" >0</td> <td align="left" >0</td> <td align="left" >0</td> <td align="left" >not-or</td>
</tr><tr><td align="left" >boole-andc1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >0</td><td align="left" >and complement of integer1 with integer2</td>
</tr><tr><td align="left" >boole-andc2</td><td align="left" >0</td><td align="left" >0</td><td align="left" >1</td><td align="left" >0</td><td align="left" >and integer1 with complement of integer2</td>
</tr><tr><td align="left" > boole-orc1 </td><td align="left" >1</td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >or complement of integer1 with integer2  </td>
</tr><tr><td align="left" > boole-orc2 </td><td align="left" >1</td><td align="left" >0</td><td align="left" >1</td><td align="left" >1</td><td align="left" >or integer1 with complement of integer2  </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table></div></div>
<!--l. 3442--><p class="indent" >   <a 
href="#x89-131022r286">boole</a> can therefore compute all sixteen logical functions on two arguments. In
general, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(boole boole-and x y)  ≡ (logand x y)
</td></tr></table>
<!--l. 3446--><p class="indent" >
</div>
</div>
<!--l. 3447--><p class="noindent" >and the latter is more perspicuous. However, <a 
href="#x89-131022r286">boole</a> is useful when it is necessary to
parameterize a procedure so that it can use one of several logical operations.
</div>
<div class=defun>
<!--l. 3452--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131055"></a><a 
 id="x89-131056r303"></a><b> lognot</b>  <i>integer</i>
<!--l. 3454--><p class="noindent" >This returns the bit-wise logical not of its argument. Every bit of the result is the
complement of the corresponding bit in the argument. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp j (lognot x))  ≡ (not (logbitp j x))
</td></tr></table>
<!--l. 3460--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 3463--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131057"></a><a 
 id="x89-131058r304"></a><b> logtest</b>  <i>integer1</i> <i>integer2</i>
<!--l. 3465--><p class="noindent" ><a 
href="#x89-131058r304">logtest</a> is a predicate that is true if any of the bits designated by the 1&#x2019;s in
integer1 are 1&#x2019;s in integer2. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logtest x y)  ≡ (not (zerop (logand x y)))
</td></tr></table>
<!--l. 3470--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 3473--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131059"></a><a 
 id="x89-131060r305"></a><b> logbitp</b>  <i>index</i> <i>integer</i>
<!--l. 3475--><p class="noindent" ><a 
href="#x89-131060r305">logbitp</a> is true if the bit in integer whose index is index (that is, its weight is
2<sup>index</sup>) is a one-bit; otherwise it is false. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp 2 6) is true
</td></tr></table>
<!--l. 3481--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp 0 6) is false</td></tr></table>
<!--l. 3482--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp k n)  ≡ (ldb-test (byte 1 k) n)</td></tr></table>
<!--l. 3484--><p class="indent" >
</div>
</div>
<div class=new>
<!--l. 3486--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx89-131061"></a>to clarify that the index must be a non-negative
integer.
</div>
</div>
                                                                          

                                                                          
<div class=defun>
<!--l. 3492--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131062"></a><a 
 id="x89-131063r306"></a><b> ash</b>  <i>integer</i> <i>count</i>
<!--l. 3494--><p class="noindent" >This function shifts integer arithmetically left by count bit positions if count is
positive, or right by  − count bit positions if count is negative. The sign of the
result is always the same as the sign of integer.
<!--l. 3500--><p class="indent" >   Mathematically speaking, this operation performs the computation
floor(integer ⋅ 2<sup>count</sup>).
<!--l. 3503--><p class="indent" >   Logically, this moves all of the bits in integer to the left, adding zero-bits at
the bottom, or moves them to the right, discarding bits. (In this context the
question of what gets shifted in on the left is irrelevant; integers, viewed as strings
of bits, are “half-inﬁnite,” that is, conceptually extend inﬁnitely far to the left.)
For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logbitp j (ash n k))  ≡ (and (&#x003E;= j k) (logbitp (- j k) n))
</td></tr></table>
<!--l. 3511--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 3514--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131064"></a><a 
 id="x89-131065r307"></a><b> logcount</b>  <i>integer</i>
<!--l. 3516--><p class="noindent" >The number of bits in integer is determined and returned. If integer is positive,
the 1-bits in its binary representation are counted. If integer is negative, the 0-bits
in its two&#x2019;s-complement binary representation are counted. The result is always a
non-negative integer. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount 13)  ⇒ 3      ;Binary representation is ...0001101
</td></tr></table>
<!--l. 3524--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount -13)  ⇒ 2     ;Binary representation is ...1110011</td></tr></table>
<!--l. 3525--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount 30)  ⇒ 4      ;Binary representation is ...0011110</td></tr></table>
<!--l. 3526--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount -30)  ⇒ 4     ;Binary representation is ...1100010</td></tr></table>
<!--l. 3528--><p class="indent" >
</div>
</div>
<!--l. 3529--><p class="noindent" >The following identity always holds: <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(logcount x)  ≡ (logcount (- (+ x 1)))
</td></tr></table>
<!--l. 3531--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              ≡ (logcount (lognot x))</td></tr></table>
<!--l. 3533--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 3536--><p class="noindent" ><i>[Function]</i><a 
 id="dx89-131066"></a><a 
 id="x89-131067r308"></a><b> integer-length</b>  <i>integer</i>
<!--l. 3538--><p class="noindent" >This function performs the computation <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">ceiling(log <sub>2</sub>(if integer &#x003C; 0 then − integer else integer + 1))
</td></tr></table>
<!--l. 3543--><p class="indent" >
</div>
<!--l. 3544--><p class="noindent" >This is useful in two diﬀerent ways. First, if integer is non-negative, then its value can
be represented in unsigned binary form in a ﬁeld whose width in bits is no smaller
than (integer-length integer). Second, regardless of the sign of integer, its value
can be represented in signed binary two&#x2019;s-complement form in a ﬁeld whose width
in bits is no smaller than (+ (integer-length integer) 1). For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 0)  ⇒ 0
</td></tr></table>
<!--l. 3553--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 1)  ⇒ 1</td></tr></table>
<!--l. 3554--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 3)  ⇒ 2</td></tr></table>
<!--l. 3555--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 4)  ⇒ 3</td></tr></table>
<!--l. 3556--><p class="indent" >                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length 7)  ⇒ 3</td></tr></table>
<!--l. 3557--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -1)  ⇒ 0</td></tr></table>
<!--l. 3558--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -4)  ⇒ 2</td></tr></table>
<!--l. 3559--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -7)  ⇒ 3</td></tr></table>
<!--l. 3560--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integer-length -8)  ⇒ 3</td></tr></table>
<!--l. 3562--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<div class=incompatibility>
<!--l. 3565--><p class="noindent" ><b>Compatibility note:</b> This function is similar to the MacLisp function haulong. One
may deﬁne haulong as <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(haulong x)  ≡ (integer-length (abs x))
</td></tr></table>
<!--l. 3570--><p class="indent" >
</div>
</div>
</div>
</div>
                                                                          

                                                                          
   <!--l. 3576--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse73.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse71.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse71.html#tailclmse71.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse72.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch12.html#clmse72.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 3576--><p class="indent" >   <a 
 id="tailclmse72.html"></a>  
</body></html> 
