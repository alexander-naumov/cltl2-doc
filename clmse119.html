<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>File Names</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-22 17:23:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 30--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse120.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch23.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch23.html#tailclmch23.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse119.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch23.html#clmse119.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">23.1   </span> <a 
 id="x147-20300023.1"></a>File Names</h3>
<!--l. 32--><p class="noindent" >Common Lisp programs need to use names to designate ﬁles. The main diﬃculty
                                                                          

                                                                          
in dealing with names of ﬁles is that diﬀerent ﬁle systems have diﬀerent naming
formats for ﬁles. For example, here is a table of several ﬁle systems (actually,
operating systems that provide ﬁle systems) and what equivalent ﬁle names might
look like for each one:
<div class="flushleft" 
>
<!--l. 38--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >System           </td><td align="left" >File Name                           </td>
</tr><tr><td align="left" >TOPS-20        </td><td align="left" ><i>&#x003C;LISPIO&#x003E;FORMAT.FASL.13</i></td></tr><tr><td align="left" >TOPS-10 </td> <td align="left" ><i>FORMAT.FAS<tt>[</tt>1,4<tt>]</tt></i></td>
</tr><tr><td align="left" >ITS                </td><td align="left" ><i>LISPIO;FORMAT FASL</i>       </td>
</tr><tr><td align="left" >MULTICS       </td><td align="left" ><i>&#x003E;udd&#x003E;LispIO&#x003E;format.fasl</i>     </td>
</tr><tr><td align="left" >TENEX          </td><td align="left" ><i>&#x003C;LISPIO&#x003E;FORMAT.FASL;13</i></td>
</tr><tr><td align="left" >VAX/VMS      </td><td align="left" ><i><tt>[</tt>LISPIO<tt>]</tt>FORMAT.FAS;13</i>   </td>
</tr><tr><td align="left" >UNIX             </td><td align="left" ><i>/usr/lispio/format.fasl</i>          </td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
<!--l. 52--><p class="noindent" >It would be impossible for each program that deals with ﬁle names to know about
each diﬀerent ﬁle name format that exists; a new Common Lisp implementation
might use a format diﬀerent from any of its predecessors. Therefore, Common
Lisp provides two ways to represent ﬁle names: namestrings, which are strings in
the implementation-dependent form customary for the ﬁle system, and pathnames,
which are special abstract data objects that represent ﬁle names in an
implementation-independent way. Functions are provided to convert between
these two representations, and all manipulations of ﬁles can be expressed in
machine-independent terms by using pathnames.
<!--l. 63--><p class="indent" >   In order to allow Common Lisp programs to operate in a network environment
that may have more than one kind of ﬁle system, the pathname facility allows
a ﬁle name to specify which ﬁle system is to be used. In this context,
each ﬁle system is called a host, in keeping with the usual networking
terminology.
<div class=newer>
<!--l. 70--><p class="indent" >   Diﬀerent hosts may use diﬀerent notations for ﬁle names. Common Lisp allows
customary notation to be used for each host, but also supports a system of logical
pathnames that provides a standard framework for naming ﬁles in a portable
manner (see section <a 
href="#x147-20800023.1.5">23.1.5<!--tex4ht:ref: LOGICAL-PATHNAMES-SECTION --></a>).
</div>
<!--l. 77--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">23.1.1   </span> <a 
 id="x147-20400023.1.1"></a>Pathnames</h4>
                                                                          

                                                                          
<!--l. 79--><p class="noindent" >All ﬁle systems dealt with by Common Lisp are forced into a common framework,
in which ﬁles are named by a Lisp data object of type <a 
href="#x147-214002r740">pathname</a>.
<!--l. 82--><p class="indent" >   A pathname always has six components, described below. These components
are the common interface that allows programs to work the same way with
diﬀerent ﬁle systems; the mapping of the pathname components into the
concepts peculiar to each ﬁle system is taken care of by the Common Lisp
implementation.
<div class=flushdesc>
<!--l. 90--><p class="indent" >
  <div><br /><b>
host                                                                      </b>
The name of the ﬁle system on which the ﬁle resides.
  <br /><b>
device                                                                    </b>
Corresponds  to  the  “device”  or  “ﬁle  structure”  concept  in  many  host  ﬁle
systems: the name of a (logical or physical) device containing ﬁles.
  <br /><b>
directory                                                                  </b>
Corresponds to the “directory” concept in many host ﬁle systems: the name of
a group of related ﬁles (typically those belonging to a single user or project).
  <br /><b>
name                                                                     </b>
The name of a group of ﬁles that can be thought of as the “same” ﬁle.
  <br /><b>
type                                                                      </b>
Corresponds to the “ﬁletype” or “extension” concept in many host ﬁle systems;
identiﬁes the type of ﬁle. Files with the same names but diﬀerent types are
usually related in some speciﬁc way, for instance, one being a source ﬁle,
another the compiled form of that source, and a third the listing of error
messages from the compiler.
  <br /><b>
version                                                                   </b>
                                                                          

                                                                          
Corresponds  to  the  “version  number”  concept  in  many  host  ﬁle  systems.
Typically this is a number that is incremented every time the ﬁle is modiﬁed.</div>
</div>
<!--l. 121--><p class="indent" >   Note that a pathname is not necessarily the name of a speciﬁc ﬁle. Rather, it
is a speciﬁcation (possibly only a partial speciﬁcation) of how to access a ﬁle. A
pathname need not correspond to any ﬁle that actually exists, and more than one
pathname can refer to the same ﬁle. For example, the pathname with a version of
“newest” may refer to the same ﬁle as a pathname with the same components
except a certain number as the version. Indeed, a pathname with version “newest”
may refer to diﬀerent ﬁles as time passes, because the meaning of such a
pathname depends on the state of the ﬁle system. In ﬁle systems with such
facilities as “links,” multiple ﬁle names, logical devices, and so on, two
pathnames that look quite diﬀerent may turn out to address the same ﬁle. To
access a ﬁle given a pathname, one must do a ﬁle system operation such as
<a 
href="clmse120.html#x148-215002r766">open</a>.
<!--l. 136--><p class="indent" >   Two important operations involving pathnames are parsing and merging.
Parsing is the conversion of a namestring (which might be something supplied
interactively by the user when asked to supply the name of a ﬁle) into a pathname
object. This operation is implementation-dependent, because the format of
namestrings is implementation-dependent. Merging takes a pathname with
missing components and supplies values for those components from a source of
defaults.
<!--l. 145--><p class="indent" >   Not all of the components of a pathname need to be speciﬁed. If a
component of a pathname is missing, its value is <a 
href="clmse31.html#x42-70002r19">nil</a>. Before the ﬁle system
interface can do anything interesting with a ﬁle, such as opening the ﬁle,
all the missing components of a pathname must be ﬁlled in (typically
from a set of defaults). Pathnames with missing components may be used
internally for various purposes; in particular, parsing a namestring that does
not specify certain components will result in a pathname with missing
components.
<div class=newer>
<!--l. 156--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to permit any component of a pathname to
have the value <i>:unspeciﬁc</i>, meaning that the component simply does not exist, for
ﬁle systems in which such a value makes sense. (For example, a UNIX ﬁle system
usually does not support version numbers, so the version component of a
pathname for a UNIX host might be <i>:unspeciﬁc</i>. Similarly, the ﬁle type is
usually regarded in a UNIX ﬁle system as the part of a name after a
                                                                          

                                                                          
period, but some ﬁle names contain no periods and therefore have no ﬁle
types.)
<!--l. 167--><p class="indent" >   When a pathname is converted to a namestring, the values <a 
href="clmse31.html#x42-70002r19">nil</a> and <i>:unspeciﬁc</i>
have the same eﬀect: they are treated as if the component were empty (that is,
they each cause the component not to appear in the namestring). When merging,
however, only a <a 
href="clmse31.html#x42-70002r19">nil</a> value for a component will be replaced with the default for
that component; the value <i>:unspeciﬁc</i> will be left alone as if the ﬁeld were
ﬁlled.
<!--l. 175--><p class="indent" >   The results are undeﬁned if <i>:unspeciﬁc</i> is supplied to a ﬁle system
in a component for which <i>:unspeciﬁc</i> does not make sense for that ﬁle
system.
<!--l. 179--><p class="indent" >   Programming hint: portable programs should be prepared to handle the value
<i>:unspeciﬁc</i> in the device, directory, type, or version ﬁeld in some implementations.
Portable programs should not explicitly place <i>:unspeciﬁc</i> in any ﬁeld because it
might not be permitted in some situations, but portable programs may sometimes
do so implicitly (by copying such a value from another pathname, for
example).
</div>
<div class=obsolete>
<!--l. 189--><p class="indent" >   A component of a pathname can also be the keyword <i>:wild</i>. This is only useful
when the pathname is being used with a directory-manipulating operation, where
it means that the pathname component matches anything. The printed
representation of a pathname typically designates <i>:wild</i> by an asterisk; however,
this is host-dependent.
</div>
<div class=newer>
<!--l. 198--><p class="indent" >   See section <a 
href="#x147-20700023.1.4">23.1.4<!--tex4ht:ref: WILD-PATHNAME-SECTION --></a> for a discussion of new wildcard pathname facilities.
</div>
<!--l. 202--><p class="indent" >   What values are allowed for components of a pathname depends, in general, on
the pathname&#x2019;s host. However, in order for pathnames to be usable in a
system-independent way, certain global conventions are adhered to. These
conventions are stronger for the type and version than for the other components,
since the type and version are explicitly manipulated by many programs,
while the other components are usually treated as something supplied
by the user that just needs to be remembered and copied from place to
place.
<!--l. 211--><p class="indent" >   The type is always a string or <a 
href="clmse31.html#x42-70002r19">nil</a> or <i>:wild</i>. It is expected that most programs
that deal with ﬁles will supply a default type for each ﬁle.
                                                                          

                                                                          
<!--l. 215--><p class="indent" >   The version is either a positive integer or a special symbol. The meanings of
<a 
href="clmse31.html#x42-70002r19">nil</a> and <i>:wild</i> have been explained above. The keyword <i>:newest</i> refers to the largest
version number that already exists in the ﬁle system when reading a ﬁle, or to a
version number greater than any already existing in the ﬁle system when writing a
new ﬁle. Some Common Lisp implementors may choose to deﬁne other special
version symbols. Some semi-standard names, suggested but not required to be
supported by every Common Lisp implementation, are <i>:oldest</i>, to refer to the
smallest version number that exists in the ﬁle system; <i>:previous</i>, to refer to the
version previous to the newest version; and <i>:installed</i>, to refer to a version that
is oﬃcially installed for users (as opposed to a working or development
version). Some Common Lisp implementors may also choose to attach a
meaning to non-positive version numbers (a typical convention is that <i>0</i> is
synonymous with <i>:newest</i> and <i>-1</i> with <i>:previous</i>), but such interpretations are
implementation-dependent.
<!--l. 235--><p class="indent" >   The host may be a string, indicating a ﬁle system, or a list of strings, of which
the ﬁrst names the ﬁle system and the rest may be used for such a purpose as
inter-network routing.
<div class=obsolete>
<!--l. 240--><p class="indent" >   The device, directory, and name can each be a string (with host-dependent
rules on allowed characters and length) or possibly some other Common Lisp data
structure (in which case such a component is said to be structured and has an
implementation-dependent format). Structured components may be used to
handle such ﬁle system features as hierarchical directories. Common Lisp
programs do not need to know about structured components unless they do
host-dependent operations. Specifying a string as a pathname component for a
host that requires a structured component will cause conversion of the string to
the appropriate form.
</div>
<div class=newer>
<!--l. 254--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to deﬁne a speciﬁc format for structured
directories (see section <a 
href="#x147-20600023.1.3">23.1.3<!--tex4ht:ref: STRUCTURED-DIRECTORY-SECTION --></a>).
</div>
<div class=newer>
<!--l. 260--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to approve the following clariﬁcations and
speciﬁcations of precisely what are valid values for the various components of a
pathname.
<!--l. 272--><p class="indent" >   Pathname component value strings never contain the punctuation
characters that are used to separate ﬁelds in a namestring (for example,
                                                                          

                                                                          
slashes and periods as used in UNIX ﬁle systems). Punctuation characters
appear only in namestrings. Characters used as punctuation can appear in
pathname component values with a non-punctuation meaning if the ﬁle system
allows it (for example, UNIX ﬁle systems allow a ﬁle name to begin with a
period).
<!--l. 280--><p class="indent" >   When examining pathname components, conforming programs must be
prepared to encounter any of the following siutations:
      <ul class="itemize1">
      <li class="itemize">Any component can be <a 
href="clmse31.html#x42-70002r19">nil</a>, which means the component has not been
      speciﬁed.
      </li>
      <li class="itemize">Any component can be <i>:unspeciﬁc</i>, which means the component has no
      meaning in this particular pathname.
      </li>
      <li class="itemize">The device, directory, name, and type can be strings.
      </li>
      <li class="itemize">The host can be any object, at the discretion of the implementation.
      </li>
      <li class="itemize">The  directory  can  be  a  list  of  strings  and  symbols  as  described  in
      section <a 
href="#x147-20600023.1.3">23.1.3<!--tex4ht:ref: STRUCTURED-DIRECTORY-SECTION --></a>.
      </li>
      <li class="itemize">The version can be any symbol or any integer. The symbol <i>:newest</i>
      refers to the largest version number that already exists in the ﬁle system
      when reading, overwriting, appending, superseding, or directory-listing
      an existing ﬁle; it refers to the smallest version number greater than
      any existing version number when creating a new ﬁle. Other symbols
      and integers have implementation-deﬁned meaning. It is suggested, but
      not required, that implementations use positive integers starting at 1 as
      version numbers, recognize the symbol <i>:oldest</i> to designate the smallest
      existing version number, and use keyword symbols for other special
      versions.</li></ul>
<!--l. 308--><p class="indent" >   When examining wildcard components of a wildcard pathname, conforming
programs must be prepared to encounter any of the following additional
values in any component or any element of a list that is the directory
component:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">The symbol <i>:wild</i>, which matches anything.
      </li>
      <li class="itemize">A   string   containing   implementation-dependent   special   wildcard
      characters.
      </li>
      <li class="itemize">Any   object,   representing   an   implementation-dependent   wildcard
      pattern.</li></ul>
<!--l. 320--><p class="indent" >   When constructing a pathname from components, conforming programs must
follow these rules:
      <ul class="itemize1">
      <li class="itemize">Any component may be <a 
href="clmse31.html#x42-70002r19">nil</a>. Specifying <a 
href="clmse31.html#x42-70002r19">nil</a> for the host may, in some
      implementations, result in using a default host rather than an actual
      <a 
href="clmse31.html#x42-70002r19">nil</a> value.
      </li>
      <li class="itemize">The host, device, directory, name, and type may be strings. There are
      implementation-dependent limits on the number and type of characters
      in these strings. A plausible assumption is that letters (of a single case)
      and digits are acceptable to most ﬁle systems.
      </li>
      <li class="itemize">The  directory  may  be  a  list  of  strings  and  symbols  as  described
      in section <a 
href="#x147-20600023.1.3">23.1.3<!--tex4ht:ref: STRUCTURED-DIRECTORY-SECTION --></a>. There are implementation-dependent limits on the
      length and contents of the list.
      </li>
      <li class="itemize">The version may be <i>:newest</i>.
      </li>
      <li class="itemize">Any component may be taken from the corresponding component of
      another  pathname.  When  the  two  pathnames  are  for  diﬀerent  ﬁle
      systems (in implementations that support multiple ﬁle systems), an
      appropriate translation occurs. If no meaningful translation is possible,
      an error is signaled. The deﬁnitions of “appropriate” and “meaningful”
      are implementation-dependent.
      </li>
      <li class="itemize">When constructing a wildcard pathname, the name, type, or version
      may be <i>:wild</i>, which matches anything.
                                                                          

                                                                          
      </li>
      <li class="itemize">An implementation might support other values for some components,
      but a portable program should not use those values. A conforming
      program can use implementation-dependent values but this can make it
      non-portable; for example, it might work only with UNIX ﬁle systems.</li></ul>
</div>
                                                                          

                                                                          
<!--l. 358--><p class="indent" >   The best way to compare two pathnames for equality is with <a 
href="clmse33.html#x44-74006r48">equal</a>, not <a 
href="clmse33.html#x44-74004r47">eql</a>.
(On pathnames, <a 
href="clmse33.html#x44-74004r47">eql</a> is simply the same as <a 
href="clmse33.html#x44-74002r46">eq</a>.) Two pathname objects are <a 
href="clmse33.html#x44-74006r48">equal</a> if
and only if all the corresponding components (host, device, and so on) are
equivalent. (Whether or not uppercase and lowercase letters are considered
equivalent in strings appearing in components depends on the ﬁle name
conventions of the ﬁle system.) Pathnames that are <a 
href="clmse33.html#x44-74006r48">equal</a> should be functionally
equivalent.
<div class=obsolete>
<!--l. 370--><p class="indent" >   Some host ﬁle systems have features that do not ﬁt into this pathname model.
For instance, directories might be accessible as ﬁles; there might be complicated
structure in the directories or names; or there might be a way to specify a
directory relative to a “current” directory, such as the <a 
href="clmse68.html#x85-124006r210">&#x003C;</a> syntax in MULTICS or
the special “<i>..</i>” ﬁle name of UNIX. Such features are not allowed for by the
standard Common Lisp ﬁle system interface. An implementation is free to
accommodate such features in its pathname representation and provide a parser
that can process such speciﬁcations in namestrings; such features are then
likely to work within that single implementation. However, note that
once a program depends explicitly on any such features, it will not be
portable.
</div> <div class=newer> X3J13 voted in June 1989 ⟨<b>?</b>⟩ to deﬁne a speciﬁc format for structured
directories (see section <a 
href="#x147-20600023.1.3">23.1.3<!--tex4ht:ref: STRUCTURED-DIRECTORY-SECTION --></a>), so some of the speciﬁc examples in the previous
paragraph no longer apply, but the principle is still correct.
</div>
<div class=newer>
<!--l. 392--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">23.1.2   </span> <a 
 id="x147-20500023.1.2"></a>Case Conventions</h4>
<!--l. 395--><p class="noindent" >Issues of alphabetic case in pathnames are a major source of problems. In some
ﬁle systems, the customary case is lowercase, in some uppercase, in some mixed.
Some ﬁle systems are case-sensitive (that is, they treat FOO and foo as diﬀerent
ﬁle names) and others are not.
<!--l. 400--><p class="indent" >   There are two kinds of pathname case portability problems: moving programs
from one Common Lisp to another, and moving pathname component values from
one ﬁle system to another. The solution to the ﬁrst problem is the requirement
that all Common Lisp implementations that support a particular ﬁle system
must use compatible representations for pathname component values. The
                                                                          

                                                                          
solution to the second problem is the use of a common representation for the
least-common-denominator pathname component values that exist on all
interesting ﬁle systems.
<!--l. 410--><p class="indent" >   Requiring a common representation directly conﬂicts with the desire among
programmers that use only one ﬁle system to work with the local conventions and
to ignore issues of porting to other ﬁle systems. The common representation
cannot be the same as local (varying) conventions.
<!--l. 416--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to add a keyword argument <i>:case</i> to each of the
functions <a 
href="#x147-214014r746">make-pathname</a>, <a 
href="#x147-214030r754">pathname-host</a>, <a 
href="#x147-214032r755">pathname-device</a>, <a 
href="#x147-214034r756">pathname-directory</a>,
<a 
href="#x147-214036r757">pathname-name</a>, and <a 
href="#x147-214038r758">pathname-type</a>. The possible values for the argument are
<i>:common</i> and <i>:local</i>. The default is <i>:local</i>.
<!--l. 424--><p class="indent" >   The value <i>:local</i> means that strings given to <a 
href="#x147-214014r746">make-pathname</a> or returned by
any of the pathname component accessors follow the local ﬁle system&#x2019;s
conventions for alphabetic case. Strings given to <a 
href="#x147-214014r746">make-pathname</a> will
be used exactly as written if the ﬁle system supports both cases. If the
ﬁle system supports only one case, the strings will be translated to that
case.
<!--l. 431--><p class="indent" >   The value <i>:common</i> means that strings given to <a 
href="#x147-214014r746">make-pathname</a> or
returned by any of the pathname component accessors follow this common
convention:
      <ul class="itemize1">
      <li class="itemize">All uppercase means that a ﬁle system&#x2019;s customary case will be used.
      </li>
      <li class="itemize">All lowercase means that the opposite of the customary case will be
      used.
      </li>
      <li class="itemize">Mixed case represents itself.</li></ul>
<!--l. 439--><p class="noindent" >Uppercase is used as the common case for no better reason than consistency with
Lisp symbols. The second and third points allow translation from local
representation to common and back to be information-preserving. (Note
that translation from common to local representation and back may or
may not be information-preserving, depending on the nature of the local
representation.)
<!--l. 446--><p class="indent" >   Namestrings always use <i>:local</i> ﬁle system case conventions.
<!--l. 448--><p class="indent" >   Finally, <a 
href="#x147-214008r743">merge-pathnames</a> and <a 
href="#x147-207006r733">translate-pathname</a> map customary case in the
input pathnames into customary case in the output pathname.
                                                                          

                                                                          
<!--l. 451--><p class="indent" >   Examples of possible use of this convention:
      <ul class="itemize1">
      <li class="itemize">TOPS-20 is case-sensitive and prefers uppercase, translating lowercase
      to uppercase unless escaped with <i><tt>^</tt>V </i>; for a TOPS-20–based ﬁle system,
      a Common Lisp implementation should use identical representations
      for common and local.
      </li>
      <li class="itemize">UNIX  is  case-sensitive  and  prefers  lowercase;  for  a  UNIX-based
      ﬁle   system,   a   Common   Lisp   implementation   should   translate
      between common and local representations by inverting the case of
      non-mixed-case strings.
      </li>
      <li class="itemize">VAX/VMS  is  uppercase-only  (that  is,  the  ﬁle  system  translates
      all  ﬁle  name  arguments  to  uppercase);  for  a  VAX/VMS-based  ﬁle
      system,  a  Common  Lisp  implementation  should  translate  common
      representation to local by converting to uppercase and should translate
      local representation to common with no change.
      </li>
      <li class="itemize">The  Macintosh  operating  system  is  case-insensitive  and  prefers
      lowercase, but remembers the cases of letters actually used to name a
      ﬁle; for a Macintosh-based ﬁle system, a Common Lisp implementation
      should  translate  between  common  and  local  representations  by
      inverting the case of non-mixed-case strings and should ignore case
      when determining whether two pathnames are <a 
href="clmse33.html#x44-74006r48">equal</a>.</li></ul>
<!--l. 478--><p class="indent" >
                                                                          

                                                                          
<!--l. 480--><p class="indent" >   Here are some examples of this behavior. Assume that the host T runs
TOPS-20, U runs UNIX, V runs VAX/VMS, and M runs the Macintosh operating
system. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Returns two values: the PATHNAME-NAME from a namestring
</td></tr></table>
<!--l. 484--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; in :COMMON and :LOCAL representations (in that order).</td></tr></table>
<!--l. 485--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun pathname-example (name)</td></tr></table>
<!--l. 486--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((path (parse-namestring name))))</td></tr></table>
<!--l. 487--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (values (pathname-name path :case :common)</td></tr></table>
<!--l. 488--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            (pathname-name path :case :local))))</td></tr></table>
<!--l. 489--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 490--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:528;" 
class="tabbing">                                              ;Common    </td><td  
class="tabbing">Local</td></tr></table>
<!--l. 492--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;T:&#x003C;ME&#x003E;FOO.LISP&#x0022;)         ⇒ &#x0022;FOO&#x0022; and &#x0022;FOO&#x0022;</td></tr></table>
<!--l. 493--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;T:&#x003C;ME&#x003E;foo.LISP&#x0022;)         ⇒ &#x0022;FOO&#x0022; and &#x0022;FOO&#x0022;</td></tr></table>
<!--l. 494--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;T:&#x003C;ME&#x003E;<tt>̂</tt>Vf<tt>̂</tt>Vo<tt>̂</tt>Vo.LISP&#x0022;)   ⇒ &#x0022;foo&#x0022; and &#x0022;foo&#x0022;</td></tr></table>
<!--l. 495--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;T:&#x003C;ME&#x003E;TeX.LISP&#x0022;)         ⇒ &#x0022;TEX&#x0022; and &#x0022;TEX&#x0022;</td></tr></table>
<!--l. 496--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;T:&#x003C;ME&#x003E;T<tt>̂</tt>VeX.LISP&#x0022;)       ⇒ &#x0022;TeX&#x0022; and &#x0022;TeX&#x0022;</td></tr></table>
<!--l. 497--><p class="indent" >    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;U:/me/FOO.lisp&#x0022;)         ⇒ &#x0022;foo&#x0022; and &#x0022;FOO&#x0022;</td></tr></table>
<!--l. 498--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;U:/me/foo.lisp&#x0022;)         ⇒ &#x0022;FOO&#x0022; and &#x0022;foo&#x0022;</td></tr></table>
<!--l. 499--><p class="indent" >    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;U:/me/TeX.lisp&#x0022;)         ⇒ &#x0022;TeX&#x0022; and &#x0022;TeX&#x0022;</td></tr></table>
<!--l. 500--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;V:[me]FOO.LISP&#x0022;)         ⇒ &#x0022;FOO&#x0022; and &#x0022;FOO&#x0022;</td></tr></table>
<!--l. 501--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;V:[me]foo.LISP&#x0022;)         ⇒ &#x0022;FOO&#x0022; and &#x0022;FOO&#x0022;</td></tr></table>
<!--l. 502--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;V:[me]TeX.LISP&#x0022;)         ⇒ &#x0022;TEX&#x0022; and &#x0022;TEX&#x0022;</td></tr></table>
<!--l. 503--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;M:FOO.LISP&#x0022;)             ⇒ &#x0022;foo&#x0022; and &#x0022;FOO&#x0022;</td></tr></table>
<!--l. 504--><p class="indent" >    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;M:foo.LISP&#x0022;)             ⇒ &#x0022;FOO&#x0022; and &#x0022;foo&#x0022;</td></tr></table>
<!--l. 505--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-example &#x0022;M:TeX.LISP&#x0022;)             ⇒ &#x0022;TeX&#x0022; and &#x0022;TeX&#x0022;</td></tr></table>
<!--l. 507--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 508--><p class="noindent" >The following example illustrates the creation of new pathnames. The name is
converted from common representation to local because namestrings always use
local conventions. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun make-pathname-example (h n)
</td></tr></table>
<!--l. 512--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (namestring (make-pathname :host h :name n :case :common))</td></tr></table>
<!--l. 513--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 514--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;T&#x0022; &#x0022;FOO&#x0022;)  ⇒ &#x0022;T:FOO&#x0022;</td></tr></table>
<!--l. 515--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;T&#x0022; &#x0022;foo&#x0022;)  ⇒ &#x0022;T:<tt>̂</tt>Vf<tt>̂</tt>Vo<tt>̂</tt>Vo&#x0022;</td></tr></table>
<!--l. 516--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;T&#x0022; &#x0022;TeX&#x0022;)  ⇒ &#x0022;T:T<tt>̂</tt>VeX&#x0022;</td></tr></table>
<!--l. 517--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;U&#x0022; &#x0022;FOO&#x0022;)  ⇒ &#x0022;U:foo&#x0022;</td></tr></table>
<!--l. 518--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;U&#x0022; &#x0022;foo&#x0022;)  ⇒ &#x0022;U:FOO&#x0022;</td></tr></table>
<!--l. 519--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;U&#x0022; &#x0022;TeX&#x0022;)  ⇒ &#x0022;U:TeX&#x0022;</td></tr></table>
<!--l. 520--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;V&#x0022; &#x0022;FOO&#x0022;)  ⇒ &#x0022;V:FOO&#x0022;</td></tr></table>
<!--l. 521--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;V&#x0022; &#x0022;foo&#x0022;)  ⇒ &#x0022;V:FOO&#x0022;</td></tr></table>
<!--l. 522--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;V&#x0022; &#x0022;TeX&#x0022;)  ⇒ &#x0022;V:TeX&#x0022;</td></tr></table>
<!--l. 523--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;M&#x0022; &#x0022;FOO&#x0022;)  ⇒ &#x0022;M:foo&#x0022;</td></tr></table>
<!--l. 524--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;M&#x0022; &#x0022;foo&#x0022;)  ⇒ &#x0022;M:FOO&#x0022;</td></tr></table>
<!--l. 525--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname-example &#x0022;M&#x0022; &#x0022;TeX&#x0022;)  ⇒ &#x0022;M:TeX&#x0022;</td></tr></table>
<!--l. 527--><p class="indent" >
</div>
</div>
<!--l. 528--><p class="noindent" >A big advantage of this set of conventions is that one can, for example, call
<a 
href="#x147-214014r746">make-pathname</a> with <i>:type &#x0022;LISP&#x0022;</i> and <i>:case :common</i>, and the result will appear
in a namestring as <i>.LISP</i> or <i>.lisp</i>, whichever is appropriate.
</div>
<div class=newer>
   <h4 class="subsectionHead"><span class="titlemark">23.1.3   </span> <a 
 id="x147-20600023.1.3"></a>Structured Directories</h4>
<!--l. 538--><p class="noindent" >X3J13 voted in June 1989 ⟨<b>?</b>⟩ to deﬁne a speciﬁc pathname component format for
structured directories.
                                                                          

                                                                          
<!--l. 541--><p class="indent" >   The value of a pathname&#x2019;s directory component may be a list. The car of the
list should be a keyword, either <i>:absolute</i> or <i>:relative</i>. Each remaining element of
the list should be a string or a symbol (see below). Each string names a single
level of directory structure and should consist of only the directory name without
any punctuation characters.
<!--l. 547--><p class="indent" >   A list whose car is the symbol <i>:absolute</i> represents a directory path starting
from the root directory. For example, the list <i>(:absolute)</i> represents the root
directory itself; the list <i>(:absolute &#x0022;foo&#x0022; &#x0022;bar&#x0022; &#x0022;baz&#x0022;)</i> represents the directory that
in a UNIX ﬁle system would be called <i>/foo/bar/baz</i>.
<!--l. 552--><p class="indent" >   A list whose car is the symbol <i>:relative</i> represents a directory path
starting from a default directory. The list <i>(:relative)</i> has the same meaning
as <a 
href="clmse31.html#x42-70002r19">nil</a> and hence normally is not used. The list <i>(:relative &#x0022;foo&#x0022; &#x0022;bar&#x0022;)</i>
represents the directory named bar in the directory named foo in the default
directory.
<!--l. 558--><p class="indent" >   In place of a string, at any point in the list, a symbol may occur to indicate
a special ﬁle notation. The following symbols have standard meanings.
<div class=indentdesc>
                <div><br /><b>
<i>:wild</i>           </b>Wildcard match of one level of directory structure
                <br /><b>
<i>:wild-inferiors</i>  </b>Wildcard match of any number of directory levels
                <br /><b>
<i>:up</i>             </b>Go upward in directory structure (semantic)
                <br /><b>
<i>:back</i>           </b>Go upward in directory structure (syntactic)</div>
</div>
<!--l. 567--><p class="noindent" >(See section <a 
href="#x147-20700023.1.4">23.1.4<!--tex4ht:ref: WILD-PATHNAME-SECTION --></a> for a discussion of wildcard pathnames.)
<!--l. 569--><p class="indent" >   Implementations are permitted to add additional objects of any non-string
type if necessary to represent features of their ﬁle systems that cannot be
represented with the standard strings and symbols. Supplying any non-string,
including any of the symbols listed below, to a ﬁle system for which it
does not make sense signals an error of type <a 
href="clmse156.html#x190-346047r1043">ﬁle-error</a>. For example, most
implementations of the UNIX ﬁle system do not support <i>:wild-inferiors</i>.
Any directory list in which <i>:absolute</i> or <i>:wild-inferiors</i> is immediately
                                                                          

                                                                          
followed by <i>:up</i> or <i>:back</i> is illegal and when processed causes an error to be
signaled.
<!--l. 579--><p class="indent" >   The keyword <i>:back</i> has a “syntactic” meaning that depends only on the
pathname and not on the contents of the ﬁle system. The keyword <i>:up</i> has a
“semantic” meaning that depends on the contents of the ﬁle system; to resolve a
pathname containing <i>:up</i> to a pathname whose directory component contains only
<i>:absolute</i> and strings requires a search of the ﬁle system. Note that use of <i>:up</i>
instead of <i>:back</i> can result in designating a diﬀerent actual directory only
in ﬁle systems that support multiple names for directories, perhaps via
symbolic links. For example, suppose that there is a directory link such that <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(:absolute &#x0022;X&#x0022; &#x0022;Y&#x0022;)  is linked to  (:absolute &#x0022;A&#x0022; &#x0022;B&#x0022;)
</td></tr></table>
<!--l. 590--><p class="indent" >
</div>
</div>
<!--l. 591--><p class="noindent" >and there also exist directories <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(:absolute &#x0022;A&#x0022; &#x0022;Q&#x0022;)  and  (:absolute &#x0022;X&#x0022; &#x0022;Q&#x0022;)
</td></tr></table>
<!--l. 594--><p class="indent" >
</div>
</div>
<!--l. 595--><p class="noindent" >Then <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(:absolute &#x0022;X&#x0022; &#x0022;Y&#x0022; :up &#x0022;Q&#x0022;)  designates  (:absolute &#x0022;A&#x0022; &#x0022;Q&#x0022;)
</td></tr></table>
<!--l. 598--><p class="indent" >
</div>
</div>
<!--l. 599--><p class="noindent" >but <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(:absolute &#x0022;X&#x0022; &#x0022;Y&#x0022; :back &#x0022;Q&#x0022;)  designates  (:absolute &#x0022;X&#x0022; &#x0022;Q&#x0022;)
</td></tr></table>
<!--l. 602--><p class="indent" >
</div>
</div>
<!--l. 604--><p class="indent" >   If a string is used as the value of the <i>:directory</i> argument to <a 
href="#x147-214014r746">make-pathname</a>, it
should be the name of a top-level directory and should not contain any
punctuation characters. Specifying a string s is equivalent to specifying the list
<i>(:absolute s)</i>. Specifying the symbol <i>:wild</i> is equivalent to specifying the list
<i>(:absolute :wild-inferiors)</i> (or <i>(:absolute :wild)</i> in a ﬁle system that does not
support <i>:wild-inferiors</i>).
<!--l. 611--><p class="indent" >   The function <a 
href="#x147-214034r756">pathname-directory</a> always returns <a 
href="clmse31.html#x42-70002r19">nil</a>, <i>:unspeciﬁc</i>, or a
list—never a string, never <i>:wild</i>. If a list is returned, it is not guaranteed to be
freshly consed; the consequences of modifying this list are undeﬁned.
<!--l. 616--><p class="indent" >   In non-hierarchical ﬁle systems, the only valid list values for the directory
component of a pathname are <i>(:absolute s)</i> (where s is a string) and <i>(:absolute
:wild)</i>. The keywords <i>:relative</i>, <i>:wild-inferiors</i>, <i>:up</i>, and <i>:back</i> are not used in
non-hierarchical ﬁle systems.
<!--l. 623--><p class="indent" >   Pathname merging treats a relative directory specially. Let pathname and
defaults be the ﬁrst two arguments to <a 
href="#x147-214008r743">merge-pathnames</a>. If <i>(pathname-directory
pathname)</i> is a list whose car is <i>:relative</i>, and <i>(pathname-directory defaults)</i> is a
list, then the merged directory is the value of <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(append (pathname-directory defaults)
</td></tr></table>
<!--l. 629--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (cdr     ;Remove <i>:relative</i> from the front</td></tr></table>
<!--l. 630--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (pathname-directory pathname)))</td></tr></table>
<!--l. 632--><p class="indent" >
</div>
</div>
<!--l. 633--><p class="noindent" >except that if the resulting list contains a string or <i>:wild</i> immediately followed by
<i>:back</i>, both of them are removed. This removal of redundant occurrences of <i>:back</i>
is repeated as many times as possible. If <i>(pathname-directory defaults)</i> is not a list
or <i>(pathname-directory pathname)</i> is not a list whose car is <i>:relative</i>, the merged
directory is the value of <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(or (pathname-directory pathname)
</td></tr></table>
<!--l. 640--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (pathname-directory defaults))</td></tr></table>
<!--l. 642--><p class="indent" >
</div>
</div>
<!--l. 644--><p class="indent" >   A relative directory in the pathname argument to a function such as <a 
href="clmse120.html#x148-215002r766">open</a> is
merged with the value of <i>*default-pathname-defaults*</i> before the ﬁle system is
accessed.
<!--l. 648--><p class="indent" >   Here are some examples of the use of structured directories. Suppose that host
L supports a Symbolics Lisp Machine ﬁle system, host U supports a UNIX ﬁle
system, and host V supports a VAX/VMS ﬁle system. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-directory (parse-namestring &#x0022;V:[FOO.BAR]BAZ.LSP&#x0022;))
</td></tr></table>
<!--l. 653--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (:ABSOLUTE &#x0022;FOO&#x0022; &#x0022;BAR&#x0022;)</td></tr></table>
<!--l. 655--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-directory (parse-namestring &#x0022;U:/foo/bar/baz.lisp&#x0022;))
</td></tr></table>
<!--l. 657--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (:ABSOLUTE &#x0022;foo&#x0022; &#x0022;bar&#x0022;)</td></tr></table>
<!--l. 659--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-directory (parse-namestring &#x0022;U:../baz.lisp&#x0022;))
</td></tr></table>
                                                                          

                                                                          
<!--l. 661--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (:RELATIVE :UP)</td></tr></table>
<!--l. 663--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-directory (parse-namestring &#x0022;U:/foo/bar/../mum/baz&#x0022;))
</td></tr></table>
<!--l. 665--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (:ABSOLUTE &#x0022;foo&#x0022; &#x0022;bar&#x0022; :UP &#x0022;mum&#x0022;)</td></tr></table>
<!--l. 667--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-directory (parse-namestring &#x0022;U:bar/../../ztesch/zip&#x0022;))
</td></tr></table>
<!--l. 669--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (:RELATIVE &#x0022;bar&#x0022; :UP :UP &#x0022;ztesch&#x0022;)</td></tr></table>
<!--l. 671--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-directory (parse-namestring &#x0022;L:&#x003E;foo&#x003E;**&#x003E;bar&#x003E;baz.lisp&#x0022;))
</td></tr></table>
<!--l. 673--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (:ABSOLUTE &#x0022;FOO&#x0022; :WILD-INFERIORS &#x0022;BAR&#x0022;)</td></tr></table>
<!--l. 675--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathname-directory (parse-namestring &#x0022;L:&#x003E;foo&#x003E;*&#x003E;bar&#x003E;baz.lisp&#x0022;))
</td></tr></table>
<!--l. 677--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ (:ABSOLUTE &#x0022;FOO&#x0022; :WILD &#x0022;BAR&#x0022;)</td></tr></table>
<!--l. 679--><p class="indent" >
</div>
</div>
</div>
<div class=newer>
<!--l. 683--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">23.1.4   </span> <a 
 id="x147-20700023.1.4"></a>Extended Wildcards</h4>
<!--l. 687--><p class="noindent" >Some ﬁle systems provide more complex conventions for wildcards than
simple component-wise wildcards representable by <i>:wild</i>. For example,
the namestring <i>&#x0022;F*O&#x0022;</i> might mean a normal three-character name; a
three-character name with the middle character wild; a name with at
least two characters, beginning with F and ending with O; or perhaps
a wild match spanning multiple directories. Similarly, the namestring
<i>&#x0022;&#x003E;foo&#x003E;**&#x003E;bar&#x003E;&#x0022;</i> might imply that the middle directory is named <i>&#x0022;**&#x0022;</i>; the
middle directory is <i>:wild</i>; there are zero or more middle directories that are <i>:wild</i>;
or perhaps that the middle directory name matches any two-letter name.
Some ﬁle systems support even more complex wildcards, such as regular
expressions.
<!--l. 700--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to provide some facilities for dealing with more
general wildcard pathnames in a fairly portable manner.
<div class=defun>
<!--l. 704--><p class="noindent" > <i>[Function]</i>   <b>wild-pathname-p</b> <a 
 id="dx147-207001"></a><a 
 id="x147-207002r731"></a>   <i>pathname</i>  <b>&#x0026;optional</b>  <i>ﬁeld-key</i>
<!--l. 706--><p class="noindent" >Tests a pathname for the presence of wildcard components. If the ﬁrst argument
is not a pathname, string, or ﬁle stream, an error of type <a 
href="clmse156.html#x190-346025r1032">type-error</a> is
signaled.
<!--l. 711--><p class="indent" >   If no ﬁeld-key is provided, or the ﬁeld-key is <a 
href="clmse31.html#x42-70002r19">nil</a>, the result is true if and only if
pathname has any wildcard components.
<!--l. 714--><p class="indent" >   If a non-null ﬁeld-key is provided, it must be one of <i>:host</i>, <i>:device</i>, <i>:directory</i>,
<i>:name</i>, <i>:type</i>, or <i>:version</i>. In this case, the result is true if and only if the indicated
component of pathname is a wildcard.
                                                                          

                                                                          
<!--l. 719--><p class="indent" >   Note that X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that an implementation
need not support wildcards in all ﬁelds; the only requirement is that the name,
type, or version may be <i>:wild</i>. However, portable programs should be prepared to
encounter either <i>:wild</i> or implementation-dependent wildcards in any pathname
component. The function <a 
href="#x147-207002r731">wild-pathname-p</a> provides a portable way for testing the
presence of wildcards.
</div>
<div class=defun>
<!--l. 729--><p class="noindent" > <i>[Function]</i>   <b>pathname-match-p</b> <a 
 id="dx147-207003"></a><a 
 id="x147-207004r732"></a>   <i>pathname</i>  <i>wildname</i>
<!--l. 731--><p class="noindent" >This predicate is true if and only if the pathname matches the wildname. The
matching rules are implementation-deﬁned but should be consistent with the
behavior of the <a 
href="clmse123.html#x151-218002r783">directory</a> function. Missing components of wildname default to
<i>:wild</i>.
<!--l. 737--><p class="indent" >   If either argument is not a pathname, string, or ﬁle stream, an error of type
<a 
href="clmse156.html#x190-346025r1032">type-error</a> is signaled. It is valid for pathname to be a wild pathname; a wildcard
ﬁeld in pathname will match only a wildcard ﬁeld in wildname; that is,
<a 
href="#x147-207004r732">pathname-match-p</a> is not commutative. It is valid for wildname to be a
non-wild pathname; I believe that in this case <a 
href="#x147-207004r732">pathname-match-p</a> will have
the same behavior as <a 
href="clmse33.html#x44-74006r48">equal</a>, though the X3J13 speciﬁcation did not say
so.
</div>
<div class=defun>
<!--l. 746--><p class="noindent" > <i>[Function]</i>   <b>translate-pathname</b> <a 
 id="dx147-207005"></a><a 
 id="x147-207006r733"></a>   <i>source</i>  <i>from-wildname</i>  <i>to-wildname</i>
<b>&#x0026;key</b>
<!--l. 748--><p class="noindent" >Translates the pathname source, which must match from-wildname, into a
corresponding pathname (call it result), which is constructed so as to match
to-wildname, and returns result.
<!--l. 753--><p class="indent" >   The pathname result is a copy of to-wildname with each missing or
wildcard ﬁeld replaced by a portion of source; for this purpose a wildcard
ﬁeld is a pathname component with a value of <i>:wild</i>, a <i>:wild</i> element of a
list-valued directory component, or an implementation-deﬁned portion of a
component, such as the <a 
href="clmse111.html#x136-181010r628">*</a> in the complex wildcard string <i>&#x0022;foo*bar&#x0022;</i> that some
implementations support. An implementation that adds other wildcard
features, such as regular expressions, must deﬁne how <a 
href="#x147-207006r733">translate-pathname</a>
extends to those features. A missing ﬁeld is a pathname component that is
<a 
href="clmse31.html#x42-70002r19">nil</a>.
<!--l. 764--><p class="indent" >   The portion of source that is copied into result is implementation-deﬁned.
Typically it is determined by the user interface conventions of the ﬁle systems
                                                                          

                                                                          
involved. Usually it is the portion of source that matches a wildcard ﬁeld of
from-wildname that is in the same position as the missing or wildcard ﬁeld of
to-wildname. If there is no wildcard ﬁeld in from-wildname at that position, then
usually it is the entire corresponding pathname component of source or, in the
case of a list-valued directory component, the entire corresponding list
element. For example, if the name components of source, from-wildname, and
to-wildname are <i>&#x0022;gazonk&#x0022;</i>, <i>&#x0022;gaz*&#x0022;</i>, and <i>&#x0022;h*&#x0022;</i> respectively, then in most ﬁle
systems the wildcard ﬁelds of the name component of from-wildname and
to-wildname are each <i>&#x0022;*&#x0022;</i>, the matching portion of source is <i>&#x0022;onk&#x0022;</i>, and
the name component of result is <i>&#x0022;honk&#x0022;</i>; however, the exact behavior of
<a 
href="#x147-207006r733">translate-pathname</a> is not dictated by the Common Lisp language and
may vary according to the user interface conventions of the ﬁle systems
involved.
<!--l. 782--><p class="indent" >   During the copying of a portion of source into result, additional
implementation-deﬁned translations of alphabetic case or ﬁle naming conventions
may occur, especially when from-wildname and to-wildname are for diﬀerent
hosts.
<!--l. 787--><p class="indent" >   If any of the ﬁrst three arguments is not a pathname, string, or ﬁle stream, an
error of type <a 
href="clmse156.html#x190-346025r1032">type-error</a> is signaled. It is valid for source to be a wild pathname; in
general this will produce a wild result pathname. It is valid for from-wildname or
to-wildname or both to be non-wild. An error is signaled if the source pathname
does not match the from-wildname, that is, if <i>(pathname-match-p source
from-wildname)</i> would not be true.
<!--l. 795--><p class="indent" >   There are no speciﬁed keyword arguments for <a 
href="#x147-207006r733">translate-pathname</a>, but
implementations are permitted to extend it by adding keyword arguments. There
is one speciﬁed return value from <a 
href="#x147-207006r733">translate-pathname</a>; implementations are
permitted to extend it by returning additional values.
<!--l. 801--><p class="indent" >   Here is an implementation suggestion. One ﬁle system performs this operation
by examining corresponding pieces of the three pathnames in turn, where a piece
is a pathname component or a list element of a structured component such as a
hierarchical directory. Hierarchical directory elements in from-wildname and
to-wildname are matched by whether they are wildcards, not by depth in the
directory hierarchy. If the piece in to-wildname is present and not wild, it is copied
into the result. If the piece in to-wildname is <i>:wild</i> or <a 
href="clmse31.html#x42-70002r19">nil</a>, the corresponding piece
in source is copied into the result. Otherwise, the piece in to-wildname
might be a complex wildcard such as <i>&#x0022;foo*bar&#x0022;</i>; the portion of the piece in
source that matches the wildcard portion of the corresponding piece in
from-wildname (or the entire source piece, if the from-wildname piece
                                                                          

                                                                          
is not wild and therefore equals the source piece) replaces the wildcard
portion of the piece in to-wildname and the value produced is used in the
result.
<!--l. 819--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to require <a 
href="#x147-207006r733">translate-pathname</a> to map
customary case in argument pathnames to the customary case in returned
pathnames (see section <a 
href="#x147-20500023.1.2">23.1.2<!--tex4ht:ref: PATHNAME-COMPONENT-CASE-SECTION --></a>).
<!--l. 824--><p class="indent" >   Here are some examples of the use of the new wildcard pathname facilities.
These examples are not portable. They are written to run with particular
ﬁle systems and particular wildcard conventions and are intended to be
illustrative, not prescriptive. Other implementations may behave diﬀerently. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(wild-pathname-p (make-pathname :name :wild))  ⇒ t
</td></tr></table>
<!--l. 830--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(wild-pathname-p (make-pathname :name :wild) :name)  ⇒ t</td></tr></table>
<!--l. 831--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(wild-pathname-p (make-pathname :name :wild) :type)  ⇒ nil</td></tr></table>
<!--l. 832--><p class="indent" >     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(wild-pathname-p (pathname &#x0022;S:&#x003E;foo&#x003E;**&#x003E;&#x0022;))  ⇒ t         ;Maybe</td></tr></table>
<!--l. 833--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(wild-pathname-p (make-pathname :name &#x0022;F*O&#x0022;))  ⇒ t     ;Probably</td></tr></table>
<!--l. 835--><p class="indent" >
</div>
</div>
<!--l. 836--><p class="noindent" >One cannot rely on <a 
href="clmse121.html#x149-216002r768">rename-ﬁle</a> to handle wild pathnames in a predictable manner.
However, one can use <a 
href="#x147-207006r733">translate-pathname</a> explicitly to control the process. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun rename-ﬁles (from to)
</td></tr></table>
<!--l. 840--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  &#x0022;Rename all ﬁles that match the ﬁrst argument by</td></tr></table>
<!--l. 841--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   translating their names to the form of the second</td></tr></table>
<!--l. 842--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   argument. Both arguments may be wild pathnames.&#x0022;</td></tr></table>
<!--l. 843--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (dolist (ﬁle (directory from))</td></tr></table>
<!--l. 844--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ;; DIRECTORY produces only pathnames that match from-wildname.</td></tr></table>
<!--l. 845--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (rename-ﬁle ﬁle (translate-pathname ﬁle from to))))</td></tr></table>
<!--l. 847--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<!--l. 850--><p class="indent" >   Assuming one particular set of popular wildcard conventions, this function
might exhibit the following behavior. Not all ﬁle systems will run this example
exactly as written. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(rename-ﬁles &#x0022;/usr/me/*.lisp&#x0022; &#x0022;/dev/her/*.l&#x0022;)
</td></tr></table>
<!--l. 854--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:90;" 
class="tabbing">   renames</td><td  
class="tabbing">  /usr/me/init.lisp</td></tr></table>
<!--l. 855--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:90;" 
class="tabbing">               </td><td  
class="tabbing">to  /dev/her/init.l</td></tr></table>
<!--l. 856--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 857--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(rename-ﬁles &#x0022;/usr/me/pcl*/*&#x0022; &#x0022;/sys/pcl/*/&#x0022;)</td></tr></table>
<!--l. 858--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   renames  /usr/me/pcl-5-may/low.lisp</td></tr></table>
<!--l. 859--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:90;" 
class="tabbing">               </td><td  
class="tabbing">to  /sys/pcl/pcl-5-may/low.lisp</td></tr></table>
<!--l. 860--><p class="indent" >     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (in some ﬁle systems the result might be /sys/pcl/5-may/low.lisp)</td></tr></table>
<!--l. 861--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 862--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(rename-ﬁles &#x0022;/usr/me/pcl*/*&#x0022; &#x0022;/sys/library/*/&#x0022;)</td></tr></table>
<!--l. 863--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   renames  /usr/me/pcl-5-may/low.lisp</td></tr></table>
<!--l. 864--><p class="indent" >                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:90;" 
class="tabbing">               </td><td  
class="tabbing">to  /sys/library/pcl-5-may/low.lisp</td></tr></table>
<!--l. 865--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   (in some ﬁle systems the result might be /sys/library/5-may/low.lisp)</td></tr></table>
<!--l. 866--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 867--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(rename-ﬁles &#x0022;/usr/me/foo.bar&#x0022; &#x0022;/usr/me2/&#x0022;)</td></tr></table>
<!--l. 868--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   renames  /usr/me/foo.bar</td></tr></table>
<!--l. 869--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:90;" 
class="tabbing">               </td><td  
class="tabbing">to  /usr/me2/foo.bar</td></tr></table>
<!--l. 870--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 871--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(rename-ﬁles &#x0022;/usr/joe/*-recipes.text&#x0022;</td></tr></table>
<!--l. 872--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              &#x0022;/usr/jim/personal/cookbook/joe&#x2019;s-*-rec.text&#x0022;)</td></tr></table>
<!--l. 873--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   renames  /usr/joe/lamb-recipes.text</td></tr></table>
<!--l. 874--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:90;" 
class="tabbing">               </td><td  
class="tabbing">to  /usr/jim/personal/cookbook/joe&#x2019;s-lamb-rec.text    </td></tr></table>
<!--l. 875--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   renames  /usr/joe/veg-recipes.text</td></tr></table>
<!--l. 876--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:90;" 
class="tabbing">               </td><td  
class="tabbing">to  /usr/jim/personal/cookbook/joe&#x2019;s-veg-rec.text     </td></tr></table>
<!--l. 877--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   renames  /usr/joe/cajun-recipes.text</td></tr></table>
<!--l. 878--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:90;" 
class="tabbing">               </td><td  
class="tabbing">to  /usr/jim/personal/cookbook/joe&#x2019;s-cajun-rec.text   </td></tr></table>
<!--l. 879--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   renames  /usr/joe/szechuan-recipes.text</td></tr></table>
<!--l. 880--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:90;" 
class="tabbing">               </td><td  
class="tabbing">to  /usr/jim/personal/cookbook/joe&#x2019;s-szechuan-rec.text</td></tr></table>
                                                                          

                                                                          
<!--l. 882--><p class="indent" >
</div>
</div>
<!--l. 884--><p class="indent" >   The following examples use UNIX syntax and the wildcard conventions of one
particular version of UNIX. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(namestring
</td></tr></table>
<!--l. 887--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (translate-pathname &#x0022;/usr/dmr/hacks/frob.l&#x0022;</td></tr></table>
<!--l. 888--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      &#x0022;/usr/d*/hacks/*.l&#x0022;</td></tr></table>
<!--l. 889--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      &#x0022;/usr/d*/backup/hacks/backup-*.*&#x0022;))</td></tr></table>
<!--l. 890--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ &#x0022;/usr/dmr/backup/hacks/backup-frob.l&#x0022;</td></tr></table>
<!--l. 892--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(namestring
</td></tr></table>
<!--l. 895--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (translate-pathname &#x0022;/usr/dmr/hacks/frob.l&#x0022;</td></tr></table>
<!--l. 896--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      &#x0022;/usr/d*/hacks/fr*.l&#x0022;</td></tr></table>
<!--l. 897--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      &#x0022;/usr/d*/backup/hacks/backup-*.*&#x0022;))</td></tr></table>
<!--l. 898--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ &#x0022;/usr/dmr/backup/hacks/backup-ob.l&#x0022;</td></tr></table>
<!--l. 900--><p class="indent" >
</div>
</div>
<!--l. 901--><p class="noindent" >The following examples are similar to the preceding examples but use two diﬀerent
hosts; host U supports a UNIX ﬁle system and host V supports a VAX/VMS ﬁle
system. Note the translation of ﬁle type (from l to LSP) and the change of
alphabetic case conventions. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(namestring
</td></tr></table>
<!--l. 906--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (translate-pathname &#x0022;U:/usr/dmr/hacks/frob.l&#x0022;</td></tr></table>
<!--l. 907--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      &#x0022;U:/usr/d*/hacks/*.l&#x0022;</td></tr></table>
<!--l. 908--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      &#x0022;V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*&#x0022;))</td></tr></table>
<!--l. 909--><p class="indent" >    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ &#x0022;V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-FROB.LSP&#x0022;</td></tr></table>
<!--l. 911--><p class="indent" >
</div>
</div>
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(namestring
</td></tr></table>
<!--l. 913--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (translate-pathname &#x0022;U:/usr/dmr/hacks/frob.l&#x0022;</td></tr></table>
<!--l. 914--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      &#x0022;U:/usr/d*/hacks/fr*.l&#x0022;</td></tr></table>
<!--l. 915--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                      &#x0022;V:SYS$DISK:[D*.BACKUP.HACKS]BACKUP-*.*&#x0022;))</td></tr></table>
<!--l. 916--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ &#x0022;V:SYS$DISK:[DMR.BACKUP.HACKS]BACKUP-OB.LSP&#x0022;</td></tr></table>
<!--l. 918--><p class="indent" >
</div>
</div>
<!--l. 919--><p class="noindent" >The next example is a version of the function <a 
href="#x147-211004r736">translate-logical-pathname</a>
(simpliﬁed a bit) for a logical host named FOO. The points of interest
are the use of <a 
href="#x147-207004r732">pathname-match-p</a> as a <i>:test</i> argument for <a 
href="clmse91.html#x111-153006r533">assoc</a> and the
use of <a 
href="#x147-207006r733">translate-pathname</a> as a substrate for <a 
href="#x147-211004r736">translate-logical-pathname</a>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deﬁne-condition logical-translation-error (ﬁle-error))
</td></tr></table>
<!--l. 925--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 926--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defun my-translate-logical-pathname (pathname &#x0026;key rules)</td></tr></table>
<!--l. 927--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (let ((rule (assoc pathname rules :test #&#x2019;pathname-match-p)))</td></tr></table>
<!--l. 928--><p class="indent" >                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (unless rule</td></tr></table>
<!--l. 929--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (error &#x2019;logical-translation-error :pathname pathname))</td></tr></table>
<!--l. 930--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (translate-pathname pathname (ﬁrst rule) (second rule))))</td></tr></table>
<!--l. 931--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
                                                                          

                                                                          
<!--l. 932--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(my-translate-logical-pathname</td></tr></table>
<!--l. 933--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  &#x0022;FOO:CODE;BASIC.LISP&#x0022;</td></tr></table>
<!--l. 934--><p class="indent" >                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  :rules &#x2019;((&#x0022;FOO:DOCUMENTATION;&#x0022; &#x0022;U:/doc/foo/&#x0022;)</td></tr></table>
<!--l. 935--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (&#x0022;FOO:CODE;&#x0022;          &#x0022;U:/lib/foo/&#x0022;)</td></tr></table>
<!--l. 936--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (&#x0022;FOO:PATCHES;*;&#x0022;     &#x0022;U:/lib/foo/patch/*/&#x0022;)))</td></tr></table>
<!--l. 937--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ #P&#x0022;U:/lib/foo/basic.l&#x0022;</td></tr></table>
<!--l. 939--><p class="indent" >
</div>
</div>
<!--l. 941--><p class="indent" >
                                                                          

                                                                          
   <h4 class="subsectionHead"><span class="titlemark">23.1.5   </span> <a 
 id="x147-20800023.1.5"></a>Logical Pathnames</h4>
<!--l. 946--><p class="noindent" >Pathname values are not portable, but sometimes they must be mentioned in a
program (for example, the names of ﬁles containing the program and the data
used by the program).
<!--l. 950--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to provide some facilities for portable
pathname values. The idea is to provide a portable framework for pathname
values; these logical pathnames are then mapped to physical (that is,
actual) pathnames by a set of implementation-dependent or site-dependent
rules. The logical pathname facility therefore separates the concerns of
program writing and user software architecture from the details of how
a software system is embedded in a particular ﬁle system or operating
environment.
<!--l. 959--><p class="indent" >   Pathname values are not portable because not all Common Lisp
implementations use the same operating system and ﬁle name syntax varies
widely among operating systems. In addition, corresponding ﬁles at two
diﬀerent sites may have diﬀerent names even when the operating system is
the same; for example, they may be on diﬀerent directories or diﬀerent
devices. The Common Lisp logical pathname system deﬁnes a particular
pathname structure and namestring syntax that must be supported by all
implementations.
<div class=defun>
<!--l. 968--><p class="noindent" > <i>[Class]</i>   <b>logical-pathname</b> <a 
 id="dx147-208001"></a><a 
 id="x147-208002r734"></a>
<!--l. 970--><p class="noindent" >This is a subclass of <a 
href="#x147-214002r740">pathname</a>.
</div>
<!--l. 974--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x147-20900023.1.5"></a>Syntax of Logical Pathname Namestrings</h5>
<!--l. 976--><p class="noindent" >The syntax of a logical pathname namestring is as follows: <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">logical-namestring ::=  [<i>host <i>:</i></i>]   [<i><i>;</i></i>]   {<i>directory <i>;</i></i>}∗  [<i>name</i>]   [<i><i>.</i> type  [<i><i>.</i> version</i>] </i>]
</td></tr></table>
<!--l. 980--><p class="indent" >
</div>
<!--l. 981--><p class="noindent" >Note that a logical namestring has no device portion.
                                                                          

                                                                          
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">host ::= word
</td></tr></table>
<!--l. 984--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">directory ::= word | wildcard-word | wildcard-inferiors</td></tr></table>
<!--l. 985--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">name ::= word | wildcard-word</td></tr></table>
<!--l. 986--><p class="indent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">type ::= word | wildcard-word</td></tr></table>
<!--l. 987--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">version ::= word | wildcard-word</td></tr></table>
<!--l. 988--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">word ::=  {<i>letter | digit |<a 
href="clmse111.html#x136-181008r627">-</a></i>}+ </td></tr></table>
<!--l. 989--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">wildcard-word ::=  [<i>word</i>]  <a 
href="clmse111.html#x136-181010r628">*</a>  {<i>word <a 
href="clmse111.html#x136-181010r628">*</a></i>}∗  [<i>word</i>] </td></tr></table>
<!--l. 990--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">wildcard-inferiors ::= <a 
href="clmse111.html#x136-181012r629">**</a></td></tr></table>
<!--l. 992--><p class="indent" >
</div>
<!--l. 994--><p class="indent" >   A word consists of one or more uppercase letters, digits, and hyphens.
<!--l. 996--><p class="indent" >   A wildcard word consists of one or more asterisks, uppercase letters, digits, and
hyphens, including at least one asterisk, with no two asterisks adjacent. Each
asterisk matches a sequence of zero or more characters. The wildcard word <a 
href="clmse111.html#x136-181010r628">*</a>
parses as <i>:wild</i>; all others parse as strings.
<!--l. 1003--><p class="indent" >   Lowercase letters may also appear in a word or wildcard word occurring in a
namestring. Such letters are converted to uppercase when the namestring is
converted to a pathname. The consequences of using other characters are
unspeciﬁed.
<!--l. 1008--><p class="indent" >   The host is a word that has been deﬁned as a logical pathname host by using
<a 
href="clmse36.html#x48-80002r66">setf</a> with the function <a 
href="#x147-211006r737">logical-pathname-translations</a>.
<!--l. 1011--><p class="indent" >   There is no device, so the device component of a logical pathname is
always <i>:unspeciﬁc</i>. No other component of a logical pathname can be
<i>:unspeciﬁc</i>.
<!--l. 1014--><p class="indent" >   Each directory is a word, a wildcard word, or <a 
href="clmse111.html#x136-181012r629">**</a> (which is parsed as
<i>:wild-inferiors</i>). If a semicolon precedes the directories, the directory component is
relative; otherwise it is absolute.
<!--l. 1018--><p class="indent" >   The name is a word or a wildcard word.
<!--l. 1020--><p class="indent" >   The type is a word or a wildcard word.
<!--l. 1022--><p class="indent" >   The version is a positive decimal integer or the word NEWEST (which is
parsed as <i>:newest</i>) or <a 
href="clmse111.html#x136-181010r628">*</a> (which is parsed as <i>:wild</i>). The letters in NEWEST can be
in either alphabetic case.
                                                                          

                                                                          
<!--l. 1026--><p class="indent" >   The consequences of using any value not speciﬁed here as a logical pathname
component are unspeciﬁed. The null string <i>&#x0022;&#x0022;</i> is not a valid value for any
component of a logical pathname, since the null string is not a word or a wildcard
word.
<!--l. 1031--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x147-21000023.1.5"></a>Parsing of Logical Pathname Namestrings</h5>
<!--l. 1033--><p class="noindent" >Logical pathname namestrings are recognized by the functions <a 
href="#x147-211002r735">logical-pathname</a>
and <a 
href="#x147-211004r736">translate-logical-pathname</a>. The host portion of the logical pathname
namestring and its following colon must appear in the namestring arguments to
these functions.
<!--l. 1038--><p class="indent" >   The function <a 
href="#x147-214006r742">parse-namestring</a> recognizes a logical pathname namestring when
the host argument is logical or the defaults argument is a logical pathname. In this
case the host portion of the logical pathname namestring and its following colon
are optional. If the host portion of the namestring and the host argument are both
present and do not match, an error is signaled. The host argument is logical if it is
supplied and came from <a 
href="#x147-214030r754">pathname-host</a> of a logical pathname. Whether a host
argument is logical if it is a string <a 
href="clmse33.html#x44-74006r48">equal</a> to a logical pathname host name is
implementation-deﬁned.
<!--l. 1049--><p class="indent" >   The function <a 
href="#x147-214008r743">merge-pathnames</a> recognizes a logical pathname namestring
when the defaults argument is a logical pathname. In this case the host
portion of the logical pathname namestring and its following colon are
optional.
<!--l. 1054--><p class="indent" >   Whether the other functions that coerce strings to pathnames recognize
logical pathname namestrings is implementation-deﬁned. These functions
include <a 
href="#x147-214006r742">parse-namestring</a> in circumstances other than those described above,
<i>merge-pathnames</i> in circumstances other than those described above, the <i>:defaults</i>
argument to <a 
href="#x147-214014r746">make-pathname</a>, and the following functions:
<div class="flushleft" 
>
<!--l. 1059--><p class="noindent" >
                                                                          

                                                                          
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" > <a 
href="clmse127.html#x157-224006r797">compile-ﬁle</a>              </td><td align="left" ><a 
href="clmse121.html#x149-216008r771">ﬁle-write-date</a>        </td><td align="left" ><a 
href="#x147-214036r757">pathname-name</a>     </td>
</tr><tr><td align="left" > <a 
href="#x147-211010r739">compile-ﬁle-pathname</a></td><td align="left" ><a 
href="#x147-214048r763">host-namestring</a>     </td><td align="left" ><a 
href="#x147-214038r758">pathname-type</a>      </td>
</tr><tr><td align="left" > <a 
href="clmse121.html#x149-216004r769">delete-ﬁle</a>                </td><td align="left" ><a 
href="clmse122.html#x150-217002r776">load</a>                    </td><td align="left" ><a 
href="#x147-214040r759">pathname-version</a>  </td>
</tr><tr><td align="left" > <a 
href="clmse123.html#x151-218002r783">directory</a>                 </td><td align="left" ><a 
href="#x147-214042r760">namestring</a>           </td><td align="left" ><a 
href="clmse121.html#x149-216006r770">probe-ﬁle</a>             </td>
</tr><tr><td align="left" > <a 
href="#x147-214046r762">directory-namestring</a>  </td><td align="left" ><a 
href="clmse120.html#x148-215002r766">open</a>                   </td><td align="left" ><a 
href="clmse121.html#x149-216002r768">rename-ﬁle</a>           </td>
</tr><tr><td align="left" > <a 
href="clmse129.html#x159-230024r818">dribble</a>                    </td><td align="left" ><a 
href="#x147-214002r740">pathname</a>             </td><td align="left" ><a 
href="#x147-207006r733">translate-pathname</a></td>
</tr><tr><td align="left" > <a 
href="clmse129.html#x159-230022r817">ed</a>                          </td><td align="left" ><a 
href="#x147-214032r755">pathname-device</a>    </td><td align="left" ><a 
href="#x147-214004r741">truename</a>             </td>
</tr><tr><td align="left" > <a 
href="#x147-214050r764">enough-namestring</a>    </td><td align="left" ><a 
href="#x147-214034r756">pathname-directory</a></td><td align="left" ><a 
href="#x147-207002r731">wild-pathname-p</a>   </td>
</tr><tr><td align="left" > <a 
href="clmse121.html#x149-216010r772">ﬁle-author</a>               </td><td align="left" ><a 
href="#x147-214030r754">pathname-host</a>      </td><td align="left" ><a 
href="clmse120.html#x148-215004r767">with-open-ﬁle</a>        </td>
</tr><tr><td align="left" > <a 
href="#x147-214044r761">ﬁle-namestring</a>         </td><td align="left" ><a 
href="#x147-207004r732">pathname-match-p</a> </td><td align="left" >                          </td></tr></table></div></div>
<!--l. 1073--><p class="noindent" >Note that many of these functions must accept logical pathnames even though they
do not accept logical pathname namestrings.
<!--l. 1077--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x147-21100023.1.5"></a>Using Logical Pathnames</h5>
<!--l. 1079--><p class="noindent" >Some real ﬁle systems do not have versions. Logical pathname translation to such
a ﬁle system ignores the version. This implies that a portable program cannot rely
on being able to store in a ﬁle system more than one version of a ﬁle named by a
logical pathname.
<!--l. 1085--><p class="indent" >   The type of a logical pathname for a Common Lisp source ﬁle is LISP. This
should be translated into whatever implementation-deﬁned type is appropriate in
a physical pathname.
<!--l. 1089--><p class="indent" >   The logical pathname host name SYS is reserved for the implementation.
The existence and meaning of logical pathnames for logical host SYS is
implementation-deﬁned.
<!--l. 1093--><p class="indent" >   File manipulation functions must operate with logical pathnames according to
the following requirements:
      <ul class="itemize1">
      <li class="itemize">The following accept logical pathnames and translate them into physical
      pathnames as if by calling the function <a 
href="#x147-211004r736">translate-logical-pathname</a>:
      <div class="flushleft" 
>
<!--l. 1099--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" ><a 
href="clmse127.html#x157-224006r797">compile-ﬁle</a>               </td><td align="left" ><a 
href="clmse129.html#x159-230022r817">ed</a>               </td><td align="left" ><a 
href="clmse121.html#x149-216006r770">probe-ﬁle</a>      </td>
</tr><tr><td align="left" ><a 
href="#x147-211010r739">compile-ﬁle-pathname</a> </td><td align="left" ><a 
href="clmse121.html#x149-216010r772">ﬁle-author</a>     </td><td align="left" ><a 
href="clmse121.html#x149-216002r768">rename-ﬁle</a>    </td>
</tr><tr><td align="left" ><a 
href="clmse121.html#x149-216004r769">delete-ﬁle</a>                 </td><td align="left" ><a 
href="clmse121.html#x149-216008r771">ﬁle-write-date</a></td><td align="left" ><a 
href="#x147-214004r741">truename</a>      </td></tr><tr><td align="left" ><a 
href="clmse123.html#x151-218002r783">directory</a>  </td> <td align="left" ><a 
href="clmse122.html#x150-217002r776">load</a> </td> <td align="left" ><a 
href="clmse120.html#x148-215004r767">with-open-ﬁle</a></td>
</tr><tr><td align="left" ><a 
href="clmse129.html#x159-230024r818">dribble</a>                     </td><td align="left" ><a 
href="clmse120.html#x148-215002r766">open</a>            </td><td align="left" >                  </td></tr></table>
</div></div>
                                                                          

                                                                          
      </li>
      <li class="itemize">Applying the function <a 
href="#x147-214002r740">pathname</a> to a stream created by the function <a 
href="clmse120.html#x148-215002r766">open</a>
      or the macro <a 
href="clmse120.html#x148-215004r767">with-open-ﬁle</a> using a logical pathname produces a logical
      pathname.
      </li>
      <li class="itemize">The functions <a 
href="#x147-214004r741">truename</a>, <a 
href="clmse121.html#x149-216006r770">probe-ﬁle</a>, and <a 
href="clmse123.html#x151-218002r783">directory</a> never return logical
      pathnames.
      </li>
      <li class="itemize">Calling <a 
href="clmse121.html#x149-216002r768">rename-ﬁle</a> with a logical pathname as the second argument returns
      a logical pathname as the ﬁrst value.
      </li>
      <li class="itemize"><a 
href="#x147-214014r746">make-pathname</a> returns a logical pathname if and only if the host is logical.
      If the <i>:host</i> argument to <a 
href="#x147-214014r746">make-pathname</a> is supplied, the host is logical if it
      came from the <a 
href="#x147-214030r754">pathname-host</a> of a logical pathname. Whether a <i>:host</i>
      argument is logical if it is a string equal to a logical pathname host name is
      implementation-deﬁned.</li></ul>
<div class=defun>
<!--l. 1125--><p class="noindent" > <i>[Function]</i>   <b>logical-pathname</b> <a 
 id="dx147-211001"></a><a 
 id="x147-211002r735"></a>   <i>pathname</i>
<!--l. 1127--><p class="noindent" >Converts the argument to a logical pathname and returns it. The argument can be
a logical pathname, a logical pathname namestring containing a host
component, or a stream for which the <a 
href="#x147-214002r740">pathname</a> function returns a logical
pathname. For any other argument, <a 
href="#x147-211002r735">logical-pathname</a> signals an error of type
<a 
href="clmse156.html#x190-346025r1032">type-error</a>.
</div>
<div class=defun>
<!--l. 1135--><p class="noindent" > <i>[Function]</i>   <b>translate-logical-pathname</b> <a 
 id="dx147-211003"></a><a 
 id="x147-211004r736"></a>   <i>pathname</i>  <b>&#x0026;key</b>
<!--l. 1137--><p class="noindent" >Translates a logical pathname to the corresponding physical pathname. The
pathname argument is ﬁrst coerced to a pathname. If it is not a pathname, string,
or ﬁle stream, an error of type <a 
href="clmse156.html#x190-346025r1032">type-error</a> is signaled.
<!--l. 1143--><p class="indent" >   If the coerced argument is a physical pathname, it is returned.
<!--l. 1145--><p class="indent" >   If the coerced argument is a logical pathname, the ﬁrst matching translation
(according to <a 
href="#x147-207004r732">pathname-match-p</a>) of the logical pathname host is applied, as if
by calling <a 
href="#x147-207006r733">translate-pathname</a>. If the result is a logical pathname, this
process is repeated. When the result is ﬁnally a physical pathname, it is
returned.
                                                                          

                                                                          
<!--l. 1151--><p class="indent" >   If no translation matches a logical pathname, an error of type <a 
href="clmse156.html#x190-346047r1043">ﬁle-error</a> is
signaled.
<!--l. 1154--><p class="indent" >   <a 
href="#x147-211004r736">translate-logical-pathname</a> may perform additional translations, typically to
provide translation of ﬁle types to local naming conventions, to accommodate
physical ﬁle systems with names of limited length, or to deal with special
character requirements such as translating hyphens to underscores or uppercase
letters to lowercase. Any such additional translations are implementation-deﬁned.
Some implementations do no additional translations.
<!--l. 1162--><p class="indent" >   There are no speciﬁed keyword arguments for <a 
href="#x147-211004r736">translate-logical-pathname</a> but
implementations are permitted to extend it by adding keyword arguments. There
is one speciﬁed return value from <a 
href="#x147-211004r736">translate-logical-pathname</a>; implementations are
permitted to extend it by returning additional values.
</div>
<div class=defun>
<!--l. 1169--><p class="noindent" > <i>[Function]</i>   <b>logical-pathname-translations</b> <a 
 id="dx147-211005"></a><a 
 id="x147-211006r737"></a>   <i>host</i>
<!--l. 1171--><p class="noindent" >If the speciﬁed host is not the host component of a logical pathname and is not a
string that has been deﬁned as a logical pathname host name by <a 
href="clmse36.html#x48-80002r66">setf</a> of
<a 
href="#x147-211006r737">logical-pathname-translations</a>, this function signals an error of type <a 
href="clmse156.html#x190-346025r1032">type-error</a>;
otherwise, it returns the list of translations for the speciﬁed host. Each translation
is a list of at least two elements, from-wildname and to-wildname. Any additional
elements are implementation-deﬁned. A from-wildname is a logical pathname
whose host is the speciﬁed host. A to-wildname is any pathname. Translations are
searched in the order listed, so more speciﬁc from-wildnames must precede more
general ones.
<i>
<!--l. 1182--><p class="indent" >   (setf (logical-pathname-translations host) translations)</i> sets the list of
translations for the logical pathname host to translations. If host is a string that
has not previously been used as logical pathname host, a new logical pathname
host is deﬁned; otherwise an existing host&#x2019;s translations are replaced. Logical
pathname host names are compared with <a 
href="clmse101.html#x124-166004r594">string-equal</a>.
<!--l. 1189--><p class="indent" >   When setting the translations list, each from-wildname can be a logical
pathname whose host is host or a logical pathname namestring s parseable by
<i>(parse-namestring s host-object)</i>, where host-object is an appropriate object for
representing the speciﬁed host to <a 
href="#x147-214006r742">parse-namestring</a>. (This circuitous speciﬁcation
dodges the fact that <a 
href="#x147-214006r742">parse-namestring</a> does not necessarily accept as its second
argument any old string that names a logical host.) Each to-wildname can be
anything coercible to a pathname by application of the function <a 
href="#x147-214002r740">pathname</a>. If
to-wildname coerces to a logical pathname, <a 
href="#x147-211004r736">translate-logical-pathname</a> will
                                                                          

                                                                          
retranslate the result, repeatedly if necessary.
<!--l. 1202--><p class="indent" >   Implementations may deﬁne additional functions that operate on logical
pathname hosts (for example, to specify additional translation rules or
options).
</div>
<div class=defun>
<!--l. 1207--><p class="noindent" > <i>[Function]</i>   <b>load-logical-pathname-translations</b> <a 
 id="dx147-211007"></a><a 
 id="x147-211008r738"></a>   <i>host</i>
<!--l. 1209--><p class="noindent" >If a logical pathname host named host (a string) is already deﬁned, this
function returns <a 
href="clmse31.html#x42-70002r19">nil</a>. Otherwise, it searches for a logical pathname host
deﬁnition in an implementation-deﬁned manner. If none is found, it signals
an error. If a deﬁnition is found, it installs the deﬁnition and returns
<a 
href="clmse31.html#x42-70004r20">t</a>.
<!--l. 1215--><p class="indent" >   The search used by <a 
href="#x147-211008r738">load-logical-pathname-translations</a> should be documented,
as logical pathname deﬁnitions will be created by users as well as by Lisp
implementors. A typical search technique is to look in an implementation-deﬁned
directory for a ﬁle whose name is derived from the host name in an
implementation-deﬁned fashion.
</div>
<div class=defun>
<!--l. 1222--><p class="noindent" > <i>[Function]</i>   <b>compile-ﬁle-pathname</b> <a 
 id="dx147-211009"></a><a 
 id="x147-211010r739"></a>   <i>pathname</i>  <b>&#x0026;key</b>  :output-ﬁle
<!--l. 1224--><p class="noindent" >Returns the pathname that <a 
href="clmse127.html#x157-224006r797">compile-ﬁle</a> would write into, if given the same
arguments. If the pathname argument is a logical pathname and the <i>:output-ﬁle</i>
argument is unspeciﬁed, the result is a logical pathname. If an implementation
supports additional keyword arguments to <a 
href="clmse127.html#x157-224006r797">compile-ﬁle</a>, <a 
href="#x147-211010r739">compile-ﬁle-pathname</a>
must accept the same arguments.
</div>
<!--l. 1232--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x147-21200023.1.5"></a>Examples of the Use of Logical Pathnames</h5>
<!--l. 1234--><p class="noindent" >Here is a very simple example of setting up a logical pathname host named FOO.
Suppose that no translations are necessary to get around ﬁle system restrictions,
so all that is necessary is to specify the root of the physical directory tree that
contains the logical ﬁle system. The namestring syntax in the to-wildname is
implementation-speciﬁc. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (logical-pathname-translations &#x0022;foo&#x0022;)
</td></tr></table>
<!--l. 1241--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      &#x2019;((&#x0022;**;*.*.*&#x0022;          &#x0022;MY-LISPM:&#x003E;library&#x003E;foo&#x003E;**&#x003E;&#x0022;)))</td></tr></table>
<!--l. 1243--><p class="indent" >
</div>
</div>
<!--l. 1244--><p class="noindent" >The following is a sample use of that logical pathname. All return values are of course
implementation-speciﬁc; all of the examples in this section are of course meant to
be illustrative and not prescriptive. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(translate-logical-pathname &#x0022;foo:bar;baz;mum.quux.3&#x0022;)
</td></tr></table>
<!--l. 1248--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ #P&#x0022;MY-LISPM:&#x003E;library&#x003E;foo&#x003E;bar&#x003E;baz&#x003E;mum.quux.3&#x0022;</td></tr></table>
<!--l. 1250--><p class="indent" >
</div>
</div>
<!--l. 1252--><p class="indent" >   Next we have a more complex example, dividing the ﬁles among two ﬁle
servers (U, supporting a UNIX ﬁle system, and V, supporting a VAX/VMS ﬁle
system) and several diﬀerent directories. This UNIX ﬁle system doesn&#x2019;t support
<i>:wild-inferiors</i> in the directory, so each directory level must be translated
individually. No ﬁle name or type translations are required except for
<i>.MAIL</i> to <i>.MBX</i>. The namestring syntax used for the to-wildnames is
implementation-speciﬁc. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (logical-pathname-translations &#x0022;prog&#x0022;)
</td></tr></table>
<!--l. 1260--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      &#x2019;((&#x0022;RELEASED;*.*.*&#x0022;    &#x0022;U:/sys/bin/my-prog/&#x0022;)</td></tr></table>
<!--l. 1261--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (&#x0022;RELEASED;*;*.*.*&#x0022;  &#x0022;U:/sys/bin/my-prog/*/&#x0022;)</td></tr></table>
<!--l. 1262--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (&#x0022;EXPERIMENTAL;*.*.*&#x0022;</td></tr></table>
<!--l. 1263--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                             &#x0022;U:/usr/Joe/development/prog/&#x0022;)</td></tr></table>
<!--l. 1264--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (&#x0022;EXPERIMENTAL;DOCUMENTATION;*.*.*&#x0022;</td></tr></table>
<!--l. 1265--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                             &#x0022;V:SYS$DISK:[JOE.DOC]&#x0022;)</td></tr></table>
<!--l. 1266--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (&#x0022;EXPERIMENTAL;*;*.*.*&#x0022;</td></tr></table>
<!--l. 1267--><p class="indent" >    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                             &#x0022;U:/usr/Joe/development/prog/*/&#x0022;)</td></tr></table>
<!--l. 1268--><p class="indent" >   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (&#x0022;MAIL;**;*.MAIL&#x0022;    &#x0022;V:SYS$DISK:[JOE.MAIL.PROG...]*.MBX&#x0022;)</td></tr></table>
<!--l. 1269--><p class="indent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        ))</td></tr></table>
<!--l. 1271--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1272--><p class="noindent" >Here are sample uses of logical host PROG. All return values are of course
implementation-speciﬁc. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(translate-logical-pathname &#x0022;prog:mail;save;ideas.mail.3&#x0022;)
</td></tr></table>
<!--l. 1275--><p class="indent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ #P&#x0022;V:SYS$DISK:[JOE.MAIL.PROG.SAVE]IDEAS.MBX.3&#x0022;</td></tr></table>
<!--l. 1276--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1277--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(translate-logical-pathname &#x0022;prog:experimental;spreadsheet.c&#x0022;)</td></tr></table>
<!--l. 1278--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ #P&#x0022;U:/usr/Joe/development/prog/spreadsheet.c&#x0022;</td></tr></table>
<!--l. 1280--><p class="indent" >
</div>
</div>
<!--l. 1282--><p class="indent" >   Suppose now that we have a program that uses three ﬁles logically
named <i>MAIN.LISP</i>, <i>AUXILIARY.LISP</i>, and <i>DOCUMENTATION.LISP</i>.
The following translations might be provided by a software supplier as
examples.
<!--l. 1286--><p class="indent" >   For a UNIX ﬁle system with long ﬁle names: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (logical-pathname-translations &#x0022;prog&#x0022;)
</td></tr></table>
<!--l. 1288--><p class="indent" >                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      &#x2019;((&#x0022;CODE;*.*.*&#x0022;        &#x0022;/lib/prog/&#x0022;)))</td></tr></table>
<!--l. 1289--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1290--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(translate-logical-pathname &#x0022;prog:code;documentation.lisp&#x0022;)</td></tr></table>
<!--l. 1291--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ #P&#x0022;/lib/prog/documentation.lisp&#x0022;</td></tr></table>
<!--l. 1293--><p class="indent" >
</div>
</div>
<!--l. 1294--><p class="noindent" >For a UNIX ﬁle system with 14-character ﬁle names, using <i>.lisp</i> as the type: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (logical-pathname-translations &#x0022;prog&#x0022;)
</td></tr></table>
<!--l. 1296--><p class="indent" >         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      &#x2019;((&#x0022;CODE;DOCUMENTATION.*.*&#x0022; &#x0022;/lib/prog/docum.*&#x0022;)</td></tr></table>
                                                                          

                                                                          
<!--l. 1297--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (&#x0022;CODE;*.*.*&#x0022;             &#x0022;/lib/prog/&#x0022;)))</td></tr></table>
<!--l. 1298--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1299--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(translate-logical-pathname &#x0022;prog:code;documentation.lisp&#x0022;)</td></tr></table>
<!--l. 1300--><p class="indent" >                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ #P&#x0022;/lib/prog/docum.lisp&#x0022;</td></tr></table>
<!--l. 1302--><p class="indent" >
</div>
</div>
<!--l. 1303--><p class="noindent" >For a UNIX ﬁle system with 14-character ﬁle names, using <i>.l</i> as the type (the second
translation shortens the compiled ﬁle type to <i>.b</i>): <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (logical-pathname-translations &#x0022;prog&#x0022;)
</td></tr></table>
<!--l. 1306--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      <tt>‘</tt>((&#x0022;**;*.LISP.*&#x0022;      ,(logical-pathname &#x0022;PROG:**;*.L.*&#x0022;))</td></tr></table>
<!--l. 1307--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (,(compile-ﬁle-pathname</td></tr></table>
<!--l. 1308--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">            (logical-pathname &#x0022;PROG:**;*.LISP.*&#x0022;))</td></tr></table>
<!--l. 1309--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                            ,(logical-pathname &#x0022;PROG:**;*.B.*&#x0022;))</td></tr></table>
<!--l. 1310--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (&#x0022;CODE;DOCUMENTATION.*.*&#x0022; &#x0022;/lib/prog/documentatio.*&#x0022;)</td></tr></table>
<!--l. 1311--><p class="indent" >                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (&#x0022;CODE;*.*.*&#x0022;             &#x0022;/lib/prog/&#x0022;)))</td></tr></table>
<!--l. 1312--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1313--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(translate-logical-pathname &#x0022;prog:code;documentation.lisp&#x0022;)</td></tr></table>
<!--l. 1314--><p class="indent" >                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ #P&#x0022;/lib/prog/documentatio.l&#x0022;</td></tr></table>
<!--l. 1316--><p class="indent" >
</div>
</div>
<!--l. 1318--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
 id="x147-21300023.1.5"></a>Discussion of Logical Pathnames</h5>
<!--l. 1320--><p class="noindent" >Large programs can be moved between sites without changing any pathnames,
provided all pathnames used are logical. A portable system construction tool can
be created that operates on programs deﬁned as sets of ﬁles named by logical
pathnames.
                                                                          

                                                                          
<!--l. 1325--><p class="indent" >   Logical pathname syntax was chosen to be easily translated into the formats of
most popular ﬁle systems, while still being powerful enough for storing large
programs. Although they have hierarchical directories, extended wildcard
matching, versions, and no limit on the length of names, logical pathnames can be
mapped onto a less capable real ﬁle system by translating each directory that is
used into a ﬂat directory name, processing wildcards in the Lisp implementation
rather than in the ﬁle system, treating all versions as <i>:newest</i>, and using
translations to shorten long names.
<!--l. 1334--><p class="indent" >   Logical pathname words are restricted to non-case-sensitive letters, digits, and
hyphens to avoid creating problems with real ﬁle systems that support limited
character sets for ﬁle naming. (If logical pathnames were case-sensitive, it would
be very diﬃcult to map them into a ﬁle system that is not sensitive to case in its
ﬁle names.)
<!--l. 1341--><p class="indent" >   It is not a goal of logical pathnames to be able to represent all possible ﬁle
names. Their goal is rather to represent just enough ﬁle names to be useful for
storing software. Real pathnames, in contrast, need to provide a uniform interface
to all possible ﬁle names, including names and naming conventions that are not
under the control of Common Lisp.
<!--l. 1348--><p class="indent" >   The choice of logical pathname syntax, using colon, semicolon, and period, was
guided by the goals of being visually distinct from real ﬁle systems and
minimizing the use of special characters.
<!--l. 1352--><p class="indent" >   The <a 
href="#x147-211002r735">logical-pathname</a> function is separate from the <a 
href="#x147-214002r740">pathname</a> function so that
the syntax of logical pathname namestrings does not constrain the syntax of
physical pathname namestrings in any way. Logical pathname syntax must be
deﬁned by Common Lisp so that logical pathnames can be conveniently
exchanged between implementations, but physical pathname syntax is dictated by
the operating environments.
<!--l. 1361--><p class="indent" >   The <a 
href="#x147-211010r739">compile-ﬁle-pathname</a> function and the speciﬁcation of LISP as the type
of a logical pathname for a Common Lisp source ﬁle together provide enough
information about compilation to make possible a portable system construction
tool. Suppose that it is desirable to call <a 
href="clmse127.html#x157-224006r797">compile-ﬁle</a> only if the source ﬁle is newer
than the compiled ﬁle. For this to succeed, it must be possible to know
the name of the compiled ﬁle without actually calling <a 
href="clmse127.html#x157-224006r797">compile-ﬁle</a>. In
some implementations the compiler produces one of several ﬁle types,
depending on a variety of implementation-dependent circumstances, so it is not
suﬃcient simply to prescribe a standard logical ﬁle type for compiled ﬁles;
<a 
href="#x147-211010r739">compile-ﬁle-pathname</a> provides access to the defaulting that is performed by
<a 
href="clmse127.html#x157-224006r797">compile-ﬁle</a> “in a manner appropriate to the implementation&#x2019;s ﬁle system
                                                                          

                                                                          
conventions.”
<!--l. 1378--><p class="indent" >   The use of the logical pathname host name SYS for the implementation is
current practice. Standardizing on this name helps users choose logical
pathname host names that avoid conﬂicting with implementation-deﬁned
names.
<!--l. 1385--><p class="indent" >   Loading of logical pathname translations from a site-dependent ﬁle allows
software to be distributed using logical pathnames. The assumed model of
software distribution is a division of labor between the supplier of the software
and the user installing it. The supplier chooses logical pathnames to name all the
ﬁles used or created by the software, and supplies examples of logical pathname
translations for a few popular ﬁle systems. Each example uses an assumed
directory and/or device name, assumes local ﬁle naming conventions, and provides
translations that will translate all the logical pathnames used or generated by the
particular software into valid physical pathnames. For a powerful ﬁle system these
translations can be quite simple. For a more restricted ﬁle system, it may be
necessary to list an explicit translation for every logical pathname used (for
example, when dealing with restrictions on the maximum length of a ﬁle
name).
<!--l. 1402--><p class="indent" >   The user installing the software decides on which device and directory to store
the ﬁles and edits the example logical pathname translations accordingly. If
necessary, the user also adjusts the translations for local ﬁle naming conventions
and any other special aspects of the user&#x2019;s local ﬁle system policy and local
Common Lisp implementation. For example, the ﬁles might be divided among
several ﬁle server hosts to share the load. The process of deﬁning site-customized
logical pathname translations is quite easy for a user of a popular ﬁle system for
which the software supplier has provided an example. A user of a more
unusual ﬁle system might have to take more time; the supplier can help by
providing a list of all the logical pathnames used or generated by the
software.
<!--l. 1415--><p class="indent" >   Once the user has created and executed a suitable <a 
href="clmse36.html#x48-80002r66">setf</a> form for setting the
<a 
href="#x147-211006r737">logical-pathname-translations</a> of the relevant logical host, the software can be
loaded and run. It may be necessary to use the translations again, or on another
workstation at the same site, so it is best to save the <a 
href="clmse36.html#x48-80002r66">setf</a> form in the standard
place where it can be found later by <a 
href="#x147-211008r738">load-logical-pathname-translations</a>. Often a
software supplier will include a program for restoring software from the
distribution medium to the ﬁle system and a program for loading the software
from the ﬁle system into a Common Lisp; these programs will start by calling
<a 
href="#x147-211008r738">load-logical-pathname-translations</a> to make sure that the logical pathname host is
                                                                          

                                                                          
deﬁned.
<!--l. 1427--><p class="indent" >   Note that the <a 
href="clmse36.html#x48-80002r66">setf</a> of <a 
href="#x147-211006r737">logical-pathname-translations</a> form isn&#x2019;t part of the
program; it is separate and is written by the user, not by the software supplier.
That separation and a uniform convention for doing the separation are the key
aspects of logical pathnames. For small programs involving only a handful of ﬁles,
it doesn&#x2019;t matter much. The real beneﬁts come with large programs with
hundreds or thousands of ﬁles and more complicated situations such as
program-generated ﬁle names or porting a program developed on a system with
long ﬁle names onto a system with a very restrictive limit on the length of ﬁle
names.
</div>
<!--l. 1438--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">23.1.6   </span> <a 
 id="x147-21400023.1.6"></a>Pathname Functions</h4>
<!--l. 1441--><p class="noindent" >These functions are what programs use to parse and default ﬁle names that have
been typed in or otherwise supplied by the user.
<div class=obsolete>
<!--l. 1445--><p class="indent" >   Any argument called pathname in this book may actually be a pathname, a
string or symbol, or a stream. Any argument called defaults may likewise be a
pathname, a string or symbol, or a stream.
</div>
<div class=new>
<!--l. 1451--><p class="indent" >   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to change the language so that a symbol is
never allowed as a pathname argument. More speciﬁcally, the following functions
are changed to disallow a symbol as a pathname argument:
<div class="flushleft" 
>
<!--l. 1457--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" > <a 
href="#x147-214002r740">pathname</a>          </td><td align="left" ><a 
href="#x147-214032r755">pathname-device</a>    </td><td align="left" ><a 
href="#x147-214042r760">namestring</a>             </td>
</tr><tr><td align="left" > <a 
href="#x147-214004r741">truename</a>           </td><td align="left" ><a 
href="#x147-214034r756">pathname-directory</a></td><td align="left" ><a 
href="#x147-214044r761">ﬁle-namestring</a>        </td>
</tr><tr><td align="left" > <a 
href="#x147-214006r742">parse-namestring</a> </td><td align="left" ><a 
href="#x147-214036r757">pathname-name</a>     </td><td align="left" ><a 
href="#x147-214046r762">directory-namestring</a></td>
</tr><tr><td align="left" > <a 
href="#x147-214008r743">merge-pathnames</a></td><td align="left" ><a 
href="#x147-214038r758">pathname-type</a>      </td><td align="left" ><a 
href="#x147-214048r763">host-namestring</a>      </td>
</tr><tr><td align="left" > <a 
href="#x147-214030r754">pathname-host</a>    </td><td align="left" ><a 
href="#x147-214040r759">pathname-version</a>   </td><td align="left" ><a 
href="#x147-214050r764">enough-namestring</a>  </td></tr></table></div></div>
<!--l. 1466--><p class="noindent" >(The function <a 
href="clmse64.html#x80-119006r202">require</a> was also changed by this vote but was deleted from the
language by a vote in January 1989 ⟨<b>?</b>⟩.) Furthermore, the vote reaﬃrmed that
the following functions do not accept symbols as ﬁle, ﬁlename, or pathname
arguments:
                                                                          

                                                                          
<div class="flushleft" 
>
<!--l. 1472--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" > <a 
href="clmse120.html#x148-215002r766">open</a>             </td><td align="left" ><i>rename-ﬁle       </i></td><td align="left" ><i>ﬁle-write-date     </i></td>
</tr><tr><td align="left" > <i>with-open-ﬁle </i></td><td align="left" ><a 
href="clmse121.html#x149-216004r769">delete-ﬁle</a>            </td><td align="left" ><a 
href="clmse121.html#x149-216010r772">ﬁle-author</a>            </td>
</tr><tr><td align="left" > <a 
href="clmse122.html#x150-217002r776">load</a>              </td><td align="left" ><a 
href="clmse121.html#x149-216006r770">probe-ﬁle</a>            </td><td align="left" ><a 
href="clmse123.html#x151-218002r783">directory</a>             </td>
</tr><tr><td align="left" > <a 
href="clmse127.html#x157-224006r797">compile-ﬁle</a>    </td></tr></table></div></div>
<!--l. 1480--><p class="noindent" >In older implementations of Lisp that did not have strings, for example MacLisp,
symbols were the only means for specifying pathnames. This was convenient only
because the ﬁle systems of the time allowed only uppercase letters in ﬁle names.
Typing <i>(load &#x2019;foo)</i> caused the function <a 
href="clmse122.html#x150-217002r776">load</a> to receive the symbol FOO (with
uppercase letters because of the way symbols are parsed) and therefore to load the
ﬁle named FOO. Now that many ﬁle systems, most notably UNIX, support
case-sensitive ﬁle names, the use of symbols is less convenient and more
error-prone.
</div>
<div class=new>
<!--l. 1493--><p class="indent" >   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to specify that a stream may be used as a
<a 
href="#x147-214002r740">pathname</a>, ﬁle, or ﬁlename argument only if it was created by use of <a 
href="clmse120.html#x148-215002r766">open</a> or
<a 
href="clmse120.html#x148-215004r767">with-open-ﬁle</a>, or if it is a synonym stream whose symbol is bound to a stream
that may be used as a pathname.
<!--l. 1501--><p class="indent" >   If such a stream is used as a pathname, it is as if the <a 
href="#x147-214002r740">pathname</a> function were
applied to the stream and the resulting pathname used in place of the stream.
This represents the name used to open the ﬁle. This may be, but is not required
to be, the actual name of the ﬁle.
<!--l. 1506--><p class="indent" >   It is an error to attempt to obtain a pathname from a stream created by any
of the following:
<div class="flushleft" 
>
<!--l. 1508--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" > <a 
href="clmse113.html#x139-184008r644">make-two-way-stream</a>      </td><td align="left" ><a 
href="clmse113.html#x139-184012r646">make-string-input-stream</a>  </td>
</tr><tr><td align="left" > <a 
href="clmse113.html#x139-184010r645">make-echo-stream</a>           </td><td align="left" ><a 
href="clmse113.html#x139-184016r648">make-string-output-stream</a></td>
</tr><tr><td align="left" > <a 
href="clmse113.html#x139-184004r642">make-broadcast-stream</a>    </td><td align="left" ><a 
href="clmse113.html#x139-184022r651">with-input-from-string</a>      </td>
</tr><tr><td align="left" > <a 
href="clmse113.html#x139-184006r643">make-concatenated-stream</a></td><td align="left" ><a 
href="clmse113.html#x139-184026r653">with-output-to-string</a>       </td></tr></table></div></div>
</div>
<!--l. 1518--><p class="indent" >   In the examples, it is assumed that the host named CMUC runs the
TOPS-20 operating system, and therefore uses TOPS-20 ﬁle system syntax;
furthermore, an explicit host name is indicated by following the host
name with a double colon. Remember, however, that namestring syntax is
implementation-dependent, and this syntax is used here purely for the sake of
                                                                          

                                                                          
examples.
<div class=defun>
<!--l. 1525--><p class="noindent" > <i>[Function]</i>   <b>pathname</b> <a 
 id="dx147-214001"></a><a 
 id="x147-214002r740"></a>   <i>pathname</i>
<!--l. 1527--><p class="noindent" >The <a 
href="#x147-214002r740">pathname</a> function converts its argument to be a pathname. The argument
may be a pathname, a string or symbol, or a stream; the result is always a
pathname.
<div class=new>
<!--l. 1533--><p class="indent" >   X3J13 voted in March 1988 not to permit symbols as pathnames ⟨<b>?</b>⟩ and to
specify exactly which streams may be used as pathnames ⟨<b>?</b>⟩.
</div>
<div class=new>
<!--l. 1541--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to specify that <a 
href="#x147-214002r740">pathname</a> is unaﬀected by
whether its argument, if a stream, is open or closed. X3J13 further commented
that because some implementations cannot provide the “true name” of a ﬁle until
the ﬁle is closed, in such an implementation <a 
href="#x147-214002r740">pathname</a> might, in principle, return
a diﬀerent (perhaps more speciﬁc) ﬁle name after the stream is closed. However,
such behavior is prohibited; <a 
href="#x147-214002r740">pathname</a> must return the same pathname
after a stream is closed as it would have while the stream was open. See
<a 
href="#x147-214004r741">truename</a>.
</div>
</div>
<div class=defun>
<!--l. 1555--><p class="noindent" > <i>[Function]</i>   <b>truename</b> <a 
 id="dx147-214003"></a><a 
 id="x147-214004r741"></a>   <i>pathname</i>
<!--l. 1557--><p class="noindent" >The <a 
href="#x147-214004r741">truename</a> function endeavors to discover the “true name” of the ﬁle associated
with the pathname within the ﬁle system. If the pathname is an open
stream already associated with a ﬁle in the ﬁle system, that ﬁle is used.
The “true name” is returned as a pathname. An error is signaled if an
appropriate ﬁle cannot be located within the ﬁle system for the given
pathname.
<!--l. 1567--><p class="indent" >   The <a 
href="#x147-214004r741">truename</a> function may be used to account for any ﬁle name translations
performed by the ﬁle system, for example.
<!--l. 1571--><p class="indent" >   For example, suppose that <i>DOC:</i> is a TOPS-20 logical device name that is
translated by the TOPS-20 ﬁle system to be <i>PS:&#x003C;DOCUMENTATION&#x003E;</i>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq ﬁle (open &#x0022;CMUC::DOC:DUMPER.HLP&#x0022;))
</td></tr></table>
                                                                          

                                                                          
<!--l. 1575--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(namestring (pathname ﬁle))  ⇒ &#x0022;CMUC::DOC:DUMPER.HLP&#x0022;</td></tr></table>
<!--l. 1576--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(namestring (truename ﬁle))</td></tr></table>
<!--l. 1577--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ &#x0022;CMUC::PS:&#x003C;DOCUMENTATION&#x003E;DUMPER.HLP.13&#x0022;</td></tr></table>
<!--l. 1579--><p class="indent" >
</div>
</div>
<div class=new>
<!--l. 1582--><p class="indent" >   X3J13 voted in March 1988 not to permit symbols as pathnames ⟨<b>?</b>⟩ and to
specify exactly which streams may be used as pathnames ⟨<b>?</b>⟩.
</div>
<div class=new>
<!--l. 1590--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to specify that <a 
href="#x147-214004r741">truename</a> may be applied to a
stream whether the stream is open or closed. X3J13 further commented
that because some implementations cannot provide the “true name” of a
ﬁle until the ﬁle is closed, in principle it would be possible in such an
implementation for <a 
href="#x147-214004r741">truename</a> to return a diﬀerent ﬁle name after the stream is
closed. Such behavior is permitted; in this respect <a 
href="#x147-214004r741">truename</a> diﬀers from
<a 
href="#x147-214002r740">pathname</a>.
</div>
<div class=newer>
<!--l. 1603--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to clarify that <a 
href="#x147-214004r741">truename</a> accepts only non-wild
pathnames; an error is signaled if <a 
href="#x147-207002r731">wild-pathname-p</a> would be true of the pathname
argument.
</div>
<div class=newer>
<!--l. 1610--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to require <a 
href="#x147-214004r741">truename</a> to accept logical
pathnames (see section <a 
href="#x147-20800023.1.5">23.1.5<!--tex4ht:ref: LOGICAL-PATHNAMES-SECTION --></a>). However, <a 
href="#x147-214004r741">truename</a> never returns a logical
pathname.
</div>
</div>
<div class=defun>
<!--l. 1616--><p class="noindent" > <i>[Function]</i>   <b>parse-namestring</b> <a 
 id="dx147-214005"></a><a 
 id="x147-214006r742"></a>   <i>thing</i>  <b>&#x0026;optional</b>  <i>host</i> <i>defaults</i> <b>&#x0026;key</b>  :start
:end  :junk-allowed
<!--l. 1618--><p class="noindent" ><div class=obsolete>This turns thing into a pathname. The thing is usually a string (that is, a
namestring), but it may be a symbol (in which case the print name is used) or a
pathname or stream (in which case no parsing is needed, but an error check may
be made for matching hosts).
                                                                          

                                                                          
</div>
<div class=new>
<!--l. 1628--><p class="indent" >   X3J13 voted in March 1988 not to permit symbols as pathnames ⟨<b>?</b>⟩ and to
specify exactly which streams may be used as pathnames ⟨<b>?</b>⟩. The thing argument
may not be a symbol.
</div>
<div class=newer>
<!--l. 1636--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to require <a 
href="#x147-214006r742">parse-namestring</a> to accept logical
pathname namestrings (see section <a 
href="#x147-20800023.1.5">23.1.5<!--tex4ht:ref: LOGICAL-PATHNAMES-SECTION --></a>).
</div>
<!--l. 1640--><p class="indent" >   This function does not, in general, do defaulting of pathname components,
even though it has an argument named defaults; it only does parsing. The host
and defaults arguments are present because in some implementations it may be
that a namestring can only be parsed with reference to a particular ﬁle name
syntax of several available in the implementation. If host is non-<a 
href="clmse31.html#x42-70002r19">nil</a>, it must be a
host name that could appear in the host component of a pathname, or <a 
href="clmse31.html#x42-70002r19">nil</a>; if host
is <a 
href="clmse31.html#x42-70002r19">nil</a> then the host name is extracted from the default pathname in defaults and
used to determine the syntax convention. The defaults argument defaults to the
value of <i>*default-pathname-defaults*</i>.
<!--l. 1654--><p class="indent" >   For a string (or symbol) argument, <a 
href="#x147-214006r742">parse-namestring</a> parses a ﬁle name within
it in the range delimited by the <i>:start</i> and <i>:end</i> arguments (which are
integer indices into string, defaulting to the beginning and end of the
string).
<div class=newer>
<!--l. 1661--><p class="indent" >   See chapter <a 
href="clmch14.html#x99-14100014">14<!--tex4ht:ref: KSEQUE --></a> for a discussion of <i>:start</i> and <i>:end</i> arguments.
</div>
<!--l. 1664--><p class="indent" >   If <i>:junk-allowed</i> is not <a 
href="clmse31.html#x42-70002r19">nil</a>, then the ﬁrst value returned is the pathname
parsed, or <a 
href="clmse31.html#x42-70002r19">nil</a> if no syntactically correct pathname was seen.
<!--l. 1668--><p class="indent" >   If <i>:junk-allowed</i> is <a 
href="clmse31.html#x42-70002r19">nil</a> (the default), then the entire substring is scanned. The
returned value is the pathname parsed. An error is signaled if the substring does
not consist entirely of the representation of a pathname, possibly surrounded on
either side by whitespace characters if that is appropriate to the cultural
conventions of the implementation.
<!--l. 1676--><p class="indent" >   In either case, the second value is the index into the string of the delimiter
that terminated the parse, or the index beyond the substring if the parse
terminated at the end of the substring (as will always be the case if <i>:junk-allowed</i>
is false).
<!--l. 1681--><p class="indent" >   If thing is not a string or symbol, then start (which defaults to zero in any
                                                                          

                                                                          
case) is always returned as the second value.
<!--l. 1684--><p class="indent" >   Parsing an empty string always succeeds, producing a pathname with all
components (except the host) equal to <a 
href="clmse31.html#x42-70002r19">nil</a>.
<!--l. 1687--><p class="indent" >   Note that if host is speciﬁed and not <a 
href="clmse31.html#x42-70002r19">nil</a>, and thing contains a manifest host
name, an error is signaled if the hosts do not match.
<!--l. 1691--><p class="indent" >   If thing contains an explicit host name and no explicit device name, then it
might be appropriate, depending on the implementation environment, for
<a 
href="#x147-214006r742">parse-namestring</a> to supply the standard default device for that host as the device
component of the resulting pathname.
</div>
<!--l. 1698--><p class="indent" >
                                                                          

                                                                          
<div class=defun>
<!--l. 1700--><p class="noindent" > <i>[Function]</i>   <b>merge-pathnames</b> <a 
 id="dx147-214007"></a><a 
 id="x147-214008r743"></a>   <i>pathname</i>  <b>&#x0026;optional</b>  <i>defaults</i>
<i>default-version</i>
<!--l. 1702--><p class="noindent" >
<div class=obsolete>
<!--l. 1705--><p class="indent" >   This is the function that most programs should call to process a ﬁle name
supplied by the user. It ﬁlls in unspeciﬁed components of pathname from the
defaults, and returns a new pathname. The pathname and defaults arguments may
each be a pathname, stream, string, or symbol. The result is always a
pathname.
</div>
<div class=new>
<!--l. 1714--><p class="indent" >   X3J13 voted in March 1988 not to permit symbols as pathnames ⟨<b>?</b>⟩ and to
specify exactly which streams may be used as pathnames ⟨<b>?</b>⟩.
</div>
<div class=newer>
<!--l. 1722--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to require merge-namestrings to recognize a
logical pathname namestring as its ﬁrst argument if its second argument is a
logical pathname (see section <a 
href="#x147-20800023.1.5">23.1.5<!--tex4ht:ref: LOGICAL-PATHNAMES-SECTION --></a>).
</div>
<div class=new>
<!--l. 1728--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to specify that merge-pathname is
unaﬀected by whether the ﬁrst argument, if a stream, is open or closed. If the
ﬁrst argument is a stream, merge-pathname behaves as if the function
<a 
href="#x147-214002r740">pathname</a> were applied to the stream and the resulting pathname used
instead.
</div>
<div class=newer>
<!--l. 1737--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to require <a 
href="#x147-214008r743">merge-pathnames</a> to map customary
case in argument pathnames to the customary case in returned pathnames (see
section <a 
href="#x147-20500023.1.2">23.1.2<!--tex4ht:ref: PATHNAME-COMPONENT-CASE-SECTION --></a>).
</div>
<!--l. 1743--><p class="indent" >   defaults defaults to the value of <i>*default-pathname-defaults*</i>.
<!--l. 1745--><p class="indent" >   default-version defaults to <i>:newest</i>.
<!--l. 1747--><p class="indent" >   Here is an example of the use of <a 
href="#x147-214008r743">merge-pathnames</a>: <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(merge-pathnames &#x0022;CMUC::FORMAT&#x0022;
</td></tr></table>
<!--l. 1749--><p class="indent" >                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 &#x0022;CMUC::PS:&#x003C;LISPIO&#x003E;.FASL&#x0022;)</td></tr></table>
<!--l. 1750--><p class="indent" >     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ⇒ a pathname object that re-expressed as a namestring would be</td></tr></table>
<!--l. 1751--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      &#x0022;CMUC::PS:&#x003C;LISPIO&#x003E;FORMAT.FASL.0&#x0022;</td></tr></table>
<!--l. 1753--><p class="indent" >
</div>
</div>
<!--l. 1755--><p class="indent" >   Defaulting of pathname components is done by ﬁlling in components taken
from another pathname. This is especially useful for cases such as a program that
has an input ﬁle and an output ﬁle, and asks the user for the name of
both, letting the unsupplied components of one name default from the
other. Unspeciﬁed components of the output pathname will come from the
input pathname, except that the type should default not to the type
of the input but to the appropriate default type for output from this
program.
<!--l. 1765--><p class="indent" >   The pathname merging operation takes as input a given pathname, a
defaults pathname, and a default version, and returns a new pathname.
Basically, the missing components in the given pathname are ﬁlled in from
the defaults pathname, except that if no version is speciﬁed the default
version is used. The default version is usually <i>:newest</i>; if no version is
speciﬁed the newest version in existence should be used. The default version
can be <a 
href="clmse31.html#x42-70002r19">nil</a>, to preserve the information that it was missing in the input
pathname.
<!--l. 1776--><p class="indent" >   If the given pathname explicitly speciﬁes a host and does not supply a device,
then if the host component of the defaults matches the host component of the
given pathname, then the device is taken from the defaults; otherwise
the device will be the default ﬁle device for that host. Next, if the given
pathname does not specify a host, device, directory, name, or type, each such
component is copied from the defaults. The merging rules for the version
are more complicated and depend on whether the pathname speciﬁes a
name. If the pathname doesn&#x2019;t specify a name, then the version, if not
provided, will come from the defaults, just like the other components.
However, if the pathname does specify a name, then the version is not
aﬀected by the defaults. The reason is that the version “belongs to” some
other ﬁle name and is unlikely to have anything to do with the new one.
Finally, if this process leaves the version missing, the default version is
used.
                                                                          

                                                                          
<!--l. 1796--><p class="indent" >   The net eﬀect is that if the user supplies just a name, then the host, device,
directory, and type will come from the defaults, but the version will come
from the default version argument to the merging operation. If the user
supplies nothing, or just a directory, the name, type, and version will come
over from the defaults together. If the host&#x2019;s ﬁle name syntax provides
a way to input a version without a name or type, the user can let the
name and type default but supply a version diﬀerent from the one in the
defaults.
<div class=newer>
<!--l. 1807--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to agree to disagree: merge-pathname might or
might not perform plausibility checking on its arguments to ensure that the
resulting pathname can be converted a valid namestring. User beware: this could
cause portability problems.
<!--l. 1812--><p class="indent" >   For example, suppose that host LOSER constrains ﬁle types to be three
characters or fewer but host CMUC does not. Then <i>&#x0022;LOSER::FORMAT&#x0022;</i> is a
valid namestring and <i>&#x0022;CMUC::PS:&#x003C;LISPIO&#x003E;.FASL&#x0022;</i> is a valid namestring, but <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(merge-pathnames &#x0022;LOSER::FORMAT&#x0022; &#x0022;CMUC::PS:&#x003C;LISPIO&#x003E;.FASL&#x0022;)
</td></tr></table>
<!--l. 1817--><p class="indent" >
</div>
</div>
<!--l. 1818--><p class="noindent" >might signal an error in some implementations because the hypothetical result would
be a pathname equivalent to the namestring <i>&#x0022;LOSER::FORMAT.FASL&#x0022;</i> which is
illegal because the ﬁle type FASL has more than three characters. In other
implementations merge-pathname might return a pathname but that pathname
might cause <a 
href="#x147-214042r760">namestring</a> to signal an error.
</div>
</div>
<div class=defun>
<!--l. 1826--><p class="noindent" > <i>[Variable]</i>   <b>*default-pathname-defaults*</b> <a 
 id="dx147-214009"></a><a 
 id="x147-214010r744"></a>
<!--l. 1828--><p class="noindent" >This is the default pathname-defaults pathname; if any pathname primitive that
needs a set of defaults is not given one, it uses this one. As a general rule,
however, each program should have its own pathname defaults rather than using
this one.
</div>
                                                                          

                                                                          
<div class=obsolete>
<div class=defun>
<!--l. 1836--><p class="noindent" > <i>[Function]</i>   <b>make-pathname</b> <a 
 id="dx147-214011"></a><a 
 id="x147-214012r745"></a>   <b>&#x0026;key</b>  :host  :device  :directory  :name  :type
:version  :defaults
<!--l. 1838--><p class="noindent" >Given some components, <a 
href="#x147-214014r746">make-pathname</a> constructs and returns a pathname.
After the components speciﬁed explicitly by the <i>:host</i>, <i>:device</i>, <i>:directory</i>, <i>:name</i>,
<i>:type</i>, and <i>:version</i> arguments are ﬁlled in, the merging rules used by
<a 
href="#x147-214008r743">merge-pathnames</a> are used to ﬁll in any missing components from the defaults
speciﬁed by the <i>:defaults</i> argument. The default value of the <i>:defaults</i> argument is
a pathname whose host component is the same as the host component of the
value of <i>*default-pathname-defaults*</i>, and whose other components are all
<a 
href="clmse31.html#x42-70002r19">nil</a>.
<!--l. 1852--><p class="indent" >   Whenever a pathname is constructed, whether by <a 
href="#x147-214014r746">make-pathname</a> or some
other function, the components may be canonicalized if appropriate. For example,
if a ﬁle system is insensitive to case, then alphabetic characters may be forced to
be all uppercase or all lowercase by the implementation.
</div>
</div>
<div class=newer>
<!--l. 1861--><p class="indent" >   The following example assumes the use of UNIX syntax and conventions. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(make-pathname :host &#x0022;technodrome&#x0022;
</td></tr></table>
<!--l. 1863--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               :directory &#x2019;(:absolute &#x0022;usr&#x0022; &#x0022;krang&#x0022;)</td></tr></table>
<!--l. 1864--><p class="indent" >                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">               :name &#x0022;shredder&#x0022;)</td></tr></table>
<!--l. 1865--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   ⇒ #P&#x0022;technodrome:/usr/krang/shredder&#x0022;</td></tr></table>
<!--l. 1867--><p class="indent" >
</div>
</div>
<!--l. 1868--><p class="noindent" >X3J13 voted in June 1989 ⟨<b>?</b>⟩ to add a new keyword argument <i>:case</i> to <a 
href="#x147-214014r746">make-pathname</a>.
The new argument description is therefore as follows:
<div class=defun>
<!--l. 1872--><p class="noindent" > <i>[Function]</i>   <b>make-pathname</b> <a 
 id="dx147-214013"></a><a 
 id="x147-214014r746"></a>   <b>&#x0026;key</b>  :host  :device  :directory  :name  :type
:version  :defaults  :case
<!--l. 1874--><p class="noindent" >See section <a 
href="#x147-20500023.1.2">23.1.2<!--tex4ht:ref: PATHNAME-COMPONENT-CASE-SECTION --></a> for a description of the <i>:case</i> argument.
                                                                          

                                                                          
<!--l. 1878--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to agree to disagree: <a 
href="#x147-214014r746">make-pathname</a> might or
might not check on its arguments to ensure that the resulting pathname can be
converted to a valid namestring. If <a 
href="#x147-214014r746">make-pathname</a> does not check its arguments
and signal an error in problematical cases, <a 
href="#x147-214042r760">namestring</a> yet might or might not
signal an error when given the resulting pathname. User beware: this could cause
portability problems.
</div>
</div>
<div class=defun>
<!--l. 1888--><p class="noindent" > <i>[Function]</i>   <b>pathnamep</b> <a 
 id="dx147-214015"></a><a 
 id="x147-214016r747"></a>   <i>object</i>
<!--l. 1890--><p class="noindent" >This predicate is true if object is a pathname, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(pathnamep x)  ≡ (typep x &#x2019;pathname)
</td></tr></table>
<!--l. 1894--><p class="indent" >
</div>
</div>
</div>
<div class=obsolete>
<div class=defun>
<!--l. 1898--><p class="noindent" > <i>[Function]</i>   <b>pathname-host</b> <a 
 id="dx147-214017"></a><a 
 id="x147-214018r748"></a>   <i>pathname</i> <br 
class="newline" /><i>[Function]</i>   <b>pathname-device</b> <a 
 id="dx147-214019"></a><a 
 id="x147-214020r749"></a>   <i>pathname</i> <br 
class="newline" /><i>[Function]</i>   <b>pathname-directory</b> <a 
 id="dx147-214021"></a><a 
 id="x147-214022r750"></a>   <i>pathname</i> <br 
class="newline" /><i>[Function]</i>   <b>pathname-name</b> <a 
 id="dx147-214023"></a><a 
 id="x147-214024r751"></a>   <i>pathname</i> <br 
class="newline" /><i>[Function]</i>   <b>pathname-type</b> <a 
 id="dx147-214025"></a><a 
 id="x147-214026r752"></a>   <i>pathname</i> <br 
class="newline" /><i>[Function]</i>   <b>pathname-version</b> <a 
 id="dx147-214027"></a><a 
 id="x147-214028r753"></a>   <i>pathname</i>
<!--l. 1905--><p class="noindent" >These return the components of the argument pathname, which may be a
pathname, string or symbol, or stream. The returned values can be strings, special
symbols, or some other object in the case of structured components. The type will
always be a string or a symbol. The version will always be a number or a
symbol.
</div>
</div>
<div class=new>
<!--l. 1916--><p class="indent" >   X3J13 voted in March 1988 not to permit symbols as pathnames ⟨<b>?</b>⟩ and to
specify exactly which streams may be used as pathnames ⟨<b>?</b>⟩.
                                                                          

                                                                          
</div>
<div class=new>
<!--l. 1924--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to specify that these operations are
unaﬀected by whether the ﬁrst argument, if a stream, is open or closed. If
the ﬁrst argument is a stream, each operation behaves as if the function
<a 
href="#x147-214002r740">pathname</a> were applied to the stream and the resulting pathname used
instead.
</div>
<div class=newer>
<!--l. 1933--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to add a keyword argument <i>:case</i> to all of the
pathname accessor functions except <a 
href="#x147-214040r759">pathname-version</a>. The new argument
descriptions are therefore as follows:
<div class=defun>
<!--l. 1938--><p class="noindent" > <i>[Function]</i>   <b>pathname-host</b> <a 
 id="dx147-214029"></a><a 
 id="x147-214030r754"></a>   <i>pathname</i>  <b>&#x0026;key</b>  :case <br 
class="newline" /><i>[Function]</i>   <b>pathname-device</b> <a 
 id="dx147-214031"></a><a 
 id="x147-214032r755"></a>   <i>pathname</i>  <b>&#x0026;key</b>  :case <br 
class="newline" /><i>[Function]</i>   <b>pathname-directory</b> <a 
 id="dx147-214033"></a><a 
 id="x147-214034r756"></a>   <i>pathname</i>  <b>&#x0026;key</b>  :case <br 
class="newline" /><i>[Function]</i>   <b>pathname-name</b> <a 
 id="dx147-214035"></a><a 
 id="x147-214036r757"></a>   <i>pathname</i>  <b>&#x0026;key</b>  :case <br 
class="newline" /><i>[Function]</i>   <b>pathname-type</b> <a 
 id="dx147-214037"></a><a 
 id="x147-214038r758"></a>   <i>pathname</i>  <b>&#x0026;key</b>  :case <br 
class="newline" /><i>[Function]</i>   <b>pathname-version</b> <a 
 id="dx147-214039"></a><a 
 id="x147-214040r759"></a>   <i>pathname</i>
<!--l. 1945--><p class="noindent" >See section <a 
href="#x147-20500023.1.2">23.1.2<!--tex4ht:ref: PATHNAME-COMPONENT-CASE-SECTION --></a> for a description of the <i>:case</i> argument.
<!--l. 1949--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify that <a 
href="#x147-214034r756">pathname-directory</a> always
returns <a 
href="clmse31.html#x42-70002r19">nil</a>, <i>:unspeciﬁc</i>, or a list—never a string, never <i>:wild</i> (see section <a 
href="#x147-20600023.1.3">23.1.3<!--tex4ht:ref: STRUCTURED-DIRECTORY-SECTION --></a>). If
a list is returned, it is not guaranteed to be freshly consed; the consequences of
modifying this list are undeﬁned.
</div>
</div>
<div class=defun>
<!--l. 1958--><p class="noindent" > <i>[Function]</i>   <b>namestring</b> <a 
 id="dx147-214041"></a><a 
 id="x147-214042r760"></a>   <i>pathname</i> <br 
class="newline" /><i>[Function]</i>   <b>ﬁle-namestring</b> <a 
 id="dx147-214043"></a><a 
 id="x147-214044r761"></a>   <i>pathname</i> <br 
class="newline" /><i>[Function]</i>   <b>directory-namestring</b> <a 
 id="dx147-214045"></a><a 
 id="x147-214046r762"></a>   <i>pathname</i> <br 
class="newline" /><i>[Function]</i>   <b>host-namestring</b> <a 
 id="dx147-214047"></a><a 
 id="x147-214048r763"></a>   <i>pathname</i> <br 
class="newline" /><i>[Function]</i>   <b>enough-namestring</b> <a 
 id="dx147-214049"></a><a 
 id="x147-214050r764"></a>   <i>pathname</i>  <b>&#x0026;optional</b>  <i>defaults</i>
<!--l. 1964--><p class="noindent" >The pathname argument may be a pathname, a string or symbol, or a stream that
is or was open to a ﬁle. The name represented by pathname is returned as a
namelist in canonical form.
<!--l. 1970--><p class="indent" >   If pathname is a stream, the name returned represents the name used to open
the ﬁle, which may not be the actual name of the ﬁle (see <a 
href="#x147-214004r741">truename</a>).
<div class=new>
                                                                          

                                                                          
<!--l. 1975--><p class="indent" >   X3J13 voted in March 1988 not to permit symbols as pathnames ⟨<b>?</b>⟩ and to
specify exactly which streams may be used as pathnames ⟨<b>?</b>⟩.
</div>
<div class=new>
<!--l. 1983--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to specify that these operations are
unaﬀected by whether the ﬁrst argument, if a stream, is open or closed. If
the ﬁrst argument is a stream, each operation behaves as if the function
<a 
href="#x147-214002r740">pathname</a> were applied to the stream and the resulting pathname used
instead.
</div>
<!--l. 1991--><p class="indent" >   <a 
href="#x147-214042r760">namestring</a> returns the full form of the pathname as a string. <a 
href="#x147-214044r761">ﬁle-namestring</a>
returns a string representing just the name, type, and version components
of the pathname; the result of <a 
href="#x147-214046r762">directory-namestring</a> represents just the
directory-name portion; and <a 
href="#x147-214048r763">host-namestring</a> returns a string for just the
host-name portion. Note that a valid namestring cannot necessarily be
constructed simply by concatenating some of the three shorter strings in some
order.
<!--l. 2000--><p class="indent" >   <a 
href="#x147-214050r764">enough-namestring</a> takes another argument, defaults. It returns an
abbreviated namestring that is just suﬃcient to identify the ﬁle named
by pathname when considered relative to the defaults (which defaults to
the value of <i>*default-pathname-defaults*</i>). That is, it is required that <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(merge-pathnames (enough-namestring pathname defaults) defaults)  ≡
</td></tr></table>
<!--l. 2007--><p class="indent" >     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> (merge-pathnames (parse-namestring pathname nil defaults) defaults)</td></tr></table>
<!--l. 2009--><p class="indent" >
</div>
</div>
<!--l. 2010--><p class="noindent" >in all cases; and the result of <a 
href="#x147-214050r764">enough-namestring</a> is, roughly speaking, the shortest
reasonable string that will still satisfy this criterion. <div class=newer> X3J13 voted in June 1989
⟨<b>?</b>⟩ to agree to disagree: <a 
href="#x147-214014r746">make-pathname</a> and <a 
href="#x147-214008r743">merge-pathnames</a> might or might
not be able to produce pathnames that cannot be converted to valid namestrings.
User beware: this could cause portability problems.
</div>
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 2020--><p class="noindent" > <i>[Function]</i>   <b>user-homedir-pathname</b> <a 
 id="dx147-214051"></a><a 
 id="x147-214052r765"></a>   <b>&#x0026;optional</b>  <i>host</i>
<!--l. 2022--><p class="noindent" >Returns a pathname for the user&#x2019;s “home directory” on host. The host argument
defaults in some appropriate implementation-dependent manner. The concept of
“home directory” is itself somewhat implementation-dependent, but from the point
of view of Common Lisp it is the directory where the user keeps personal ﬁles such
as initialization ﬁles and mail. If it is impossible to determine this information,
then <a 
href="clmse31.html#x42-70002r19">nil</a> is returned instead of a pathname; however, <a 
href="#x147-214052r765">user-homedir-pathname</a>
never returns <a 
href="clmse31.html#x42-70002r19">nil</a> if the host argument is not speciﬁed. This function returns a
pathname without any name, type, or version component (those components are
all <a 
href="clmse31.html#x42-70002r19">nil</a>).
</div>
                                                                          

                                                                          
   <!--l. 2038--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse120.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch23.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch23.html#tailclmch23.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse119.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch23.html#clmse119.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 2038--><p class="indent" >   <a 
 id="tailclmse119.html"></a>  
</body></html> 
