<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Формы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-03-19 00:40:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 1529--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse29.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#tailclmch5.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse28.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse28.html" >Вверх</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
 id="x38-570005.1"></a>Формы</h3>
                                                                          

                                                                          
<!--l. 1531--><p class="noindent" >Стандартная единица взаимодействия с реализацией Common Lisp&#x2019;а является
<i>форма</i>, которая является объектом данных, который выполняется как
программа для вычисления одного или более <i>значений</i> (который также
являются объектами данных). Запросить выполнение можно для <i>любого</i>
объекта данных, но не для всех это имеет смысл. Например, символы и
списки имеет смысл выполнять, тогда как массивы обычно нет. Примеры
содержательных форм: 3, значение которой 3, и (+ 3 4), значение которой
7. Для обозначения этих фактов мы пишем 3 <span class="math"> ⇒</span> 3 и (+ 3 4) <span class="math"> ⇒</span> 7.
(<span class="math"> ⇒</span> означает «вычисляется в»)
<!--l. 1541--><p class="indent" >   Содержательные формы могут быть разделены на три категории:
самовычисляемые формы, такие как числа, символы, которые используются
для переменных, и списки. Списки в свою очередь могут быть разделены
на три категории: специальные формы, вызовы макросов, вызовы
функций.
<div class=newer>
<!--l. 1550--><p class="indent" >   Все стандартные объекты данных Common Lisp, не являющиеся
символами и списками (включая <a 
href="clmse99.html#x123-227002r580">defstruct</a> структуры, определённые без
опции :type) являются самовычисляемыми.
</div>
<!--l. 1555--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.1   </span> <a 
 id="x38-580005.1.1"></a>Самовычисляемые формы</h4>
<!--l. 1557--><p class="noindent" >Все числа, строковые символы, строки и битовые векторы являются
<i>самовычисляемыми</i> формами. Когда данный объект вычисляется, тогда
объект (или возможно копия в случае с числами и строковыми символами)
возвращается в качестве значения данной формы. Пустой список (), который
также является значением false <a 
href="clmse31.html#x42-74002r18">nil</a>, также является самовычисляемой
формой: значение <a 
href="clmse31.html#x42-74002r18">nil</a> является <a 
href="clmse31.html#x42-74002r18">nil</a>. Ключевые символы (примечание
переводчика: не путать с ключевыми словами в других языках, в Common
Lisp&#x2019;е это вид символов) также вычисляются сами в себя: значение :start
является :start.
<div class=newer>
<!--l. 1569--><p class="indent" >   X3J13 проголосовал в январе 1989 <a 
 id="dx38-58001"></a>для определения того, что деструктивная
модификация любого объекта, представленного как константа, с помощью
самовычисляемой формы или специальной формы <a 
href="clmse35.html#x47-84002r51">quote</a>, является
ошибкой.
                                                                          

                                                                          
</div>
<!--l. 1575--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.2   </span> <a 
 id="x38-590005.1.2"></a>Переменные</h4>
<!--l. 1577--><p class="noindent" >В Common Lisp программах символы используются в качестве имён
переменных. Когда символ вычисляется как форма, то в качестве результата
возвращается значение переменной, которую данный символ именовал.
Например, после выполнения (setq items 3), которая присвоила значение 3
переменой именованной символом items, форма items выполнится в 3 (items
<span class="math"> ⇒</span> 3). Переменные могут <i>назначены</i> с помощью <a 
href="clmse35.html#x47-87002r59">setq</a> или <i>связаны</i> с помощью
<a 
href="clmse39.html#x51-100002r74">let</a>. Любая программная конструкция, которая связывает переменную,
сохраняет старое значение переменной, и назначает новое, и при выходе из
конструкции восстанавливается старое значение.
<!--l. 1589--><p class="indent" >   В Common Lisp&#x2019;е есть два вида переменных. Они называются лексические
(или <i>статические</i>) и <i>специальные</i> (или <i>динамические</i>). В одно время каждая
из или обе переменные с одинаковым именем могут иметь некоторое
значение. На какую переменную ссылается символ при его вычислении,
зависит от контекста выполнения. Главное правило заключается в
том, что если символ вычисляется по тексту в конструкции, которая
создала <i>связывание</i> для переменной с одинаковым именем, то символ
ссылается на переменную, обозначенную в этом связывании, если же по
тексту такой конструкции нет, то символ ссылается на специальную
переменную.
<!--l. 1599--><p class="indent" >   Различие между двумя видами переменных заключается в области
видимости и продолжительности видимости. Лексически связанная
переменная может быть использована <i>только</i> по тексту в форме, которая
установила связывание. Динамически связанная (специальная) переменная
может быть использована в любое <i>время</i> между установкой связи и до
выполнения конструкции, которая упраздняет связывание. Таким образом
лексическое связывание переменных накладывает ограничение на
использование переменной только в некоторой текстовой области (но не на
временные ограничения, так связывание продолжает существовать, пока
возможно существование ссылки на переменную). И наоборот, динамическое
связывание переменных накладывает ограничение на временные рамки
использования переменной (но не на текстовую область). Для более
подробной информации смотрите главу <a 
href="clmch3.html#x25-430003">3<!--tex4ht:ref: SCOPE --></a>.
                                                                          

                                                                          
<!--l. 1612--><p class="indent" >   Когда нет связываний, значение, которое имеет специальная переменная,
называется <i>глобальным</i> значением (специальной) переменной. Глобальное
значение может быть задано переменной только с помощью назначения,
потому что значение заданное связыванием по определению не глобально.
<!--l. 1617--><p class="indent" >   Специальная переменная может вообще не иметь значения, в таком
случае, говориться, что они <i>несвязанная</i>. По умолчанию, каждая глобальная
переменная является несвязанной, пока значение не будет назначено явно, за
исключением переменных определённых в этой книге или реализацией,
которые уже имеют значения сразу после первого запуска Lisp машины.
Кроме того, существует возможность установки связывания специальной
переменной и затем упразднения этого связывания с помощью функции
<a 
href="clmse35.html#x47-89004r62">makunbound</a>. В такой ситуации переменная также называется «несвязанной»,
хотя это и неправильно, если быть точнее, переменная связана, но
без значения FIXME. Ссылка на несвязанную переменную является
ошибкой.
<!--l. 1628--><p class="indent" >   Некоторые глобальные переменные зарезервированы в качестве
«именованных констант». Они имеют глобальное значение и не могут быть
связаны или переназначены. Например символы <a 
href="clmse31.html#x42-74004r19">t</a> и <a 
href="clmse31.html#x42-74002r18">nil</a> зарезервированы.
Невозможно назначить и этим символам. Также невозможно связать эти
символы со другими значениями. Символы констант определённых с
помощью <a 
href="clmse30.html#x40-69006r16">defconstant</a> также становятся зарезервированными и не могут быть
переназначены или связаны (но они могут быть переопределены с
помощью вызова <a 
href="clmse30.html#x40-69006r16">defconstant</a>). Ключевые символы также не могут быть
переназначены или связаны, ключевые символы всегда вычисляются сами в
себя.
<!--l. 1639--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.3   </span> <a 
 id="x38-600005.1.3"></a>Специальные формы</h4>
<!--l. 1641--><p class="noindent" >Если список выполняется в качестве формы, первым шагом является
определение первого элемента списка. Если первый элемент списка
является одним из символов, перечисленных в таблице ??, тогда список
называется <i>специальной формой</i>. (Использование слова «специальный»
никак не связано с использованием этого слова в фразе «специальная
переменная».)
<!--l. 1647--><p class="indent" >   Специальные формы обычно являются окружениями и управляющими
конструкциями. Каждая специальная форма имеет свой идиосинкразитечский
                                                                          

                                                                          
синтаксис. Например специальная форма <a 
href="clmse136.html#x167-340002r835">if</a>: (if p (+ x 4) 5) в Common Lisp&#x2019;е
означает то же, что и «<b>if</b> <i>p</i> <b>then</b> <i>x</i>+4 <b>else</b> 5» означает в Algol&#x2019;е.
<!--l. 1654--><p class="indent" >   Выполнение специальной формы обычно возвращает значение или
значения, но выполнение может и вызвать нелокальный выход; смотрите
<a 
href="clmse41.html#x53-114002r88">return-from</a>, <a 
href="clmse42.html#x54-128002r104">go</a> и <a 
href="clmse44.html#x56-141002r116">throw</a>.
<!--l. 1658--><p class="indent" >   Множество специальных форм в Common Lisp&#x2019;е фиксировано. Создание
пользовательский специальных форм невозможно. Однако пользователь
может создавать новые синтаксические конструкции с помощью определения
макросов.
<!--l. 1662--><p class="indent" >   Множество специальных форм в Common Lisp&#x2019;е специально держится
малым, потому что любая программа, анализирующая программы, должна
содержать специальные знания он каждом типе специальной формы. Такие
программы не нуждаются в специальных знаниях о макросах, так как
раскрытие макроса просто, и далее остаётся только оперирования с
результатом раскрытия. (Это не значит, что программы, в частности,
компиляторы, не будут иметь специальных знаний о макросах. Компилятор
может генерировать более лучший код, если он распознает такие
конструкции, как <a 
href="clmse40.html#x52-111002r86">typecase</a> и <a 
href="clmse43.html#x55-134002r111">multiple-value-bind</a> и по особому будет
обращаться с ними.)
<!--l. 1671--><p class="indent" >   Реализация может осуществлять как макросы любую конструкцию
описанную здесь как специальную форму. И наоборот, реализация
может осуществлять как специальную форму любую конструкцию
описанную здесь как макрос, при условии что также предоставляется
эквивалентное определение макроса. Практическое значение заключается
в том, что предикаты <a 
href="clmse45.html#x58-144002r117">macro-function</a> и <a 
href="clmse35.html#x47-86015r58">special-operator-p</a> могут оба
возвращать true принимая один и тот же символ. Рекомендуется,
чтобы программа для анализа других программ обрабатывала форму
являющуюся списком, <i>car</i> которого является символом, следующим
образом:
<!--l. 1680--><p class="indent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x38-60002x1">Если программа имеет подробные знания о символе, обрабатывать
      форму  необходимо  с  помощью  специализированного  кода.  Все
      символы,  перечисленные  в  таблице ??  должны  попадать  под
      данную категорию.
      </li>
                                                                          

                                                                          
      <li 
  class="enumerate" id="x38-60004x2">В  противном  случае,  если  для  этого  символа  <a 
href="clmse45.html#x58-144002r117">macro-function</a>
      вычисляется  в  true,  необходимо  применить  <a 
href="clmse46.html#x59-146002r119">macroexpand</a>  или
      <a 
href="clmse46.html#x59-146004r120">macroexpand-1</a>   для   раскрытия   формы,   и   результат   вновь
      анализировать.
      </li>
      <li 
  class="enumerate" id="x38-60006x3">В  противном  случае,  необходимо  расценивать  форму  как  вызов
      функции.</li></ol>
<!--l. 1696--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.4   </span> <a 
 id="x38-610005.1.4"></a>Макросы</h4>
<!--l. 1698--><p class="noindent" >Если форма является списком и первый элемент не обозначает специальную
форму, возможно он является именем <i>макроса</i>. Если так, то форма
называется <i>макровызовом или вызовом макроса (macrocall)</i> FIXME.
Макрос это функция, которая принимает формы и возвращает формы.
Возвращённые формы подставляются в то место, где происходил
макровызов, и затем выполняются. (Этот процесс иногда называется
<i>раскрытием макроса</i>.) Например, макрос с именем <a 
href="clmse137.html#x168-343002r840">return</a> принимает
форма, вот так: (return x), и полученная в результате раскрытия форма
такая: (return-from <a 
href="clmse31.html#x42-74002r18">nil</a> x). Мы говорим: старая форма раскрылась в
новую. Новая форма будет вычислена на месте оригинальной формы.
Значение новой формы будет возвращено, как значение оригинальной
формы.
<!--l. 1710--><p class="indent" >   В Common Lisp&#x2019;е существует некоторое количество стандартных
макросов, и пользователь может определять свои макросы используя
<a 
href="clmse45.html#x58-144004r118">defmacro</a>.
<!--l. 1713--><p class="indent" >   Макросы, предоставляемые реализацией Common Lisp&#x2019;а и описанные
здесь, могут раскрываться в код, которые не будет являться переносимым
между реализациями. Вызов макроса является портабельным, в то время как
результат раскрытия нет.
<!--l. 1717--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.5   </span> <a 
 id="x38-620005.1.5"></a>Вызовы функций</h4>
<!--l. 1719--><p class="noindent" >Если список выполняется как форма, и первый элемент не является символом,
обозначающим специальную форму или макрос, тогда предполагается, что
                                                                          

                                                                          
список является <i>вызовом функции</i>. Первый элемент списка является именем
функции. Все следующие элементы списка будут вычислены. Одно значение
каждого вычисленного элемента будет является <i>аргументом</i> для
вызываемой функции. Затем функция будет <i>применена</i> к аргументам.
Вычисление функции обычно возвращает значение, однако вместо этого
может быть выполнен нелокальный выход, смотрите <a 
href="clmse44.html#x56-141002r116">throw</a>. Функция может
возвращать 0 и более значений, смотрите <a 
href="clmse43.html#x55-131002r105">values</a>. Если и когда функция
возвращает значения, они становятся значениями вычисления формы вызова
функции.
<!--l. 1732--><p class="indent" >   Например, рассмотрим вычисление формы: (+ (* 4 5)). Символ <a 
href="clmse106.html#x131-239002r587">+</a>
обозначает функцию сложения, а не специальную форму или макрос.
Таким образом две формы 3 и (* 4 5) вычисляются для аргументов.
Форма 3 вычисляется в 3, а форма (* 4 5) является вызовом функции
(умножения). Таким образом формы 4 и 5 вычисляются сами в себя, тем
самым предоставляя аргументы для функции умножения. Функция
умножения вычисляет результат 20 и возвращает его. Значения 3 и 20
становятся аргументами функции сложения, которая вычисляет и
возвращает результат 23. Таким образом мы говорим (+3 (* 4 5))
<span class="math"> ⇒</span> 23.
                                                                          

                                                                          
   <!--l. 1742--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse29.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#tailclmch5.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse28.html" >Вверх</a><tt>&#x003E;</tt></p></div>
<!--l. 1742--><p class="indent" >   <a 
 id="tailclmse28.html"></a>  
</body></html> 
