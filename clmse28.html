<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Формы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 23:44:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1295--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse29.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#tailclmch5.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse28.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse28.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
href="clm.html#QQ2-38-230" id="x38-2230005.1">Формы</a></h3>
<!--l. 1297--><p class="noindent" >Стандартной единицей взаимодействия с реализацией Common Lisp&#x2019;а
является <i>форма</i>, которая является объектом данных, который выполняется
                                                                          

                                                                          
как программа для вычисления одного или более <i>значений</i> (которые также
являются объектами данных). Запросить выполнение можно для <i>любого</i>
объекта данных, но не для всех это имеет смысл. Например, символы и
списки имеет смысл выполнять, тогда как массивы обычно нет. Примеры
содержательных форм: <tt>3</tt>, значение которой <tt>3</tt>, и <tt>(+ 3 4)</tt>, значение которой <tt>7</tt>.
Для обозначения этих фактов мы пишем <tt>3</tt> <span class="math"> ⇒</span> <tt>3</tt> и <tt>(+ 3 4)</tt> <span class="math"> ⇒</span> <tt>7</tt>.
(<span class="math"> ⇒</span> означает «вычисляется в»)
<!--l. 1307--><p class="indent" >   Содержательные формы могут быть разделены на три категории:
самовычисляемые формы, такие как числа, символы, которые используются
для переменных, и списки. Списки в свою очередь могут быть разделены
на три категории: специальные формы, вызовы макросов, вызовы
функций.
<!--l. 1315--><p class="indent" >   Все стандартные объекты данных Common Lisp, не являющиеся
символами и списками (включая <tt><a 
href="clmli7.html#x196-3479318r318">defstruct</a></tt> структуры, определённые без
опции <tt>:type</tt>) являются самовычисляемыми.
<!--l. 1319--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.1   </span> <a 
href="clmli1.html#QQ2-38-231" id="x38-2240005.1.1">Самовычисляемые формы</a></h4>
<!--l. 1321--><p class="noindent" >Все числа, строковые символы, строки и битовые векторы являются
<i>самовычисляемыми</i> формами. Когда данный объект вычисляется, тогда
объект (или возможно копия в случае с числами и строковыми символами)
возвращается в качестве значения данной формы. Пустой список (), который
также является значением ложь (<tt><a 
href="clmli7.html#x196-3479650r650">nil</a></tt>), также является самовычисляемой
формой: значение <tt><a 
href="clmli7.html#x196-3479650r650">nil</a></tt> является <tt><a 
href="clmli7.html#x196-3479650r650">nil</a></tt>. Ключевые символы (примечание
переводчика: не путать с ключевыми словами в других языках, в Common
Lisp&#x2019;е это вид символов) также вычисляются сами в себя: значение <tt>:start</tt>
является <tt>:start</tt>.
<!--l. 1332--><p class="indent" >   Деструктивная модификация любого объекта, представленного как
константа с помощью самовычисляемой формы или специальной формы
<tt><a 
href="clmli7.html#x196-3479753r753">quote</a></tt>, является ошибкой.
<!--l. 1336--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.2   </span> <a 
href="clmli1.html#QQ2-38-232" id="x38-2250005.1.2">Переменные</a></h4>
<!--l. 1338--><p class="noindent" >В Common Lisp программах символы используются в качестве имён
переменных. Когда символ вычисляется как форма, то в качестве результата
                                                                          

                                                                          
возвращается значение переменной, которую данный символ именовал.
Например, после выполнения <tt>(setq items 3)</tt>, которая присвоила значение <tt>3</tt>
переменой именованной символом <tt>items</tt>, форма <tt>items</tt> выполнится
в <tt>3</tt> (<tt>items</tt> <span class="math"> ⇒</span> <tt>3</tt>). Переменные могут быть <i>назначены</i> с помощью
<tt><a 
href="clmli7.html#x196-3479841r841">setq</a></tt> или <i>связаны</i> с помощью <tt><a 
href="clmli7.html#x196-3479524r524">let</a></tt>. Любая программная конструкция,
которая связывает переменную, сохраняет старое значение переменной, и
назначает новое, и при выходе из конструкции восстанавливается старое
значение.
<!--l. 1350--><p class="indent" >   В Common Lisp&#x2019;е есть два вида переменных. Они называются <tt>лексические</tt>
(или <i>статические</i>) и <i>специальные</i> (или <i>динамические</i>). В одно время каждая
из них или обе переменные с одинаковым именем могут иметь некоторое
значение. На какую переменную ссылается символ при его вычислении,
зависит от контекста выполнения. Главное правило заключается в
том, что если символ вычисляется по тексту в конструкции, которая
создала <i>связывание</i> для переменной с одинаковым именем, то символ
ссылается на переменную, обозначенную в этом связывании, если же по
тексту такой конструкции нет, то символ ссылается на специальную
переменную.
<!--l. 1360--><p class="indent" >   Различие между двумя видами переменных заключается в области
видимости и продолжительности видимости. Лексически связанная
переменная может быть использована <i>только</i> по тексту в форме, которая
установила связывание. Динамически связанная (специальная) переменная
может быть использована в любое <i>время</i> между установкой связи и до
выполнения конструкции, которая упраздняет связывание. Таким образом
лексическое связывание переменных накладывает ограничение на
использование переменной только в некоторой текстовой области (но не на
временные ограничения, так связывание продолжает существовать, пока
возможно существование ссылки на переменную). И наоборот, динамическое
связывание переменных накладывает ограничение на временные рамки
использования переменной (но не на текстовую область). Для более
подробной информации смотрите главу <a 
href="clmch3.html#x25-1250003">3<!--tex4ht:ref: SCOPE --></a>.
<!--l. 1373--><p class="indent" >   Когда нет связываний, значение, которое имеет специальная переменная,
называется <i>глобальным</i> значением (специальной) переменной. Глобальное
значение может быть задано переменной только с помощью назначения,
потому что значение заданное связыванием по определению не глобально.
<!--l. 1378--><p class="indent" >   Специальная переменная может вообще не иметь значения, в таком
случае, говориться, что она <i>несвязанная</i>. По умолчанию, каждая глобальная
переменная является несвязанной, пока значение не будет назначено явно, за
                                                                          

                                                                          
исключением переменных определённых в этой книге или реализацией,
которые уже имеют значения сразу после первого запуска Lisp машины.
Кроме того, существует возможность установки связывания специальной
переменной и затем упразднения этого связывания с помощью функции
<tt><a 
href="clmli7.html#x196-3479591r591">makunbound</a></tt>. В такой ситуации переменная также называется «несвязанной»,
хотя это и неправильно, если быть точнее, переменная связана, но
без значения FIXME. Ссылка на несвязанную переменную является
ошибкой.
<!--l. 1389--><p class="indent" >   Чтение несвязанной переменной или неопределённой функции может быть
обработано при самом высоком уровне безопасности (смотрите свойство
<tt>safety</tt> декларации <tt>optimize</tt>). При других уровнях безопасности поведение
не определено. Таким образом, чтение несвязанной переменной или
неопределённой функции должно сигнализировать ошибку. («Чтение
функции» включает ссылку на функцию используя специальный оператор
<tt><a 
href="clmli7.html#x196-3479430r430">function</a></tt>, как для <tt><a 
href="clmli7.html#x196-3479382r382">f</a></tt> в форме <tt>(function f)</tt> и ссылку при вызове функции,
как для <tt><a 
href="clmli7.html#x196-3479382r382">f</a></tt> в форме <tt>(f x y)</tt>.)
<!--l. 1399--><p class="indent" >   В случае <tt>inline</tt> функций (в реализациях где они поддерживаются),
выполнение встраивания функци представляет собой чтение функции, таким
образом нет необходимости в проверке <tt><a 
href="clmli7.html#x196-3479383r383">fboundp</a></tt> во время исполнения. Иными
словами, результат применения <tt><a 
href="clmli7.html#x196-3479420r420">fmakunbound</a></tt> к имени <tt>inline</tt> функции не
определён.
<!--l. 1405--><p class="indent" >   При несвязанной переменой сигнализируется ошибка <tt><a 
href="clmli7.html#x196-3479963r963">unbound-variable</a></tt>, и
слот <tt>name</tt> условия <tt><a 
href="clmli7.html#x196-3479963r963">unbound-variable</a></tt> содержит значение имени переменной,
вызвавшей ошибку.
<!--l. 1409--><p class="indent" >   При неопределённой функции сигнализируется ошибка <tt>unbound-function</tt>,
и слот <tt>name</tt> условия <tt>unbound-function</tt> содержит значение имени переменной,
вызвавшей ошибку.
<!--l. 1413--><p class="indent" >   Тип условия <tt>unbound-slot</tt>, которое унаследовано от <tt><a 
href="clmli7.html#x196-3479199r199">cell-error</a></tt>, имеет
дополнительный слот <tt>instance</tt>, который может быть инициализировать
параметром <tt>:instance</tt> в функции <tt><a 
href="clmli7.html#x196-3479572r572">make-condition</a></tt>. Функция
<tt>unbound-slot-instance</tt> предоставляет доступ к этому слоту.
<!--l. 1418--><p class="indent" >   Тип ошибки, по-умолчанию сигнализирующейся для метода обобщённой
функции <tt><a 
href="clmli7.html#x196-3479871r871">slot-unbound</a></tt> CLOS, является <tt>unbound-slot</tt>. Слот <tt>instance</tt>
условия <tt>unbound-slot</tt> устанавливается в соответствующий экземпляр
объекта и слот <tt>name</tt> в соответствующее имя переменной.
<!--l. 1424--><p class="indent" >   Некоторые глобальные переменные зарезервированы в качестве
«именованных констант». Они имеют глобальное значение и не могут быть
связаны или переназначены. Например символы <tt><a 
href="clmli7.html#x196-3479935r935">t</a></tt> и <tt><a 
href="clmli7.html#x196-3479650r650">nil</a></tt> зарезервированы. Этим
                                                                          

                                                                          
символам невозможно назначить значение. Также и невозможно связать эти
символы с другими значениями. Символы констант определённых с помощью
<tt><a 
href="clmli7.html#x196-3479304r304">defconstant</a></tt> также становятся зарезервированными и не могут быть
переназначены или связаны (но они могут быть переопределены с
помощью вызова <tt><a 
href="clmli7.html#x196-3479304r304">defconstant</a></tt>). Ключевые символы также не могут быть
переназначены или связаны, ключевые символы всегда вычисляются сами в
себя.
<!--l. 1435--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.3   </span> <a 
href="clmli1.html#QQ2-38-233" id="x38-2260005.1.3">Специальные операторы</a></h4>
<!--l. 1437--><p class="noindent" >Если список выполняется в качестве формы, первым шагом является
определение первого элемента списка. Если первый элемент списка
является одним из символов, перечисленных в таблице <a 
href="#x38-2260011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>, тогда список
называется <i>специальным оператором</i>. (Использование слова «специальный»
никак не связано с использованием этого слова в фразе «специальная
переменная».)
<!--l. 1443--><p class="indent" >   Специальные операторы обычно являются окружениями и управляющими
конструкциями. Каждый специальный оператор имеет свой идиосинкразический
синтаксис. Например, специальный оператор <tt><a 
href="clmli7.html#x196-3479469r469">if</a></tt>: <tt>(if p (+ x 4) 5)</tt> в
Common Lisp&#x2019;е означает то же, что и «<b>if</b> <i>p</i> <b>then</b> <i>x</i>+4 <b>else</b> 5» означает в
Algol&#x2019;е.
<!--l. 1450--><p class="indent" >   Выполнение специального оператора обычно возвращает одно или
несколько значений, но выполнение может и вызвать нелокальный выход;
смотрите <tt><a 
href="clmli7.html#x196-3479799r799">return-from</a></tt>, <tt><a 
href="clmli7.html#x196-3479457r457">go</a></tt> и <tt>throw</tt>.
<!--l. 1454--><p class="indent" >   Множество специальных операторов в Common Lisp&#x2019;е фиксировано.
Создание пользовательских специальных форм невозможно. Однако
пользователь может создавать новые синтаксические конструкции с
помощью определения макросов.
<!--l. 1458--><p class="indent" >   Множество специальных операторов в Common Lisp&#x2019;е специально
держится малым, потому что любая программа, анализирующая программы,
должна содержать специальные знания о каждом типе специального
оператора. Такие программы не нуждаются в специальных знаниях о
макросах, так как раскрытие макроса просто, и далее остаётся только
оперирование с результатом раскрытия. (Это не значит, что программы, в
частности, компиляторы, не будут иметь специальных знаний о макросах.
Компилятор может генерировать боле эффективный код, если он распознает
                                                                          

                                                                          
такие конструкции, как <tt><a 
href="clmli7.html#x196-3479961r961">typecase</a></tt> и <tt><a 
href="clmli7.html#x196-3479634r634">multiple-value-bind</a></tt> и будет по-особому
с ними обращаться.)
   <div class="table">
                                                                          

                                                                          
<!--l. 1468--><p class="indent" >   <a 
 id="x38-2260011"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Таблица 5.1: </span><span  
class="content">Имена всех специальных форм</span></div><!--tex4ht:label?: x38-2260011 -->
<div class="tabular"><table width="100%" class="tabular"><tr><td align="left" > <tt><a 
href="clmli7.html#x196-3479135r135">block</a></tt>    </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479469r469">if</a></tt>                  </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479747r747">progv</a></tt>          </td>
</tr><tr><td align="left" > <tt>catch</tt>    </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479496r496">labels</a></tt>              </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479753r753">quote</a></tt>          </td>
</tr><tr><td align="left" >               </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479524r524">let</a></tt>                 </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479799r799">return-from</a></tt>    </td></tr><tr><td align="left" > <tt><a 
href="clmli7.html#x196-3479300r300">declare</a></tt> </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479525r525">let*</a></tt> </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479841r841">setq</a></tt></td>
</tr><tr><td align="left" > <tt><a 
href="clmli7.html#x196-3479374r374">eval-when</a></tt></td><td align="left" ><tt><a 
href="clmli7.html#x196-3479568r568">macrolet</a></tt>            </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479936r936">tagbody</a></tt>        </td>
</tr><tr><td align="left" > <tt><a 
href="clmli7.html#x196-3479410r410">flet</a></tt>     </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479635r635">multiple-value-call</a></tt> </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479943r943">the</a></tt>            </td>
</tr><tr><td align="left" > <tt><a 
href="clmli7.html#x196-3479430r430">function</a></tt> </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479637r637">multiple-value-prog1</a></tt></td><td align="left" ><tt>throw</tt>          </td>
</tr><tr><td align="left" > <tt><a 
href="clmli7.html#x196-3479457r457">go</a></tt>       </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479745r745">progn</a></tt>               </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479975r975">unwind-protect</a></tt> </td>
</tr><tr><td align="left" >               </td><td align="left" >                        </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479928r928">symbol-macrolet</a></tt></td>
</tr><tr><td align="left" >               </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479537r537">locally</a></tt>             </td><td align="left" ><tt><a 
href="clmli7.html#x196-3479536r536">load-time-value</a></tt></td></tr></table>
</div>
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<!--l. 1486--><p class="indent" >   Реализация может исполнять в виде макроса любую конструкцию,
описанную здесь как специальную оператор. И наоборот, реализация может
выполнять в виде специального оператора любую конструкцию, описанную
здесь как макрос, при условии, что также предоставляется эквивалентное
определение макроса. Практическое значение заключается в том, что
предикаты <tt><a 
href="clmli7.html#x196-3479565r565">macro-function</a></tt> и <tt><a 
href="clmli7.html#x196-3479877r877">special-operator-p</a></tt> могут оба возвращать
истину, принимая один и тот же символ. Рекомендуется, чтобы программа
для анализа других программ обрабатывала форму являющуюся списком с
символом в первой позиции следующим образом:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x38-226003x1">Если программа имеет подробные знания о символе, обрабатывать
      форму  необходимо  с  помощью  специализированного  кода.  Все
      символы,  перечисленные  в  таблице <a 
href="#x38-2260011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>  должны  попадать  под
      данную категорию.
      </li>
      <li 
  class="enumerate" id="x38-226005x2">В  противном  случае,  если  для  этого  символа  <tt><a 
href="clmli7.html#x196-3479565r565">macro-function</a></tt>
      вычисляется   в   истину,   необходимо   применить   <tt><a 
href="clmli7.html#x196-3479566r566">macroexpand</a></tt>
      или  <tt><a 
href="clmli7.html#x196-3479567r567">macroexpand-1</a></tt> для  раскрытия  формы,  и  результат  вновь
      анализировать.
      </li>
      <li 
  class="enumerate" id="x38-226007x3">В  противном  случае,  необходимо  расценивать  форму  как  вызов
      функции.</li></ol>
   <h4 class="subsectionHead"><span class="titlemark">5.1.4   </span> <a 
href="clmli1.html#QQ2-38-235" id="x38-2270005.1.4">Макросы</a></h4>
<!--l. 1512--><p class="noindent" >Если форма является списком и первый элемент не обозначает специальную
форму, возможно он является именем <i>макроса</i>. Если так, то форма
называется <i>макровызовом или вызовом макроса (macrocall)</i>. Макрос это
функция, которая принимает формы и возвращает формы. Возвращённые
формы подставляются в то место, где происходил макровызов, и затем
выполняются. (Этот процесс иногда называется <i>раскрытием макроса</i>.)
Например, макрос с именем <tt><a 
href="clmli7.html#x196-3479798r798">return</a></tt> принимает форму, вот так: <tt>(return x)</tt>, и
полученная в результате раскрытия форма такая: <tt>(return-from <tt><a 
href="clmli7.html#x196-3479650r650">nil</a></tt> x)</tt>. Мы
                                                                          

                                                                          
говорим: старая форма раскрылась в новую. Новая форма будет вычислена
на месте оригинальной формы. Значение новой формы будет возвращено, как
значение оригинальной формы.
<!--l. 1524--><p class="indent" >   Макровызовы, и подформы макровызовов не обязательно должны быть Ъ
списками, но использование списков с точкой требует совпадения с
определением макроса, например «<tt>. <i>var</i></tt>» или «<tt>&#x0026;rest <i>var</i></tt>». Таким образом
определение макроса с точкой, позволяет корректно обрабатывать
макровызовы и их подформы с точкой.
<!--l. 1530--><p class="indent" >   В Common Lisp&#x2019;е существует некоторое количество стандартных
макросов, и пользователь может определять свои макросы используя
<tt><a 
href="clmli7.html#x196-3479313r313">defmacro</a></tt>.
<!--l. 1533--><p class="indent" >   Макросы, предоставляемые реализацией Common Lisp&#x2019;а и описанные
здесь, могут раскрываться в код, который не будет являться переносимым
между реализациями. Вызов макроса является портабельным, в то время как
результат раскрытия нет.
<div class="implementation">
<!--l. 1538--><p class="noindent" ><b>Заметка для реализации:</b> Implementors are encouraged to implement the macros
deﬁned in this book, as far as is possible, in such a way that the expansion will not
contain any implementation-dependent special operators, nor contain as forms data
objects that are not considered to be forms in Common Lisp. The purpose of this
restriction is to ensure that the expansion can be processed by a program-analyzing
program in an implementation-independent manner. There is no problem with a macro
expansion containing calls to implementation-dependent functions. This restriction
is not a requirement of Common Lisp; it is recognized that certain complex
macros may be able to expand into signiﬁcantly more eﬃcient code in certain
implementations by using implementation-dependent special operators in the macro
expansion.
</div>
<!--l. 1556--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.5   </span> <a 
href="clmli1.html#QQ2-38-236" id="x38-2280005.1.5">Вызовы функций</a></h4>
<!--l. 1558--><p class="noindent" >Если список выполняется как форма, и первый элемент не является символом,
обозначающим специальную форму или макрос, тогда предполагается, что
список является <i>вызовом функции</i>. Первый элемент списка является именем
функции. Все следующие элементы списка будут вычислены. Одно значение
каждого вычисленного элемента будет является <i>аргументом</i> для
вызываемой функции. Затем функция будет <i>применена</i> к аргументам.
                                                                          

                                                                          
Вычисление функции обычно возвращает значение, однако вместо этого
может быть выполнен нелокальный выход, смотрите <tt>throw</tt>. Функция может
возвращать 0 и более значений, смотрите <tt><a 
href="clmli7.html#x196-3479984r984">values</a></tt>. Если и когда функция
возвращает значения, они становятся значениями вычисления формы вызова
функции.
<!--l. 1571--><p class="indent" >   Например, рассмотрим вычисление формы: <tt>(+ (* 4 5))</tt>. Символ <tt><a 
href="clmli7.html#x196-3479052r52">+</a></tt>
обозначает функцию сложения, а не специальную форму или макрос.
Таким образом две формы <tt>3</tt> и <tt>(* 4 5)</tt> вычисляются для аргументов.
Форма <tt>3</tt> вычисляется в <tt>3</tt>, а форма <tt>(* 4 5)</tt> является вызовом функции
(умножения). Таким образом формы <tt>4</tt> и <tt>5</tt> вычисляются сами в себя, тем
самым предоставляя аргументы для функции умножения. Функция
умножения вычисляет результат <tt>20</tt> и возвращает его. Значения <tt>3</tt> и <tt>20</tt>
становятся аргументами функции сложения, которая вычисляет и
возвращает результат <tt>23</tt>. Таким образом мы говорим <tt>(+3 (* 4 5))
<span class="math"> ⇒</span> 23</tt>.
<!--l. 1581--><p class="indent" >   Тогда как аргументы в вызове функции всегда выполняются слева
направо, поиск самой функции для вызова может производится как до
выполнения аргументов, так и после. Программы, которые полагаются на тот
факт, что поиск функции осуществляется перед выполнением аргументов,
являются ошибочными.
                                                                          

                                                                          
<!--l. 1586--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse29.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#tailclmch5.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse28.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse28.html"></a>  </div> </div> 
</body></html> 
