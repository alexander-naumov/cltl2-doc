<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Forms Формы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-22 01:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 40--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse29.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#tailclmch5.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse28.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse28.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
 id="x38-560005.1"></a>Forms Формы</h3>
<!--l. 42--><p class="noindent" >The standard unit of interaction with a Common Lisp implementation is the
<i>form</i>, which is simply a data object meant to be <i>evaluated</i> as a program to
produce one or more <i>values</i> (which are also data objects). One may request
evaluation of <i>any</i> data object, but only certain ones are meaningful. For instance,
symbols and lists are meaningful forms, while arrays normally are not. Examples
of meaningful forms are <i>3</i>, whose value is <i>3</i>, and <i>(+ 3 4)</i>, whose value is <i>7</i>. We
write <i>3</i>  ⇒ <i>3</i> and <i>(+ 3 4)</i>  ⇒ <i>7</i> to indicate these facts. ( ⇒ means “evaluates
to.”)
<!--l. 53--><p class="indent" >   Стандартная единица взаимодействия с реализацией Common Lisp&#x2019;а
является <i>форма</i>, которая является объектом данных, который выполняется
как программа для вычисления одного или более <i>значений</i> (который также
являются объектами данных). Запросить выполнение можно для <i>любого</i>
объекта данных, но не для всех это имеет смысл. Например, символы и
списки имеет смысл выполнять, тогда как массивы обычно нет. Примеры
содержательных форм: <i>3</i>, значение которой <i>3</i>, и <i>(+ 3 4)</i>, значение которой <i>7</i>.
Для обозначения этих фактов мы пишем <i>3</i>  ⇒ <i>3</i> и <i>(+ 3 4)</i>  ⇒ <i>7</i>.
( ⇒ означает «вычисляется в»)
<!--l. 63--><p class="indent" >   Meaningful forms may be divided into three categories: self-evaluating forms,
such as numbers; symbols, which stand for variables; and lists. The lists in turn
may be divided into three categories: special forms, macro calls, and function
calls.
<!--l. 68--><p class="indent" >   Содержательные формы могут быть разделены на три категории:
самовычисляемые формы, такие как числа, символы, которые используются
для переменных, и списки. Списки в свою очередь могут быть разделены
на три категории: специальные формы, вызовы макросов, вызовы
функций.
                                                                          

                                                                          
<div class=obsolete>
<!--l. 77--><p class="indent" >   Any Common Lisp data object not explicitly deﬁned here to be a valid
form is not a valid form. It is an error to evaluate anything but a valid
form.
<div class=implementation>
<!--l. 82--><p class="noindent" ><b>Implementation note:</b> An implementation is free to make implementation-dependent
extensions to the evaluator but is strongly encouraged to signal an error on any attempt
to evaluate anything but a valid form or an object for which a meaningful evaluation
extension has been purposely deﬁned.
</div>
</div>
<div class=newer>
<!--l. 93--><p class="indent" >   X3J13 voted in October 1988 ⟨<b>?</b>⟩ to specify that <i>all</i> standard Common Lisp
data objects other than symbols and lists (including <a 
href="clmse104.html#x128-170002r617">defstruct</a> structures deﬁned
without the <i>:type</i> option) are self-evaluating.
<!--l. 98--><p class="indent" >   Все стандартные объекты данных Common Lisp, не являющиеся
символами и списками (включая <a 
href="clmse104.html#x128-170002r617">defstruct</a> структуры, определенные без
опции <i>:type</i>) являются самовычисляемыми.
</div>
<!--l. 103--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.1   </span> <a 
 id="x38-570005.1.1"></a>Self-Evaluating Forms Самовычисляемые формы</h4>
<!--l. 105--><p class="noindent" >All numbers, characters, strings, and bit-vectors are <i>self-evaluating</i> forms. When
such an object is evaluated, that object (or possibly a copy in the case of numbers
or characters) is returned as the value of the form. The empty list <i>(</i><i>)</i>, which is
also the false value <a 
href="clmse31.html#x42-70002r19">nil</a>, is also a self-evaluating form: the value of <a 
href="clmse31.html#x42-70002r19">nil</a> is <a 
href="clmse31.html#x42-70002r19">nil</a>.
Keywords (symbols written with a leading colon) also evaluate to themselves: the
value of <i>:start</i> is <i>:start</i>.
<!--l. 115--><p class="indent" >   Все числа, строковые символы, строки и битовые векторы являются
<i>самовычисляемыми</i> формами. Когда данный объект вычисляется, тогда
объект (или возможно копия в случае с числами и строковыми символами)
возвращается в качестве значения данной формы. Пустой список <i>(</i><i>)</i>, который
также является значением false <a 
href="clmse31.html#x42-70002r19">nil</a>, также является самовычисляемой
формой: значение <a 
href="clmse31.html#x42-70002r19">nil</a> является <a 
href="clmse31.html#x42-70002r19">nil</a>. Ключевые символы (примечание
переводчика: не путать с ключевыми словами в других языках, в Common
Lisp&#x2019;е это вид символов) также вычисляюется сами в себя: значение <i>:start</i>
                                                                          

                                                                          
является <i>:start</i>.
<div class=newer>
<!--l. 127--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to clarify that it is an error to destructively
modify any object that appears as a constant in executable code, whether as a
self-evaluating form or within a <a 
href="clmse35.html#x47-78002r53">quote</a> special form.
</div>
<!--l. 133--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.2   </span> <a 
 id="x38-580005.1.2"></a>Variables Переменные</h4>
<!--l. 135--><p class="noindent" >Symbols are used as names of variables in Common Lisp programs. When a
symbol is evaluated as a form, the value of the variable it names is produced. For
example, after doing <i>(setq items 3)</i>, which assigns the value <i>3</i> to the variable
named items, then items  ⇒ <i>3</i>. Variables can be <i>assigned</i> to, as by <a 
href="clmse35.html#x47-79002r61">setq</a>, or
<i>bound</i>, as by <a 
href="clmse39.html#x51-83004r84">let</a>. Any program construct that binds a variable eﬀectively saves the
old value of the variable and causes it to have a new value, and on exit from the
construct the old value is reinstated.
<!--l. 145--><p class="indent" >   В Common Lisp программах символы используются в качестве имен
переменных. Когда символ вычисляется как форма, то в качестве результата
возвращается значение переменной, которую данный символ именовал.
Например, после выполнения <i>(setq items 3)</i>, которая присвоила значение <i>3</i>
переменой именованной символом items, форма items выполнится в <i>3</i> (items
 ⇒ <i>3</i>). Переменные могут <i>назначены</i> с помощью <a 
href="clmse35.html#x47-79002r61">setq</a> или <i>связаны</i> с помощью
<a 
href="clmse39.html#x51-83004r84">let</a>. Любая программная конструкция, которая связывает переменную,
сохраняет старое значение переменной, и назначает новое, и при выходе из
конструкции восстанавливается старое значение.
<!--l. 157--><p class="indent" >   There are actually two kinds of variables in Common Lisp, called <i>lexical</i> (or
<i>static</i>) variables and <i>special</i> (or <i>dynamic</i>) variables. At any given time
either or both kinds of variable with the same name may have a current
value. Which of the two kinds of variable is referred to when a symbol is
evaluated depends on the context of the evaluation. The general rule is that
if the symbol occurs textually within a program construct that creates
a <i>binding</i> for a variable of the same name, then the reference is to the
variable speciﬁed by the binding; if no such program construct textually
contains the reference, then it is taken to refer to the special variable of that
name.
<!--l. 168--><p class="indent" >   В Common Lisp&#x2019;е есть два вида переменных. Они называются <i>лексические</i>
                                                                          

                                                                          
(или <i>статические</i>) и <i>специальные</i> (или <i>динамические</i>). В одно время каждая
из или обе переменные с одинаковым именем могут иметь некоторое
значение. На какую переменную ссылается символ при его вычислении,
зависит от контекста выполнения. Главное правило заключается в
том, что если символ вычисляется по тексту в конструкции, которая
создала <i>связывание</i> для переменной с одинаковым именем, то символ
ссылается на переменную, обозначенную в этом связывании, если же по
тексту такой конструкции нет, то символ ссылается на специальную
переменную.
<!--l. 178--><p class="indent" >   The distinction between the two kinds of variable is one of scope and extent. A
lexically bound variable can be referred to <i>only</i> by forms occurring at any <i>place</i>
textually within the program construct that binds the variable. A dynamically
bound (special) variable can be referred to at any <i>time</i> from the time the binding
is made until the time evaluation of the construct that binds the variable
terminates. Therefore lexical binding of variables imposes a spatial limitation on
occurrences of references (but no temporal limitation, for the binding continues to
exist as long as the possibility of reference remains). Conversely, dynamic binding
of variables imposes a temporal limitation on occurrences of references (but
no spatial limitation). For more information on scope and extent, see
chapter <a 
href="clmch3.html#x25-430003">3<!--tex4ht:ref: SCOPE --></a>.
<!--l. 192--><p class="indent" >   Различие между двумя видами переменных заключается в области
видимости и продолжительности видимости. Лексически связанная
переменная может быть использована <i>только</i> по тексту в форме, которая
установила связывание. Динамически связанная (специальная) переменная
может быть использована в любое <i>время</i> между установкой связи и до
выполнения конструкции, которая упраздняет связывание. Таким образом
лексическое связывание переменных накладывает ограничение на
использование переменной только в некоторой текстовой области (но не на
временные ограничения, так связывание продолжает существовать, пока
возможно существование ссылки на переменную). И наоборот, динамическое
связывание переменных накладывает ограничение на временные рамки
использования переменной (но не на текстовую область). Для более
подробной информации смотрите главу <a 
href="clmch3.html#x25-430003">3<!--tex4ht:ref: SCOPE --></a>.
<!--l. 205--><p class="indent" >   The value a special variable has when there are currently no bindings of that
variable is called the <i>global</i> value of the (special) variable. A global value can be
given to a variable only by assignment, because a value given by binding is by
deﬁnition not global.
<!--l. 211--><p class="indent" >   Когда нет связываний, значение, которое имеет специальная переменная,
                                                                          

                                                                          
называется <i>глобальным</i> значением (специальной) переменной. Глобальное
значение может быть задано переменной только с помощью назначения,
потому что значение заданное связыванием по определению не глобально.
<!--l. 216--><p class="indent" >   It is possible for a special variable to have no value at all, in which case it is
said to be <i>unbound</i>. By default, every global variable is unbound unless and until
explicitly assigned a value, except for those global variables deﬁned in this book or
by the implementation already to have values when the Lisp system is ﬁrst
started. It is also possible to establish a binding of a special variable and then
cause that binding to be valueless by using the function <a 
href="clmse35.html#x47-79008r64">makunbound</a>. In this
situation the variable is also said to be “unbound,” although this is a misnomer;
precisely speaking, it is bound but valueless. It is an error to refer to a variable
that is unbound.
<!--l. 229--><p class="indent" >   Специальная переменная может вообще не иметь значения, в таком
случае, говориться, что они <i>несвязанная</i>. По умолчанию, каждая глобальная
переменная является несвязанной, пока значение не будет назначено явно, за
исключением переменных определенных в этой книге или реализацией,
которые уже имеют значения сразу после первого запуска Lisp машины.
Кроме того, существует возможность установки связывания специальной
переменной и затем упразднения этого связывания с помощью функции
<a 
href="clmse35.html#x47-79008r64">makunbound</a>. В такой ситуации переменная также называется «несвязанной»,
хотя это и неправильно, если быть точнее, переменная связана, но
без значения FIXME. Ссылка на несвязанную переменную является
ошибкой.
<div class=newer>
<!--l. 241--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify more precisely the eﬀects of referring
to an unbound variable.
<!--l. 244--><p class="indent" >   Reading an unbound variable or an undeﬁned function must be detected in the
highest safety setting (see the safety quality of the optimize declaration
speciﬁer) but the eﬀect is undeﬁned in any other safety setting. That
is, reading an unbound variable should signal an error and reading an
undeﬁned function should signal an error. (“Reading a function” includes
both references to the function using the <a 
href="clmse35.html#x47-78004r54">function</a> special form, such as
<a 
href="clmse151.html#x184-311004r904">f</a> in <i>(function f)</i>, and references to the function in a call, such as <a 
href="clmse151.html#x184-311004r904">f</a> in
<i>(f x y)</i>.)
<!--l. 255--><p class="indent" >   For the case of inline functions (in implementations where they are
supported), a permitted point of view is that performing the inlining constitutes
the read of the function, so that an <a 
href="clmse35.html#x47-78015r59">fboundp</a> check need not be done at
execution time. Put another way, the eﬀect of the application of <a 
href="clmse35.html#x47-79010r65">fmakunbound</a>
                                                                          

                                                                          
to a function name on potentially inlined references to that function is
undeﬁned.
<!--l. 263--><p class="indent" >   When an unbound variable is detected an error of type <a 
href="clmse156.html#x190-346055r1047">unbound-variable</a> is
signaled, and the name slot of the <a 
href="clmse156.html#x190-346055r1047">unbound-variable</a> condition is initialized to the
name of the oﬀending variable.
<!--l. 269--><p class="indent" >   When an undeﬁned function is detected an error of type <a 
href="clmse156.html#x190-346057r1048">undeﬁned-function</a> is
signaled, and the name slot of the <a 
href="clmse156.html#x190-346057r1048">undeﬁned-function</a> condition is initialized to
the name of the oﬀending function.
<!--l. 275--><p class="indent" >   The condition type unbound-slot, which inherits from <a 
href="clmse156.html#x190-346051r1045">cell-error</a>, has
an additional slot instance, which can be initialized using the <i>:instance</i>
keyword to <a 
href="clmse155.html#x189-340002r1002">make-condition</a>. The function unbound-slot-instance accesses this
slot.
<!--l. 280--><p class="indent" >   The type of error signaled by the default primary method for the CLOS
<a 
href="clmse151.html#x184-311154r979">slot-unbound</a> generic function is unbound-slot. The instance slot of the
unbound-slot condition is initialized to the oﬀending instance and the name slot is
initialized to the name of the oﬀending variable.
</div>
<!--l. 288--><p class="indent" >   Certain global variables are reserved as “named constants.” They have a global
value and may not be bound or assigned to. For example, the symbols <a 
href="clmse31.html#x42-70004r20">t</a> and <a 
href="clmse31.html#x42-70002r19">nil</a>
are reserved. One may not assign a value to <a 
href="clmse31.html#x42-70004r20">t</a> or <a 
href="clmse31.html#x42-70002r19">nil</a>, and one may not bind <a 
href="clmse31.html#x42-70004r20">t</a> or
<a 
href="clmse31.html#x42-70002r19">nil</a>. The global value of <a 
href="clmse31.html#x42-70004r20">t</a> is always <a 
href="clmse31.html#x42-70004r20">t</a>, and the global value of <a 
href="clmse31.html#x42-70002r19">nil</a> is always <a 
href="clmse31.html#x42-70002r19">nil</a>.
Constant symbols deﬁned by <a 
href="clmse30.html#x40-67006r16">defconstant</a> also become reserved and may not be
further assigned to or bound (although they may be redeﬁned, if necessary, by
using <a 
href="clmse30.html#x40-67006r16">defconstant</a> again). Keyword symbols, which are notated with a leading
colon, are reserved and may never be assigned to or bound; a keyword always
evaluates to itself.
<!--l. 303--><p class="indent" >   Некоторые глобальные переменные зарезервированы в качестве
«именованных констант». Они имеют глобальное значение и не могут быть
связаны или переназначены. Например символы <a 
href="clmse31.html#x42-70004r20">t</a> и <a 
href="clmse31.html#x42-70002r19">nil</a> зарезервированы.
Невозможно назначить и этим символам. Также невозможно связать эти
символы со другими значениями. Символы констант определенных с
помощью <a 
href="clmse30.html#x40-67006r16">defconstant</a> также становяться зарезервированными и не могут
быть переназначены или связаны (но они могут быть переопределены с
помощью вызова <a 
href="clmse30.html#x40-67006r16">defconstant</a>). Ключевые символы также не могут быть
переназначены или связаны, ключевые символы всегда вычисляются сами в
себя.
                                                                          

                                                                          
<!--l. 314--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.3   </span> <a 
 id="x38-590005.1.3"></a>Special Forms Специальные формы</h4>
<!--l. 316--><p class="noindent" >If a list is to be evaluated as a form, the ﬁrst step is to examine the ﬁrst element
of the list. If the ﬁrst element is one of the symbols appearing in table <a 
href="#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>, then
the list is called a <i>special form</i>. (This use of the word “special” is unrelated to its
use in the phrase “special variable.”)
<!--l. 322--><p class="indent" >   Если список выполняется в качестве формы, первым шагом является
определение первого элемента списка. Если первый элемент списка
является одним из символов, перечисленных в таблице <a 
href="#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>, тогда список
называется <i>специальной формой</i>. (Использование слова «специальный»
никак не связано с использованием этого слова в фразе «специальная
переменная».)
<!--l. 328--><p class="indent" >   Special forms are generally environment and control constructs. Every special
form has its own idiosyncratic syntax. An example is the <a 
href="clmse141.html#x172-248002r876">if</a> special form: <i>(if p (+ x
4) 5)</i> in Common Lisp means what “<b>if</b> <i>p</i> <b>then</b> <i>x</i>+4 <b>else</b> 5” means in
Algol.
<!--l. 335--><p class="indent" >   Специальные формы обычно являются окружениями и управляющими
конструкциями. Каждая специальная форма имеет свой идиосинкразитечский
синтаксис. Например специальная форма <a 
href="clmse141.html#x172-248002r876">if</a>: <i>(if p (+ x 4) 5)</i> в Common Lisp&#x2019;е
означает то же, что и «<b>if</b> <i>p</i> <b>then</b> <i>x</i>+4 <b>else</b> 5» означает в Algol&#x2019;е.
<!--l. 342--><p class="indent" >   The evaluation of a special form normally produces a value or values, but the
evaluation may instead call for a non-local exit; see <a 
href="clmse41.html#x53-85004r102">return-from</a>, <a 
href="clmse42.html#x54-91008r120">go</a>, and
<a 
href="clmse45.html#x57-96012r132">throw</a>.
<!--l. 346--><p class="indent" >   Выполнение специальной формы обычно возвращает значение или
значения, но выполнение может и вызвать нелокальный выход; смотрите
<a 
href="clmse41.html#x53-85004r102">return-from</a>, <a 
href="clmse42.html#x54-91008r120">go</a> и <a 
href="clmse45.html#x57-96012r132">throw</a>.
<!--l. 350--><p class="indent" >   The set of special forms is ﬁxed in Common Lisp; no way is provided for the
user to deﬁne more. The user can create new syntactic constructs, however, by
deﬁning macros.
<!--l. 354--><p class="indent" >   Множество специальных форм в Common Lisp&#x2019;е фиксировано. Создание
пользовательский специальных форм невозможно. Однако пользователь
может создавать новые синтаксические конструкции с помощью оперделения
макросов.
<!--l. 358--><p class="indent" >   The set of special forms in Common Lisp is purposely kept very small because
any program-analyzing program must have special knowledge about every type of
special form. Such a program needs no special knowledge about macros because it
is simple to expand the macro and operate on the resulting expansion. (This is
not to say that many such programs, particularly compilers, will not have such
                                                                          

                                                                          
special knowledge. A compiler may be able to produce much better code if it
recognizes such constructs as <a 
href="clmse40.html#x52-84012r100">typecase</a> and <a 
href="clmse44.html#x56-94014r127">multiple-value-bind</a> and gives them
customized treatment.)
<!--l. 369--><p class="indent" >   Множество специальных форм в Common Lisp&#x2019;е специально держится
малым, потому что любая программа, анализирующая программы, должна
содержить специальные знания он каждом типе специальной формы. Такие
программы не нуждаются в специальных знаниях о макросах, так как
раскрытие макроса просто, и далее остается только оперирования с
результатом раскрытия. (Это не значит, что программы, в частности,
компиляторы, не будут иметь специальных знаний о макросах. Компилятор
может генерировать более лучший код, если он распознает такие
конструкции, как <a 
href="clmse40.html#x52-84012r100">typecase</a> и <a 
href="clmse44.html#x56-94014r127">multiple-value-bind</a> и по особому будет
обращаться с ними.)
   <div class="table">
                                                                          

                                                                          
<!--l. 378--><p class="indent" >   <a 
 id="x38-590011"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 5.1: </span><span  
class="content">Names of All Common Lisp Special Forms</span></div><!--tex4ht:label?: x38-590011 -->
<div class="tabular"><table width="100%"><tr><td align="left" > <a 
href="clmse41.html#x53-85002r101">block</a>          </td><td align="left" ><a 
href="clmse141.html#x172-248002r876">if</a>                         </td><td align="left" ><a 
href="clmse39.html#x51-83014r89">progv</a>             </td>
</tr><tr><td align="left" > <a 
href="clmse45.html#x57-96006r130">catch</a>          </td><td align="left" ><a 
href="clmse39.html#x51-83022r93">labels</a>                   </td><td align="left" ><a 
href="clmse35.html#x47-78002r53">quote</a>             </td>
</tr><tr><td align="left" > [<a 
href="clmse39.html#x51-83012r88">compiler-let</a>]</td><td align="left" ><a 
href="clmse39.html#x51-83004r84">let</a>                       </td><td align="left" ><a 
href="clmse41.html#x53-85004r102">return-from</a>     </td>
</tr><tr><td align="left" > <a 
href="clmse51.html#x65-104002r151">declare</a>        </td><td align="left" ><i>let*</i>                    </td><td align="left" ><a 
href="clmse35.html#x47-79002r61">setq</a>               </td>
</tr><tr><td align="left" > <a 
href="clmse30.html#x40-68004r18">eval-when</a>    </td><td align="left" >macrolet               </td><td align="left" ><a 
href="clmse42.html#x54-91002r117">tagbody</a>         </td>
</tr><tr><td align="left" > ﬂet             </td><td align="left" ><a 
href="clmse44.html#x56-94010r125">multiple-value-call</a>   </td><td align="left" ><a 
href="clmse53.html#x67-106002r156">the</a>                </td>
</tr><tr><td align="left" > <a 
href="clmse35.html#x47-78004r54">function</a>      </td><td align="left" ><i>multiple-value-prog1</i></td><td align="left" ><a 
href="clmse45.html#x57-96012r132">throw</a>            </td>
</tr><tr><td align="left" > <a 
href="clmse42.html#x54-91008r120">go</a>              </td><td align="left" ><a 
href="clmse38.html#x50-82002r80">progn</a>                   </td><td align="left" ><a 
href="clmse45.html#x57-96010r131">unwind-protect</a></td></tr></table></div>
<div class=newer>
<!--l. 393--><p class="noindent" >X3J13 voted in June 1989 ⟨<b>?</b>⟩ to remove <a 
href="clmse39.html#x51-83012r88">compiler-let</a> from the language.
</div>
<div class=newer>
<!--l. 398--><p class="noindent" >X3J13 voted in June 1988 ⟨<b>?</b>⟩ to add the special forms <a 
href="clmse151.html#x184-311086r945">generic-ﬂet</a>, <a 
href="clmse151.html#x184-311090r947">generic-labels</a>,
<a 
href="clmse39.html#x51-83024r94">symbol-macrolet</a>, and <a 
href="clmse151.html#x184-311168r986">with-added-methods</a>.
</div>
<div class=newer>
<!--l. 403--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to make <a 
href="clmse51.html#x65-104006r153">locally</a> a special form rather than a
macro.
</div>
<div class=newer>
<!--l. 408--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to add the special form load-time-eval.
</div>
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<!--l. 413--><p class="indent" >   An implementation is free to implement as a macro any construct described
herein as a special form. Conversely, an implementation is free to implement as a
special form any construct described herein as a macro if an equivalent macro
deﬁnition is also provided. The practical consequence is that the predicates
<a 
href="clmse46.html#x59-98004r134">macro-function</a> and <a 
href="clmse35.html#x47-78017r60">special-form-p</a> may both be true of the same symbol. It is
recommended that a program-analyzing program process a form that is a list
whose <i>car</i> is a symbol as follows:
<!--l. 422--><p class="indent" >   Реализация может осуществлять как макросы любую конструкцию
описанную здесь как специальную форму. И наоборот, реализация может
осуществлять как специальную форму любую конструкцию описанную здесь
как макрос, при условии что также предоставляется эквивалентное
определение макроса. Практическое значение заключается в том, что
предикаты <a 
href="clmse46.html#x59-98004r134">macro-function</a> и <a 
href="clmse35.html#x47-78017r60">special-form-p</a> могут оба возвращать true
принимая один и тот же символ. Рекомендуется, чтобы программа для
анализа других программ обрабатывала форму являющуюся списком, <i>car</i>
которого является символом, следующим образом:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x38-59003x1">If the program has particular knowledge about the symbol, process the
      form using special-purpose code. All of the symbols listed in table <a 
href="#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>
      should fall into this category.
      </li>
      <li 
  class="enumerate" id="x38-59005x2">Если программа имеет подробные знания о символе, обрабатывать
      форму  необходимо  с  помощью  специализированного  кода.  Все
      символы,  перечисленные  в  таблице <a 
href="#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>  должны  попадать  под
      данную категорию.
      </li>
      <li 
  class="enumerate" id="x38-59007x3">Otherwise,  if  <a 
href="clmse46.html#x59-98004r134">macro-function</a>  is  true  of  the  symbol,  apply  either
      <a 
href="clmse47.html#x60-99002r136">macroexpand</a> or <i>macroexpand-1</i>, as appropriate, to the entire form and
      then start over.
      </li>
      <li 
  class="enumerate" id="x38-59009x4">В                    противном                    случае,                    если
      для этого символа <a 
href="clmse46.html#x59-98004r134">macro-function</a> вычисляется в true, необходимо
      применить <a 
href="clmse47.html#x60-99002r136">macroexpand</a> или <i>macroexpand-1</i> для раскрытия формы,
      и результат вновь анализировать.
                                                                          

                                                                          
      </li>
      <li 
  class="enumerate" id="x38-59011x5">Otherwise, assume it is a function call.
      </li>
      <li 
  class="enumerate" id="x38-59013x6">В  противном  случае,  необходимо  раценивать  форму  как  вызов
      функции.</li></ol>
   <h4 class="subsectionHead"><span class="titlemark">5.1.4   </span> <a 
 id="x38-600005.1.4"></a>Macros Макросы</h4>
<!--l. 462--><p class="noindent" >If a form is a list and the ﬁrst element is not the name of a special form, it may be
the name of a <i>macro</i>; if so, the form is said to be a <i>macro call</i>. A macro is
essentially a function from forms to forms that will, given a call to that macro,
compute a new form to be evaluated in place of the macro call. (This computation
is sometimes referred to as <i>macro expansion</i>.) For example, the macro named
<a 
href="clmse142.html#x173-249006r881">return</a> will take a form such as <i>(return x)</i> and from that form compute a
new form <i>(return-from <a 
href="clmse31.html#x42-70002r19">nil</a> x)</i>. We say that the old form <i>expands</i> into
the new form. The new form is then evaluated in place of the original
form; the value of the new form is returned as the value of the original
form.
<!--l. 475--><p class="indent" >   Если форма является списком и первый элемент не обозначает
специальную форму, возможно он является именем <i>макроса</i>. Если так, то
форма называется <i>макровызовом или вызовом марокса (macrocall)</i> FIXME.
Макрос это функция, которая принимает формы и возвращает формы.
Возвращенные формы подставляются в то место, где происходил
макровызов, и затем выполняются. (Этот процесс иногда называется
<i>раскрытием макроса</i>.) Например, макрос с именем <a 
href="clmse142.html#x173-249006r881">return</a> принимает
форма, вот так: <i>(return x)</i>, и полученная в результате раскрытия форма
такая: <i>(return-from <a 
href="clmse31.html#x42-70002r19">nil</a> x)</i>. Мы говорим: старая форма раскрылась в
новую. Новая форма будет вычислена на месте оригинальной формы.
Значение новой формы будет возвращено, как значение оригинальной
формы.
<div class=new>
<!--l. 488--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to clarify that macro calls, and subforms of
macro calls, need not be proper lists, but that use of dotted forms requires the
macro deﬁnition to use “<i>. <i>var</i></i>” or “<i>&#x0026;rest <i>var</i></i>” in order to match them properly. It
is then the responsibility of the macro deﬁnition to recognize and appropriately
handle such dotted forms or subforms.
</div>
                                                                          

                                                                          
<!--l. 498--><p class="indent" >   There are a number of standard macros in Common Lisp, and the user can
deﬁne more by using <a 
href="clmse46.html#x59-98006r135">defmacro</a>.
<!--l. 501--><p class="indent" >   В Common Lisp&#x2019;е существует некоторое количество стандартных
макросов, и пользователь может определять свои макросы используя
<a 
href="clmse46.html#x59-98006r135">defmacro</a>.
<!--l. 504--><p class="indent" >   Macros provided by a Common Lisp implementation as described herein may
expand into code that is not portable among diﬀering implementations. That is, a
macro call may be implementation-independent because the macro is deﬁned in
this book, but the expansion need not be.
<!--l. 509--><p class="indent" >   Макросы, предоставляемые реализацией Common Lisp&#x2019;а и описанные
здесь, могут раскрываться в код, которые не будет являться переносимым
между реализациями. Вызов макроса является портабельным, в то время как
результат раскрытия нет.
<div class=implementation>
<!--l. 514--><p class="noindent" ><b>Implementation note:</b> Implementors are encouraged to implement the macros deﬁned
in this book, as far as is possible, in such a way that the expansion will not contain any
implementation-dependent special forms, nor contain as forms data objects that are not
considered to be forms in Common Lisp. The purpose of this restriction is to
ensure that the expansion can be processed by a program-analyzing program in
an implementation-independent manner. There is no problem with a macro
expansion containing calls to implementation-dependent functions. This restriction
is not a requirement of Common Lisp; it is recognized that certain complex
macros may be able to expand into signiﬁcantly more eﬃcient code in certain
implementations by using implementation-dependent special forms in the macro
expansion.
</div>
<!--l. 532--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.5   </span> <a 
 id="x38-610005.1.5"></a>Function Calls Вызовы функций</h4>
<!--l. 534--><p class="noindent" >If a list is to be evaluated as a form and the ﬁrst element is not a symbol that
names a special form or macro, then the list is assumed to be a <i>function call</i>. The
ﬁrst element of the list is taken to name a function. Any and all remaining
elements of the list are forms to be evaluated; one value is obtained from each
form, and these values become the <i>arguments</i> to the function. The function is
then <i>applied</i> to the arguments. The functional computation normally produces a
value, but it may instead call for a non-local exit; see <a 
href="clmse45.html#x57-96012r132">throw</a>. A function that does
return may produce no value or several values; see <a 
href="clmse44.html#x56-94002r121">values</a>. If and when the
                                                                          

                                                                          
function returns, whatever values it returns become the values of the function-call
form.
<!--l. 549--><p class="indent" >   Если список выполняется как форма, и первый элемент не является
символом, обозначающим специальную форму или макрос, тогда
предполагается, что список является <i>вызовом функции</i>. Первый элемент
списка является именем функции. Все следующие элементы списка будут
вычислены. Одно значение каждого вычисленного элемента будет является
<i>аргументом</i> для вызываемой функции. Затем функция будет <i>применена</i> к
аргументам. Вычисление функции обычно возвращает значение, однако
вместо этого может быть выполнен нелокальный выход, смотрите <a 
href="clmse45.html#x57-96012r132">throw</a>.
Функция может возвращать 0 и более значений, смотрите <a 
href="clmse44.html#x56-94002r121">values</a>. Если и
когда функция возвращает значения, они становяться значениями
вычисления формы вызова функции.
<!--l. 562--><p class="indent" >   For example, consider the evaluation of the form <i>(+ 3 (* 4 5))</i>. The symbol <i>+</i>
names the addition function, not a special form or macro. Therefore the two forms
<i>3</i> and <i>(* 4 5)</i> are evaluated to produce arguments. The form <i>3</i> evaluates to <i>3</i>,
and the form <i>(* 4 5)</i> is a function call (to the multiplication function). Therefore
the forms <i>4</i> and <i>5</i> are evaluated, producing arguments <i>4</i> and <i>5</i> for the
multiplication. The multiplication function calculates the number <i>20</i> and returns
it. The values <i>3</i> and <i>20</i> are then given as arguments to the addition function,
which calculates and returns the number <i>23</i>. Therefore we say <i>(+ 3 (* 4 5))
 ⇒ 23</i>.
<!--l. 573--><p class="indent" >   Например, рассмотрим вычисление формы: <i>(+ (* 4 5))</i>. Символ <i>+</i>
обозначает функцию сложения, а не специальную форму или макрос.
Таким образом две формы <i>3</i> и <i>(* 4 5)</i> вычисляются для аргументов.
Форма <i>3</i> вычисляется в <i>3</i>, а форма <i>(* 4 5)</i> является вызовом функции
(умножения). Таким образом формы <i>4</i> и <i>5</i> вычисляются сами в себя, тем
самым предоставляя аргументы для функции умножения. Функция
умножения вычисляет результат <i>20</i> и возвращает его. Значения <i>3</i> и <i>20</i>
становяться аргументами функции сложения, которая вычисляет и
возвращает результат <i>23</i>. Таким образом мы говорим <i>(+3 (* 4 5))
 ⇒ 23</i>.
<div class=newer>
<!--l. 584--><p class="indent" >   X3J13 voted in October 1988 ⟨<b>?</b>⟩ to clarify that while the arguments in a
function call are always evaluated in strict left-to-right order, whether the
function to be called is determined before or after argument evaluation
is unspeciﬁed. Programs are in error that rely on a particular order of
evaluation of the ﬁrst element of a function call relative to the argument
                                                                          

                                                                          
forms.
</div>
                                                                          

                                                                          
   <!--l. 594--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse29.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#tailclmch5.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse28.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 594--><p class="indent" >   <a 
 id="tailclmse28.html"></a>  
</body></html> 
