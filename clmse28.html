<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Forms Формы</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 40--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse29.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#tailclmch5.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse28.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse28.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
 id="x38-560005.1"></a>Forms Формы</h3>
<!--l. 42--><p class="noindent" >The standard unit of interaction with a Common Lisp implementation is the
<i>form</i>, which is simply a data object meant to be <i>evaluated</i> as a program to
produce one or more <i>values</i> (which are also data objects). One may request
evaluation of <i>any</i> data object, but only certain ones are meaningful. For instance,
symbols and lists are meaningful forms, while arrays normally are not. Examples
of meaningful forms are <i>3</i>, whose value is <i>3</i>, and <i>(+ 3 4)</i>, whose value is <i>7</i>. We
write <i>3</i>  ⇒ <i>3</i> and <i>(+ 3 4)</i>  ⇒ <i>7</i> to indicate these facts. ( ⇒ means “evaluates
to.”)
<!--l. 53--><p class="indent" >   Стандартная единица взаимодействия с реализацией Common Lisp&#x2019;а
является <i>форма</i>, которая является объектом данных, который выполняется
как программа для вычисления одного или более <i>значений</i> (который также
являются объектами данных). Запросить выполнение можно для <i>любого</i>
объекта данных, но не для всех это имеет смысл. Например, символы и
списки имеет смысл выполнять, тогда как массивы обычно нет. Примеры
содержательных форм: <i>3</i>, значение которой <i>3</i>, и <i>(+ 3 4)</i>, значение которой <i>7</i>.
Для обозначения этих фактов мы пишем <i>3</i>  ⇒ <i>3</i> и <i>(+ 3 4)</i>  ⇒ <i>7</i>.
( ⇒ означает «вычисляется в»)
<!--l. 63--><p class="indent" >   Meaningful forms may be divided into three categories: self-evaluating forms,
such as numbers; symbols, which stand for variables; and lists. The lists in turn
may be divided into three categories: special forms, macro calls, and function
calls.
<!--l. 68--><p class="indent" >   Содержательные формы могут быть разделены на три категории:
самовычисляемые формы, такие как числа, символы, которые используются
для переменных, и списки. Списки в свою очередь могут быть разделены
на три категории: специальные формы, вызовы макросов, вызовы
функций.
<div class=obsolete>
                                                                          

                                                                          
<!--l. 77--><p class="indent" >   Any Common Lisp data object not explicitly deﬁned here to be a valid
form is not a valid form. It is an error to evaluate anything but a valid
form.
<div class=implementation>
<!--l. 82--><p class="noindent" ><b>Implementation note:</b> An implementation is free to make implementation-dependent
extensions to the evaluator but is strongly encouraged to signal an error on any attempt
to evaluate anything but a valid form or an object for which a meaningful evaluation
extension has been purposely deﬁned.
</div>
</div>
<div class=newer>
<!--l. 93--><p class="indent" >   X3J13 voted in October 1988 ⟨<b>?</b>⟩ to specify that <i>all</i> standard Common Lisp
data objects other than symbols and lists (including <i>defstruct</i> structures deﬁned
without the <i>:type</i> option) are self-evaluating.
<!--l. 98--><p class="indent" >   Все стандартные объекты данных Common Lisp, не являющиеся
символами и списками (включая <i>defstruct</i> структуры, определенные без
опции <i>:type</i>) являются самовычисляемыми.
</div>
<!--l. 103--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.1   </span> <a 
 id="x38-570005.1.1"></a>Self-Evaluating Forms Самовычисляемые формы</h4>
<!--l. 105--><p class="noindent" >All numbers, characters, strings, and bit-vectors are <i>self-evaluating</i> forms. When
such an object is evaluated, that object (or possibly a copy in the case of numbers
or characters) is returned as the value of the form. The empty list <i>(</i><i>)</i>, which is
also the false value <i>nil</i>, is also a self-evaluating form: the value of <i>nil</i> is <i>nil</i>.
Keywords (symbols written with a leading colon) also evaluate to themselves: the
value of <i>:start</i> is <i>:start</i>.
<!--l. 115--><p class="indent" >   Все числа, строковые символы, строки и битовые векторы являются
<i>самовычисляемыми</i> формами. Когда данный объект вычисляется, тогда
объект (или возможно копия в случае с числами и строковыми символами)
возвращается в качестве значения данной формы. Пустой список <i>(</i><i>)</i>, который
также является значением false <i>nil</i>, также является самовычисляемой
формой: значение <i>nil</i> является <i>nil</i>. Ключевые символы (примечание
переводчика: не путать с ключевыми словами в других языках, в Common
Lisp&#x2019;е это вид символов) также вычисляюется сами в себя: значение <i>:start</i>
является <i>:start</i>.
                                                                          

                                                                          
<div class=newer>
<!--l. 127--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to clarify that it is an error to destructively
modify any object that appears as a constant in executable code, whether as a
self-evaluating form or within a <i>quote</i> special form.
</div>
<!--l. 133--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.2   </span> <a 
 id="x38-580005.1.2"></a>Variables Переменные</h4>
<!--l. 135--><p class="noindent" >Symbols are used as names of variables in Common Lisp programs. When a
symbol is evaluated as a form, the value of the variable it names is produced. For
example, after doing <i>(setq items 3)</i>, which assigns the value <i>3</i> to the variable
named <i>items</i>, then <i>items</i>  ⇒ <i>3</i>. Variables can be <i>assigned</i> to, as by <i>setq</i>, or
<i>bound</i>, as by <i>let</i>. Any program construct that binds a variable eﬀectively saves the
old value of the variable and causes it to have a new value, and on exit from the
construct the old value is reinstated.
<!--l. 145--><p class="indent" >   В Common Lisp программах символы используются в качестве имен
переменных. Когда символ вычисляется как форма, то в качестве результата
возвращается значение переменной, которую данный символ именовал.
Например, после выполнения <i>(setq items 3)</i>, которая присвоила значение <i>3</i>
переменой именованной символом <i>items</i>, форма <i>items</i> выполнится в <i>3</i> (<i>items</i>
 ⇒ <i>3</i>). Переменные могут <i>назначены</i> с помощью <i>setq</i> или <i>связаны</i> с помощью
<i>let</i>. Любая программная конструкция, которая связывает переменную,
сохраняет старое значение переменной, и назначает новое, и при выходе из
конструкции восстанавливается старое значение.
<!--l. 157--><p class="indent" >   There are actually two kinds of variables in Common Lisp, called <i>lexical</i> (or
<i>static</i>) variables and <i>special</i> (or <i>dynamic</i>) variables. At any given time
either or both kinds of variable with the same name may have a current
value. Which of the two kinds of variable is referred to when a symbol is
evaluated depends on the context of the evaluation. The general rule is that
if the symbol occurs textually within a program construct that creates
a <i>binding</i> for a variable of the same name, then the reference is to the
variable speciﬁed by the binding; if no such program construct textually
contains the reference, then it is taken to refer to the special variable of that
name.
<!--l. 168--><p class="indent" >   В Common Lisp&#x2019;е есть два вида переменных. Они называются <i>лексические</i>
(или <i>статические</i>) и <i>специальные</i> (или <i>динамические</i>). В одно время каждая
                                                                          

                                                                          
из или обе переменные с одинаковым именем могут иметь некоторое
значение. На какую переменную ссылается символ при его вычислении,
зависит от контекста выполнения. Главное правило заключается в
том, что если символ вычисляется по тексту в конструкции, которая
создала <i>связывание</i> для переменной с одинаковым именем, то символ
ссылается на переменную, обозначенную в этом связывании, если же по
тексту такой конструкции нет, то символ ссылается на специальную
переменную.
<!--l. 178--><p class="indent" >   The distinction between the two kinds of variable is one of scope and extent. A
lexically bound variable can be referred to <i>only</i> by forms occurring at any <i>place</i>
textually within the program construct that binds the variable. A dynamically
bound (special) variable can be referred to at any <i>time</i> from the time the binding
is made until the time evaluation of the construct that binds the variable
terminates. Therefore lexical binding of variables imposes a spatial limitation on
occurrences of references (but no temporal limitation, for the binding continues to
exist as long as the possibility of reference remains). Conversely, dynamic binding
of variables imposes a temporal limitation on occurrences of references (but
no spatial limitation). For more information on scope and extent, see
chapter <a 
href="clmch3.html#x25-430003">3<!--tex4ht:ref: SCOPE --></a>.
<!--l. 192--><p class="indent" >   Различие между двумя видами переменных заключается в области
видимости и продолжительности видимости. Лексически связанная
переменная может быть использована <i>только</i> по тексту в форме, которая
установила связывание. Динамически связанная (специальная) переменная
может быть использована в любое <i>время</i> между установкой связи и до
выполнения конструкции, которая упраздняет связывание. Таким образом
лексическое связывание переменных накладывает ограничение на
использование переменной только в некоторой текстовой области (но не на
временные ограничения, так связывание продолжает существовать, пока
возможно существование ссылки на переменную). И наоборот, динамическое
связывание переменных накладывает ограничение на временные рамки
использования переменной (но не на текстовую область). Для более
подробной информации смотрите главу <a 
href="clmch3.html#x25-430003">3<!--tex4ht:ref: SCOPE --></a>.
<!--l. 205--><p class="indent" >   The value a special variable has when there are currently no bindings of that
variable is called the <i>global</i> value of the (special) variable. A global value can be
given to a variable only by assignment, because a value given by binding is by
deﬁnition not global.
<!--l. 211--><p class="indent" >   Когда нет связываний, значение, которое имеет специальная переменная,
называется <i>глобальным</i> значением (специальной) переменной. Глобальное
                                                                          

                                                                          
значение может быть задано переменной только с помощью назначения,
потому что значение заданное связыванием по определению не глобально.
<!--l. 216--><p class="indent" >   It is possible for a special variable to have no value at all, in which case it is
said to be <i>unbound</i>. By default, every global variable is unbound unless and until
explicitly assigned a value, except for those global variables deﬁned in this book or
by the implementation already to have values when the Lisp system is ﬁrst
started. It is also possible to establish a binding of a special variable and then
cause that binding to be valueless by using the function <i>makunbound</i>. In this
situation the variable is also said to be “unbound,” although this is a misnomer;
precisely speaking, it is bound but valueless. It is an error to refer to a variable
that is unbound.
<!--l. 229--><p class="indent" >   Специальная переменная может вообще не иметь значения, в таком
случае, говориться, что они <i>несвязанная</i>. По умолчанию, каждая глобальная
переменная является несвязанной, пока значение не будет назначено явно, за
исключением переменных определенных в этой книге или реализацией,
которые уже имеют значения сразу после первого запуска Lisp машины.
Кроме того, существует возможность установки связывания специальной
переменной и затем упразднения этого связывания с помощью функции
<i>makunbound</i>. В такой ситуации переменная также называется «несвязанной»,
хотя это и неправильно, если быть точнее, переменная связана, но
без значения FIXME. Ссылка на несвязанную переменную является
ошибкой.
<div class=newer>
<!--l. 241--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to specify more precisely the eﬀects of referring
to an unbound variable.
<!--l. 244--><p class="indent" >   Reading an unbound variable or an undeﬁned function must be detected in the
highest safety setting (see the <i>safety</i> quality of the <i>optimize</i> declaration
speciﬁer) but the eﬀect is undeﬁned in any other safety setting. That
is, reading an unbound variable should signal an error and reading an
undeﬁned function should signal an error. (“Reading a function” includes
both references to the function using the <i>function</i> special form, such as
<i>f </i> in <i>(function f)</i>, and references to the function in a call, such as <i>f </i> in
<i>(f x y)</i>.)
<!--l. 255--><p class="indent" >   For the case of <i>inline</i> functions (in implementations where they are
supported), a permitted point of view is that performing the inlining constitutes
the read of the function, so that an <i>fboundp</i> check need not be done at
execution time. Put another way, the eﬀect of the application of <i>fmakunbound</i>
to a function name on potentially inlined references to that function is
                                                                          

                                                                          
undeﬁned.
<!--l. 263--><p class="indent" >   When an unbound variable is detected an error of type <i>unbound-variable</i> is
signaled, and the <i>name</i> slot of the <i>unbound-variable</i> condition is initialized to the
name of the oﬀending variable.
<!--l. 269--><p class="indent" >   When an undeﬁned function is detected an error of type <i>undeﬁned-function</i> is
signaled, and the <i>name</i> slot of the <i>undeﬁned-function</i> condition is initialized to
the name of the oﬀending function.
<!--l. 275--><p class="indent" >   The condition type <i>unbound-slot</i>, which inherits from <i>cell-error</i>, has
an additional slot <i>instance</i>, which can be initialized using the <i>:instance</i>
keyword to <i>make-condition</i>. The function <i>unbound-slot-instance</i> accesses this
slot.
<!--l. 280--><p class="indent" >   The type of error signaled by the default primary method for the CLOS
<i>slot-unbound</i> generic function is <i>unbound-slot</i>. The <i>instance</i> slot of the
<i>unbound-slot</i> condition is initialized to the oﬀending instance and the <i>name</i> slot is
initialized to the name of the oﬀending variable.
</div>
<!--l. 288--><p class="indent" >   Certain global variables are reserved as “named constants.” They have a global
value and may not be bound or assigned to. For example, the symbols <i>t</i> and <i>nil</i>
are reserved. One may not assign a value to <i>t</i> or <i>nil</i>, and one may not bind <i>t</i> or
<i>nil</i>. The global value of <i>t</i> is always <i>t</i>, and the global value of <i>nil</i> is always <i>nil</i>.
Constant symbols deﬁned by <i>defconstant</i> also become reserved and may not be
further assigned to or bound (although they may be redeﬁned, if necessary, by
using <i>defconstant</i> again). Keyword symbols, which are notated with a leading
colon, are reserved and may never be assigned to or bound; a keyword always
evaluates to itself.
<!--l. 303--><p class="indent" >   Некоторые глобальные переменные зарезервированы в качестве
«именованных констант». Они имеют глобальное значение и не могут быть
связаны или переназначены. Например символы <i>t</i> и <i>nil</i> зарезервированы.
Невозможно назначить и этим символам. Также невозможно связать эти
символы со другими значениями. Символы констант определенных с
помощью <i>defconstant</i> также становяться зарезервированными и не могут
быть переназначены или связаны (но они могут быть переопределены с
помощью вызова <i>defconstant</i>). Ключевые символы также не могут быть
переназначены или связаны, ключевые символы всегда вычисляются сами в
себя.
                                                                          

                                                                          
<!--l. 314--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.3   </span> <a 
 id="x38-590005.1.3"></a>Special Forms Специальные формы</h4>
<!--l. 316--><p class="noindent" >If a list is to be evaluated as a form, the ﬁrst step is to examine the ﬁrst element
of the list. If the ﬁrst element is one of the symbols appearing in table <a 
href="#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>, then
the list is called a <i>special form</i>. (This use of the word “special” is unrelated to its
use in the phrase “special variable.”)
<!--l. 322--><p class="indent" >   Если список выполняется в качестве формы, первым шагом является
определение первого элемента списка. Если первый элемент списка
является одним из символов, перечисленных в таблице <a 
href="#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>, тогда список
называется <i>специальной формой</i>. (Использование слова «специальный»
никак не связано с использованием этого слова в фразе «специальная
переменная».)
<!--l. 328--><p class="indent" >   Special forms are generally environment and control constructs. Every special
form has its own idiosyncratic syntax. An example is the <i>if </i> special form: <i>(if p (+
x 4) 5)</i> in Common Lisp means what “<b>if</b> <i>p</i> <b>then</b> <i>x</i>+4 <b>else</b> 5” means in
Algol.
<!--l. 335--><p class="indent" >   Специальные формы обычно являются окружениями и управляющими
конструкциями. Каждая специальная форма имеет свой идиосинкразитечский
синтаксис. Например специальная форма <i>if </i>: <i>(if p (+ x 4) 5)</i> в Common Lisp&#x2019;е
означает то же, что и «<b>if</b> <i>p</i> <b>then</b> <i>x</i>+4 <b>else</b> 5» означает в Algol&#x2019;е.
<!--l. 342--><p class="indent" >   The evaluation of a special form normally produces a value or values, but the
evaluation may instead call for a non-local exit; see <i>return-from</i>, <i>go</i>, and
<i>throw</i>.
<!--l. 346--><p class="indent" >   Выполнение специальной формы обычно возвращает значение или
значения, но выполнение может и вызвать нелокальный выход; смотрите
<i>return-from</i>, <i>go</i> и <i>throw</i>.
<!--l. 350--><p class="indent" >   The set of special forms is ﬁxed in Common Lisp; no way is provided for the
user to deﬁne more. The user can create new syntactic constructs, however, by
deﬁning macros.
<!--l. 354--><p class="indent" >   Множество специальных форм в Common Lisp&#x2019;е фиксировано. Создание
пользовательский специальных форм невозможно. Однако пользователь
может создавать новые синтаксические конструкции с помощью оперделения
макросов.
<!--l. 358--><p class="indent" >   The set of special forms in Common Lisp is purposely kept very small because
any program-analyzing program must have special knowledge about every type of
special form. Such a program needs no special knowledge about macros because it
is simple to expand the macro and operate on the resulting expansion. (This is
not to say that many such programs, particularly compilers, will not have such
                                                                          

                                                                          
special knowledge. A compiler may be able to produce much better code if it
recognizes such constructs as <i>typecase</i> and <i>multiple-value-bind</i> and gives them
customized treatment.)
<!--l. 369--><p class="indent" >   Множество специальных форм в Common Lisp&#x2019;е специально держится
малым, потому что любая программа, анализирующая программы, должна
содержить специальные знания он каждом типе специальной формы. Такие
программы не нуждаются в специальных знаниях о макросах, так как
раскрытие макроса просто, и далее остается только оперирования с
результатом раскрытия. (Это не значит, что программы, в частности,
компиляторы, не будут иметь специальных знаний о макросах. Компилятор
может генерировать более лучший код, если он распознает такие
конструкции, как <i>typecase</i> и <i>multiple-value-bind</i> и по особому будет
обращаться с ними.)
   <div class="table">
                                                                          

                                                                          
<!--l. 378--><p class="indent" >   <a 
 id="x38-590011"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
 <div class="caption" 
><span class="id">Table 5.1: </span><span  
class="content">Names of All Common Lisp Special Forms</span></div><!--tex4ht:label?: x38-590011 -->
<div class="tabular"><table width="100%"><tr><td align="left" > <i>block</i>          </td><td align="left" ><i>if </i>                      </td><td align="left" ><i>progv</i>            </td>
</tr><tr><td align="left" > <i>catch</i>          </td><td align="left" ><i>labels</i>                  </td><td align="left" ><i>quote</i>            </td>
</tr><tr><td align="left" > [<i>compiler-let</i>]</td><td align="left" ><i>let</i>                      </td><td align="left" ><i>return-from</i>    </td>
</tr><tr><td align="left" > <i>declare</i>        </td><td align="left" ><i>let*</i>                    </td><td align="left" ><i>setq</i>             </td>
</tr><tr><td align="left" > <i>eval-when</i>    </td><td align="left" ><i>macrolet</i>              </td><td align="left" ><i>tagbody</i>         </td>
</tr><tr><td align="left" > <i>ﬂet</i>            </td><td align="left" ><i>multiple-value-call</i>  </td><td align="left" ><i>the</i>              </td>
</tr><tr><td align="left" > <i>function</i>      </td><td align="left" ><i>multiple-value-prog1</i></td><td align="left" ><i>throw</i>           </td>
</tr><tr><td align="left" > <i>go</i>             </td><td align="left" ><i>progn</i>                  </td><td align="left" ><i>unwind-protect</i></td></tr></table></div>
<div class=newer>
<!--l. 393--><p class="noindent" >X3J13 voted in June 1989 ⟨<b>?</b>⟩ to remove <i>compiler-let</i> from the language.
</div>
<div class=newer>
<!--l. 398--><p class="noindent" >X3J13 voted in June 1988 ⟨<b>?</b>⟩ to add the special forms <i>generic-ﬂet</i>, <i>generic-labels</i>,
<i>symbol-macrolet</i>, and <i>with-added-methods</i>.
</div>
<div class=newer>
<!--l. 403--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to make <i>locally</i> a special form rather than a
macro.
</div>
<div class=newer>
<!--l. 408--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to add the special form <i>load-time-eval</i>.
</div>
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
<!--l. 413--><p class="indent" >   An implementation is free to implement as a macro any construct described
herein as a special form. Conversely, an implementation is free to implement as a
special form any construct described herein as a macro if an equivalent macro
deﬁnition is also provided. The practical consequence is that the predicates
<i>macro-function</i> and <i>special-form-p</i> may both be true of the same symbol. It is
recommended that a program-analyzing program process a form that is a list
whose <i>car</i> is a symbol as follows:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x38-59003x1">If the program has particular knowledge about the symbol, process the
      form using special-purpose code. All of the symbols listed in table <a 
href="#x38-590011">5.1<!--tex4ht:ref: SPECIAL-FORM-TABLE --></a>
      should fall into this category.
      </li>
      <li 
  class="enumerate" id="x38-59005x2">Otherwise,  if  <i>macro-function</i>  is  true  of  the  symbol,  apply  either
      <i>macroexpand</i> or <i>macroexpand-1</i>, as appropriate, to the entire form and
      then start over.
      </li>
      <li 
  class="enumerate" id="x38-59007x3">Otherwise, assume it is a function call.</li></ol>
   <h4 class="subsectionHead"><span class="titlemark">5.1.4   </span> <a 
 id="x38-600005.1.4"></a>Macros</h4>
<!--l. 439--><p class="noindent" >If a form is a list and the ﬁrst element is not the name of a special form, it may be
the name of a <i>macro</i>; if so, the form is said to be a <i>macro call</i>. A macro is
essentially a function from forms to forms that will, given a call to that macro,
compute a new form to be evaluated in place of the macro call. (This computation
is sometimes referred to as <i>macro expansion</i>.) For example, the macro named
<i>return</i> will take a form such as <i>(return x)</i> and from that form compute a
new form <i>(return-from <i>nil</i> x)</i>. We say that the old form <i>expands</i> into
the new form. The new form is then evaluated in place of the original
form; the value of the new form is returned as the value of the original
form.
<div class=new>
<!--l. 453--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to clarify that macro calls, and subforms of
macro calls, need not be proper lists, but that use of dotted forms requires the
                                                                          

                                                                          
macro deﬁnition to use “<i>. <i>var</i></i>” or “<i>&#x0026;rest <i>var</i></i>” in order to match them properly. It
is then the responsibility of the macro deﬁnition to recognize and appropriately
handle such dotted forms or subforms.
</div>
<!--l. 463--><p class="indent" >   There are a number of standard macros in Common Lisp, and the user can
deﬁne more by using <i>defmacro</i>.
<!--l. 466--><p class="indent" >   Macros provided by a Common Lisp implementation as described herein may
expand into code that is not portable among diﬀering implementations. That is, a
macro call may be implementation-independent because the macro is deﬁned in
this book, but the expansion need not be.
<div class=implementation>
<!--l. 472--><p class="noindent" ><b>Implementation note:</b> Implementors are encouraged to implement the macros deﬁned
in this book, as far as is possible, in such a way that the expansion will not contain any
implementation-dependent special forms, nor contain as forms data objects that are not
considered to be forms in Common Lisp. The purpose of this restriction is to
ensure that the expansion can be processed by a program-analyzing program in
an implementation-independent manner. There is no problem with a macro
expansion containing calls to implementation-dependent functions. This restriction
is not a requirement of Common Lisp; it is recognized that certain complex
macros may be able to expand into signiﬁcantly more eﬃcient code in certain
implementations by using implementation-dependent special forms in the macro
expansion.
</div>
<!--l. 490--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">5.1.5   </span> <a 
 id="x38-610005.1.5"></a>Function Calls</h4>
<!--l. 492--><p class="noindent" >If a list is to be evaluated as a form and the ﬁrst element is not a symbol that
names a special form or macro, then the list is assumed to be a <i>function call</i>. The
ﬁrst element of the list is taken to name a function. Any and all remaining
elements of the list are forms to be evaluated; one value is obtained from each
form, and these values become the <i>arguments</i> to the function. The function is
then <i>applied</i> to the arguments. The functional computation normally produces a
value, but it may instead call for a non-local exit; see <i>throw</i>. A function that does
return may produce no value or several values; see <i>values</i>. If and when the
function returns, whatever values it returns become the values of the function-call
form.
<!--l. 508--><p class="indent" >   For example, consider the evaluation of the form <i>(+ 3 (* 4 5))</i>. The symbol <i>+</i>
                                                                          

                                                                          
names the addition function, not a special form or macro. Therefore the two forms
<i>3</i> and <i>(* 4 5)</i> are evaluated to produce arguments. The form <i>3</i> evaluates to <i>3</i>,
and the form <i>(* 4 5)</i> is a function call (to the multiplication function). Therefore
the forms <i>4</i> and <i>5</i> are evaluated, producing arguments <i>4</i> and <i>5</i> for the
multiplication. The multiplication function calculates the number <i>20</i> and returns
it. The values <i>3</i> and <i>20</i> are then given as arguments to the addition function,
which calculates and returns the number <i>23</i>. Therefore we say <i>(+ 3 (* 4 5))
 ⇒ 23</i>.
<div class=newer>
<!--l. 520--><p class="indent" >   X3J13 voted in October 1988 ⟨<b>?</b>⟩ to clarify that while the arguments in a
function call are always evaluated in strict left-to-right order, whether the
function to be called is determined before or after argument evaluation
is unspeciﬁed. Programs are in error that rely on a particular order of
evaluation of the ﬁrst element of a function call relative to the argument
forms.
</div>
                                                                          

                                                                          
   <!--l. 530--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse29.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#tailclmch5.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse28.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch5.html#clmse28.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 530--><p class="indent" >   <a 
 id="tailclmse28.html"></a>  
</body></html> 
