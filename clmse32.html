<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Data Type Predicates</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 72--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse33.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html#tailclmse31.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse32.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse32.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">6.2   </span> <a 
 id="x43-710006.2"></a>Data Type Predicates</h3>
<!--l. 74--><p class="noindent" >Perhaps the most important predicates in Lisp are those that deal with data
types; that is, given a data object one can determine whether or not it belongs to
a given type, or one can compare two type speciﬁers.
<!--l. 78--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.1   </span> <a 
 id="x43-720006.2.1"></a>General Type Predicates</h4>
<!--l. 80--><p class="noindent" >If a data type is viewed as the set of all objects belonging to the type, then
the <i>typep</i> function is a set membership test, while <i>subtypep</i> is a subset
test.
<div class=defun>
<!--l. 84--><p class="noindent" > <i>[Function]</i>   <b>typep</b> <a 
 id="dx43-72001"></a><a 
 id="x43-72002r22"></a>   <i>object</i>  <i>type</i>
<!--l. 86--><p class="noindent" ><i>typep</i> is a predicate that is true if object is of type type, and is false otherwise.
Note that an object can be “of” more than one type, since one type can
include another. The type may be any of the type speciﬁers mentioned
in chapter <a 
href="clmch4.html#x26-440004">4<!--tex4ht:ref: DTSPEC --></a> except that it may not be or contain a type speciﬁer list
whose ﬁrst element is <i>function</i> or <i>values</i>. A speciﬁer of the form <i>(satisﬁes
fn)</i> is handled simply by applying the function fn to object (see <i>funcall</i>);
the object is considered to be of the speciﬁed type if the result is not
<i>nil</i>.
<div class=new>
<!--l. 100--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to change <i>typep</i> to give specialized
<i>array</i> and <i>complex</i> type speciﬁers the same meaning for purposes of type
discrimination as they have for declaration purposes. Of course, this also applies
to such type speciﬁers as <i>vector</i> and <i>simple-array</i> (see section <a 
href="clmse22.html#x31-490004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>). Thus <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(typep foo &#x2019;(array bignum))
</td></tr></table>
                                                                          

                                                                          
<!--l. 111--><p class="indent" >
</div>
</div>
<!--l. 112--><p class="noindent" >in the ﬁrst edition asked the question, Is <i>foo</i> an array specialized to hold
bignums? but under the new interpretation asks the question, Could the array
<i>foo</i> have resulted from giving <i>bignum</i> as the <i>:element-type</i> argument to
<i>make-array</i>?
</div>
</div>
<div class=defun>
<!--l. 120--><p class="noindent" > <i>[Function]</i>   <b>subtypep</b> <a 
 id="dx43-72003"></a><a 
 id="x43-72004r23"></a>   <i>type1</i>  <i>type2</i>
<!--l. 122--><p class="noindent" >The arguments must be type speciﬁers that are acceptable to <i>typep</i>. The two type
speciﬁers are compared; this predicate is true if type1 is deﬁnitely a (not
necessarily proper) subtype of type2. If the result is <i>nil</i>, however, then type1 may
or may not be a subtype of type2 (sometimes it is impossible to tell, especially
when <i>satisﬁes</i> type speciﬁers are involved). A second returned value indicates the
certainty of the result; if it is true, then the ﬁrst value is an accurate indication of
the subtype relationship. Thus there are three possible result combinations:
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:74;" 
class="tabbing"><i>t</i>           </td><td style="width:74;" 
class="tabbing"><i>t</i>           </td><td  
class="tabbing">type1 is deﬁnitely a subtype of type2
</td></tr></table>
<!--l. 135--><p class="indent" >                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:74;" 
class="tabbing"><i>nil</i>        </td><td style="width:74;" 
class="tabbing"><i>t</i>           </td><td  
class="tabbing">type1 is deﬁnitely not a subtype of type2</td></tr></table>
<!--l. 136--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:74;" 
class="tabbing"><i>nil</i>        </td><td style="width:74;" 
class="tabbing"><i>nil</i>        </td><td  
class="tabbing"><i>subtypep</i> could not determine the relationship</td></tr></table>
<!--l. 138--><p class="indent" >
</div>
<div class=new>
<!--l. 141--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to place certain requirements upon the
implementation of <i>subtypep</i>, for it noted that implementations in many cases
simply “give up” and return the two values <i>nil</i> and <i>nil</i> when in fact it would have
been possible to determine the relationship between the given types. The
requirements are as follows, where it is understood that a type speciﬁer s
involves a type speciﬁer u if either s contains an occurrence of u directly or s
contains a type speciﬁer w deﬁned by <i>deftype</i> whose expansion involves
u.
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize"><i>subtypep</i> is not permitted to return a second value of <i>nil</i> unless one or
      both of its arguments involves <i>satisﬁes</i>, <i>and</i>, <i>or</i>, <i>not</i>, or <i>member</i>.
      </li>
      <li class="itemize"><i>subtypep</i> should signal an error when one or both of its arguments
      involves <i>values</i> or the list form of the <i>function</i> type speciﬁer.
      </li>
      <li class="itemize"><i>subtypep</i> must always return the two values <i>t</i> and <i>t</i> in the case where its
      arguments, after expansion of speciﬁers deﬁned by <i>deftype</i>, are <i>equal</i>.</li></ul>
<!--l. 161--><p class="noindent" >In addition, X3J13 voted to clarify that in some cases the relationships between types
as reﬂected by <i>subtypep</i> may be implementation-speciﬁc. For example, in an
implementation supporting only one type of ﬂoating-point number, <i>(subtypep
&#x2019;ﬂoat &#x2019;long-ﬂoat)</i> would return <i>t</i> and <i>t</i>, since the two types would be
identical.
<!--l. 168--><p class="indent" >   Note that <i>satisﬁes</i> is an exception because relationships between types
involving <i>satisﬁes</i> are undecidable in general, but (as X3J13 noted) <i>and</i>, <i>or</i>, <i>not</i>,
and <i>member</i> are merely very messy to deal with. In all likelihood these will not be
addressed unless and until someone is willing to write a careful speciﬁcation that
covers all the cases for the processing of these type speciﬁers by <i>subtypep</i>. The
requirements stated above were easy to state and probably suﬃce for most cases
of interest.
</div>
<div class=new>
<!--l. 179--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to change <i>subtypep</i> to give specialized <i>array</i>
and <i>complex</i> type speciﬁers the same meaning for purposes of type discrimination
as they have for declaration purposes. Of course, this also applies to such type
speciﬁers as <i>vector</i> and <i>simple-array</i> (see section <a 
href="clmse22.html#x31-490004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>).
<!--l. 188--><p class="indent" >   If A and B are type speciﬁers (other than <i>*</i>, which technically is not a type
speciﬁer anyway), then <i>(array A)</i> and <i>(array B)</i> represent the same type in
a given implementation if and only if they denote arrays of the same
specialized representation in that implementation; otherwise they are
disjoint. To put it another way, they represent the same type if and only if
<i>(upgraded-array-element-type &#x2019;A)</i> and <i>(upgraded-array-element-type &#x2019;B)</i> are the
same type. Therefore <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subtypep &#x2019;(array A) &#x2019;(array B))
</td></tr></table>
<!--l. 202--><p class="indent" >
</div>
</div>
<!--l. 203--><p class="noindent" >is true if and only if <i>(upgraded-array-element-type &#x2019;A)</i> is the same type as
<i>(upgraded-array-element-type &#x2019;B)</i>.
<!--l. 208--><p class="indent" >   The <i>complex</i> type speciﬁer is treated in a similar but subtly diﬀerent manner.
If A and B are two type speciﬁers (but not <i>*</i>, which technically is not a type
speciﬁer anyway), then <i>(complex A)</i> and <i>(complex B)</i> represent the same type in
a given implementation if and only if they refer to complex numbers of the same
specialized representation in that implementation; otherwise they are
disjoint. Note, however, that there is no function called <i>make-complex</i> that
allows one to specify a particular element type (then to be upgraded);
instead, one must describe specialized complex numbers in terms of the
actual types of the parts from which they were constructed. There is no
number of type (or rather, representation) <i>ﬂoat</i> as such; there are only
numbers of type <i>single-ﬂoat</i>, numbers of type <i>double-ﬂoat</i>, and so on.
Therefore we want <i>(complex single-ﬂoat)</i> to be a subtype of <i>(complex
ﬂoat)</i>.
<!--l. 226--><p class="indent" >   The rule, then, is that <i>(complex A)</i> and <i>(complex B)</i> represent the same type
(and otherwise are disjoint) in a given implementation if and only if either
the type A is a subtype of B, or <i>(upgraded-complex-part-type &#x2019;A)</i> and
<i>(upgraded-complex-part-type &#x2019;B)</i> are the same type. In the latter case <i>(complex A)</i>
and <i>(complex B)</i> in fact refer to the same specialized representation. Therefore <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subtypep &#x2019;(complex A) &#x2019;(complex B))
</td></tr></table>
<!--l. 237--><p class="indent" >
</div>
</div>
<!--l. 238--><p class="noindent" >is true if and only if the results of <i>(upgraded-complex-part-type &#x2019;A)</i> and
<i>(upgraded-complex-part-type &#x2019;B)</i> are the same type.
<!--l. 242--><p class="indent" >   Under this interpretation <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subtypep &#x2019;(complex single-ﬂoat) &#x2019;(complex ﬂoat))
</td></tr></table>
<!--l. 245--><p class="indent" >
</div>
</div>
<!--l. 246--><p class="noindent" >must be true in all implementations; but <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subtypep &#x2019;(array single-ﬂoat) &#x2019;(array ﬂoat))
</td></tr></table>
<!--l. 249--><p class="indent" >
</div>
</div>
<!--l. 250--><p class="noindent" >is true only in implementations that do not have a specialized array representation
for <i>single-ﬂoat</i> elements distinct from that for <i>ﬂoat</i> elements in general.
</div>
</div>
<!--l. 256--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.2   </span> <a 
 id="x43-730006.2.2"></a>Speciﬁc Data Type Predicates</h4>
<!--l. 258--><p class="noindent" >The following predicates test for individual data types.
<div class=defun>
<!--l. 260--><p class="noindent" > <i>[Function]</i>   <b>null</b> <a 
 id="dx43-73001"></a><a 
 id="x43-73002r24"></a>   <i>object</i>
<!--l. 262--><p class="noindent" ><i>null</i> is true if its argument is <i>(</i><i>)</i>, and otherwise is false. This is the same operation
performed by the function <i>not</i>; however, <i>not</i> is normally used to invert a
Boolean value, whereas <i>null</i> is normally used to test for an empty list. The
programmer can therefore express intent by the choice of function name. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(null x)  ≡ (typep x &#x2019;null)  ≡ (eq x &#x2019;<i>(</i><i>)</i>)
</td></tr></table>
<!--l. 271--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
<div class=defun>
<!--l. 274--><p class="noindent" > <i>[Function]</i>   <b>symbolp</b> <a 
 id="dx43-73003"></a><a 
 id="x43-73004r25"></a>   <i>object</i>
<!--l. 276--><p class="noindent" ><i>symbolp</i> is true if its argument is a symbol, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(symbolp x)  ≡ (typep x &#x2019;symbol)
</td></tr></table>
<!--l. 281--><p class="indent" >
</div>
</div>
<div class=incompatibility>
<!--l. 284--><p class="noindent" ><b>Compatibility note:</b> The Interlisp equivalent of <i>symbolp</i> is called <i>litatom</i>.
</div>
</div>
<div class=defun>
<!--l. 291--><p class="noindent" > <i>[Function]</i>   <b>atom</b> <a 
 id="dx43-73005"></a><a 
 id="x43-73006r26"></a>   <i>object</i>
<!--l. 293--><p class="noindent" >The predicate <i>atom</i> is true if its argument is not a cons, and otherwise is false.
Note that <i>(atom &#x2019;<i>(</i><i>)</i>)</i> is true, because <i>(</i><i>)</i>  ≡<i>nil</i>. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(atom x)  ≡ (typep x &#x2019;atom)  ≡ (not (typep x &#x2019;cons))
</td></tr></table>
<!--l. 299--><p class="indent" >
</div>
</div>
<div class=incompatibility>
<!--l. 302--><p class="noindent" ><b>Compatibility note:</b> In some Lisp dialects, notably Interlisp, only symbols and
numbers are considered to be atoms; arrays and strings are considered to be neither
atoms nor lists (conses).
</div>
</div>
<div class=defun>
<!--l. 310--><p class="noindent" > <i>[Function]</i>   <b>consp</b> <a 
 id="dx43-73007"></a><a 
 id="x43-73008r27"></a>   <i>object</i>
<!--l. 312--><p class="noindent" >The predicate <i>consp</i> is true if its argument is a cons, and otherwise is false. Note
that the empty list is not a cons, so <i>(consp &#x2019;<i>(</i><i>)</i>)</i>  ≡ <i>(consp &#x2019;<i>nil</i>)</i>  ⇒ <i>nil</i>. <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(consp x)  ≡ (typep x &#x2019;cons)  ≡ (not (typep x &#x2019;atom))
</td></tr></table>
<!--l. 319--><p class="indent" >
</div>
</div>
<div class=incompatibility>
<!--l. 322--><p class="noindent" ><b>Compatibility note:</b> Some Lisp implementations call this function <i>pairp</i> or <i>listp</i>. The
name <i>pairp</i> was rejected for Common Lisp because it emphasizes too strongly the
dotted-pair notion rather than the usual usage of conses in lists. On the other hand, <i>listp</i>
too strongly implies that the cons is in fact part of a list, which after all it might not be;
moreover, <i>(</i><i>)</i> is a list, though not a cons. The name <i>consp</i> seems to be the appropriate
compromise.
</div>
</div>
<div class=defun>
<!--l. 334--><p class="noindent" > <i>[Function]</i>   <b>listp</b> <a 
 id="dx43-73009"></a><a 
 id="x43-73010r28"></a>   <i>object</i>
<!--l. 336--><p class="noindent" ><i>listp</i> is true if its argument is a cons or the empty list <i>(</i><i>)</i>, and otherwise is false. It
does not check for whether the list is a “true list” (one terminated by <i>nil</i>) or a
“dotted list” (one terminated by a non-null atom). <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(listp x)  ≡ (typep x &#x2019;list)  ≡ (typep x &#x2019;(or cons null))
</td></tr></table>
<!--l. 343--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 346--><p class="noindent" > <i>[Function]</i>   <b>numberp</b> <a 
 id="dx43-73011"></a><a 
 id="x43-73012r29"></a>   <i>object</i>
<!--l. 348--><p class="noindent" ><i>numberp</i> is true if its argument is any kind of number, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(numberp x)  ≡ (typep x &#x2019;number)
</td></tr></table>
<!--l. 353--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 356--><p class="noindent" > <i>[Function]</i>   <b>integerp</b> <a 
 id="dx43-73013"></a><a 
 id="x43-73014r30"></a>   <i>object</i>
<!--l. 358--><p class="noindent" ><i>integerp</i> is true if its argument is an integer, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integerp x)  ≡ (typep x &#x2019;integer)
</td></tr></table>
<!--l. 363--><p class="indent" >
</div>
</div>
<div class=incompatibility>
<!--l. 366--><p class="noindent" ><b>Compatibility note:</b> In MacLisp this is called <i>ﬁxp</i>. Users have been confused as to
whether this meant <i>integerp</i> or <i>ﬁxnump</i>, and so the name <i>integerp</i> has been adopted
here.
</div>
</div>
<div class=defun>
<!--l. 374--><p class="noindent" > <i>[Function]</i>   <b>rationalp</b> <a 
 id="dx43-73015"></a><a 
 id="x43-73016r31"></a>   <i>object</i>
<!--l. 376--><p class="noindent" ><i>rationalp</i> is true if its argument is a rational number (a ratio or an integer), and
otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(rationalp x)  ≡ (typep x &#x2019;rational)
</td></tr></table>
<!--l. 381--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 384--><p class="noindent" > <i>[Function]</i>   <b>ﬂoatp</b> <a 
 id="dx43-73017"></a><a 
 id="x43-73018r32"></a>   <i>object</i>
<!--l. 386--><p class="noindent" ><i>ﬂoatp</i> is true if its argument is a ﬂoating-point number, and otherwise is false. <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬂoatp x)  ≡ (typep x &#x2019;ﬂoat)
</td></tr></table>
<!--l. 391--><p class="indent" >
</div>
</div>
</div>
<div class=newer>
<div class=defun>
<!--l. 396--><p class="noindent" > <i>[Function]</i>   <b>realp</b> <a 
 id="dx43-73019"></a><a 
 id="x43-73020r33"></a>   <i>object</i>
<!--l. 398--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to add the function <i>realp</i>. <i>realp</i> is true if its
argument is a real number, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(realp x)  ≡ (typep x &#x2019;real)
</td></tr></table>
<!--l. 404--><p class="indent" >
</div>
</div>
</div>
</div>
<div class=defun>
<!--l. 408--><p class="noindent" > <i>[Function]</i>   <b>complexp</b> <a 
 id="dx43-73021"></a><a 
 id="x43-73022r34"></a>   <i>object</i>
<!--l. 410--><p class="noindent" ><i>complexp</i> is true if its argument is a complex number, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(complexp x)  ≡ (typep x &#x2019;complex)
</td></tr></table>
<!--l. 415--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 418--><p class="noindent" > <i>[Function]</i>   <b>characterp</b> <a 
 id="dx43-73023"></a><a 
 id="x43-73024r35"></a>   <i>object</i>
<!--l. 420--><p class="noindent" ><i>characterp</i> is true if its argument is a character, and otherwise is false. <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(characterp x)  ≡ (typep x &#x2019;character)
</td></tr></table>
<!--l. 425--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 428--><p class="noindent" > <i>[Function]</i>   <b>stringp</b> <a 
 id="dx43-73025"></a><a 
 id="x43-73026r36"></a>   <i>object</i>
<!--l. 430--><p class="noindent" ><i>stringp</i> is true if its argument is a string, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(stringp x)  ≡ (typep x &#x2019;string)
</td></tr></table>
<!--l. 435--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 438--><p class="noindent" > <i>[Function]</i>   <b>bit-vector-p</b> <a 
 id="dx43-73027"></a><a 
 id="x43-73028r37"></a>   <i>object</i>
<!--l. 440--><p class="noindent" ><i>bit-vector-p</i> is true if its argument is a bit-vector, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(bit-vector-p x)  ≡ (typep x &#x2019;bit-vector)
</td></tr></table>
<!--l. 445--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 448--><p class="noindent" > <i>[Function]</i>   <b>vectorp</b> <a 
 id="dx43-73029"></a><a 
 id="x43-73030r38"></a>   <i>object</i>
<!--l. 450--><p class="noindent" ><i>vectorp</i> is true if its argument is a vector, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(vectorp x)  ≡ (typep x &#x2019;vector)
</td></tr></table>
<!--l. 455--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 458--><p class="noindent" > <i>[Function]</i>   <b>simple-vector-p</b> <a 
 id="dx43-73031"></a><a 
 id="x43-73032r39"></a>   <i>object</i>
<!--l. 460--><p class="noindent" ><i>vectorp</i> is true if its argument is a simple general vector, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(simple-vector-p x)  ≡ (typep x &#x2019;simple-vector)
</td></tr></table>
<!--l. 465--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 468--><p class="noindent" > <i>[Function]</i>   <b>simple-string-p</b> <a 
 id="dx43-73033"></a><a 
 id="x43-73034r40"></a>   <i>object</i>
<!--l. 470--><p class="noindent" ><i>simple-string-p</i> is true if its argument is a simple string, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(simple-string-p x)  ≡ (typep x &#x2019;simple-string)
</td></tr></table>
<!--l. 475--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 478--><p class="noindent" > <i>[Function]</i>   <b>simple-bit-vector-p</b> <a 
 id="dx43-73035"></a><a 
 id="x43-73036r41"></a>   <i>object</i>
<!--l. 480--><p class="noindent" ><i>simple-bit-vector-p</i> is true if its argument is a simple bit-vector, and otherwise is
false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(simple-bit-vector-p x)  ≡ (typep x &#x2019;simple-bit-vector)
</td></tr></table>
<!--l. 485--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 488--><p class="noindent" > <i>[Function]</i>   <b>arrayp</b> <a 
 id="dx43-73037"></a><a 
 id="x43-73038r42"></a>   <i>object</i>
<!--l. 490--><p class="noindent" ><i>arrayp</i> is true if its argument is an array, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(arrayp x)  ≡ (typep x &#x2019;array)
</td></tr></table>
<!--l. 495--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 498--><p class="noindent" > <i>[Function]</i>   <b>packagep</b> <a 
 id="dx43-73039"></a><a 
 id="x43-73040r43"></a>   <i>object</i>
<!--l. 500--><p class="noindent" ><i>packagep</i> is true if its argument is a package, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(packagep x)  ≡ (typep x &#x2019;package)
</td></tr></table>
<!--l. 505--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 508--><p class="noindent" > <i>[Function]</i>   <b>functionp</b> <a 
 id="dx43-73041"></a><a 
 id="x43-73042r44"></a>   <i>object</i>
<!--l. 510--><p class="noindent" ><div class=obsolete> <i>functionp</i> is true if its argument is suitable for applying to arguments,
using for example the <i>funcall</i> or <i>apply</i> function. Otherwise <i>functionp</i> is
false.
<i>
<!--l. 516--><p class="indent" >   functionp</i> is always true of symbols, lists whose car is the symbol <i>lambda</i>, any
value returned by the <i>function</i> special form, and any values returned by the
function <i>compile</i> when the ﬁrst argument is <i>nil</i>.
</div> <div class=newer> X3J13 voted in June 1988 ⟨<b>?</b>⟩ to deﬁne <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(functionp x)  ≡ (typep x &#x2019;function)
</td></tr></table>
<!--l. 526--><p class="indent" >
</div>
</div>
<!--l. 527--><p class="noindent" >Because the vote also speciﬁes that types <i>cons</i> and <i>symbol</i> are disjoint from the type
<i>function</i>, this is an incompatible change; now <i>functionp</i> is in fact always false of
symbols and lists.
</div>
</div>
<div class=defun>
<!--l. 533--><p class="noindent" > <i>[Function]</i>   <b>compiled-function-p</b> <a 
 id="dx43-73043"></a><a 
 id="x43-73044r45"></a>   <i>object</i>
<!--l. 535--><p class="noindent" ><i>compiled-function-p</i> is true if its argument is any compiled code object, and
otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(compiled-function-p x)  ≡ (typep x &#x2019;compiled-function)
</td></tr></table>
<!--l. 540--><p class="indent" >
</div>
</div>
</div>
<div class=obsolete>
<div class=defun>
<!--l. 544--><p class="noindent" > <i>[Function]</i>   <b>commonp</b> <a 
 id="dx43-73045"></a><a 
 id="x43-73046r46"></a>   <i>object</i>
<!--l. 546--><p class="noindent" ><i>commonp</i> is true if its argument is any standard Common Lisp data type, and
otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(commonp x)  ≡ (typep x &#x2019;common)
</td></tr></table>
<!--l. 551--><p class="indent" >
</div>
</div>
</div>
</div>
<div class=newer>
                                                                          

                                                                          
<!--l. 556--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to remove the predicate <i>commonp</i> (and the
type <i>common</i>) from the language.
</div>
<!--l. 563--><p class="indent" >   See also <i>standard-char-p</i>, <i>string-char-p</i>, <i>streamp</i>, <i>random-state-p</i>, <i>readtablep</i>,
<i>hash-table-p</i>, and <i>pathnamep</i>.
                                                                          

                                                                          
   <!--l. 568--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse33.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html#tailclmse31.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse32.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 568--><p class="indent" >   <a 
 id="tailclmse32.html"></a>  
</body></html> 
