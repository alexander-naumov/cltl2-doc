<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Data Type Predicates Предикаты типов данных</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-22 01:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 120--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse33.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html#tailclmse31.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse32.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse32.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">6.2   </span> <a 
 id="x43-710006.2"></a>Data Type Predicates Предикаты типов данных</h3>
<!--l. 122--><p class="noindent" >Perhaps the most important predicates in Lisp are those that deal with data
types; that is, given a data object one can determine whether or not it belongs to
a given type, or one can compare two type speciﬁers.
<!--l. 126--><p class="indent" >   Возможно наиболее важными предикатами в Lisp&#x2019;е эти предикаты,
которые различают типы данных. То есть позволяют узнать принадлежит ли
заданный объект данному типу, или могут сравнивать два спецификатора
типов.
<!--l. 130--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.1   </span> <a 
 id="x43-720006.2.1"></a>General Type Predicates Общие предикаты типов</h4>
<!--l. 132--><p class="noindent" >If a data type is viewed as the set of all objects belonging to the type, then
the <a 
href="#x43-72002r21">typep</a> function is a set membership test, while <a 
href="#x43-72004r22">subtypep</a> is a subset
test.
<!--l. 136--><p class="indent" >   Если тип данных рассматривать, как множество все объектов
приндлежащих этому типу, тогда функция <a 
href="#x43-72002r21">typep</a> проверяет принадлежность
множеству, тогда как <i>subtypep</i> — принадлежность подмножеству.
<div class=defun>
<!--l. 140--><p class="noindent" > <i>[Function]</i>   <b>typep</b> <a 
 id="dx43-72001"></a><a 
 id="x43-72002r21"></a>   <i>object</i>  <i>type</i>
<!--l. 142--><p class="noindent" ><a 
href="#x43-72002r21">typep</a> is a predicate that is true if <i>object</i> is of type <i>type</i>, and is false otherwise.
Note that an object can be “of” more than one type, since one type can
include another. The <i>type</i> may be any of the type speciﬁers mentioned in
chapter <a 
href="clmch4.html#x26-440004">4<!--tex4ht:ref: DTSPEC --></a> <i>except</i> that it may not be or contain a type speciﬁer list whose
ﬁrst element is <a 
href="clmse35.html#x47-78004r54">function</a> or <a 
href="clmse44.html#x56-94002r121">values</a>. A speciﬁer of the form <i>(satisﬁes <i>fn</i>)</i>
is handled simply by applying the function <i>fn</i> to <i>object</i> (see <a 
href="clmse37.html#x49-81004r78">funcall</a>);
the <i>object</i> is considered to be of the speciﬁed type if the result is not
<a 
href="clmse31.html#x42-70002r19">nil</a>.
<!--l. 155--><p class="indent" >   <a 
href="#x43-72002r21">typep</a> является предикатом, которые истенен, если объект <i>object</i>
принадлежит типу <i>type</i>, и ложен в противном случае. Следует отметить что
                                                                          

                                                                          
объект может принадлежать нескольким типам, так как один тип может
включать другой. <i>type</i> может быть любым спецификатором типа,
описанным в главе <a 
href="clmch4.html#x26-440004">4<!--tex4ht:ref: DTSPEC --></a>, за исключением того, что он не может быть или
включать список спецификатор типа, у которого первый элемент равен
<a 
href="clmse35.html#x47-78004r54">function</a> или <a 
href="clmse44.html#x56-94002r121">values</a>. Спецификатор формы <i>(satisﬁes <i>fn</i>)</i> обрабатывается
просто как применение функции <i>fn</i> к объекту <i>object</i> (смотрите <a 
href="clmse37.html#x49-81004r78">funcall</a>).
Объект <i>object</i> принадлежит заданному типу, если результат не равен
<a 
href="clmse31.html#x42-70002r19">nil</a>.
<div class=new>
<!--l. 167--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to change <a 
href="#x43-72002r21">typep</a> to give specialized
array and <a 
href="clmse71.html#x88-130046r271">complex</a> type speciﬁers the same meaning for purposes of type
discrimination as they have for declaration purposes. Of course, this also applies
to such type speciﬁers as <a 
href="clmse94.html#x116-158010r560">vector</a> and simple-array (see section <a 
href="clmse22.html#x31-490004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>). Thus <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(typep foo &#x2019;(array bignum))
</td></tr></table>
<!--l. 178--><p class="indent" >
</div>
</div>
<!--l. 179--><p class="noindent" >in the ﬁrst edition asked the question, Is foo an array specialized to hold
bignums? but under the new interpretation asks the question, Could the array
foo have resulted from giving bignum as the <i>:element-type</i> argument to
<a 
href="clmse94.html#x116-158002r556">make-array</a>?
</div>
</div>
<div class=defun>
<!--l. 187--><p class="noindent" > <i>[Function]</i>   <b>subtypep</b> <a 
 id="dx43-72003"></a><a 
 id="x43-72004r22"></a>   <i>type1</i>  <i>type2</i>
<!--l. 189--><p class="noindent" >The arguments must be type speciﬁers that are acceptable to <a 
href="#x43-72002r21">typep</a>. The two type
speciﬁers are compared; this predicate is true if <i>type1</i> is deﬁnitely a (not
necessarily proper) subtype of <i>type2</i>. If the result is <a 
href="clmse31.html#x42-70002r19">nil</a>, however, then <i>type1</i> may
or may not be a subtype of <i>type2</i> (sometimes it is impossible to tell, especially
when satisﬁes type speciﬁers are involved). A second returned value indicates the
certainty of the result; if it is true, then the ﬁrst value is an accurate indication of
the subtype relationship. Thus there are three possible result combinations:
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:74;" 
class="tabbing"><a 
href="clmse31.html#x42-70004r20">t</a>           </td><td style="width:74;" 
class="tabbing"><a 
href="clmse31.html#x42-70004r20">t</a>           </td><td  
class="tabbing"><i>type1</i> is deﬁnitely a subtype of <i>type2</i>
</td></tr></table>
<!--l. 202--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:74;" 
class="tabbing"><a 
href="clmse31.html#x42-70002r19">nil</a>         </td><td style="width:74;" 
class="tabbing"><a 
href="clmse31.html#x42-70004r20">t</a>           </td><td  
class="tabbing"><i>type1</i> is deﬁnitely not a subtype of <i>type2</i></td></tr></table>
<!--l. 203--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:74;" 
class="tabbing"><a 
href="clmse31.html#x42-70002r19">nil</a>         </td><td style="width:74;" 
class="tabbing"><a 
href="clmse31.html#x42-70002r19">nil</a>         </td><td  
class="tabbing"><a 
href="#x43-72004r22">subtypep</a> could not determine the relationship</td></tr></table>
<!--l. 205--><p class="indent" >
</div>
<div class=new>
<!--l. 208--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to place certain requirements upon the
implementation of <a 
href="#x43-72004r22">subtypep</a>, for it noted that implementations in many cases
simply “give up” and return the two values <a 
href="clmse31.html#x42-70002r19">nil</a> and <a 
href="clmse31.html#x42-70002r19">nil</a> when in fact it would have
been possible to determine the relationship between the given types. The
requirements are as follows, where it is understood that a type speciﬁer <i>s</i> <i>involves</i>
a type speciﬁer <i>u</i> if either <i>s</i> contains an occurrence of <i>u</i> directly or <i>s</i>
contains a type speciﬁer <i>w</i> deﬁned by <a 
href="clmse24.html#x33-51002r6">deftype</a> whose expansion involves
<i>u</i>.
      <ul class="itemize1">
      <li class="itemize"><a 
href="#x43-72004r22">subtypep</a> is not permitted to return a second value of <a 
href="clmse31.html#x42-70002r19">nil</a> unless one or
      both of its arguments involves satisﬁes, <a 
href="clmse34.html#x45-75004r51">and</a>, <a 
href="clmse34.html#x45-75006r52">or</a>, <a 
href="clmse34.html#x45-75002r50">not</a>, or <a 
href="clmse90.html#x110-152002r517">member</a>.
      </li>
      <li class="itemize"><a 
href="#x43-72004r22">subtypep</a> should signal an error when one or both of its arguments
      involves <a 
href="clmse44.html#x56-94002r121">values</a> or the list form of the <a 
href="clmse35.html#x47-78004r54">function</a> type speciﬁer.
      </li>
      <li class="itemize"><a 
href="#x43-72004r22">subtypep</a> must always return the two values <a 
href="clmse31.html#x42-70004r20">t</a> and <a 
href="clmse31.html#x42-70004r20">t</a> in the case where its
      arguments, after expansion of speciﬁers deﬁned by <a 
href="clmse24.html#x33-51002r6">deftype</a>, are <a 
href="clmse33.html#x44-74006r48">equal</a>.</li></ul>
<!--l. 228--><p class="noindent" >In addition, X3J13 voted to clarify that in some cases the relationships between types
as reﬂected by <a 
href="#x43-72004r22">subtypep</a> may be implementation-speciﬁc. For example, in
an implementation supporting only one type of ﬂoating-point number,
<i>(subtypep &#x2019;ﬂoat &#x2019;long-ﬂoat)</i> would return <a 
href="clmse31.html#x42-70004r20">t</a> and <a 
href="clmse31.html#x42-70004r20">t</a>, since the two types would be
identical.
<!--l. 235--><p class="indent" >   Note that satisﬁes is an exception because relationships between types
involving satisﬁes are undecidable in general, but (as X3J13 noted) <a 
href="clmse34.html#x45-75004r51">and</a>, <a 
href="clmse34.html#x45-75006r52">or</a>, <a 
href="clmse34.html#x45-75002r50">not</a>,
and <a 
href="clmse90.html#x110-152002r517">member</a> are merely very messy to deal with. In all likelihood these will not be
addressed unless and until someone is willing to write a careful speciﬁcation that
                                                                          

                                                                          
covers all the cases for the processing of these type speciﬁers by <a 
href="#x43-72004r22">subtypep</a>. The
requirements stated above were easy to state and probably suﬃce for most cases
of interest.
</div>
<div class=new>
<!--l. 246--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to change <a 
href="#x43-72004r22">subtypep</a> to give specialized array
and <a 
href="clmse71.html#x88-130046r271">complex</a> type speciﬁers the same meaning for purposes of type discrimination
as they have for declaration purposes. Of course, this also applies to such type
speciﬁers as <a 
href="clmse94.html#x116-158010r560">vector</a> and simple-array (see section <a 
href="clmse22.html#x31-490004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>).
<!--l. 255--><p class="indent" >   If <i>A</i> and <i>B</i> are type speciﬁers (other than <i>*</i>, which technically is not a type
speciﬁer anyway), then <i>(array <i>A</i>)</i> and <i>(array <i>B</i>)</i> represent the same type in
a given implementation if and only if they denote arrays of the same
specialized representation in that implementation; otherwise they are
disjoint. To put it another way, they represent the same type if and only if
<i>(upgraded-array-element-type &#x2019;<i>A</i>)</i> and <i>(upgraded-array-element-type &#x2019;<i>B</i>)</i> are the
same type. Therefore <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subtypep &#x2019;(array <i>A</i>) &#x2019;(array <i>B</i>))
</td></tr></table>
<!--l. 269--><p class="indent" >
</div>
</div>
<!--l. 270--><p class="noindent" >is true if and only if <i>(upgraded-array-element-type &#x2019;<i>A</i>)</i> is the same type as
<i>(upgraded-array-element-type &#x2019;<i>B</i>)</i>.
<!--l. 275--><p class="indent" >   The <a 
href="clmse71.html#x88-130046r271">complex</a> type speciﬁer is treated in a similar but subtly diﬀerent manner.
If <i>A</i> and <i>B</i> are two type speciﬁers (but not <i>*</i>, which technically is not a type
speciﬁer anyway), then <i>(complex <i>A</i>)</i> and <i>(complex <i>B</i>)</i> represent the same type in
a given implementation if and only if they refer to complex numbers of the same
specialized representation in that implementation; otherwise they are
disjoint. Note, however, that there is no function called make-complex that
allows one to specify a particular element type (then to be upgraded);
instead, one must describe specialized complex numbers in terms of the
actual types of the parts from which they were constructed. There is no
number of type (or rather, <i>representation</i>) <a 
href="clmse71.html#x88-130002r249">ﬂoat</a> as such; there are only
numbers of type single-ﬂoat, numbers of type double-ﬂoat, and so on.
Therefore we want <i>(complex single-ﬂoat)</i> to be a subtype of <i>(complex
ﬂoat)</i>.
                                                                          

                                                                          
<!--l. 293--><p class="indent" >   The rule, then, is that <i>(complex <i>A</i>)</i> and <i>(complex <i>B</i>)</i> represent the same type
(and otherwise are disjoint) in a given implementation if and only if <i>either</i>
the type <i>A</i> is a subtype of <i>B</i>, <i>or</i> <i>(upgraded-complex-part-type &#x2019;<i>A</i>)</i> and
<i>(upgraded-complex-part-type &#x2019;<i>B</i>)</i> are the same type. In the latter case <i>(complex <i>A</i>)</i>
and <i>(complex <i>B</i>)</i> in fact refer to the same specialized representation. Therefore <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subtypep &#x2019;(complex <i>A</i>) &#x2019;(complex <i>B</i>))
</td></tr></table>
<!--l. 304--><p class="indent" >
</div>
</div>
<!--l. 305--><p class="noindent" >is true if and only if the results of <i>(upgraded-complex-part-type &#x2019;<i>A</i>)</i> and
<i>(upgraded-complex-part-type &#x2019;<i>B</i>)</i> are the same type.
<!--l. 309--><p class="indent" >   Under this interpretation <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subtypep &#x2019;(complex single-ﬂoat) &#x2019;(complex ﬂoat))
</td></tr></table>
<!--l. 312--><p class="indent" >
</div>
</div>
<!--l. 313--><p class="noindent" >must be true in all implementations; but <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(subtypep &#x2019;(array single-ﬂoat) &#x2019;(array ﬂoat))
</td></tr></table>
<!--l. 316--><p class="indent" >
</div>
</div>
<!--l. 317--><p class="noindent" >is true only in implementations that do not have a specialized array representation
for single-ﬂoat elements distinct from that for <a 
href="clmse71.html#x88-130002r249">ﬂoat</a> elements in general.
</div>
</div>
                                                                          

                                                                          
<!--l. 323--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.2   </span> <a 
 id="x43-730006.2.2"></a>Speciﬁc Data Type Predicates</h4>
<!--l. 325--><p class="noindent" >The following predicates test for individual data types.
<div class=defun>
<!--l. 327--><p class="noindent" > <i>[Function]</i>   <b>null</b> <a 
 id="dx43-73001"></a><a 
 id="x43-73002r23"></a>   <i>object</i>
<!--l. 329--><p class="noindent" ><a 
href="#x43-73002r23">null</a> is true if its argument is <i>(</i><i>)</i>, and otherwise is false. This is the same operation
performed by the function <a 
href="clmse34.html#x45-75002r50">not</a>; however, <a 
href="clmse34.html#x45-75002r50">not</a> is normally used to invert a
Boolean value, whereas <a 
href="#x43-73002r23">null</a> is normally used to test for an empty list. The
programmer can therefore express <i>intent</i> by the choice of function name. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(null x)  ≡ (typep x &#x2019;null)  ≡ (eq x &#x2019;<i>(</i><i>)</i>)
</td></tr></table>
<!--l. 338--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 341--><p class="noindent" > <i>[Function]</i>   <b>symbolp</b> <a 
 id="dx43-73003"></a><a 
 id="x43-73004r24"></a>   <i>object</i>
<!--l. 343--><p class="noindent" ><a 
href="#x43-73004r24">symbolp</a> is true if its argument is a symbol, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(symbolp x)  ≡ (typep x &#x2019;symbol)
</td></tr></table>
<!--l. 348--><p class="indent" >
</div>
</div>
<div class=incompatibility>
<!--l. 351--><p class="noindent" ><b>Compatibility note:</b> The Interlisp equivalent of <a 
href="#x43-73004r24">symbolp</a> is called litatom.
</div>
</div>
<div class=defun>
<!--l. 358--><p class="noindent" > <i>[Function]</i>   <b>atom</b> <a 
 id="dx43-73005"></a><a 
 id="x43-73006r25"></a>   <i>object</i>
<!--l. 360--><p class="noindent" >The predicate <a 
href="#x43-73006r25">atom</a> is true if its argument is not a cons, and otherwise is false.
Note that <i>(atom &#x2019;<i>(</i><i>)</i>)</i> is true, because <i>(</i><i>)</i>  ≡<a 
href="clmse31.html#x42-70002r19">nil</a>. <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(atom x)  ≡ (typep x &#x2019;atom)  ≡ (not (typep x &#x2019;cons))
</td></tr></table>
<!--l. 366--><p class="indent" >
</div>
</div>
<div class=incompatibility>
<!--l. 369--><p class="noindent" ><b>Compatibility note:</b> In some Lisp dialects, notably Interlisp, only symbols and
numbers are considered to be atoms; arrays and strings are considered to be neither
atoms nor lists (conses).
</div>
</div>
<div class=defun>
<!--l. 377--><p class="noindent" > <i>[Function]</i>   <b>consp</b> <a 
 id="dx43-73007"></a><a 
 id="x43-73008r26"></a>   <i>object</i>
<!--l. 379--><p class="noindent" >The predicate <a 
href="#x43-73008r26">consp</a> is true if its argument is a cons, and otherwise is false. Note
that the empty list is not a cons, so <i>(consp &#x2019;<i>(</i><i>)</i>)</i>  ≡ <i>(consp &#x2019;<a 
href="clmse31.html#x42-70002r19">nil</a>)</i>  ⇒ <a 
href="clmse31.html#x42-70002r19">nil</a>. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(consp x)  ≡ (typep x &#x2019;cons)  ≡ (not (typep x &#x2019;atom))
</td></tr></table>
<!--l. 386--><p class="indent" >
</div>
</div>
<div class=incompatibility>
<!--l. 389--><p class="noindent" ><b>Compatibility note:</b> Some Lisp implementations call this function pairp or <a 
href="#x43-73010r27">listp</a>. The
name pairp was rejected for Common Lisp because it emphasizes too strongly the
dotted-pair notion rather than the usual usage of conses in lists. On the other hand, <a 
href="#x43-73010r27">listp</a>
too strongly implies that the cons is in fact part of a list, which after all it might not be;
moreover, <i>(</i><i>)</i> is a list, though not a cons. The name <a 
href="#x43-73008r26">consp</a> seems to be the appropriate
compromise.
</div>
</div>
<div class=defun>
<!--l. 401--><p class="noindent" > <i>[Function]</i>   <b>listp</b> <a 
 id="dx43-73009"></a><a 
 id="x43-73010r27"></a>   <i>object</i>
<!--l. 403--><p class="noindent" ><a 
href="#x43-73010r27">listp</a> is true if its argument is a cons or the empty list <i>(</i><i>)</i>, and otherwise is false. It
does not check for whether the list is a “true list” (one terminated by <a 
href="clmse31.html#x42-70002r19">nil</a>) or a
“dotted list” (one terminated by a non-null atom). <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(listp x)  ≡ (typep x &#x2019;list)  ≡ (typep x &#x2019;(or cons null))
</td></tr></table>
<!--l. 410--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 413--><p class="noindent" > <i>[Function]</i>   <b>numberp</b> <a 
 id="dx43-73011"></a><a 
 id="x43-73012r28"></a>   <i>object</i>
<!--l. 415--><p class="noindent" ><a 
href="#x43-73012r28">numberp</a> is true if its argument is any kind of number, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(numberp x)  ≡ (typep x &#x2019;number)
</td></tr></table>
<!--l. 420--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 423--><p class="noindent" > <i>[Function]</i>   <b>integerp</b> <a 
 id="dx43-73013"></a><a 
 id="x43-73014r29"></a>   <i>object</i>
<!--l. 425--><p class="noindent" ><a 
href="#x43-73014r29">integerp</a> is true if its argument is an integer, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(integerp x)  ≡ (typep x &#x2019;integer)
</td></tr></table>
<!--l. 430--><p class="indent" >
</div>
</div>
<div class=incompatibility>
<!--l. 433--><p class="noindent" ><b>Compatibility note:</b> In MacLisp this is called ﬁxp. Users have been confused as to
whether this meant <a 
href="#x43-73014r29">integerp</a> or ﬁxnump, and so the name <a 
href="#x43-73014r29">integerp</a> has been adopted
here.
</div>
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 441--><p class="noindent" > <i>[Function]</i>   <b>rationalp</b> <a 
 id="dx43-73015"></a><a 
 id="x43-73016r30"></a>   <i>object</i>
<!--l. 443--><p class="noindent" ><a 
href="#x43-73016r30">rationalp</a> is true if its argument is a rational number (a ratio or an integer), and
otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(rationalp x)  ≡ (typep x &#x2019;rational)
</td></tr></table>
<!--l. 448--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 451--><p class="noindent" > <i>[Function]</i>   <b>ﬂoatp</b> <a 
 id="dx43-73017"></a><a 
 id="x43-73018r31"></a>   <i>object</i>
<!--l. 453--><p class="noindent" ><a 
href="#x43-73018r31">ﬂoatp</a> is true if its argument is a ﬂoating-point number, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(ﬂoatp x)  ≡ (typep x &#x2019;ﬂoat)
</td></tr></table>
<!--l. 458--><p class="indent" >
</div>
</div>
</div>
<div class=newer>
<div class=defun>
<!--l. 463--><p class="noindent" > <i>[Function]</i>   <b>realp</b> <a 
 id="dx43-73019"></a><a 
 id="x43-73020r32"></a>   <i>object</i>
<!--l. 465--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to add the function <a 
href="#x43-73020r32">realp</a>. <a 
href="#x43-73020r32">realp</a> is true if its
argument is a real number, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(realp x)  ≡ (typep x &#x2019;real)
</td></tr></table>
<!--l. 471--><p class="indent" >
</div>
</div>
</div>
</div>
                                                                          

                                                                          
<div class=defun>
<!--l. 475--><p class="noindent" > <i>[Function]</i>   <b>complexp</b> <a 
 id="dx43-73021"></a><a 
 id="x43-73022r33"></a>   <i>object</i>
<!--l. 477--><p class="noindent" ><a 
href="#x43-73022r33">complexp</a> is true if its argument is a complex number, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(complexp x)  ≡ (typep x &#x2019;complex)
</td></tr></table>
<!--l. 482--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 485--><p class="noindent" > <i>[Function]</i>   <b>characterp</b> <a 
 id="dx43-73023"></a><a 
 id="x43-73024r34"></a>   <i>object</i>
<!--l. 487--><p class="noindent" ><a 
href="#x43-73024r34">characterp</a> is true if its argument is a character, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(characterp x)  ≡ (typep x &#x2019;character)
</td></tr></table>
<!--l. 492--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 495--><p class="noindent" > <i>[Function]</i>   <b>stringp</b> <a 
 id="dx43-73025"></a><a 
 id="x43-73026r35"></a>   <i>object</i>
<!--l. 497--><p class="noindent" ><a 
href="#x43-73026r35">stringp</a> is true if its argument is a string, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(stringp x)  ≡ (typep x &#x2019;string)
</td></tr></table>
<!--l. 502--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
                                                                          

                                                                          
<!--l. 505--><p class="noindent" > <i>[Function]</i>   <b>bit-vector-p</b> <a 
 id="dx43-73027"></a><a 
 id="x43-73028r36"></a>   <i>object</i>
<!--l. 507--><p class="noindent" ><a 
href="#x43-73028r36">bit-vector-p</a> is true if its argument is a bit-vector, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(bit-vector-p x)  ≡ (typep x &#x2019;bit-vector)
</td></tr></table>
<!--l. 512--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 515--><p class="noindent" > <i>[Function]</i>   <b>vectorp</b> <a 
 id="dx43-73029"></a><a 
 id="x43-73030r37"></a>   <i>object</i>
<!--l. 517--><p class="noindent" ><a 
href="#x43-73030r37">vectorp</a> is true if its argument is a vector, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(vectorp x)  ≡ (typep x &#x2019;vector)
</td></tr></table>
<!--l. 522--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 525--><p class="noindent" > <i>[Function]</i>   <b>simple-vector-p</b> <a 
 id="dx43-73031"></a><a 
 id="x43-73032r38"></a>   <i>object</i>
<!--l. 527--><p class="noindent" ><a 
href="#x43-73030r37">vectorp</a> is true if its argument is a simple general vector, and otherwise is false. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(simple-vector-p x)  ≡ (typep x &#x2019;simple-vector)
</td></tr></table>
<!--l. 532--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 535--><p class="noindent" > <i>[Function]</i>   <b>simple-string-p</b> <a 
 id="dx43-73033"></a><a 
 id="x43-73034r39"></a>   <i>object</i>
<!--l. 537--><p class="noindent" ><a 
href="#x43-73034r39">simple-string-p</a> is true if its argument is a simple string, and otherwise is false. <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(simple-string-p x)  ≡ (typep x &#x2019;simple-string)
</td></tr></table>
<!--l. 542--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 545--><p class="noindent" > <i>[Function]</i>   <b>simple-bit-vector-p</b> <a 
 id="dx43-73035"></a><a 
 id="x43-73036r40"></a>   <i>object</i>
<!--l. 547--><p class="noindent" ><a 
href="#x43-73036r40">simple-bit-vector-p</a> is true if its argument is a simple bit-vector, and otherwise is
false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(simple-bit-vector-p x)  ≡ (typep x &#x2019;simple-bit-vector)
</td></tr></table>
<!--l. 552--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 555--><p class="noindent" > <i>[Function]</i>   <b>arrayp</b> <a 
 id="dx43-73037"></a><a 
 id="x43-73038r41"></a>   <i>object</i>
<!--l. 557--><p class="noindent" ><a 
href="#x43-73038r41">arrayp</a> is true if its argument is an array, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(arrayp x)  ≡ (typep x &#x2019;array)
</td></tr></table>
<!--l. 562--><p class="indent" >
</div>
</div>
</div>
<div class=defun>
<!--l. 565--><p class="noindent" > <i>[Function]</i>   <b>packagep</b> <a 
 id="dx43-73039"></a><a 
 id="x43-73040r42"></a>   <i>object</i>
<!--l. 567--><p class="noindent" ><a 
href="#x43-73040r42">packagep</a> is true if its argument is a package, and otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(packagep x)  ≡ (typep x &#x2019;package)
</td></tr></table>
<!--l. 572--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
</div>
<div class=defun>
<!--l. 575--><p class="noindent" > <i>[Function]</i>   <b>functionp</b> <a 
 id="dx43-73041"></a><a 
 id="x43-73042r43"></a>   <i>object</i>
<!--l. 577--><p class="noindent" ><div class=obsolete> <a 
href="#x43-73042r43">functionp</a> is true if its argument is suitable for applying to arguments,
using for example the <a 
href="clmse37.html#x49-81004r78">funcall</a> or <a 
href="clmse37.html#x49-81002r77">apply</a> function. Otherwise <a 
href="#x43-73042r43">functionp</a> is
false.
<!--l. 583--><p class="indent" >   <a 
href="#x43-73042r43">functionp</a> is always true of symbols, lists whose <i>car</i> is the symbol lambda, any
value returned by the <a 
href="clmse35.html#x47-78004r54">function</a> special form, and any values returned by the
function <a 
href="clmse127.html#x157-224002r795">compile</a> when the ﬁrst argument is <a 
href="clmse31.html#x42-70002r19">nil</a>.
</div> <div class=newer> X3J13 voted in June 1988 ⟨<b>?</b>⟩ to deﬁne <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(functionp x)  ≡ (typep x &#x2019;function)
</td></tr></table>
<!--l. 593--><p class="indent" >
</div>
</div>
<!--l. 594--><p class="noindent" >Because the vote also speciﬁes that types <a 
href="clmse86.html#x106-148062r472">cons</a> and <a 
href="clmch10.html#x68-10700010">symbol</a> are disjoint from the type
<a 
href="clmse35.html#x47-78004r54">function</a>, this is an incompatible change; now <a 
href="#x43-73042r43">functionp</a> is in fact always false of
symbols and lists.
</div>
</div>
<div class=defun>
<!--l. 600--><p class="noindent" > <i>[Function]</i>   <b>compiled-function-p</b> <a 
 id="dx43-73043"></a><a 
 id="x43-73044r44"></a>   <i>object</i>
<!--l. 602--><p class="noindent" ><a 
href="#x43-73044r44">compiled-function-p</a> is true if its argument is any compiled code object, and
otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(compiled-function-p x)  ≡ (typep x &#x2019;compiled-function)
</td></tr></table>
<!--l. 607--><p class="indent" >
</div>
</div>
</div>
<div class=obsolete>
                                                                          

                                                                          
<div class=defun>
<!--l. 611--><p class="noindent" > <i>[Function]</i>   <b>commonp</b> <a 
 id="dx43-73045"></a><a 
 id="x43-73046r45"></a>   <i>object</i>
<!--l. 613--><p class="noindent" ><a 
href="#x43-73046r45">commonp</a> is true if its argument is any standard Common Lisp data type, and
otherwise is false. <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(commonp x)  ≡ (typep x &#x2019;common)
</td></tr></table>
<!--l. 618--><p class="indent" >
</div>
</div>
</div>
</div>
<div class=newer>
<!--l. 623--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to remove the predicate <a 
href="#x43-73046r45">commonp</a> (and the
type common) from the language.
</div>
<!--l. 630--><p class="indent" >   See also <a 
href="clmse77.html#x95-137002r356">standard-char-p</a>, <a 
href="clmse77.html#x95-137006r358">string-char-p</a>, <a 
href="clmse114.html#x140-185002r654">streamp</a>, <a 
href="clmse74.html#x91-133014r318">random-state-p</a>, <a 
href="clmse115.html#x142-192007r674">readtablep</a>,
<a 
href="clmse92.html#x113-155004r544">hash-table-p</a>, and <a 
href="clmse119.html#x147-214016r747">pathnamep</a>.
                                                                          

                                                                          
   <!--l. 635--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse33.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html#tailclmse31.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse32.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 635--><p class="indent" >   <a 
 id="tailclmse32.html"></a>  
</body></html> 
