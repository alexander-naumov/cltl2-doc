<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Предикаты типов данных</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,index=2,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-04-16 00:55:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="cltl2ed.css"></head><body 
>
<!--l. 1067--><p class="noindent" > <div id="main_container"> <div id="content"> <div id="toplinks"><tt>&#x003C;</tt><a 
href="clmse33.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html#tailclmse31.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse32.html">В-конец</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse32.html" >Наверх</a><tt>&#x003E;</tt></div><h3 class="sectionHead"><span class="titlemark">6.2   </span> <a 
href="clm.html#QQ2-43-323" id="x43-3150006.2">Предикаты типов
данных</a></h3>
<!--l. 1069--><p class="noindent" >Возможно наиболее важными предикатами в Lisp&#x2019;е это предикаты, которые
различают типы данных. То есть позволяют узнать принадлежит ли
заданный объект данному типу. Также предикаты могут сравнивать два
спецификатора типов.
<!--l. 1073--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.1   </span> <a 
href="clmli1.html#QQ2-43-324" id="x43-3160006.2.1">Основные предикаты</a></h4>
<!--l. 1075--><p class="noindent" >Если тип данных рассматривать, как множество все объектов, принадлежащих
этому типу, тогда функция <tt><a 
href="#x43-316002r20">typep</a></tt> проверяет принадлежность множеству,
тогда как <tt>subtypep</tt> — принадлежность подмножеству.
<div class="defun">
<!--l. 1079--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-316001"></a><a 
 id="x43-316002r20"></a><b> typep</b>  <i>object</i> <i>type</i>
</div>
<!--l. 1081--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3170006.2.1" id="x43-3170006.2.1"></a></span>
<tt>
   <a 
href="#x43-316002r20">typep</a></tt> является предикатом, который истинен, если объект <i>object</i>
принадлежит типу <i>type</i>, и ложен в противном случае. Следует отметить, что
объект может принадлежать нескольким типам, так как один тип может
включать другой. <i>type</i> может быть любым спецификатором типа, описанным
в главе <a 
href="clmch4.html#x26-1460004">4<!--tex4ht:ref: DTSPEC --></a>, за исключением того, что он не может быть или включать список
спецификатор типа, у которого первый элемент равен <tt><a 
href="clmse35.html#x47-433005r52">function</a></tt> или
<tt><a 
href="clmse43.html#x55-707002r111">values</a></tt>. Спецификатор формы <tt>(satisfies <i>fn</i>)</tt> обрабатывается просто
как применение функции <i>fn</i> к объекту <i>object</i> (смотрите <tt><a 
href="clmse37.html#x49-575002r74">funcall</a></tt>).
Объект <i>object</i> принадлежит заданному типу, если результат не равен
<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>.
<div class="new">
<!--l. 1094--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx43-317001"></a>to change <tt><a 
href="#x43-316002r20">typep</a></tt> to give specialized
<tt>array</tt> and <tt><a 
href="clmse68.html#x85-1068002r253">complex</a></tt> type speciﬁers the same meaning for purposes of type
                                                                          

                                                                          
discrimination as they have for declaration purposes. Of course, this also applies
to such type speciﬁers as <tt><a 
href="clmse90.html#x112-1468002r522">vector</a></tt> and <tt>simple-array</tt> (see section <a 
href="clmse22.html#x31-1610004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>). Thus
<div class="lisp"><div class="tabbing">
(typep foo &#x2019;(array bignum))
   <br>
<!--l. 1105--><p class="noindent" ></div>
<!--l. 1105--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3180006.2.1" id="x43-3180006.2.1"></a></span>
<!--l. 1105--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3190006.2.1" id="x43-3190006.2.1"></a></span>
</div>
<!--l. 1106--><p class="indent" >   in the ﬁrst edition asked the question, Is <tt>foo</tt> an array specialized to hold
bignums? but under the new interpretation asks the question, Could the array <tt>foo</tt>
have resulted from giving <tt>bignum</tt> as the <tt>:element-type</tt> argument to
<tt><a 
href="clmse90.html#x112-1460002r518">make-array</a></tt>?
</div>
</div>
<div class="defun">
<!--l. 1114--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-319001"></a><a 
 id="x43-319002r21"></a><b> subtypep</b>  <i>type1</i> <i>type2</i>
</div>
<!--l. 1116--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3200006.2.1" id="x43-3200006.2.1"></a></span>
   Аргументы должны быть спецификаторами типов, но только теми,
которые могут использоваться и для <tt><a 
href="#x43-316002r20">typep</a></tt>. Два спецификатора типа
сравниваются. Данный предикат истинен, если тип <i>type1</i> точно является
подтипом типа <i>type2</i>, иначе предикат ложен. Если результат <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>, тогда тип
<i>type1</i> может быть, а может и не быть подтипом типа <i>type2</i> (иногда это
невозможно определить, особенно когда используется тип <tt>satisfies</tt>). Второе
возвращаемое значение указывает на точность результата. Если оно является
истиной, значит первое значение указывает на точную принадлежность
типов. Таким образом возможны следующие комбинации результатов:
<div class="tabbing">
                                                                          

                                                                          
<tt><a 
href="clmse31.html#x42-313002r19">t</a></tt>       <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt>       <i>type1</i> точно является подтипом <i>type2</i>
   <br>             <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>     <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt>       <i>type1</i> точно не является подтипом <i>type2</i><br>
<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>     <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>     <tt><a 
href="#x43-319002r21">subtypep</a></tt> не может определить отношение<br>
<!--l. 1132--><p class="noindent" ></div>
<!--l. 1132--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3210006.2.1" id="x43-3210006.2.1"></a></span>
<div class="new">
   X3J13 voted in January 1989 <a 
 id="dx43-321001"></a>to place certain requirements upon the
implementation of <tt><a 
href="#x43-319002r21">subtypep</a></tt>, for it noted that implementations in many cases
simply “give up” and return the two values <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> and <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> when in fact it would
have been possible to determine the relationship between the given types. The
requirements are as follows, where it is understood that a type speciﬁer <i>s</i> <i>involves</i>
a type speciﬁer <i>u</i> if either <i>s</i> contains an occurrence of <i>u</i> directly or <i>s</i>
contains a type speciﬁer <i>w</i> deﬁned by <tt><a 
href="clmse24.html#x33-193002r6">deftype</a></tt> whose expansion involves
<i>u</i>.
      <ul class="itemize1">
      <li class="itemize"><tt><a 
href="#x43-319002r21">subtypep</a></tt> is not permitted to return a second value of <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt> unless one
      or both of its arguments involves <tt>satisfies</tt>, <tt><a 
href="clmse34.html#x45-413002r49">and</a></tt>, <tt><a 
href="clmse34.html#x45-420002r50">or</a></tt>, <tt><a 
href="clmse34.html#x45-412002r48">not</a></tt>, or <tt><a 
href="clmse86.html#x106-1379002r484">member</a></tt>.
      </li>
      <li class="itemize"><tt><a 
href="#x43-319002r21">subtypep</a></tt> should signal an error when one or both of its arguments
      involves <tt><a 
href="clmse43.html#x55-707002r111">values</a></tt> or the list form of the <tt><a 
href="clmse35.html#x47-433005r52">function</a></tt> type speciﬁer.
      </li>
      <li class="itemize"><tt><a 
href="#x43-319002r21">subtypep</a></tt> must always return the two values <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> and <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> in the case where
      its arguments, after expansion of speciﬁers deﬁned by <tt><a 
href="clmse24.html#x33-193002r6">deftype</a></tt>, are
      <tt><a 
href="clmse33.html#x44-405002r46">equal</a></tt>.</li></ul>
<!--l. 1155--><p class="noindent" >In addition, X3J13 voted to clarify that in some cases the relationships between types
as reﬂected by <tt><a 
href="#x43-319002r21">subtypep</a></tt> may be implementation-speciﬁc. For example, in an
implementation supporting only one type of ﬂoating-point number, <tt>(subtypep
&#x2019;float &#x2019;long-float)</tt> would return <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt> and <tt><a 
href="clmse31.html#x42-313002r19">t</a></tt>, since the two types would be
identical.
<!--l. 1162--><p class="indent" >   Note that <tt>satisfies</tt> is an exception because relationships between types
involving <tt>satisfies</tt> are undecidable in general, but (as X3J13 noted) <tt><a 
href="clmse34.html#x45-413002r49">and</a></tt>, <tt><a 
href="clmse34.html#x45-420002r50">or</a></tt>,
                                                                          

                                                                          
<tt><a 
href="clmse34.html#x45-412002r48">not</a></tt>, and <tt><a 
href="clmse86.html#x106-1379002r484">member</a></tt> are merely very messy to deal with. In all likelihood these will
not be addressed unless and until someone is willing to write a careful
speciﬁcation that covers all the cases for the processing of these type speciﬁers by
<tt><a 
href="#x43-319002r21">subtypep</a></tt>. The requirements stated above were easy to state and probably suﬃce
for most cases of interest.
</div>
<div class="new">
   X3J13 voted in January 1989 <a 
 id="dx43-321002"></a>to change <tt><a 
href="#x43-319002r21">subtypep</a></tt> to give specialized
<tt>array</tt> and <tt><a 
href="clmse68.html#x85-1068002r253">complex</a></tt> type speciﬁers the same meaning for purposes of
type discrimination as they have for declaration purposes. Of course, this
also applies to such type speciﬁers as <tt><a 
href="clmse90.html#x112-1468002r522">vector</a></tt> and <tt>simple-array</tt> (see
section <a 
href="clmse22.html#x31-1610004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>).
<!--l. 1182--><p class="indent" >   If <i>A</i> and <i>B</i> are type speciﬁers (other than <tt><a 
href="clmse107.html#x132-1646002r590">*</a></tt>, which technically is not a type
speciﬁer anyway), then <tt>(array <i>A</i>)</tt> and <tt>(array <i>B</i>)</tt> represent the same type in
a given implementation if and only if they denote arrays of the same
specialized representation in that implementation; otherwise they are
disjoint. To put it another way, they represent the same type if and only if
<tt>(upgraded-array-element-type &#x2019;<i>A</i>)</tt> and <tt>(upgraded-array-element-type &#x2019;<i>B</i>)</tt>
are the same type. Therefore <div class="lisp"><div class="tabbing">
(subtypep &#x2019;(array <i>A</i>) &#x2019;(array <i>B</i>))
   <br>
<!--l. 1196--><p class="noindent" ></div>
<!--l. 1196--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3220006.2.1" id="x43-3220006.2.1"></a></span>
<!--l. 1196--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3230006.2.1" id="x43-3230006.2.1"></a></span>
</div>
<!--l. 1197--><p class="indent" >   is true if and only if <tt>(upgraded-array-element-type &#x2019;<i>A</i>)</tt> is the same type
as <tt>(upgraded-array-element-type &#x2019;<i>B</i>)</tt>.
<!--l. 1202--><p class="indent" >   The <tt><a 
href="clmse68.html#x85-1068002r253">complex</a></tt> type speciﬁer is treated in a similar but subtly diﬀerent manner.
If <i>A</i> and <i>B</i> are two type speciﬁers (but not <tt><a 
href="clmse107.html#x132-1646002r590">*</a></tt>, which technically is not a type
speciﬁer anyway), then <tt>(complex <i>A</i>)</tt> and <tt>(complex <i>B</i>)</tt> represent the same type
in a given implementation if and only if they refer to complex numbers of the
                                                                          

                                                                          
same specialized representation in that implementation; otherwise they are
disjoint. Note, however, that there is no function called <tt>make-complex</tt> that
allows one to specify a particular element type (then to be upgraded);
instead, one must describe specialized complex numbers in terms of the
actual types of the parts from which they were constructed. There is no
number of type (or rather, <i>representation</i>) <tt><a 
href="clmse68.html#x85-1039002r231">float</a></tt> as such; there are only
numbers of type <tt>single-float</tt>, numbers of type <tt>double-float</tt>, and so on.
Therefore we want <tt>(complex single-float)</tt> to be a subtype of <tt>(complex
float)</tt>.
<!--l. 1220--><p class="indent" >   The rule, then, is that <tt>(complex <i>A</i>)</tt> and <tt>(complex <i>B</i>)</tt> represent the same
type (and otherwise are disjoint) in a given implementation if and only if <i>either</i>
the type <i>A</i> is a subtype of <i>B</i>, <i>or</i> <tt>(upgraded-complex-part-type &#x2019;<i>A</i>)</tt> and
<tt>(upgraded-complex-part-type &#x2019;<i>B</i>)</tt> are the same type. In the latter
case <tt>(complex <i>A</i>)</tt> and <tt>(complex <i>B</i>)</tt> in fact refer to the same specialized
representation. Therefore <div class="lisp"><div class="tabbing">
(subtypep &#x2019;(complex <i>A</i>) &#x2019;(complex <i>B</i>))
   <br>
<!--l. 1231--><p class="noindent" ></div>
<!--l. 1231--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3240006.2.1" id="x43-3240006.2.1"></a></span>
<!--l. 1231--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3250006.2.1" id="x43-3250006.2.1"></a></span>
</div>
<!--l. 1232--><p class="indent" >   is true if and only if the results of <tt>(upgraded-complex-part-type &#x2019;<i>A</i>)</tt> and
<tt>(upgraded-complex-part-type &#x2019;<i>B</i>)</tt> are the same type.
<!--l. 1236--><p class="indent" >   Under this interpretation <div class="lisp"><div class="tabbing">
(subtypep &#x2019;(complex single-ﬂoat) &#x2019;(complex ﬂoat))
   <br>
<!--l. 1239--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1239--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3260006.2.1" id="x43-3260006.2.1"></a></span>
<!--l. 1239--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3270006.2.1" id="x43-3270006.2.1"></a></span>
</div>
<!--l. 1240--><p class="indent" >   must be true in all implementations; but <div class="lisp"><div class="tabbing">
(subtypep &#x2019;(array single-ﬂoat) &#x2019;(array ﬂoat))
   <br>
<!--l. 1243--><p class="noindent" ></div>
<!--l. 1243--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3280006.2.1" id="x43-3280006.2.1"></a></span>
<!--l. 1243--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3290006.2.1" id="x43-3290006.2.1"></a></span>
</div>
<!--l. 1244--><p class="indent" >   is true only in implementations that do not have a specialized array
representation for <tt>single-float</tt> elements distinct from that for <tt><a 
href="clmse68.html#x85-1039002r231">float</a></tt> elements
in general.
</div>
</div>
<!--l. 1250--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">6.2.2   </span> <a 
href="clmli1.html#QQ2-43-338" id="x43-3300006.2.2">Специальные предикаты</a></h4>
<!--l. 1252--><p class="noindent" >Следующие предикаты осуществляют проверку определённых типов
данных.
<div class="defun">
<!--l. 1254--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-330001"></a><a 
 id="x43-330002r22"></a><b> null</b>  <i>object</i>
</div>
<!--l. 1256--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3310006.2.2" id="x43-3310006.2.2"></a></span>
<tt>
                                                                          

                                                                          
   <a 
href="#x43-330002r22">null</a></tt> истинен, если аргумент является (), иначе является ложью. Похожая
операция производится <tt><a 
href="clmse34.html#x45-412002r48">not</a></tt>, однако <tt><a 
href="clmse34.html#x45-412002r48">not</a></tt> используется для отрицания булевых
значение, тогда как <tt><a 
href="#x43-330002r22">null</a></tt> используется для проверки того, пустой ли список.
Таким образом программист может выразить свои намерения, выбрав
нужное имя функции. <div class="lisp"><div class="tabbing">
(null x) <span class="math"> ≡</span> (typep x &#x2019;null) <span class="math"> ≡</span> (eq x &#x2019;())
   <br>
<!--l. 1264--><p class="noindent" ></div>
<!--l. 1264--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3320006.2.2" id="x43-3320006.2.2"></a></span>
<!--l. 1264--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3330006.2.2" id="x43-3330006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1267--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-333001"></a><a 
 id="x43-333002r23"></a><b> symbolp</b>  <i>object</i>
</div>
<!--l. 1269--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3340006.2.2" id="x43-3340006.2.2"></a></span>
<tt>
   <a 
href="#x43-333002r23">symbolp</a></tt> истинен, если её аргумент является символом, в противном
случае ложен. <div class="lisp"><div class="tabbing">
(symbolp x) <span class="math"> ≡</span> (typep x &#x2019;symbol)
   <br>
<!--l. 1274--><p class="noindent" ></div>
<!--l. 1274--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3350006.2.2" id="x43-3350006.2.2"></a></span>
                                                                          

                                                                          
<!--l. 1274--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3360006.2.2" id="x43-3360006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1277--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-336001"></a><a 
 id="x43-336002r24"></a><b> atom</b>  <i>object</i>
</div>
<!--l. 1279--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3370006.2.2" id="x43-3370006.2.2"></a></span>
   Предикат <tt><a 
href="#x43-336002r24">atom</a></tt> истинен, если аргумент не является cons-ячейкой, в
противном случае ложен. Следует отметить <tt>(atom &#x2019;())</tt> являет истиной,
потому что ()<span class="math">  ≡</span><tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. <div class="lisp"><div class="tabbing">
(atom x) <span class="math"> ≡</span> (typep x &#x2019;atom) <span class="math"> ≡</span> (not (typep x &#x2019;cons))
   <br>
<!--l. 1286--><p class="noindent" ></div>
<!--l. 1286--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3380006.2.2" id="x43-3380006.2.2"></a></span>
<!--l. 1286--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3390006.2.2" id="x43-3390006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1289--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-339001"></a><a 
 id="x43-339002r25"></a><b> consp</b>  <i>object</i>
</div>
<!--l. 1291--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3400006.2.2" id="x43-3400006.2.2"></a></span>
   Предикат <tt><a 
href="#x43-339002r25">consp</a></tt> истинен, если его аргумент является cons-ячейкой, в
противном случае ложен. Следует отметить, пустой список не является
cons-ячейкой, так <tt>(consp &#x2019;())</tt> <span class="math"> ≡</span> <tt>(consp &#x2019;<tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>)</tt> <span class="math"> ⇒</span> <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>. <div class="lisp"><div class="tabbing">
(consp x) <span class="math"> ≡</span> (typep x &#x2019;cons) <span class="math"> ≡</span> (not (typep x &#x2019;atom))
   <br>
<!--l. 1298--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1298--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3410006.2.2" id="x43-3410006.2.2"></a></span>
<!--l. 1298--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3420006.2.2" id="x43-3420006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1301--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-342001"></a><a 
 id="x43-342002r26"></a><b> listp</b>  <i>object</i>
</div>
<!--l. 1303--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3430006.2.2" id="x43-3430006.2.2"></a></span>
<tt>
   <a 
href="#x43-342002r26">listp</a></tt> истинен, если его аргумент является cons-ячейкой или пустым
списком (), в противном случае ложен. Она не проверяет является ли «список
Ъ (true list)» (завершающийся <tt><a 
href="clmse31.html#x42-312002r18">nil</a></tt>) или «с точкой (dotted)» (завершающийся
не-null атомом). <div class="lisp"><div class="tabbing">
(listp x) <span class="math"> ≡</span> (typep x &#x2019;list) <span class="math"> ≡</span> (typep x &#x2019;(or cons null))
   <br>
<!--l. 1310--><p class="noindent" ></div>
<!--l. 1310--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3440006.2.2" id="x43-3440006.2.2"></a></span>
<!--l. 1310--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3450006.2.2" id="x43-3450006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1313--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-345001"></a><a 
 id="x43-345002r27"></a><b> numberp</b>  <i>object</i>
</div>
<!--l. 1315--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3460006.2.2" id="x43-3460006.2.2"></a></span>
<tt>
   <a 
href="#x43-345002r27">numberp</a></tt> истинен, если аргумент это любой вид числа, в противном случае
ложен. <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(numberp x) <span class="math"> ≡</span> (typep x &#x2019;number)
   <br>
<!--l. 1320--><p class="noindent" ></div>
<!--l. 1320--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3470006.2.2" id="x43-3470006.2.2"></a></span>
<!--l. 1320--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3480006.2.2" id="x43-3480006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1323--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-348001"></a><a 
 id="x43-348002r28"></a><b> integerp</b>  <i>object</i>
</div>
<!--l. 1325--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3490006.2.2" id="x43-3490006.2.2"></a></span>
<i>
   integerp</i> истинен, если аргумент целое число, в противном случае ложен.
<div class="lisp"><div class="tabbing">
(integerp x) <span class="math"> ≡</span> (typep x &#x2019;integer)
   <br>
<!--l. 1330--><p class="noindent" ></div>
<!--l. 1330--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3500006.2.2" id="x43-3500006.2.2"></a></span>
<!--l. 1330--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3510006.2.2" id="x43-3510006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1333--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-351001"></a><a 
 id="x43-351002r29"></a><b> rationalp</b>  <i>object</i>
</div>
                                                                          

                                                                          
<!--l. 1335--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3520006.2.2" id="x43-3520006.2.2"></a></span>
<tt>
   <a 
href="#x43-351002r29">rationalp</a></tt> истинен, если аргумент рациональное число (дробь или целое),
в противном случае ложен. <div class="lisp"><div class="tabbing">
(rationalp x) <span class="math"> ≡</span> (typep x &#x2019;rational)
   <br>
<!--l. 1340--><p class="noindent" ></div>
<!--l. 1340--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3530006.2.2" id="x43-3530006.2.2"></a></span>
<!--l. 1340--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3540006.2.2" id="x43-3540006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1343--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-354001"></a><a 
 id="x43-354002r30"></a><b> ﬂoatp</b>  <i>object</i>
</div>
<!--l. 1345--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3550006.2.2" id="x43-3550006.2.2"></a></span>
<tt>
   <a 
href="#x43-354002r30">floatp</a></tt> истинен, если аргумент число с плавающей точкой, в противном
случае ложен. <div class="lisp"><div class="tabbing">
(ﬂoatp x) <span class="math"> ≡</span> (typep x &#x2019;ﬂoat)
   <br>
<!--l. 1350--><p class="noindent" ></div>
<!--l. 1350--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3560006.2.2" id="x43-3560006.2.2"></a></span>
                                                                          

                                                                          
<!--l. 1350--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3570006.2.2" id="x43-3570006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1353--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-357001"></a><a 
 id="x43-357002r31"></a><b> realp</b>  <i>object</i>
</div>
<!--l. 1355--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3580006.2.2" id="x43-3580006.2.2"></a></span>
<tt>
   <a 
href="#x43-357002r31">realp</a></tt> истинна, если аргумент является действительным числом, иначе
ложна. <div class="lisp"><div class="tabbing">
(realp x) <span class="math"> ≡</span> (typep x &#x2019;real)
   <br>
<!--l. 1360--><p class="noindent" ></div>
<!--l. 1360--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3590006.2.2" id="x43-3590006.2.2"></a></span>
<!--l. 1360--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3600006.2.2" id="x43-3600006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1363--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-360001"></a><a 
 id="x43-360002r32"></a><b> complexp</b>  <i>object</i>
</div>
<!--l. 1365--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3610006.2.2" id="x43-3610006.2.2"></a></span>
<i>
   complexp</i> истинен, если аргумент комплексное число, в противном случае
ложен. <div class="lisp"><div class="tabbing">
(complexp x) <span class="math"> ≡</span> (typep x &#x2019;complex)
   <br>
<!--l. 1370--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1370--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3620006.2.2" id="x43-3620006.2.2"></a></span>
<!--l. 1370--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3630006.2.2" id="x43-3630006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1373--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-363001"></a><a 
 id="x43-363002r33"></a><b> characterp</b>  <i>object</i>
</div>
<!--l. 1375--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3640006.2.2" id="x43-3640006.2.2"></a></span>
<tt>
   <a 
href="#x43-363002r33">characterp</a></tt> истинен, если аргумент строковый символ, иначе ложен.
<div class="lisp"><div class="tabbing">
(characterp x) <span class="math"> ≡</span> (typep x &#x2019;character)
   <br>
<!--l. 1380--><p class="noindent" ></div>
<!--l. 1380--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3650006.2.2" id="x43-3650006.2.2"></a></span>
<!--l. 1380--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3660006.2.2" id="x43-3660006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1383--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-366001"></a><a 
 id="x43-366002r34"></a><b> stringp</b>  <i>object</i>
</div>
<!--l. 1385--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3670006.2.2" id="x43-3670006.2.2"></a></span>
<tt>
   <a 
href="#x43-366002r34">stringp</a></tt> истинен, если аргумент строка, иначе ложен. <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(stringp x) <span class="math"> ≡</span> (typep x &#x2019;string)
   <br>
<!--l. 1389--><p class="noindent" ></div>
<!--l. 1389--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3680006.2.2" id="x43-3680006.2.2"></a></span>
<!--l. 1389--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3690006.2.2" id="x43-3690006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1392--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-369001"></a><a 
 id="x43-369002r35"></a><b> bit-vector-p</b>  <i>object</i>
</div>
<!--l. 1394--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3700006.2.2" id="x43-3700006.2.2"></a></span>
<tt>
   <a 
href="#x43-369002r35">bit-vector-p</a></tt> истинен, если аргумент битовый вектор, иначе ложен.
<div class="lisp"><div class="tabbing">
(bit-vector-p x) <span class="math"> ≡</span> (typep x &#x2019;bit-vector)
   <br>
<!--l. 1398--><p class="noindent" ></div>
<!--l. 1398--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3710006.2.2" id="x43-3710006.2.2"></a></span>
<!--l. 1398--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3720006.2.2" id="x43-3720006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1401--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-372001"></a><a 
 id="x43-372002r36"></a><b> vectorp</b>  <i>object</i>
</div>
                                                                          

                                                                          
<!--l. 1403--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3730006.2.2" id="x43-3730006.2.2"></a></span>
<tt>
   <a 
href="#x43-372002r36">vectorp</a></tt> истинен, если аргумент вектор, иначе ложен. <div class="lisp"><div class="tabbing">
(vectorp x) <span class="math"> ≡</span> (typep x &#x2019;vector)
   <br>
<!--l. 1407--><p class="noindent" ></div>
<!--l. 1407--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3740006.2.2" id="x43-3740006.2.2"></a></span>
<!--l. 1407--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3750006.2.2" id="x43-3750006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1410--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-375001"></a><a 
 id="x43-375002r37"></a><b> simple-vector-p</b>  <i>object</i>
</div>
<!--l. 1412--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3760006.2.2" id="x43-3760006.2.2"></a></span>
<tt>
   <a 
href="#x43-372002r36">vectorp</a></tt> истинен, если аргумент простой общий вектор, иначе ложен.
<div class="lisp"><div class="tabbing">
(simple-vector-p x) <span class="math"> ≡</span> (typep x &#x2019;simple-vector)
   <br>
<!--l. 1417--><p class="noindent" ></div>
<!--l. 1417--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3770006.2.2" id="x43-3770006.2.2"></a></span>
                                                                          

                                                                          
<!--l. 1417--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3780006.2.2" id="x43-3780006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1420--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-378001"></a><a 
 id="x43-378002r38"></a><b> simple-string-p</b>  <i>object</i>
</div>
<!--l. 1422--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3790006.2.2" id="x43-3790006.2.2"></a></span>
<tt>
   <a 
href="#x43-378002r38">simple-string-p</a></tt> истинен, если аргумент простая строка, иначе ложен.
<div class="lisp"><div class="tabbing">
(simple-string-p x) <span class="math"> ≡</span> (typep x &#x2019;simple-string)
   <br>
<!--l. 1427--><p class="noindent" ></div>
<!--l. 1427--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3800006.2.2" id="x43-3800006.2.2"></a></span>
<!--l. 1427--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3810006.2.2" id="x43-3810006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1430--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-381001"></a><a 
 id="x43-381002r39"></a><b> simple-bit-vector-p</b>  <i>object</i>
</div>
<!--l. 1432--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3820006.2.2" id="x43-3820006.2.2"></a></span>
<tt>
   <a 
href="#x43-381002r39">simple-bit-vector-p</a></tt> истинен, если аргумент простой битовый вектор,
иначе ложен. <div class="lisp"><div class="tabbing">
(simple-bit-vector-p x) <span class="math"> ≡</span> (typep x &#x2019;simple-bit-vector)
   <br>
<!--l. 1437--><p class="noindent" ></div>
                                                                          

                                                                          
<!--l. 1437--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3830006.2.2" id="x43-3830006.2.2"></a></span>
<!--l. 1437--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3840006.2.2" id="x43-3840006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1440--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-384001"></a><a 
 id="x43-384002r40"></a><b> arrayp</b>  <i>object</i>
</div>
<!--l. 1442--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3850006.2.2" id="x43-3850006.2.2"></a></span>
<tt>
   <a 
href="#x43-384002r40">arrayp</a></tt> истинен, если аргумент массив, иначе ложен. <div class="lisp"><div class="tabbing">
(arrayp x) <span class="math"> ≡</span> (typep x &#x2019;array)
   <br>
<!--l. 1446--><p class="noindent" ></div>
<!--l. 1446--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3860006.2.2" id="x43-3860006.2.2"></a></span>
<!--l. 1446--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3870006.2.2" id="x43-3870006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1449--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-387001"></a><a 
 id="x43-387002r41"></a><b> packagep</b>  <i>object</i>
</div>
<!--l. 1451--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3880006.2.2" id="x43-3880006.2.2"></a></span>
<tt>
   <a 
href="#x43-387002r41">packagep</a></tt> истинен, если аргумент является пакетом, иначе является
ложью. <div class="lisp"><div class="tabbing">
                                                                          

                                                                          
(packagep x) <span class="math"> ≡</span> (typep x &#x2019;package)
   <br>
<!--l. 1456--><p class="noindent" ></div>
<!--l. 1456--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3890006.2.2" id="x43-3890006.2.2"></a></span>
<!--l. 1456--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3900006.2.2" id="x43-3900006.2.2"></a></span>
</div>
</div>
<div class="defun">
<!--l. 1459--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-390001"></a><a 
 id="x43-390002r42"></a><b> functionp</b>  <i>object</i>
</div>
<!--l. 1461--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3910006.2.2" id="x43-3910006.2.2"></a></span>
<div class="lisp">
   <div class="tabbing">
(functionp x) <span class="math"> ≡</span> (typep x &#x2019;function)
   <br>
</div>
<!--l. 1464--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3920006.2.2" id="x43-3920006.2.2"></a></span>
<!--l. 1464--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3930006.2.2" id="x43-3930006.2.2"></a></span>
</div>
   Типы <tt><a 
href="clmse82.html#x102-1278002r440">cons</a></tt> и <tt><a 
href="clmch10.html#x67-85500010">symbol</a></tt> непересекаются с типом <tt><a 
href="clmse35.html#x47-433005r52">function</a></tt>. <tt><a 
href="#x43-390002r42">functionp</a></tt>
является ложной для символов и списков.
</div>
<div class="defun">
<!--l. 1471--><p class="noindent" ><div class="defunheader"> <i>[Функция]</i><a 
 id="dx43-393001"></a><a 
 id="x43-393002r43"></a><b> compiled-function-p</b>  <i>object</i>
</div>
                                                                          

                                                                          
<!--l. 1473--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3940006.2.2" id="x43-3940006.2.2"></a></span>
<tt>
   <a 
href="#x43-393002r43">compiled-function-p</a></tt> истинен, если аргумент — скомпилированный
объект кода, иначе ложен. <div class="lisp"><div class="tabbing">
(compiled-function-p x) <span class="math"> ≡</span> (typep x &#x2019;compiled-function)
   <br>
<!--l. 1478--><p class="noindent" ></div>
<!--l. 1478--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3950006.2.2" id="x43-3950006.2.2"></a></span>
<!--l. 1478--><p class="noindent" ><span class="paragraphHead"><a 
href="#x43-3960006.2.2" id="x43-3960006.2.2"></a></span>
</div>
</div>
<!--l. 1481--><p class="indent" >   Смотрите также <tt><a 
href="clmse74.html#x92-1147002r336">standard-char-p</a></tt>, <tt>string-char-p</tt>, <tt><a 
href="clmse110.html#x136-1676002r614">streamp</a></tt>, <tt><a 
href="clmse71.html#x88-1126002r300">random-state-p</a></tt>,
<tt><a 
href="clmse111.html#x138-1792002r632">readtablep</a></tt>, <tt><a 
href="clmse88.html#x109-1437002r507">hash-table-p</a></tt> и <tt><a 
href="clmse115.html#x143-2126003r704">pathnamep</a></tt>.
                                                                          

                                                                          
<!--l. 1486--><p class="indent" >   <div id="bottomlinks"><tt>&#x003C;</tt><a 
href="clmse33.html" >Далее</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html" >Назад</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse31.html#tailclmse31.html" >Назад-и-вниз</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse32.html" >В-начало</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch6.html#clmse32.html" >Наверх</a><tt>&#x003E;</tt></div><a 
 id="tailclmse32.html"></a>   </div> </div> 
</body></html> 
