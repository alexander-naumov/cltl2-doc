<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Generalized Variables</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-20 00:42:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 643--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse37.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html#tailclmse35.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse36.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse36.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">7.2   </span> <a 
 id="x48-800007.2"></a>Generalized Variables</h3>
<!--l. 646--><p class="noindent" >In Lisp, a variable can remember one piece of data, that is, one Lisp object. The
main operations on a variable are to recover that object and to alter the variable
to remember a new object; these operations are often called access and
update operations. The concept of variables named by symbols can be
generalized to any storage location that can remember one piece of data, no
matter how that location is named. Examples of such storage locations are
the car and cdr of a cons, elements of an array, and components of a
structure.
<!--l. 656--><p class="indent" >   For each kind of generalized variable, typically there are two functions that
implement the conceptual access and update operations. For a variable, merely
mentioning the name of the variable accesses it, while the <i>setq</i> special form can be
used to update it. The function <i>car</i> accesses the car of a cons, and the function
<i>rplaca</i> updates it. The function <i>symbol-value</i> accesses the dynamic value
of a variable named by a given symbol, and the function <i>set</i> updates
it.
<!--l. 665--><p class="indent" >   Rather than thinking about two distinct functions that respectively access and
update a storage location somehow deduced from their arguments, we can instead
simply think of a call to the access function with given arguments as a name for
the storage location. Thus, just as <i>x</i> may be considered a name for a
storage location (a variable), so <i>(car x)</i> is a name for the car of some cons
(which is in turn named by <i>x</i>). Now, rather than having to remember two
functions for each kind of generalized variable (having to remember, for
example, that <i>rplaca</i> corresponds to <i>car</i>), we adopt a uniform syntax
for updating storage locations named in this way, using the <i>setf </i> macro.
This is analogous to the way we use the <i>setq</i> special form to convert the
name of a variable (which is also a form that accesses it) into a form that
updates it. The uniformity of this approach is illustrated in the following
table.
<div class="flushleft" 
>
                                                                          

                                                                          
<!--l. 680--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Access Function </td><td align="left" >Update Function</td><td align="left" >Update Using <i>setf </i>             </td>
</tr><tr><td align="left" ><i>x</i>                   </td><td align="left" ><i>(setq x datum)</i>   </td><td align="left" ><i>(setf x datum)</i>                   </td>
</tr><tr><td align="left" ><i>(car x)</i>             </td><td align="left" ><i>(rplaca x datum)</i></td><td align="left" ><i>(setf (car x) datum)</i>            </td>
</tr><tr><td align="left" ><i>(symbol-value x)</i> </td><td align="left" ><i>(set x datum)</i>    </td><td align="left" ><i>(setf (symbol-value x) datum)</i></td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" >  </td></tr></table>
</div></div>
<i>
<!--l. 690--><p class="noindent" >setf </i> is actually a macro that examines an access form and produces a call to the
corresponding update function.
<!--l. 693--><p class="indent" >   Given the existence of <i>setf </i> in Common Lisp, it is not necessary to have <i>setq</i>,
<i>rplaca</i>, and <i>set</i>; they are redundant. They are retained in Common Lisp because
of their historical importance in Lisp. However, most other update functions
(such as <i>putprop</i>, the update function for <i>get</i>) have been eliminated from
Common Lisp in the expectation that <i>setf </i> will be uniformly used in their
place.
<div class=defmac>
<!--l. 701--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> setf </b> <a 
 id="dx48-80001"></a><a 
 id="x48-80002r67"></a>   {<i>placenewvalue</i>}∗
</td></tr></table>
<!--l. 702--><p class="indent" >
</div>
   <i>(setf place newvalue)</i> takes a form place that when evaluated accesses a data
object in some location and “inverts” it to produce a corresponding form to update
the location. A call to the <i>setf </i> macro therefore expands into an update form that
stores the result of evaluating the form newvalue into the place referred to by the
access form.
   If more than one place-newvalue pair is speciﬁed, the pairs are processed
sequentially; that is, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf place1 newvalue1
</td></tr></table>
<!--l. 713--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      place2 newvalue2)</td></tr></table>
<!--l. 714--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ...</td></tr></table>
<!--l. 715--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      placen newvaluen)</td></tr></table>
<!--l. 717--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 718--><p class="noindent" >is precisely equivalent to <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setf place1 newvalue1)
</td></tr></table>
<!--l. 720--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (setf place2 newvalue2)</td></tr></table>
<!--l. 721--><p class="indent" >                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       ...</td></tr></table>
<!--l. 722--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (setf placen newvaluen))</td></tr></table>
<!--l. 724--><p class="indent" >
</div>
</div>
<!--l. 725--><p class="noindent" >For consistency, it is legal to write <i>(setf)</i>, which simply returns <i>nil</i>.
<!--l. 727--><p class="indent" >   The form place may be any one of the following:
      <ul class="itemize1">
      <li class="itemize">The name of a variable (either lexical or dynamic).
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of any one of the
      following functions:
      <div class="flushleft" 
>
<!--l. 736--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" ><i>aref </i>          </td><td align="left" ><i>car</i>         </td><td align="left" ><i>svref </i>                  </td><td align="left" >                   </td>
</tr><tr><td align="left" ><i>nth</i>            </td><td align="left" ><i>cdr</i>         </td><td align="left" ><i>get</i>                     </td><td align="left" >                   </td>
</tr><tr><td align="left" ><i>elt</i>             </td><td align="left" ><i>caar</i>        </td><td align="left" ><i>getf </i>                    </td><td align="left" ><i>symbol-value</i>    </td>
</tr><tr><td align="left" ><i>rest</i>           </td><td align="left" ><i>cadr</i>        </td><td align="left" ><i>gethash</i>               </td><td align="left" ><i>symbol-function</i></td>
</tr><tr><td align="left" ><i>ﬁrst</i>           </td><td align="left" ><i>cdar</i>        </td><td align="left" ><i>documentation     </i></td><td align="left" ><i>symbol-plist</i>     </td>
</tr><tr><td align="left" ><i>second</i>        </td><td align="left" ><i>cddr</i>        </td><td align="left" ><i>ﬁll-pointer</i>            </td><td align="left" ><i>macro-function</i> </td>
</tr><tr><td align="left" ><i>third</i>          </td><td align="left" ><i>caaar</i>      </td><td align="left" ><i>caaaar</i>                </td><td align="left" ><i>cdaaar</i>           </td></tr><tr><td align="left" ><i>fourth</i> </td> <td align="left" ><i>caadr</i> </td> <td align="left" ><i>caaadr</i> </td> <td align="left" ><i>cdaadr</i></td>
</tr><tr><td align="left" ><i>ﬁfth</i>           </td><td align="left" ><i>cadar</i>      </td><td align="left" ><i>caadar</i>                </td><td align="left" ><i>cdadar</i>           </td>
</tr><tr><td align="left" ><i>sixth</i>          </td><td align="left" ><i>caddr</i>      </td><td align="left" ><i>caaddr</i>                </td><td align="left" ><i>cdaddr</i>           </td></tr><tr><td align="left" ><i>seventh     </i></td> <td align="left" ><i>cdaar     </i></td> <td align="left" ><i>cadaar</i> </td> <td align="left" ><i>cddaar</i></td>
</tr><tr><td align="left" ><i>eighth</i>        </td><td align="left" ><i>cdadr</i>      </td><td align="left" ><i>cadadr</i>                </td><td align="left" ><i>cddadr</i>           </td>
</tr><tr><td align="left" ><i>ninth</i>         </td><td align="left" ><i>cddar</i>      </td><td align="left" ><i>caddar</i>                </td><td align="left" ><i>cdddar</i>           </td></tr><tr><td align="left" ><i>tenth</i> </td> <td align="left" ><i>cdddr</i> </td> <td align="left" ><i>cadddr</i> </td> <td align="left" ><i>cddddr</i></td>
</tr></table></div></div>
                                                                          

                                                                          
<div class=new>
      <!--l. 756--><p class="noindent" >X3J13 voted in March 1988 ⟨<b>?</b>⟩ to add <i>row-major-aref </i> to this list.
      </div>
<div class=newer>
      <!--l. 766--><p class="noindent" >X3J13 voted in June 1989 ⟨<b>?</b>⟩ to add <i>compiler-macro-function</i> to this
      list.
      </div>
<div class=newer>
      <!--l. 781--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that this rule applies only when
      the function name refers to a global function deﬁnition and not to a locally
      deﬁned function or macro.
      </div>
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of a selector function
      constructed by <i>defstruct</i>.
<div class=newer>
      <!--l. 791--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that this rule applies only when
      the function name refers to a global function deﬁnition and not to a locally
      deﬁned function or macro.
      </div>
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of any one of the
      following functions, provided that the new value is of the speciﬁed type so
                                                                          

                                                                          
      that it can be used to replace the speciﬁed “location” (which is in each of
      these cases not truly a generalized variable):
<div class=obsolete>
      <div class="flushleft" 
>
<!--l. 805--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Function Name</td><td align="left" >Required Type</td>
</tr><tr><td align="left" ><i>char</i>             </td><td align="left" ><i>string-char</i>     </td>
</tr><tr><td align="left" ><i>schar</i>            </td><td align="left" ><i>string-char</i>     </td>
</tr><tr><td align="left" ><i>bit</i>               </td><td align="left" ><i>bit</i>               </td></tr><tr><td align="left" ><i>sbit</i> </td> <td align="left" ><i>bit</i></td>
</tr><tr><td align="left" ><i>subseq</i>           </td><td align="left" ><i>sequence</i>        </td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
</div>
<div class=newer>
      <!--l. 821--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to eliminate the type <i>string-char</i>
      and to redeﬁne <i>string</i> to be the union of one or more specialized
      vector types, the types of whose elements are subtypes of the type
      <i>character</i>. In the preceding table, the type <i>string-char</i> should be
      replaced by some such phrase as “the element-type of the argument
      vector.”
      </div>
<div class=newer>
      <!--l. 830--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that this rule applies only when
      the function name refers to a global function deﬁnition and not to a locally
      deﬁned function or macro.
      </div>
      <!--l. 835--><p class="noindent" >In the case of <i>subseq</i>, the replacement value must be a sequence whose
      elements may be contained by the sequence argument to <i>subseq</i>. (Note that
      this is not so stringent as to require that the replacement value be a
      sequence of the same type as the sequence of which the subsequence is
      speciﬁed.) If the length of the replacement value does not equal the
      length of the subsequence to be replaced, then the shorter length
      determines the number of elements to be stored, as for the function
      <i>replace</i>.
      </li>
                                                                          

                                                                          
      <li class="itemize">A function call form whose ﬁrst element is the name of any one of the
      following functions, provided that the speciﬁed argument to that function is
      in turn a place form; in this case the new place has stored back into it the
      result of applying the speciﬁed “update” function (which is in each of these
      cases not a true update function):
      <div class="flushleft" 
>
<!--l. 852--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Function Name</td><td align="left" >Argument That Is a place</td><td align="left" >Update Function Used</td>
</tr><tr><td align="left" ><i>char-bit</i>         </td><td align="left" >ﬁrst                             </td><td align="left" ><i>set-char-bit</i>              </td></tr><tr><td align="left" ><i>ldb</i> </td> <td align="left" >second </td> <td align="left" ><i>dpb</i></td>
</tr><tr><td align="left" ><i>mask-ﬁeld</i>      </td><td align="left" >second                         </td><td align="left" ><i>deposit-ﬁeld</i>             </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
<div class=newer>
      <!--l. 864--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to eliminate <i>char-bit</i> and <i>set-char-bit</i>.
      </div>
<div class=newer>
      <!--l. 869--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that this rule applies only when
      the function name refers to a global function deﬁnition and not to a locally
      deﬁned function or macro.
      </div>
      </li>
      <li class="itemize">A <i>the</i> type declaration form, in which case the declaration is transferred to
      the newvalue form, and the resulting <i>setf </i> form is analyzed. For example, <div class=lisp>
      <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (the integer (cadr x)) (+ y 3))
</td></tr></table>
      <!--l. 880--><p class="noindent" >
</div>
</div>
      <!--l. 881--><p class="noindent" >is processed as if it were <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (cadr x) (the integer (+ y 3)))
</td></tr></table>
      <!--l. 884--><p class="noindent" >
</div>
</div>
      </li>
      <li class="itemize">A call to <i>apply</i> where the ﬁrst argument form is of the form <i>#&#x2019;name</i>, that
      is, <i>(function name)</i>, where name is the name of a function, calls to which are
      recognized as places by <i>setf </i>. Suppose that the use of <i>setf </i> with <i>apply</i> looks
      like this: <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (apply #&#x2019;name x1 x2 ... xn rest) x0)
</td></tr></table>
      <!--l. 893--><p class="noindent" >
</div>
</div>
      <!--l. 894--><p class="noindent" >The <i>setf </i> method for the function name must be such that <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (name z1 z2 ... zm) z0)
</td></tr></table>
      <!--l. 897--><p class="noindent" >
</div>
</div>
      <!--l. 898--><p class="noindent" >expands into a store form <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(storefn zi<sub>1</sub> zi<sub>2</sub> ... zi<sub>k</sub> zm)
</td></tr></table>
      <!--l. 901--><p class="noindent" >
                                                                          

                                                                          
</div>
</div>
      <!--l. 902--><p class="noindent" >That is, it must expand into a function call such that all arguments
      but the last may be any permutation or subset of the new value z0
      and the arguments of the access form, but the last argument of the
      storing call must be the same as the last argument of the access call.
      See <i>deﬁne-setf-method</i> for more details on accessing and storing
      forms.
      <!--l. 909--><p class="noindent" >Given this, the <i>setf </i>-of-<i>apply</i> form shown above expands into <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(apply #&#x2019;storefn xi<sub>1</sub> xi<sub>2</sub> ... xi<sub>k</sub> rest)
</td></tr></table>
      <!--l. 912--><p class="noindent" >
</div>
</div>
      <!--l. 913--><p class="noindent" >As an example, suppose that the variable <i>indexes</i> contains a list of
      subscripts for a multidimensional array foo whose rank is not known until
      run time. One may access the indicated element of the array by writing <div class=lisp>
      <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(apply #&#x2019;aref foo indexes)
</td></tr></table>
      <!--l. 919--><p class="noindent" >
</div>
</div>
      <!--l. 920--><p class="noindent" >and one may alter the value of the indicated element to that of <i>newvalue</i> by
      writing <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (apply #&#x2019;aref foo indexes) newvalue)
</td></tr></table>
      <!--l. 924--><p class="noindent" >
                                                                          

                                                                          
</div>
</div>
<div class=newer>
      <!--l. 927--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that this rule applies only when
      the function name <i>apply</i> refers to the global function deﬁnition and not to a
      locally deﬁned function or macro named <i>apply</i>.
      </div>
      </li>
      <li class="itemize">A macro call, in which case <i>setf </i> expands the macro call and then analyzes
      the resulting form.
<div class=newer>
      <!--l. 937--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that this step uses <i>macroexpand-1</i>,
      not <i>macroexpand</i>. This allows the chance to apply any of the rules preceding
      this one to any of the intermediate expansions.
      </div>
      </li>
      <li class="itemize">Any form for which a <i>defsetf </i> or <i>deﬁne-setf-method</i> declaration has been
      made.
<div class=newer>
      <!--l. 947--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that this rule applies only when
      the function name in the form refers to a global function deﬁnition and not
      to a locally deﬁned function or macro.
      </div>
      </li></ul>
<div class=newer>
<!--l. 955--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to add one more rule to the preceding list,
coming after all those listed above:
      <ul class="itemize1">
      <li class="itemize">Any other list whose ﬁrst element is a symbol (call it f ). In this case, the
      call to <i>setf </i> expands into a call to the function named by the list
      <i>(setf f )</i> (see section <a 
href="clmse35.html#x47-770007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). The ﬁrst argument is the new value and the
      remaining arguments are the values of the remaining elements of place.
      This expansion occurs regardless of whether either f  or <i>(setf f )</i> is
      deﬁned as a function locally, globally, or not at all. For example, <div class=lisp>
      <div class=tabbing>
                                                                          

                                                                          
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (f  arg1 arg2 ...) newvalue)
</td></tr></table>
      <!--l. 969--><p class="noindent" >
</div>
</div>
      <!--l. 970--><p class="noindent" >expands into a form with the same eﬀect and value as <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(let ((#:temp1 arg1)     ;Force correct order of evaluation
</td></tr></table>
      <!--l. 972--><p class="noindent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">      (#:temp2 arg2)</td></tr></table>
      <!--l. 973--><p class="noindent" >                                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">      ...</td></tr></table>
      <!--l. 974--><p class="noindent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">      (#:temp0 newvalue))</td></tr></table>
      <!--l. 975--><p class="noindent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">  (funcall (function (setf f ))</td></tr></table>
      <!--l. 976--><p class="noindent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">           #:temp0</td></tr></table>
      <!--l. 977--><p class="noindent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">           #:temp1</td></tr></table>
      <!--l. 978--><p class="noindent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">           #:temp2 ...))</td></tr></table>
      <!--l. 980--><p class="noindent" >
</div>
</div>
      <!--l. 981--><p class="noindent" >By convention, any function named <i>(setf f )</i> should return its ﬁrst argument
      as its only value, in order to preserve the speciﬁcation that <i>setf </i> returns its
      newvalue.</li></ul>
</div>
<div class=new>
<!--l. 988--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to add this case as well:
      <ul class="itemize1">
      <li class="itemize">A variable reference that refers to a symbol macro deﬁnition made by
      <i>symbol-macrolet</i>, in which case <i>setf </i> expands the reference and then
      analyzes the resulting form.</li></ul>
</div>
<!--l. 997--><p class="indent" >
                                                                          

                                                                          
<i>
<!--l. 999--><p class="indent" >   setf </i> carefully arranges to preserve the usual left-to-right order in which the
various subforms are evaluated. On the other hand, the exact expansion for any
particular form is not guaranteed and may even be implementation-dependent; all
that is guaranteed is that the expansion of a <i>setf </i> form will be an update form
that works for that particular implementation, and that the left-to-right
evaluation of subforms is preserved.
<!--l. 1008--><p class="indent" >   The ultimate result of evaluating a <i>setf </i> form is the value of newvalue.
Therefore <i>(setf (car x) y)</i> does not expand into precisely <i>(rplaca x y)</i>, but into
something more like <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((G1 x) (G2 y)) (rplaca G1 G2) G2)
</td></tr></table>
<!--l. 1013--><p class="indent" >
</div>
</div>
<!--l. 1014--><p class="noindent" >the precise expansion being implementation-dependent.
<!--l. 1016--><p class="indent" >   The user can deﬁne new <i>setf </i> expansions by using <i>defsetf </i>.
<div class=newer>
<!--l. 1019--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to extend the speciﬁcation of <i>setf </i> to
allow a place whose <i>setf </i> method has more than one store variable (see
<i>deﬁne-setf-method</i>). In such a case as many values are accepted from the
newvalue form as there are store variables; extra values are ignored and
missing values default to <i>nil</i>, as is usual in situations involving multiple
values.
<!--l. 1027--><p class="indent" >   A proposal was submitted to X3J13 in September 1989 to add a <i>setf </i> method
for <i>values</i> so that one could in fact write, for example, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (values quotient remainder)
</td></tr></table>
<!--l. 1031--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (truncate linewidth tabstop))</td></tr></table>
<!--l. 1033--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 1034--><p class="noindent" >but unless this proposal is accepted users will have to deﬁne a <i>setf </i> method for <i>values</i>
themselves (not a diﬃcult task).
</div>
</div>
<div class=defmac>
<!--l. 1040--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> psetf </b> <a 
 id="dx48-80003"></a><a 
 id="x48-80004r68"></a>   {<i>placenewvalue</i>}∗
</td></tr></table>
<!--l. 1041--><p class="indent" >
</div>
   <i>psetf </i> is like <i>setf </i> except that if more than one place-newvalue pair is speciﬁed,
then the assignments of new values to places are done in parallel. More
precisely, all subforms that are to be evaluated are evaluated from left to
right; after all evaluations have been performed, all of the assignments are
performed in an unpredictable order. (The unpredictability matters only if
more than one place form refers to the same place.) <i>psetf </i> always returns
<i>nil</i>.
<div class=newer>
   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to extend the speciﬁcation of <i>psetf </i> to
allow a place whose <i>setf </i> method has more than one store variable (see
<i>deﬁne-setf-method</i>). In such a case as many values are accepted from the
newvalue form as there are store variables; extra values are ignored and
missing values default to <i>nil</i>, as is usual in situations involving multiple
values.
</div>
</div>
<div class=defmac>
<!--l. 1063--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> shiftf </b> <a 
 id="dx48-80005"></a><a 
 id="x48-80006r69"></a>   {<i>place</i>}+    newvalue
</td></tr></table>
<!--l. 1064--><p class="indent" >
</div>
                                                                          

                                                                          
   Each place form may be any form acceptable as a generalized variable to <i>setf </i>.
In the form <i>(shiftf place1 place2 ... placen newvalue)</i>, the values in place1 through
placen are accessed and saved, and newvalue is evaluated, for a total of n + 1
values in all. Values 2 through n + 1 are then stored into place1 through placen,
and value 1 (the original value of place1) is returned. It is as if all the places form
a shift register; the newvalue is shifted in from the right, all values shift over to
the left one place, and the value shifted out of place1 is returned. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x (list &#x2019;a &#x2019;b &#x2019;c))  ⇒ (a b c)
</td></tr></table>
<!--l. 1076--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1077--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(shiftf (cadr x) &#x2019;z)  ⇒ b</td></tr></table>
<!--l. 1078--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   and now x  ⇒ (a z c)</td></tr></table>
<!--l. 1079--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1080--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(shiftf (cadr x) (cddr x) &#x2019;q)  ⇒ z</td></tr></table>
<!--l. 1081--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   and now x  ⇒ (a (c) . q)</td></tr></table>
<!--l. 1083--><p class="indent" >
</div>
</div>
<!--l. 1084--><p class="noindent" >The eﬀect of <i>(shiftf place1 place2 ... placen newvalue)</i> is equivalent to <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((var1 place1)
</td></tr></table>
<!--l. 1087--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (var2 place2)</td></tr></table>
<!--l. 1088--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ...</td></tr></table>
<!--l. 1089--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (varn placen))</td></tr></table>
<!--l. 1090--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf place1 var2)</td></tr></table>
<!--l. 1091--><p class="indent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf place2 var3)</td></tr></table>
<!--l. 1092--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 1093--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf placen newvalue)</td></tr></table>
<!--l. 1094--><p class="indent" >                                                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  var1)</td></tr></table>
<!--l. 1096--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 1097--><p class="noindent" >except that the latter would evaluate any subforms of each place twice, whereas <i>shiftf </i>
takes care to evaluate them only once. For example: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq n 0)
</td></tr></table>
<!--l. 1101--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x &#x2019;(a b c d))</td></tr></table>
<!--l. 1102--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(shiftf (nth (setq n (+ n 1)) x) &#x2019;z)  ⇒ b</td></tr></table>
<!--l. 1103--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   and now x  ⇒ (a z c d)</td></tr></table>
<!--l. 1104--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">but
</td></tr></table>
<!--l. 1105--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq n 0)
</td></tr></table>
<!--l. 1106--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x &#x2019;(a b c d))</td></tr></table>
<!--l. 1107--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(prog1 (nth (setq n (+ n 1)) x)</td></tr></table>
<!--l. 1108--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (setf (nth (setq n (+ n 1)) x) &#x2019;z))  ⇒ b</td></tr></table>
<!--l. 1109--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   and now x  ⇒ (a b z d)</td></tr></table>
<!--l. 1111--><p class="indent" >
</div>
</div>
<!--l. 1112--><p class="noindent" >Moreover, for certain place forms <i>shiftf </i> may be signiﬁcantly more eﬃcient than the
<i>prog1</i> version.
<div class=newer>
<!--l. 1116--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to extend the speciﬁcation of <i>shiftf </i> to
allow a place whose <i>setf </i> method has more than one store variable (see
<i>deﬁne-setf-method</i>). In such a case as many values are accepted from the
newvalue form as there are store variables; extra values are ignored and
missing values default to <i>nil</i>, as is usual in situations involving multiple
values.
</div>
<div class=rationale>
<!--l. 1126--><p class="noindent" ><b>Rationale:</b> <i>shiftf </i> and <i>rotatef </i> have been included in Common Lisp as generalizations of
two-argument versions formerly called <i>swapf </i> and <i>exchf </i>. The two-argument versions have
been found to be very useful, but the names were easily confused. The generalization
to many argument forms and the change of names were both inspired by the
work of Suzuki <span class="cite">[<a 
href="clmli5.html#XSUZUKI-POINTER-ROTATION">47</a>]</span>, which indicates that use of these primitives can make
certain complex pointer-manipulation programs clearer and easier to prove
correct.
                                                                          

                                                                          
</div>
</div>
<div class=defmac>
<!--l. 1140--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> rotatef </b> <a 
 id="dx48-80007"></a><a 
 id="x48-80008r70"></a>   {<i>place</i>}∗
</td></tr></table>
<!--l. 1141--><p class="indent" >
</div>
   Each place form may be any form acceptable as a generalized variable to <i>setf </i>.
In the form <i>(rotatef place1 place2 ... placen)</i>, the values in place1 through placen
are accessed and saved. Values 2 through n and value 1 are then stored into place1
through placen. It is as if all the places form an end-around shift register that is
rotated one place to the left, with the value of place1 being shifted around the end
to placen. Note that <i>(rotatef place1 place2)</i> exchanges the contents of place1 and
place2.
   The eﬀect of <i>(rotatef place1 place2 ... placen)</i> is roughly equivalent to <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(psetf place1 place2
</td></tr></table>
<!--l. 1156--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       place2 place3</td></tr></table>
<!--l. 1157--><p class="indent" >                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       ...</td></tr></table>
<!--l. 1158--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       placen place1)</td></tr></table>
<!--l. 1160--><p class="indent" >
</div>
</div>
<!--l. 1161--><p class="noindent" >except that the latter would evaluate any subforms of each place twice, whereas
<i>rotatef </i> takes care to evaluate them only once. Moreover, for certain place forms
<i>rotatef </i> may be signiﬁcantly more eﬃcient.
<i>
<!--l. 1166--><p class="indent" >   rotatef </i> always returns <i>nil</i>.
<div class=newer>
<!--l. 1169--><p class="indent" >   X3J13 voted in June 1989 ⟨<b>?</b>⟩ to extend the speciﬁcation of <i>rotatef </i> to
allow a place whose <i>setf </i> method has more than one store variable (see
                                                                          

                                                                          
<i>deﬁne-setf-method</i>). In such a case as many values are accepted from the
newvalue form as there are store variables; extra values are ignored and
missing values default to <i>nil</i>, as is usual in situations involving multiple
values.
</div>
</div>
<!--l. 1179--><p class="indent" >   Other macros that manipulate generalized variables include <i>getf </i>, <i>remf </i>, <i>incf </i>,
<i>decf </i>, <i>push</i>, <i>pop</i>, <i>assert</i>, <i>ctypecase</i>, and <i>ccase</i>.
<!--l. 1184--><p class="indent" >   Macros that manipulate generalized variables must guarantee the “obvious”
semantics: subforms of generalized-variable references are evaluated exactly as
many times as they appear in the source program, and they are evaluated in
exactly the same order as they appear in the source program.
<!--l. 1190--><p class="indent" >   In generalized-variable references such as <i>shiftf </i>, <i>incf </i>, <i>push</i>, and <i>setf </i> of <i>ldb</i>, the
generalized variables are both read and written in the same reference. Preserving
the source program order of evaluation and the number of evaluations is
particularly important.
<!--l. 1195--><p class="indent" >   As an example of these semantic rules, in the generalized-variable
reference <i>(setf reference value)</i> the value form must be evaluated after all the
subforms of the reference because the value form appears to the right of
them.
<!--l. 1200--><p class="indent" >   The expansion of these macros must consist of code that follows these rules or
has the same eﬀect as such code. This is accomplished by introducing temporary
variables bound to the subforms of the reference. As an optimization in
the implementation, temporary variables may be eliminated whenever it
can be proved that removing them has no eﬀect on the semantics of the
program. For example, a constant need never be saved in a temporary
variable. A variable, or for that matter any form that does not have side
eﬀects, need not be saved in a temporary variable if it can be proved
that its value will not change within the scope of the generalized-variable
reference.
<!--l. 1211--><p class="indent" >   Common Lisp provides built-in facilities to take care of these semantic
complications and optimizations. Since the required semantics can be guaranteed
by these facilities, the user does not have to worry about writing correct code for
them, especially in complex cases. Even experts can become confused and make
mistakes while writing this sort of code.
<div class=newer>
<!--l. 1219--><p class="indent" >   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to clarify the preceding discussion about the
order of evaluation of subforms in calls to <i>setf </i> and related macros. The general
                                                                          

                                                                          
intent is clear: evaluation proceeds from left to right whenever possible.
However, the left-to-right rule does not remove the obligation on writers of
macros and <i>deﬁne-setf-method</i> to work to ensure left-to-right order of
evaluation.
<!--l. 1227--><p class="indent" >   Let it be emphasized that, in the following discussion, a form is something
whose syntactic use is such that it will be evaluated. A subform means a form that
is nested inside another form, not merely any Lisp object nested inside a form
regardless of syntactic context.
<!--l. 1232--><p class="indent" >   The evaluation ordering of subforms within a generalized variable
reference is determined by the order speciﬁed by the second value returned by
<i>get-setf-method</i>. For all predeﬁned generalized variable references (<i>getf </i>,
<i>ldb</i>), this order of evaluation is exactly left-to-right. When a generalized
variable reference is derived from a macro expansion, this rule is applied
after the macro is expanded to ﬁnd the appropriate generalized variable
reference.
<!--l. 1241--><p class="indent" >   This is intended to make it clear that if the user writes a <i>defmacro</i> or
<i>deﬁne-setf-method</i> macro that doesn&#x2019;t preserve left-to-right evaluation
order, the order speciﬁed in the user&#x2019;s code holds. For example, given <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro wrong-order (x y) <tt>‘</tt>(getf ,y ,x))
</td></tr></table>
<!--l. 1247--><p class="indent" >
</div>
</div>
<!--l. 1248--><p class="noindent" >then <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(push value (wrong-order place1 place2))
</td></tr></table>
<!--l. 1251--><p class="indent" >
</div>
</div>
<!--l. 1252--><p class="noindent" >will evaluate place2 ﬁrst and then place1 because that is the order they are evaluated
in the macro expansion.
                                                                          

                                                                          
<!--l. 1255--><p class="indent" >   For the macros that manipulate generalized variables (<i>push</i>, <i>pushnew</i>, <i>getf </i>,
<i>remf </i>, <i>incf </i>, <i>decf </i>, <i>shiftf </i>, <i>rotatef </i>, <i>psetf </i>, <i>setf </i>, <i>pop</i>, and those deﬁned with
<i>deﬁne-modify-macro</i>) the subforms of the macro call are evaluated exactly once in
left-to-right order, with the subforms of the generalized variable references
evaluated in the order speciﬁed above.
<!--l. 1262--><p class="indent" >   Each of <i>push</i>, <i>pushnew</i>, <i>getf </i>, <i>remf </i>, <i>incf </i>, <i>decf </i>, <i>shiftf </i>, <i>rotatef </i>, <i>psetf </i>, and <i>pop</i>
evaluates all subforms before modifying any of the generalized variable locations.
Moreover, <i>setf </i> itself, in the case when a call on it has more than two
arguments, performs its operation on each pair in sequence. That is, in <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf place1 value1 place2 value2 ...)
</td></tr></table>
<!--l. 1271--><p class="indent" >
</div>
</div>
<!--l. 1272--><p class="noindent" >the subforms of place1 and value1 are evaluated, the location speciﬁed by place1 is
modiﬁed to contain the value returned by value1, and then the rest of the <i>setf </i>
form is processed in a like manner.
<!--l. 1276--><p class="indent" >   For the macros <i>check-type</i>, <i>ctypecase</i>, and <i>ccase</i>, subforms of the generalized
variable reference are evaluated once per test of a generalized variable, but they
may be evaluated again if the type check fails (in the case of <i>check-type</i>) or if none
of the cases holds (in <i>ctypecase</i> or <i>ccase</i>).
<!--l. 1282--><p class="indent" >   For the macro <i>assert</i>, the order of evaluation of the generalized variable
references is not speciﬁed.
</div>
<!--l. 1286--><p class="indent" >   Another reason for building in these functions is that the appropriate
optimizations will diﬀer from implementation to implementation. In some
implementations most of the optimization is performed by the compiler, while in
others a simpler compiler is used and most of the optimization is performed in the
macros. The cost of binding a temporary variable relative to the cost of other Lisp
operations may diﬀer greatly between one implementation and another, and some
implementations may ﬁnd it best never to remove temporary variables except in
the simplest cases.
<!--l. 1296--><p class="indent" >   A good example of the issues involved can be seen in the following
generalized-variable reference: <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(incf (ldb byte-ﬁeld variable))
</td></tr></table>
<!--l. 1300--><p class="indent" >
</div>
</div>
<!--l. 1301--><p class="noindent" >This ought to expand into something like <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq variable
</td></tr></table>
<!--l. 1303--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (dpb (1+ (ldb byte-ﬁeld variable))</td></tr></table>
<!--l. 1304--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           byte-ﬁeld</td></tr></table>
<!--l. 1305--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           variable))</td></tr></table>
<!--l. 1307--><p class="indent" >
</div>
</div>
<!--l. 1308--><p class="noindent" >In this expansion example we have ignored the further complexity of returning the
correct value, which is the incremented byte, not the new value of <i>variable</i>. Note
that the variable <i>byte-ﬁeld</i> is evaluated twice, and the variable <i>variable</i> is referred
to three times: once as the location in which to store a value, and twice during the
computation of that value.
<!--l. 1316--><p class="indent" >   Now consider this expression: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(incf (ldb (aref byte-ﬁelds (incf i))
</td></tr></table>
<!--l. 1318--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (aref (determine-words-array) i)))</td></tr></table>
<!--l. 1320--><p class="indent" >
</div>
</div>
<!--l. 1321--><p class="noindent" >It ought to expand into something like this: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((temp1 (aref byte-ﬁelds (incf i)))
</td></tr></table>
<!--l. 1323--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (temp2 (determine-words-array)))</td></tr></table>
                                                                          

                                                                          
<!--l. 1324--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf (aref temp2 i)</td></tr></table>
<!--l. 1325--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (dpb (1+ (ldb temp1 (aref temp2 i)))</td></tr></table>
<!--l. 1326--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             temp1</td></tr></table>
<!--l. 1327--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (aref temp2 i))))</td></tr></table>
<!--l. 1329--><p class="indent" >
</div>
</div>
<!--l. 1330--><p class="noindent" >Again we have ignored the complexity of returning the correct value. What is
important here is that the expressions <i>(incf i)</i> and <i>(determine-words-array)</i> must
not be duplicated because each may have a side eﬀect or be aﬀected by side
eﬀects.
<div class=newer>
<!--l. 1337--><p class="indent" >   X3J13 voted in January 1989 ⟨<b>?</b>⟩ to specify more precisely the order of
evaluation of subforms when <i>setf </i> is used with an access function that itself takes
a place as an argument, for example, <i>ldb</i>, <i>mask-ﬁeld</i>, and <i>getf </i>. (The vote also
discussed the function <i>char-bit</i>, but another vote ⟨<b>?</b>⟩ removed that function from
the language.) The <i>setf </i> methods for such accessors produce expansions that
eﬀectively require explicit calls to <i>get-setf-method</i>.
<!--l. 1346--><p class="indent" >   The code produced as the macro expansion of a <i>setf </i> form that itself admits a
generalized variable as an argument must essentially do the following major
steps:
      <ul class="itemize1">
      <li class="itemize">It evaluates the value-producing subforms, in left-to-right order, and
      binds  the  temporary  variables  to  them;  this  is  called  binding  the
      temporaries.
      </li>
      <li class="itemize">It reads the value from the generalized variable, using the supplied
      accessing form, to get the old value; this is called doing the access.
      Note that this is done after all the evaluations of the preceding step,
      including any side eﬀects they may have.
      </li>
      <li class="itemize">It binds the store variable to a new value, and then installs this new
      value into the generalized variable using the supplied storing form; this
      is called doing the store.</li></ul>
                                                                          

                                                                          
<!--l. 1362--><p class="noindent" >Doing the access for a generalized variable reference is not part of the series of
evaluations that must be done in left-to-right order.
<!--l. 1365--><p class="indent" >   The place-speciﬁer forms <i>ldb</i>, <i>mask-ﬁeld</i>, and <i>getf </i> admit (other) place
speciﬁers as arguments. During the <i>setf </i> expansion of these forms, it is necessary
to call <i>get-setf-method</i> to determine how the inner, nested generalized variable
must be treated.
<!--l. 1370--><p class="indent" >   In a form such as <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (ldb byte-spec place-form) newvalue-form)
</td></tr></table>
<!--l. 1373--><p class="indent" >
</div>
</div>
<!--l. 1374--><p class="noindent" >the place referred to by the place-form must always be both accessed and updated;
note that the update is to the generalized variable speciﬁed by place-form, not to
any object of type <i>integer</i>.
<!--l. 1378--><p class="indent" >   Thus this call to <i>setf </i> should generate code to do the following:
      <ul class="itemize1">
      <li class="itemize">Evaluate byte-spec and bind into a temporary
      </li>
      <li class="itemize">Bind the temporaries for place-form
      </li>
      <li class="itemize">Evaluate newvalue-form and bind into the store variable
      </li>
      <li class="itemize">Do the access to place-form
      </li>
      <li class="itemize">Do the store into place-form with the given bit-ﬁeld of the accessed
      integer replaced with the value in the store variable</li></ul>
<!--l. 1387--><p class="noindent" >If the evaluation of newvalue-form alters what is found in the given place—such as
setting a diﬀerent bit-ﬁeld of the integer—then the change of the bit-ﬁeld denoted
by byte-spec will be to that altered integer, because the access step must be
done after the newvalue-form evaluation. Nevertheless, the evaluations
                                                                          

                                                                          
required for binding the temporaries are done before the evaluation of the
newvalue-form, thereby preserving the required left-to-right evaluation
order.
<!--l. 1397--><p class="indent" >   The treatment of <i>mask-ﬁeld</i> is similar to that of <i>ldb</i>.
<!--l. 1399--><p class="indent" >   In a form such as: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (getf place-form ind-form) newvalue-form)
</td></tr></table>
<!--l. 1402--><p class="indent" >
</div>
</div>
<!--l. 1403--><p class="noindent" >the place referred to by the place-form must always be both accessed and
updated; note that the update is to the generalized variable speciﬁed by
place-form, not necessarily to the particular list which is the property list in
question.
<!--l. 1408--><p class="indent" >   Thus this call to <i>setf </i> should generate code to do the following:
      <ul class="itemize1">
      <li class="itemize">Bind the temporaries for place-form
      </li>
      <li class="itemize">Evaluate ind-form and bind into a temporary
      </li>
      <li class="itemize">Evaluate the newvalue-form and bind into the store variable
      </li>
      <li class="itemize">Do the access to place-form
      </li>
      <li class="itemize">Do the store into place-form with a possibly new property list obtained
      by combining the results of the evaluations and the access</li></ul>
<!--l. 1418--><p class="indent" >   If the evaluation of newvalue-form alters what is found in the given place—such
as setting a diﬀerent named property in the list—then the change of the property
denoted by ind-form will be to that altered list, because the access step is
done after the newvalue-form evaluation. Nevertheless, the evaluations
required for binding the temporaries are done before the evaluation of the
newvalue-form, thereby preserving the required left-to-right evaluation
order.
                                                                          

                                                                          
<!--l. 1427--><p class="indent" >   Note that the phrase “possibly new property list” treats the implementation of
property lists as a “black box”; it can mean that the former property list is
somehow destructively re-used, or it can mean partial or full copying of it. A side
eﬀect may or may not occur; therefore <i>setf </i> must proceed as if the resultant
property list were a diﬀerent copy needing to be stored back into the generalized
variable.
</div>
<!--l. 1436--><p class="indent" >   The Common Lisp facilities provided to deal with these semantic issues
include:
      <ul class="itemize1">
      <li class="itemize">Built-in macros such as <i>setf </i> and <i>push</i> that follow the semantic rules.
      </li>
      <li class="itemize">The <i>deﬁne-modify-macro</i> macro, which allows new generalized-variable
      manipulating macros (of a certain restricted kind) to be deﬁned easily.
      It takes care of the semantic rules automatically.
      </li>
      <li class="itemize">The  <i>defsetf </i>  macro,  which  allows  new  types  of  generalized-variable
      references  to  be  deﬁned  easily.  It  takes  care  of  the  semantic  rules
      automatically.
      </li>
      <li class="itemize">The <i>deﬁne-setf-method</i> macro and the <i>get-setf-method</i> function, which
      provide  access  to  the  internal  mechanisms  when  it  is  necessary  to
      deﬁne  a  complicated  new  type  of  generalized-variable  reference  or
      generalized-variable-manipulating macro.</li></ul>
<div class=newer>
<!--l. 1458--><p class="indent" >   Also important are the changes that allow lexical environments to be used in
appropriate ways in <i>setf </i> methods.
</div>
<div class=defmac>
<!--l. 1463--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> deﬁne-modify-macro </b> <a 
 id="dx48-80009"></a><a 
 id="x48-80010r71"></a>   name lambda-list function  [ <i>doc-string</i>]
</td></tr></table>
<!--l. 1464--><p class="indent" >
                                                                          

                                                                          
</div>
   This macro deﬁnes a read-modify-write macro named name. An example of
such a macro is <i>incf </i>. The ﬁrst subform of the macro will be a generalized-variable
reference. The function is literally the function to apply to the old contents of the
generalized-variable to get the new contents; it is not evaluated. lambda-list
describes the remaining arguments for the function; these arguments come
from the remaining subforms of the macro after the generalized-variable
reference. lambda-list may contain <i>&#x0026;optional</i> and <i>&#x0026;rest</i> markers. (The
<i>&#x0026;key</i> marker is not permitted here; <i>&#x0026;rest</i> suﬃces for the purposes of
<i>deﬁne-modify-macro</i>.) doc-string is documentation for the macro name being
deﬁned.
   The expansion of a <i>deﬁne-modify-macro</i> is equivalent to the following, except
that it generates code that follows the semantic rules outlined above. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro name (reference . lambda-list)
</td></tr></table>
<!--l. 1481--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  doc-string</td></tr></table>
<!--l. 1482--><p class="indent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <tt>‘</tt>(setf ,reference</td></tr></table>
<!--l. 1483--><p class="indent" >                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (function ,reference ,arg1 ,arg2 ...)))</td></tr></table>
<!--l. 1485--><p class="indent" >
</div>
</div>
<!--l. 1486--><p class="noindent" >where arg1, arg2, ..., are the parameters appearing in lambda-list; appropriate
provision is made for a <i>&#x0026;rest</i> parameter.
<!--l. 1489--><p class="indent" >   As an example, <i>incf </i> could have been deﬁned by: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deﬁne-modify-macro incf (&#x0026;optional (delta 1)) +)
</td></tr></table>
<!--l. 1492--><p class="indent" >
</div>
</div>
<!--l. 1494--><p class="indent" >   An example of a possibly useful macro not predeﬁned in Common Lisp is <div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deﬁne-modify-macro unionf (other-set &#x0026;rest keywords) union)
</td></tr></table>
<!--l. 1497--><p class="indent" >
</div>
</div>
<div class=newer>
<!--l. 1500--><p class="indent" >   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to specify that <i>deﬁne-modify-macro</i> creates
macros that take <i>&#x0026;environment</i> arguments and perform the equivalent of
correctly passing such lexical environments to <i>get-setf-method</i> in order to correctly
maintain lexical references.
</div>
</div>
<div class=defmac>
<!--l. 1510--><p class="noindent" ><div class=tabbing>
</div>
<!--l. 1512--><p class="indent" >   }
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> defsetf </b> <a 
 id="dx48-80011"></a><a 
 id="x48-80012r72"></a>   access-fn  {<i>update − fn [<i>doc − string</i>] |lambda − list(store − variable) [[ <i> {<i>declaration</i>}∗  | doc-string</div> ]] {<i>form</i>}∗
</td></tr></table>
<!--l. 1513--><p class="indent" >
</div>
   This deﬁnes how to <i>setf </i> a generalized-variable reference of the form <i>(access-fn
...)</i>. The value of a generalized-variable reference can always be obtained
simply by evaluating it, so access-fn should be the name of a function or a
macro.
<!--l. 1519--><p class="noindent" >The user of <i>defsetf </i> provides a description of how to store into the
generalized-variable reference and return the value that was stored (because <i>setf </i>
is deﬁned to return this value). The implementation of <i>defsetf </i> takes care
of ensuring that subforms of the reference are evaluated exactly once
and in the proper left-to-right order. In order to do this, <i>defsetf </i> requires
that access-fn be a function or a macro that evaluates its arguments,
behaving like a function. Furthermore, a <i>setf </i> of a call on access-fn will
also evaluate all of access-fn&#x2019;s arguments; it cannot treat any of them
specially. This means that <i>defsetf </i> cannot be used to describe how to store
into a generalized variable that is a byte, such as <i>(ldb ﬁeld reference)</i>. To
handle situations that do not ﬁt the restrictions imposed by <i>defsetf </i>, use
                                                                          

                                                                          
<i>deﬁne-setf-method</i>, which gives the user additional control at the cost of increased
complexity.
<!--l. 1535--><p class="indent" >   A <i>defsetf </i> declaration may take one of two forms. The simple form is <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defsetf access-fn update-fn  [<i>doc-string</i>] )
</td></tr></table>
<!--l. 1539--><p class="indent" >
</div>
</div>
<!--l. 1540--><p class="noindent" >The update-fn must name a function (or macro) that takes one more argument than
access-fn takes. When <i>setf </i> is given a place that is a call on access-fn, it expands
into a call on update-fn that is given all the arguments to access-fn and also, as its
last argument, the new value (which must be returned by update-fn as its value).
For example, the eﬀect of <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defsetf symbol-value set)
</td></tr></table>
<!--l. 1549--><p class="indent" >
</div>
</div>
<!--l. 1550--><p class="noindent" >is built into the Common Lisp system. This causes the expansion <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (symbol-value foo) fu)  → (set foo fu)
</td></tr></table>
<!--l. 1554--><p class="indent" >
</div>
</div>
<!--l. 1555--><p class="noindent" >for example. Note that <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defsetf car rplaca)
</td></tr></table>
<!--l. 1558--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1559--><p class="noindent" >would be incorrect because <i>rplaca</i> does not return its last argument.
<!--l. 1561--><p class="indent" >   The complex form of <i>defsetf </i> looks like <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defsetf access-fn lambda-list (store-variable) . body)
</td></tr></table>
<!--l. 1564--><p class="indent" >
</div>
</div>
<!--l. 1565--><p class="noindent" >and resembles <i>defmacro</i>. The body must compute the expansion of a <i>setf </i> of a call on
access-fn.
<!--l. 1568--><p class="indent" >   The lambda-list describes the arguments of access-fn. <i>&#x0026;optional</i>, <i>&#x0026;rest</i>, and
<i>&#x0026;key</i> markers are permitted in lambda-list. Optional arguments may have defaults
and “supplied-p” ﬂags. The store-variable describes the value to be stored into the
generalized-variable reference.
<div class=rationale>
<!--l. 1575--><p class="noindent" ><b>Rationale:</b> The store-variable is enclosed in parentheses to provide for an extension to
multiple store variables that would receive multiple values from the second subform of
<i>setf </i>. The rules given below for coding <i>setf </i> methods discuss the proper handling of
multiple store variables to allow for the possibility that this extension may be
incorporated into Common Lisp in the future.
</div>
<!--l. 1587--><p class="indent" >   The body forms can be written as if the variables in the lambda-list were bound
to subforms of the call on access-fn and the store-variable were bound
to the second subform of <i>setf </i>. However, this is not actually the case.
During the evaluation of the body forms, these variables are bound to
names of temporary variables, generated as if by <i>gensym</i> or <i>gentemp</i>, that
will be bound by the expansion of <i>setf </i> to the values of those subforms.
This binding permits the body forms to be written without regard for
order-of-evaluation issues. <i>defsetf </i> arranges for the temporary variables to be
optimized out of the ﬁnal result in cases where that is possible. In other words, an
attempt is made by <i>defsetf </i> to generate the best code possible in a particular
implementation.
<!--l. 1602--><p class="indent" >   Note that the code generated by the body forms must include provision for
returning the correct value (the value of store-variable). This is handled by the
body forms rather than by <i>defsetf </i> because in many cases this value can be
                                                                          

                                                                          
returned at no extra cost, by calling a function that simultaneously stores into the
generalized variable and returns the correct value.
<!--l. 1609--><p class="indent" >   An example of the use of the complex form of <i>defsetf </i>: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defsetf subseq (sequence start &#x0026;optional end) (new-sequence)
</td></tr></table>
<!--l. 1611--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <tt>‘</tt>(progn (replace ,sequence ,new-sequence</td></tr></table>
<!--l. 1612--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   :start1 ,start :end1 ,end)</td></tr></table>
<!--l. 1613--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          ,new-sequence))</td></tr></table>
<!--l. 1615--><p class="indent" >
</div>
</div>
<div class=newer>
<!--l. 1618--><p class="indent" >   X3J13 voted in March 1988 ⟨<b>?</b>⟩ to specify that the body of the expander
function deﬁned by the complex form of <i>defsetf </i> is implicitly enclosed in a <i>block</i>
construct whose name is the same as the name of the access-fn. Therefore
<i>return-from</i> may be used to exit from the function.
</div>
<div class=newer>
<!--l. 1626--><p class="indent" >   X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that, while deﬁning forms normally
appear at top level, it is meaningful to place them in non-top-level contexts; the
complex form of <i>defsetf </i> must deﬁne the expander function within the enclosing
lexical environment, not within the global environment.
</div>
<!--l. 1635--><p class="indent" >   The underlying theory by which <i>setf </i> and related macros arrange to conform to
the semantic rules given above is that from any generalized-variable reference one
may derive its “<i>setf </i> method,” which describes how to store into that reference and
which subforms of it are evaluated.
<div class=incompatibility>
<!--l. 1642--><p class="noindent" ><b>Compatibility note:</b> To avoid confusion, it should be noted that the use of the word
“method” here in connection with <i>setf </i> has nothing to do with its use in Lisp Machine
Lisp in connection with message-passing and the Lisp Machine Lisp “ﬂavor system.” <div class=new>
And of course it also has nothing to do with the methods in the Common Lisp Object
System ⟨<b>?</b>⟩.
</div>
</div>
                                                                          

                                                                          
<!--l. 1655--><p class="indent" >   Given knowledge of the subforms of the reference, it is possible to avoid
evaluating them multiple times or in the wrong order. A <i>setf </i> method for a given
access form can be expressed as ﬁve values:
      <ul class="itemize1">
      <li class="itemize">A list of temporary variables
      </li>
      <li class="itemize">A list of value forms (subforms of the given form) to whose values the
      temporary variables are to be bound
      </li>
      <li class="itemize">A second list of temporary variables, called store variables
      </li>
      <li class="itemize">A storing form
      </li>
      <li class="itemize">An accessing form</li></ul>
<!--l. 1677--><p class="indent" >   The temporary variables will be bound to the values of the value forms as if by
<i>let*</i>; that is, the value forms will be evaluated in the order given and
may refer to the values of earlier value forms by using the corresponding
variables.
<!--l. 1683--><p class="indent" >   The store variables are to be bound to the values of the newvalue form,
that is, the values to be stored into the generalized variable. In almost
all cases only a single value is to be stored, and there is only one store
variable.
<!--l. 1688--><p class="indent" >   The storing form and the accessing form may contain references to the
temporary variables (and also, in the case of the storing form, to the store
variables). The accessing form returns the value of the generalized variable. The
storing form modiﬁes the value of the generalized variable and guarantees to
return the values of the store variables as its values; these are the correct
values for <i>setf </i> to return. (Again, in most cases there is a single store
variable and thus a single value to be returned.) The value returned by the
accessing form is, of course, aﬀected by execution of the storing form, but
either of these forms may be evaluated any number of times and therefore
should be free of side eﬀects (other than the storing action of the storing
form).
                                                                          

                                                                          
<!--l. 1702--><p class="indent" >   The temporary variables and the store variables are generated names, as if by
<i>gensym</i> or <i>gentemp</i>, so that there is never any problem of name clashes among
them, or between them and other variables in the program. This is necessary to
make the special forms that do more than one <i>setf </i> in parallel work properly;
these are <i>psetf </i>, <i>shiftf </i>, and <i>rotatef </i>. Computation of the <i>setf </i> method must
always create new variable names; it may not return the same ones every
time.
<!--l. 1711--><p class="indent" >   Some examples of <i>setf </i> methods for particular forms:
      <ul class="itemize1">
      <li class="itemize">For a variable <i>x</i>: <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">()
</td></tr></table>
      <!--l. 1716--><p class="noindent" >                                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">()</td></tr></table>
      <!--l. 1717--><p class="noindent" >                                                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(g0001)</td></tr></table>
      <!--l. 1718--><p class="noindent" >                                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setq x g0001)</td></tr></table>
      <!--l. 1719--><p class="noindent" >                                                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">x</td></tr></table>
      <!--l. 1721--><p class="noindent" >
</div>
</div>
      </li>
      <li class="itemize">For <i>(car exp)</i>: <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(g0002)
</td></tr></table>
      <!--l. 1726--><p class="noindent" >                                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(exp)</td></tr></table>
      <!--l. 1727--><p class="noindent" >                                                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(g0003)</td></tr></table>
      <!--l. 1728--><p class="noindent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(progn (rplaca g0002 g0003) g0003)</td></tr></table>
      <!--l. 1729--><p class="noindent" >                                                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(car g0002)</td></tr></table>
      <!--l. 1731--><p class="noindent" >
                                                                          

                                                                          
</div>
</div>
      </li>
      <li class="itemize">For <i>(subseq seq s e)</i>: <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(g0004 g0005 g0006)
</td></tr></table>
      <!--l. 1736--><p class="noindent" >                                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(seq s e)</td></tr></table>
      <!--l. 1737--><p class="noindent" >                                                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(g0007)</td></tr></table>
      <!--l. 1738--><p class="noindent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(progn (replace g0004 g0007 :start1 g0005 :end1 g0006)</td></tr></table>
      <!--l. 1739--><p class="noindent" >                                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">       g0007)</td></tr></table>
      <!--l. 1740--><p class="noindent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(subseq g0004 g0005 g0006)</td></tr></table>
      <!--l. 1742--><p class="noindent" >
</div>
</div>
      </li></ul>
<div class=defmac>
<!--l. 1746--><p class="noindent" ><div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> <i>[Macro]</i><b> deﬁne-setf-method </b> <a 
 id="dx48-80013"></a><a 
 id="x48-80014r73"></a>   access-fn lambda-list  [[ <i> {<i>declaration</i>}∗  | doc-string</div> ]] {<i>form</i>}∗
</td></tr></table>
<!--l. 1748--><p class="indent" >
</div>
   This deﬁnes how to <i>setf </i> a generalized-variable reference that is of the form
<i>(access-fn...)</i>. The value of a generalized-variable reference can always be obtained
simply by evaluating it, so access-fn should be the name of a function or a
macro.
   The lambda-list describes the subforms of the generalized-variable reference,
as with <i>defmacro</i>. The result of evaluating the forms in the body must
be ﬁve values representing the <i>setf </i> method, as described above. Note
that <i>deﬁne-setf-method</i> diﬀers from the complex form of <i>defsetf </i> in that
                                                                          

                                                                          
while the body is being executed the variables in lambda-list are bound to
parts of the generalized-variable reference, not to temporary variables that
will be bound to the values of such parts. In addition, <i>deﬁne-setf-method</i>
does not have <i>defsetf </i>&#x2019;s restriction that access-fn must be a function or a
function-like macro; an arbitrary <i>defmacro</i> destructuring pattern is permitted in
lambda-list.
   By deﬁnition there are no good small examples of <i>deﬁne-setf-method</i> because
the easy cases can all be handled by <i>defsetf </i>. A typical use is to deﬁne the <i>setf </i>
method for <i>ldb</i>: <div class=obsolete> <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; SETF method for the form (LDB bytespec int).
</td></tr></table>
<!--l. 1773--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Recall that the int form must itself be suitable for SETF.</td></tr></table>
<!--l. 1774--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deﬁne-setf-method ldb (bytespec int)</td></tr></table>
<!--l. 1775--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-bind (temps vals stores</td></tr></table>
<!--l. 1776--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                        store-form access-form)</td></tr></table>
<!--l. 1777--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (get-setf-method int)         ;Get SETF method for int</td></tr></table>
<!--l. 1778--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((btemp (gensym))          ;Temp var for byte speciﬁer</td></tr></table>
<!--l. 1779--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (store (gensym))          ;Temp var for byte to store</td></tr></table>
<!--l. 1780--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (stemp (ﬁrst stores)))   ;Temp var for int to store</td></tr></table>
<!--l. 1781--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ;; Return the SETF method for LDB as ﬁve values.</td></tr></table>
<!--l. 1782--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (values (cons btemp temps)    ;Temporary variables</td></tr></table>
<!--l. 1783--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (cons bytespec vals)  ;Value forms</td></tr></table>
<!--l. 1784--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (list store)          ;Store variables</td></tr></table>
<!--l. 1785--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              <tt>‘</tt>(let ((,stemp (dpb ,store ,btemp ,access-form)))</td></tr></table>
<!--l. 1786--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 ,store-form</td></tr></table>
<!--l. 1787--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 ,store)                     ;Storing form</td></tr></table>
<!--l. 1788--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              <tt>‘</tt>(ldb ,btemp ,access-form)     ;Accessing form</td></tr></table>
<!--l. 1789--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              ))))</td></tr></table>
<!--l. 1791--><p class="indent" >
</div>
</div>
</div>
<div class=newer>
<!--l. 1795--><p class="noindent" >X3J13 voted in March 1988 ⟨<b>?</b>⟩ to specify that the <i>&#x0026;environment</i> lambda-list
keyword may appear in the lambda-list in the same manner as for <i>defmacro</i> in
                                                                          

                                                                          
order to obtain the lexical environment of the call to the <i>setf </i> macro. The
preceding example should be modiﬁed to take advantage of this new feature. The
<i>setf </i> method must accept an <i>&#x0026;environment</i> parameter, which will receive the
lexical environment of the call to <i>setf </i>; this environment must then be given to
<i>get-setf-method</i> in order that it may correctly use any locally bound <i>setf </i> method
that might be applicable to the place form that appears as the second argument to
<i>ldb</i> in the call to <i>setf </i>.
<div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; SETF method for the form (LDB bytespec int).
</td></tr></table>
<!--l. 1808--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Recall that the int form must itself be suitable for SETF.</td></tr></table>
<!--l. 1809--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Note the use of an &#x0026;environment parameter to receive the</td></tr></table>
<!--l. 1810--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; lexical environment of the call for use with GET-SETF-METHOD.</td></tr></table>
<!--l. 1811--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deﬁne-setf-method ldb (bytespec int &#x0026;environment env)</td></tr></table>
<!--l. 1812--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-bind (temps vals stores</td></tr></table>
<!--l. 1813--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                        store-form access-form)</td></tr></table>
<!--l. 1814--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (get-setf-method int env)     ;Get SETF method for int</td></tr></table>
<!--l. 1815--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((btemp (gensym))          ;Temp var for byte speciﬁer</td></tr></table>
<!--l. 1816--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (store (gensym))          ;Temp var for byte to store</td></tr></table>
<!--l. 1817--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (stemp (ﬁrst stores)))   ;Temp var for int to store</td></tr></table>
<!--l. 1818--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ;; Return the SETF method for LDB as ﬁve values.</td></tr></table>
<!--l. 1819--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (values (cons btemp temps)    ;Temporary variables</td></tr></table>
<!--l. 1820--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (cons bytespec vals)  ;Value forms</td></tr></table>
<!--l. 1821--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (list store)          ;Store variables</td></tr></table>
<!--l. 1822--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              <tt>‘</tt>(let ((,stemp (dpb ,store ,btemp ,access-form)))</td></tr></table>
<!--l. 1823--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 ,store-form</td></tr></table>
<!--l. 1824--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 ,store)                     ;Storing form</td></tr></table>
<!--l. 1825--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              <tt>‘</tt>(ldb ,btemp ,access-form)     ;Accessing form</td></tr></table>
<!--l. 1826--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              ))))</td></tr></table>
<!--l. 1828--><p class="indent" >
</div>
</div>
</div>
<div class=newer>
                                                                          

                                                                          
<!--l. 1832--><p class="noindent" >X3J13 voted in March 1988 ⟨<b>?</b>⟩ to specify that the body of the expander function
deﬁned by <i>deﬁne-setf-method</i> is implicitly enclosed in a <i>block</i> construct whose
name is the same as the name of the access-fn. Therefore <i>return-from</i> may be used
to exit from the function.
</div>
<div class=newer>
<!--l. 1840--><p class="noindent" >X3J13 voted in March 1989 ⟨<b>?</b>⟩ to clarify that, while deﬁning forms normally
appear at top level, it is meaningful to place them in non-top-level contexts;
<i>deﬁne-setf-method</i> must deﬁne the expander function within the enclosing lexical
environment, not within the global environment.
</div>
<div class=obsolete>
<div class=defun>
<!--l. 1850--><p class="noindent" > <i>[Function]</i>   <b>get-setf-method</b> <a 
 id="dx48-80015"></a><a 
 id="x48-80016r74"></a>   <i>form</i>
<!--l. 1852--><p class="noindent" ><i>get-setf-method</i> returns ﬁve values constituting the <i>setf </i> method for form. The
form must be a generalized-variable reference. <i>get-setf-method</i> takes care of
error-checking and macro expansion and guarantees to return exactly one store
variable.
<!--l. 1860--><p class="indent" >   As an example, an extremely simpliﬁed version of <i>setf </i>, allowing no more and
no fewer than two subforms, containing no optimization to remove unnecessary
variables, and not allowing storing of multiple values, could be deﬁned by: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro setf (reference value)
</td></tr></table>
<!--l. 1865--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-bind (vars vals stores store-form access-form)</td></tr></table>
<!--l. 1866--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (get-setf-method reference)</td></tr></table>
<!--l. 1867--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (declare (ignore access-form))</td></tr></table>
<!--l. 1868--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    <tt>‘</tt>(let* ,(mapcar #&#x2019;list</td></tr></table>
<!--l. 1869--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    (append vars stores)</td></tr></table>
<!--l. 1870--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    (append vals (list value)))</td></tr></table>
<!--l. 1871--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       ,store-form)))</td></tr></table>
<!--l. 1873--><p class="indent" >
</div>
</div>
</div>
                                                                          

                                                                          
</div>
<div class=newer>
<!--l. 1878--><p class="noindent" >X3J13 voted in March 1988 ⟨<b>?</b>⟩ to add an optional environment argument to
<i>get-setf-method</i>. The revised deﬁnition and example are as follows.
<div class=defun>
<!--l. 1882--><p class="noindent" > <i>[Function]</i>   <b>get-setf-method</b> <a 
 id="dx48-80017"></a><a 
 id="x48-80018r75"></a>   <i>form</i>  <b>&#x0026;optional</b>  <i>env</i>
<!--l. 1884--><p class="noindent" ><i>get-setf-method</i> returns ﬁve values constituting the <i>setf </i> method for form. The
form must be a generalized-variable reference. The env must be an environment of
the sort obtained through the <i>&#x0026;environment</i> lambda-list keyword; if env is <i>nil</i> or
omitted, the null lexical environment is assumed. <i>get-setf-method</i> takes care of
error checking and macro expansion and guarantees to return exactly one store
variable.
<!--l. 1896--><p class="indent" >   As an example, an extremely simpliﬁed version of <i>setf </i>, allowing no more and
no fewer than two subforms, containing no optimization to remove unnecessary
variables, and not allowing storing of multiple values, could be deﬁned by: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro setf (reference value &#x0026;environment env)
</td></tr></table>
<!--l. 1901--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-bind (vars vals stores store-form access-form)</td></tr></table>
<!--l. 1902--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (get-setf-method reference env)     ;Note use of environment</td></tr></table>
<!--l. 1903--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (declare (ignore access-form))</td></tr></table>
<!--l. 1904--><p class="indent" >                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    <tt>‘</tt>(let* ,(mapcar #&#x2019;list</td></tr></table>
<!--l. 1905--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    (append vars stores)</td></tr></table>
<!--l. 1906--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    (append vals (list value)))</td></tr></table>
<!--l. 1907--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       ,store-form)))</td></tr></table>
<!--l. 1909--><p class="indent" >
</div>
</div>
</div>
</div>
<div class=obsolete>
<div class=defun>
<!--l. 1914--><p class="noindent" > <i>[Function]</i>   <b>get-setf-method-multiple-value</b> <a 
 id="dx48-80019"></a><a 
 id="x48-80020r76"></a>   <i>form</i>
<!--l. 1916--><p class="noindent" ><i>get-setf-method-multiple-value</i> returns ﬁve values constituting the <i>setf </i> method for
form. The form must be a generalized-variable reference. This is the same as
                                                                          

                                                                          
<i>get-setf-method</i> except that it does not check the number of store variables; use
this in cases that allow storing multiple values into a generalized variable. There
are no such cases in standard Common Lisp, but this function is provided to allow
for possible extensions.
</div>
</div>
<div class=newer>
<!--l. 1929--><p class="noindent" >X3J13 voted in March 1988 ⟨<b>?</b>⟩ to add an optional environment argument to
<i>get-setf-method</i>. The revised deﬁnition is as follows.
<div class=defun>
<!--l. 1933--><p class="noindent" > <i>[Function]</i>   <b>get-setf-method-multiple-value</b> <a 
 id="dx48-80021"></a><a 
 id="x48-80022r77"></a>   <i>form</i>  <b>&#x0026;optional</b>
<i>env</i>
<!--l. 1935--><p class="noindent" ><i>get-setf-method-multiple-value</i> returns ﬁve values constituting the <i>setf </i> method
for form. The form must be a generalized-variable reference. The env
must be an environment of the sort obtained through the <i>&#x0026;environment</i>
lambda-list keyword; if env is <i>nil</i> or omitted, the null lexical environment is
assumed.
<!--l. 1944--><p class="indent" >   This is the same as <i>get-setf-method</i> except that it does not check the number
of store variables; use this in cases that allow storing multiple values into a
generalized variable. There are no such cases in standard Common Lisp, but this
function is provided to allow for possible extensions.
</div>
</div>
<div class=newer>
<!--l. 1953--><p class="noindent" >X3J13 voted in March 1988 ⟨<b>?</b>⟩ to clarify that a <i>setf </i> method for a functional
name is applicable only when the global binding of that name is lexically
visible. If such a name has a local binding introduced by <i>ﬂet</i>, <i>labels</i>, or
<i>macrolet</i>, then global deﬁnitions of <i>setf </i> methods for that name do not
apply and are not visible. All of the standard Common Lisp macros that
modify a <i>setf </i> place (for example, <i>incf </i>, <i>decf </i>, <i>pop</i>, and <i>rotatef </i>) obey this
convention.
</div>
                                                                          

                                                                          
   <!--l. 1963--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse37.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html#tailclmse35.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse36.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse36.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 1963--><p class="indent" >   <a 
 id="tailclmse36.html"></a>  
</body></html> 
