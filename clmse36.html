<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Generalized Variables</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,charset=utf-8,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-02-26 02:27:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
</head><body 
>
   <!--l. 645--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse37.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html#tailclmse35.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="#tailclmse36.html">Tail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse36.html" >Up</a><tt>&#x003E;</tt></p></div>
   <h3 class="sectionHead"><span class="titlemark">7.2   </span> <a 
 id="x48-800007.2"></a>Generalized Variables</h3>
<!--l. 648--><p class="noindent" >In Lisp, a variable can remember one piece of data, that is, one Lisp object. The
main operations on a variable are to recover that object and to alter the variable
to remember a new object; these operations are often called <i>access</i> and
<i>update</i> operations. The concept of variables named by symbols can be
generalized to any storage location that can remember one piece of data, no
matter how that location is named. Examples of such storage locations are
the <i>car</i> and <i>cdr</i> of a cons, elements of an array, and components of a
structure.
<!--l. 658--><p class="indent" >   For each kind of generalized variable, typically there are two functions that
implement the conceptual <i>access</i> and <i>update</i> operations. For a variable, merely
mentioning the name of the variable accesses it, while the <a 
href="clmse35.html#x47-79002r61">setq</a> special form can be
used to update it. The function <a 
href="clmse86.html#x106-148002r444">car</a> accesses the <i>car</i> of a cons, and the function
<a 
href="clmse88.html#x108-150002r509">rplaca</a> updates it. The function <a 
href="clmse35.html#x47-78013r55">symbol-value</a> accesses the dynamic value
of a variable named by a given symbol, and the function <a 
href="clmse35.html#x47-79008r63">set</a> updates
it.
<!--l. 667--><p class="indent" >   Rather than thinking about two distinct functions that respectively access and
update a storage location somehow deduced from their arguments, we can instead
simply think of a call to the access function with given arguments as a <i>name</i> for
the storage location. Thus, just as x may be considered a name for a
storage location (a variable), so (car x) is a name for the <i>car</i> of some cons
(which is in turn named by x). Now, rather than having to remember two
functions for each kind of generalized variable (having to remember, for
example, that <a 
href="clmse88.html#x108-150002r509">rplaca</a> corresponds to <a 
href="clmse86.html#x106-148002r444">car</a>), we adopt a uniform syntax
for updating storage locations named in this way, using the <a 
href="#x48-80002r66">setf</a> macro.
This is analogous to the way we use the <a 
href="clmse35.html#x47-79002r61">setq</a> special form to convert the
name of a variable (which is also a form that accesses it) into a form that
updates it. The uniformity of this approach is illustrated in the following
table.
<div class="flushleft" 
>
                                                                          

                                                                          
<!--l. 682--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Access Function  </td><td align="left" >Update Function</td><td align="left" >Update Using <a 
href="#x48-80002r66">setf</a>                </td>
</tr><tr><td align="left" >x                     </td><td align="left" >(setq x datum)   </td><td align="left" >(setf x datum)                    </td>
</tr><tr><td align="left" >(car x)              </td><td align="left" >(rplaca x datum)</td><td align="left" >(setf (car x) datum)             </td>
</tr><tr><td align="left" >(symbol-value x) </td><td align="left" >(set x datum)    </td><td align="left" >(setf (symbol-value x) datum)</td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" >  </td></tr></table>
</div></div>
<!--l. 692--><p class="noindent" ><a 
href="#x48-80002r66">setf</a> is actually a macro that examines an access form and produces a call to the
corresponding update function.
<!--l. 695--><p class="indent" >   Given the existence of <a 
href="#x48-80002r66">setf</a> in Common Lisp, it is not necessary to have <a 
href="clmse35.html#x47-79002r61">setq</a>,
<a 
href="clmse88.html#x108-150002r509">rplaca</a>, and <a 
href="clmse35.html#x47-79008r63">set</a>; they are redundant. They are retained in Common Lisp because
of their historical importance in Lisp. However, most other update functions
(such as putprop, the update function for <a 
href="clmse54.html#x69-108002r159">get</a>) have been eliminated from
Common Lisp in the expectation that <a 
href="#x48-80002r66">setf</a> will be uniformly used in their
place.
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <i>[Macro]</i> <b> setf </b> <a 
 id="dx48-80001"></a><a 
 id="x48-80002r66"></a>  {place newvalue }*
</td></tr></table>
<!--l. 704--><p class="indent" >
</div>
   (setf <i>place</i> <i>newvalue</i>) takes a form <i>place</i> that when evaluated <i>accesses</i> a data
object in some location and “inverts” it to produce a corresponding form to <i>update</i>
the location. A call to the <a 
href="#x48-80002r66">setf</a> macro therefore expands into an update form that
stores the result of evaluating the form <i>newvalue</i> into the place referred to by the
access form.
   If more than one <i>place</i>-<i>newvalue</i> pair is speciﬁed, the pairs are processed
sequentially; that is, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf <i>place1</i> <i>newvalue1</i>
</td></tr></table>
<!--l. 715--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      <i>place2</i> <i>newvalue2</i>)</td></tr></table>
<!--l. 716--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ...</td></tr></table>
<!--l. 717--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      <i>placen</i> <i>newvaluen</i>)</td></tr></table>
<!--l. 719--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 720--><p class="noindent" >is precisely equivalent to <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(progn (setf <i>place1</i> <i>newvalue1</i>)
</td></tr></table>
<!--l. 722--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (setf <i>place2</i> <i>newvalue2</i>)</td></tr></table>
<!--l. 723--><p class="indent" >                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       ...</td></tr></table>
<!--l. 724--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (setf <i>placen</i> <i>newvaluen</i>))</td></tr></table>
<!--l. 726--><p class="indent" >
</div>
</div>
<!--l. 727--><p class="noindent" >For consistency, it is legal to write (setf), which simply returns <a 
href="clmse31.html#x42-70002r19">nil</a>.
<!--l. 729--><p class="indent" >   The form <i>place</i> may be any one of the following:
      <ul class="itemize1">
      <li class="itemize">The name of a variable (either lexical or dynamic).
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of any one of the
      following functions:
      <div class="flushleft" 
>
<!--l. 738--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" ><a 
href="clmse95.html#x117-159002r563">aref</a>             </td><td align="left" ><a 
href="clmse86.html#x106-148002r444">car</a>           </td><td align="left" ><a 
href="clmse95.html#x117-159004r564">svref</a>                     </td><td align="left" >                     </td></tr><tr><td align="left" ><a 
href="clmse87.html#x107-149006r478">nth</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148004r445">cdr</a> </td> <td align="left" ><a 
href="clmse54.html#x69-108002r159">get</a> </td> <td align="left" ></td>
</tr><tr><td align="left" ><a 
href="clmse81.html#x100-142002r399">elt</a>              </td><td align="left" ><a 
href="clmse86.html#x106-148006r446">caar</a>          </td><td align="left" ><a 
href="clmse54.html#x69-108010r162">getf</a>                      </td><td align="left" ><a 
href="clmse35.html#x47-78013r55">symbol-value</a>    </td>
</tr><tr><td align="left" ><a 
href="clmse87.html#x107-149028r489">rest</a>             </td><td align="left" ><a 
href="clmse86.html#x106-148008r447">cadr</a>         </td><td align="left" ><a 
href="clmse92.html#x113-155011r547">gethash</a>                 </td><td align="left" ><a 
href="clmse35.html#x47-78015r56">symbol-function</a></td>
</tr><tr><td align="left" ><a 
href="clmse87.html#x107-149008r479">ﬁrst</a>            </td><td align="left" ><a 
href="clmse86.html#x106-148010r448">cdar</a>         </td><td align="left" >documentation     </td><td align="left" ><a 
href="clmse54.html#x69-108008r161">symbol-plist</a>     </td>
</tr><tr><td align="left" ><a 
href="clmse87.html#x107-149010r480">second</a>         </td><td align="left" ><a 
href="clmse86.html#x106-148012r449">cddr</a>         </td><td align="left" ><a 
href="clmse98.html#x120-162004r588">ﬁll-pointer</a>              </td><td align="left" ><a 
href="clmse46.html#x59-98005r136">macro-function</a> </td>
</tr><tr><td align="left" ><a 
href="clmse87.html#x107-149012r481">third</a>           </td><td align="left" ><a 
href="clmse86.html#x106-148014r450">caaar</a>        </td><td align="left" ><a 
href="clmse86.html#x106-148030r458">caaaar</a>                   </td><td align="left" ><a 
href="clmse86.html#x106-148046r466">cdaaar</a>            </td></tr><tr><td align="left" ><a 
href="clmse87.html#x107-149014r482">fourth</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148016r451">caadr</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148032r459">caaadr</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148048r467">cdaadr</a></td>
</tr><tr><td align="left" ><a 
href="clmse87.html#x107-149016r483">ﬁfth</a>            </td><td align="left" ><a 
href="clmse86.html#x106-148018r452">cadar</a>        </td><td align="left" ><a 
href="clmse86.html#x106-148034r460">caadar</a>                   </td><td align="left" ><a 
href="clmse86.html#x106-148050r468">cdadar</a>            </td></tr><tr><td align="left" ><a 
href="clmse87.html#x107-149018r484">sixth</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148020r453">caddr</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148036r461">caaddr</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148052r469">cdaddr</a></td>
</tr><tr><td align="left" >seventh     </td><td align="left" >cdaar     </td><td align="left" ><a 
href="clmse86.html#x106-148038r462">cadaar</a>                   </td><td align="left" ><a 
href="clmse86.html#x106-148054r470">cddaar</a>            </td></tr><tr><td align="left" ><a 
href="clmse87.html#x107-149022r486">eighth</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148024r455">cdadr</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148040r463">cadadr</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148056r471">cddadr</a></td>
</tr><tr><td align="left" ><a 
href="clmse87.html#x107-149024r487">ninth</a>           </td><td align="left" ><a 
href="clmse86.html#x106-148026r456">cddar</a>        </td><td align="left" ><a 
href="clmse86.html#x106-148042r464">caddar</a>                   </td><td align="left" ><a 
href="clmse86.html#x106-148058r472">cdddar</a>            </td></tr><tr><td align="left" ><a 
href="clmse87.html#x107-149026r488">tenth</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148028r457">cdddr</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148044r465">cadddr</a> </td> <td align="left" ><a 
href="clmse86.html#x106-148060r473">cddddr</a></td>
</tr></table></div></div>
                                                                          

                                                                          
<div class=new>
      <!--l. 758--><p class="noindent" >X3J13 voted in March 1988 <a 
 id="dx48-80003"></a>to add <a 
href="clmse96.html#x118-160016r572">row-major-aref</a> to this list.
      </div>
<div class=newer>
      <!--l. 768--><p class="noindent" >X3J13 voted in June 1989 <a 
 id="dx48-80004"></a>to add <a 
href="clmse49.html#x62-101006r143">compiler-macro-function</a> to this
      list.
      </div>
<div class=newer>
      <!--l. 783--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-80005"></a>to clarify that this rule applies only when the
      function name refers to a global function deﬁnition and not to a locally
      deﬁned function or macro.
      </div>
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of a selector function
      constructed by <a 
href="clmse104.html#x128-170002r619">defstruct</a>.
<div class=newer>
      <!--l. 793--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-80006"></a>to clarify that this rule applies only when the
      function name refers to a global function deﬁnition and not to a locally
      deﬁned function or macro.
      </div>
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of any one of the
      following functions, provided that the new value is of the speciﬁed type so
                                                                          

                                                                          
      that it can be used to replace the speciﬁed “location” (which is in each of
      these cases not truly a generalized variable):
<div class=obsolete>
      <div class="flushleft" 
>
<!--l. 807--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Function Name</td><td align="left" >Required Type</td>
</tr><tr><td align="left" ><a 
href="clmse100.html#x123-165002r593">char</a>               </td><td align="left" >string-char     </td>
</tr><tr><td align="left" ><a 
href="clmse100.html#x123-165004r594">schar</a>             </td><td align="left" >string-char     </td>
</tr><tr><td align="left" ><a 
href="clmse97.html#x119-161002r574">bit</a>                </td><td align="left" ><a 
href="clmse97.html#x119-161002r574">bit</a>                </td></tr><tr><td align="left" ><a 
href="clmse97.html#x119-161004r575">sbit</a> </td> <td align="left" ><a 
href="clmse97.html#x119-161002r574">bit</a></td>
</tr><tr><td align="left" ><a 
href="clmse81.html#x100-142004r400">subseq</a>            </td><td align="left" >sequence        </td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
</div>
<div class=newer>
      <!--l. 823--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-80007"></a>to eliminate the type string-char and to redeﬁne
      <a 
href="clmse102.html#x125-167028r618">string</a> to be the union of one or more specialized vector types, the types of
      whose elements are subtypes of the type <a 
href="clmse79.html#x97-139002r384">character</a>. In the preceding table,
      the type string-char should be replaced by some such phrase as “the
      element-type of the argument vector.”
      </div>
<div class=newer>
      <!--l. 832--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-80008"></a>to clarify that this rule applies only when the
      function name refers to a global function deﬁnition and not to a locally
      deﬁned function or macro.
      </div>
      <!--l. 837--><p class="noindent" >In the case of <a 
href="clmse81.html#x100-142004r400">subseq</a>, the replacement value must be a sequence whose
      elements may be contained by the sequence argument to <a 
href="clmse81.html#x100-142004r400">subseq</a>. (Note that
      this is not so stringent as to require that the replacement value be a
      sequence of the same type as the sequence of which the subsequence is
      speciﬁed.) If the length of the replacement value does not equal the
      length of the subsequence to be replaced, then the shorter length
      determines the number of elements to be stored, as for the function
      <a 
href="clmse83.html#x102-144004r415">replace</a>.
      </li>
      <li class="itemize">A function call form whose ﬁrst element is the name of any one of the
                                                                          

                                                                          
      following functions, provided that the speciﬁed argument to that function is
      in turn a <i>place</i> form; in this case the new <i>place</i> has stored back into it the
      result of applying the speciﬁed “update” function (which is in each of these
      cases not a true update function):
      <div class="flushleft" 
>
<!--l. 854--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%"><tr><td align="left" >Function Name</td><td align="left" >Argument That Is a <i>place</i></td><td align="left" >Update Function Used</td>
</tr><tr><td align="left" ><a 
href="clmse80.html#x98-140011r396">char-bit</a>          </td><td align="left" >ﬁrst                             </td><td align="left" ><a 
href="clmse80.html#x98-140014r397">set-char-bit</a>               </td></tr><tr><td align="left" ><a 
href="clmse73.html#x90-132008r312">ldb</a> </td> <td align="left" >second </td> <td align="left" ><a 
href="clmse73.html#x90-132014r315">dpb</a></td>
</tr><tr><td align="left" ><a 
href="clmse73.html#x90-132012r314">mask-ﬁeld</a>       </td><td align="left" >second                         </td><td align="left" ><a 
href="clmse73.html#x90-132016r316">deposit-ﬁeld</a>              </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
<div class=newer>
      <!--l. 866--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-80009"></a>to eliminate <a 
href="clmse80.html#x98-140011r396">char-bit</a> and <a 
href="clmse80.html#x98-140014r397">set-char-bit</a>.
      </div>
<div class=newer>
      <!--l. 871--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-80010"></a>to clarify that this rule applies only when the
      function name refers to a global function deﬁnition and not to a locally
      deﬁned function or macro.
      </div>
      </li>
      <li class="itemize">A <a 
href="clmse53.html#x67-106002r158">the</a> type declaration form, in which case the declaration is transferred to
      the <i>newvalue</i> form, and the resulting <a 
href="#x48-80002r66">setf</a> form is analyzed. For example, <div class=lisp>
      <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (the integer (cadr x)) (+ y 3))
</td></tr></table>
      <!--l. 882--><p class="noindent" >
</div>
</div>
      <!--l. 883--><p class="noindent" >is processed as if it were <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (cadr x) (the integer (+ y 3)))
</td></tr></table>
      <!--l. 886--><p class="noindent" >
</div>
</div>
      </li>
      <li class="itemize">A call to <a 
href="clmse37.html#x49-81002r77">apply</a> where the ﬁrst argument form is of the form #&#x2019;<i>name</i>, that
      is, (function <i>name</i>), where <i>name</i> is the name of a function, calls to which
      are recognized as places by <a 
href="#x48-80002r66">setf</a>. Suppose that the use of <a 
href="#x48-80002r66">setf</a> with <a 
href="clmse37.html#x49-81002r77">apply</a>
      looks like this: <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (apply #&#x2019;<i>name</i> <i>x1</i> <i>x2</i> ... <i>xn</i> <i>rest</i>) <i>x0</i>)
</td></tr></table>
      <!--l. 895--><p class="noindent" >
</div>
</div>
      <!--l. 896--><p class="noindent" >The <a 
href="#x48-80002r66">setf</a> method for the function <i>name</i> must be such that <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (<i>name</i> <i>z1</i> <i>z2</i> ... <i>zm</i>) <i>z0</i>)
</td></tr></table>
      <!--l. 899--><p class="noindent" >
</div>
</div>
      <!--l. 900--><p class="noindent" >expands into a store form <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(<i>storefn</i> <i>zi<sub>1</sub></i> <i>zi<sub>2</sub></i> ... <i>zi<sub>k</sub></i> <i>zm</i>)
</td></tr></table>
      <!--l. 903--><p class="noindent" >
                                                                          

                                                                          
</div>
</div>
      <!--l. 904--><p class="noindent" >That is, it must expand into a function call such that all arguments but the
      last may be any permutation or subset of the new value <i>z0</i> and
      the arguments of the access form, but the <i>last</i> argument of the
      storing call must be the same as the last argument of the access call.
      See <a 
href="#x48-80038r72">deﬁne-setf-method</a> for more details on accessing and storing
      forms.
      <!--l. 911--><p class="noindent" >Given this, the <a 
href="#x48-80002r66">setf</a>-of-<a 
href="clmse37.html#x49-81002r77">apply</a> form shown above expands into <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(apply #&#x2019;<i>storefn</i> <i>xi<sub>1</sub></i> <i>xi<sub>2</sub></i> ... <i>xi<sub>k</sub></i> <i>rest</i>)
</td></tr></table>
      <!--l. 914--><p class="noindent" >
</div>
</div>
      <!--l. 915--><p class="noindent" >As an example, suppose that the variable indexes contains a list of
      subscripts for a multidimensional array <i>foo</i> whose rank is not known until
      run time. One may access the indicated element of the array by writing <div class=lisp>
      <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(apply #&#x2019;aref foo indexes)
</td></tr></table>
      <!--l. 921--><p class="noindent" >
</div>
</div>
      <!--l. 922--><p class="noindent" >and one may alter the value of the indicated element to that of newvalue by
      writing <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (apply #&#x2019;aref foo indexes) newvalue)
</td></tr></table>
      <!--l. 926--><p class="noindent" >
                                                                          

                                                                          
</div>
</div>
<div class=newer>
      <!--l. 929--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-80011"></a>to clarify that this rule applies only when the
      function name <a 
href="clmse37.html#x49-81002r77">apply</a> refers to the global function deﬁnition and not to a
      locally deﬁned function or macro named <a 
href="clmse37.html#x49-81002r77">apply</a>.
      </div>
      </li>
      <li class="itemize">A macro call, in which case <a 
href="#x48-80002r66">setf</a> expands the macro call and then analyzes
      the resulting form.
<div class=newer>
      <!--l. 939--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-80012"></a>to clarify that this step uses macroexpand-1,
      not <a 
href="clmse47.html#x60-99002r138">macroexpand</a>. This allows the chance to apply any of the rules preceding
      this one to any of the intermediate expansions.
      </div>
      </li>
      <li class="itemize">Any form for which a <a 
href="#x48-80033r71">defsetf</a> or <a 
href="#x48-80038r72">deﬁne-setf-method</a> declaration has been
      made.
<div class=newer>
      <!--l. 949--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-80013"></a>to clarify that this rule applies only when the
      function name in the form refers to a global function deﬁnition and not to a
      locally deﬁned function or macro.
      </div>
      </li></ul>
<div class=newer>
<!--l. 957--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-80014"></a>to add one more rule to the preceding list, coming
after all those listed above:
      <ul class="itemize1">
      <li class="itemize">Any other list whose ﬁrst element is a symbol (call it <i>f </i>). In this case, the
      call to <a 
href="#x48-80002r66">setf</a> expands into a call to the function named by the list
      (setf <i>f </i>) (see section <a 
href="clmse35.html#x47-770007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). The ﬁrst argument is the new value and the
      remaining arguments are the values of the remaining elements of <i>place</i>.
      This expansion occurs regardless of whether either <i>f </i> or (setf <i>f </i>) is
      deﬁned as a function locally, globally, or not at all. For example, <div class=lisp>
      <div class=tabbing>
                                                                          

                                                                          
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setf (<i>f </i> <i>arg1</i> <i>arg2</i> ...) <i>newvalue</i>)
</td></tr></table>
      <!--l. 971--><p class="noindent" >
</div>
</div>
      <!--l. 972--><p class="noindent" >expands into a form with the same eﬀect and value as <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(let ((#:temp1 <i>arg1</i>)     ;Force correct order of evaluation
</td></tr></table>
      <!--l. 974--><p class="noindent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">      (#:temp2 <i>arg2</i>)</td></tr></table>
      <!--l. 975--><p class="noindent" >                                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">      ...</td></tr></table>
      <!--l. 976--><p class="noindent" >                                                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">      (#:temp0 newvalue))</td></tr></table>
      <!--l. 977--><p class="noindent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">  (funcall (function (setf <i>f </i>))</td></tr></table>
      <!--l. 978--><p class="noindent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">           #:temp0</td></tr></table>
      <!--l. 979--><p class="noindent" >                                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">           #:temp1</td></tr></table>
      <!--l. 980--><p class="noindent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">           #:temp2 ...))</td></tr></table>
      <!--l. 982--><p class="noindent" >
</div>
</div>
      <!--l. 983--><p class="noindent" >By convention, any function named (setf <i>f </i>) should return its ﬁrst argument
      as its only value, in order to preserve the speciﬁcation that <a 
href="#x48-80002r66">setf</a> returns its
      <i>newvalue</i>.</li></ul>
</div>
<div class=new>
<!--l. 990--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-80015"></a>to add this case as well:
      <ul class="itemize1">
      <li class="itemize">A variable reference that refers to a symbol macro deﬁnition made by
      symbol-macrolet, in which case <a 
href="#x48-80002r66">setf</a> expands the reference and then
      analyzes the resulting form.</li></ul>
</div>
<!--l. 999--><p class="indent" >
                                                                          

                                                                          
<!--l. 1001--><p class="indent" >   <a 
href="#x48-80002r66">setf</a> carefully arranges to preserve the usual left-to-right order in which the
various subforms are evaluated. On the other hand, the exact expansion for any
particular form is not guaranteed and may even be implementation-dependent; all
that is guaranteed is that the expansion of a <a 
href="#x48-80002r66">setf</a> form will be an update form that
works for that particular implementation, and that the left-to-right evaluation of
subforms is preserved.
<!--l. 1010--><p class="indent" >   The ultimate result of evaluating a <a 
href="#x48-80002r66">setf</a> form is the value of <i>newvalue</i>.
Therefore (setf (car x) y) does not expand into precisely (rplaca x y), but into
something more like <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((G1 x) (G2 y)) (rplaca G1 G2) G2)
</td></tr></table>
<!--l. 1015--><p class="indent" >
</div>
</div>
<!--l. 1016--><p class="noindent" >the precise expansion being implementation-dependent.
<!--l. 1018--><p class="indent" >   The user can deﬁne new <a 
href="#x48-80002r66">setf</a> expansions by using <a 
href="#x48-80033r71">defsetf</a>.
<div class=newer>
<!--l. 1021--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-80016"></a>to extend the speciﬁcation of <a 
href="#x48-80002r66">setf</a> to allow a <i>place</i>
whose <a 
href="#x48-80002r66">setf</a> method has more than one store variable (see <a 
href="#x48-80038r72">deﬁne-setf-method</a>). In
such a case as many values are accepted from the <i>newvalue</i> form as there are store
variables; extra values are ignored and missing values default to <a 
href="clmse31.html#x42-70002r19">nil</a>, as is usual in
situations involving multiple values.
<!--l. 1029--><p class="indent" >   A proposal was submitted to X3J13 in September 1989 to add a <a 
href="#x48-80002r66">setf</a> method
for <a 
href="clmse44.html#x56-94002r123">values</a> so that one could in fact write, for example, <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (values quotient remainder)
</td></tr></table>
<!--l. 1033--><p class="indent" >                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (truncate linewidth tabstop))</td></tr></table>
<!--l. 1035--><p class="indent" >
</div>
</div>
<!--l. 1036--><p class="noindent" >but unless this proposal is accepted users will have to deﬁne a <a 
href="#x48-80002r66">setf</a> method for <a 
href="clmse44.html#x56-94002r123">values</a>
themselves (not a diﬃcult task).
</div>
                                                                          

                                                                          
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <i>[Macro]</i> <b> psetf </b> <a 
 id="dx48-80017"></a><a 
 id="x48-80018r67"></a>  {place newvalue }*
</td></tr></table>
<!--l. 1043--><p class="indent" >
</div>
   <a 
href="#x48-80018r67">psetf</a> is like <a 
href="#x48-80002r66">setf</a> except that if more than one <i>place</i>-<i>newvalue</i> pair is speciﬁed,
then the assignments of new values to places are done in parallel. More
precisely, all subforms that are to be evaluated are evaluated from left to
right; after all evaluations have been performed, all of the assignments are
performed in an unpredictable order. (The unpredictability matters only if
more than one <i>place</i> form refers to the same place.) <a 
href="#x48-80018r67">psetf</a> always returns
<a 
href="clmse31.html#x42-70002r19">nil</a>.
<div class=newer>
   X3J13 voted in June 1989 <a 
 id="dx48-80019"></a>to extend the speciﬁcation of <a 
href="#x48-80018r67">psetf</a> to allow a <i>place</i>
whose <a 
href="#x48-80002r66">setf</a> method has more than one store variable (see <a 
href="#x48-80038r72">deﬁne-setf-method</a>). In
such a case as many values are accepted from the <i>newvalue</i> form as there are store
variables; extra values are ignored and missing values default to <a 
href="clmse31.html#x42-70002r19">nil</a>, as is usual in
situations involving multiple values.
</div>
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <i>[Macro]</i> <b> shiftf </b> <a 
 id="dx48-80020"></a><a 
 id="x48-80021r68"></a>  {place }+  newvalue
</td></tr></table>
<!--l. 1066--><p class="indent" >
</div>
   Each <i>place</i> form may be any form acceptable as a generalized variable to <a 
href="#x48-80002r66">setf</a>.
In the form (shiftf <i>place1</i> <i>place2</i> ... <i>placen</i> <i>newvalue</i>), the values in <i>place1</i> through
<i>placen</i> are accessed and saved, and <i>newvalue</i> is evaluated, for a total of <i>n</i> + 1
values in all. Values 2 through <i>n</i> + 1 are then stored into <i>place1</i> through <i>placen</i>,
                                                                          

                                                                          
and value 1 (the original value of <i>place1</i>) is returned. It is as if all the places form
a shift register; the <i>newvalue</i> is shifted in from the right, all values shift over to
the left one place, and the value shifted out of <i>place1</i> is returned. For example: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x (list &#x2019;a &#x2019;b &#x2019;c))  ⇒ (a b c)
</td></tr></table>
<!--l. 1078--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1079--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(shiftf (cadr x) &#x2019;z)  ⇒ b</td></tr></table>
<!--l. 1080--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   and now x  ⇒ (a z c)</td></tr></table>
<!--l. 1081--><p class="indent" >                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 1082--><p class="indent" >                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(shiftf (cadr x) (cddr x) &#x2019;q)  ⇒ z</td></tr></table>
<!--l. 1083--><p class="indent" >                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   and now x  ⇒ (a (c) . q)</td></tr></table>
<!--l. 1085--><p class="indent" >
</div>
</div>
<!--l. 1086--><p class="noindent" >The eﬀect of (shiftf <i>place1</i> <i>place2</i> ... <i>placen</i> <i>newvalue</i>) is equivalent to <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((<i>var1</i> <i>place1</i>)
</td></tr></table>
<!--l. 1089--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (<i>var2</i> <i>place2</i>)</td></tr></table>
<!--l. 1090--><p class="indent" >                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ...</td></tr></table>
<!--l. 1091--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (<i>varn</i> <i>placen</i>))</td></tr></table>
<!--l. 1092--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf <i>place1</i> <i>var2</i>)</td></tr></table>
<!--l. 1093--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf <i>place2</i> <i>var3</i>)</td></tr></table>
<!--l. 1094--><p class="indent" >                                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ...</td></tr></table>
<!--l. 1095--><p class="indent" >                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf <i>placen</i> <i>newvalue</i>)</td></tr></table>
<!--l. 1096--><p class="indent" >                                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <i>var1</i>)</td></tr></table>
<!--l. 1098--><p class="indent" >
</div>
</div>
<!--l. 1099--><p class="noindent" >except that the latter would evaluate any subforms of each <i>place</i> twice, whereas <a 
href="#x48-80021r68">shiftf</a>
takes care to evaluate them only once. For example: <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq n 0)
</td></tr></table>
<!--l. 1103--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x &#x2019;(a b c d))</td></tr></table>
<!--l. 1104--><p class="indent" >                                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(shiftf (nth (setq n (+ n 1)) x) &#x2019;z)  ⇒ b</td></tr></table>
<!--l. 1105--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   and now x  ⇒ (a z c d)</td></tr></table>
<!--l. 1106--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"><i>but</i>
</td></tr></table>
<!--l. 1107--><p class="indent" >
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq n 0)
</td></tr></table>
<!--l. 1108--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq x &#x2019;(a b c d))</td></tr></table>
<!--l. 1109--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(prog1 (nth (setq n (+ n 1)) x)</td></tr></table>
<!--l. 1110--><p class="indent" >                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       (setf (nth (setq n (+ n 1)) x) &#x2019;z))  ⇒ b</td></tr></table>
<!--l. 1111--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">   and now x  ⇒ (a b z d)</td></tr></table>
<!--l. 1113--><p class="indent" >
</div>
</div>
<!--l. 1114--><p class="noindent" >Moreover, for certain <i>place</i> forms <a 
href="#x48-80021r68">shiftf</a> may be signiﬁcantly more eﬃcient than the
prog1 version.
<div class=newer>
<!--l. 1118--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-80022"></a>to extend the speciﬁcation of <a 
href="#x48-80021r68">shiftf</a> to allow a <i>place</i>
whose <a 
href="#x48-80002r66">setf</a> method has more than one store variable (see <a 
href="#x48-80038r72">deﬁne-setf-method</a>). In
such a case as many values are accepted from the <i>newvalue</i> form as there are store
variables; extra values are ignored and missing values default to <a 
href="clmse31.html#x42-70002r19">nil</a>, as is usual in
situations involving multiple values.
</div>
<div class=rationale>
<!--l. 1128--><p class="noindent" ><b>Rationale:</b> <a 
href="#x48-80021r68">shiftf</a> and <a 
href="#x48-80024r69">rotatef</a> have been included in Common Lisp as generalizations of
two-argument versions formerly called swapf and exchf. The two-argument versions have
been found to be very useful, but the names were easily confused. The generalization
to many argument forms and the change of names were both inspired by the
work of Suzuki <span class="cite">[<a 
href="clmli5.html#XSUZUKI-POINTER-ROTATION">47</a>]</span>, which indicates that use of these primitives can make
certain complex pointer-manipulation programs clearer and easier to prove
correct.
</div>
</div>
<div class=defmac>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <i>[Macro]</i> <b> rotatef </b> <a 
 id="dx48-80023"></a><a 
 id="x48-80024r69"></a>  {place }*
</td></tr></table>
<!--l. 1143--><p class="indent" >
</div>
   Each <i>place</i> form may be any form acceptable as a generalized variable to <a 
href="#x48-80002r66">setf</a>.
In the form (rotatef <i>place1</i> <i>place2</i> ... <i>placen</i>), the values in <i>place1</i> through <i>placen</i>
are accessed and saved. Values 2 through <i>n</i> and value 1 are then stored into
<i>place1</i> through <i>placen</i>. It is as if all the places form an end-around shift register
that is rotated one place to the left, with the value of <i>place1</i> being shifted around
the end to <i>placen</i>. Note that (rotatef <i>place1</i> <i>place2</i>) exchanges the contents of
<i>place1</i> and <i>place2</i>.
   The eﬀect of (rotatef <i>place1</i> <i>place2</i> ... <i>placen</i>) is roughly equivalent to <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(psetf <i>place1</i> <i>place2</i>
</td></tr></table>
<!--l. 1158--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       <i>place2</i> <i>place3</i></td></tr></table>
<!--l. 1159--><p class="indent" >                                                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       ...</td></tr></table>
<!--l. 1160--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       <i>placen</i> <i>place1</i>)</td></tr></table>
<!--l. 1162--><p class="indent" >
</div>
</div>
<!--l. 1163--><p class="noindent" >except that the latter would evaluate any subforms of each <i>place</i> twice, whereas
<a 
href="#x48-80024r69">rotatef</a> takes care to evaluate them only once. Moreover, for certain <i>place</i> forms
<a 
href="#x48-80024r69">rotatef</a> may be signiﬁcantly more eﬃcient.
<!--l. 1168--><p class="indent" >   <a 
href="#x48-80024r69">rotatef</a> always returns <a 
href="clmse31.html#x42-70002r19">nil</a>.
<div class=newer>
<!--l. 1171--><p class="indent" >   X3J13 voted in June 1989 <a 
 id="dx48-80025"></a>to extend the speciﬁcation of <a 
href="#x48-80024r69">rotatef</a> to
allow a <i>place</i> whose <a 
href="#x48-80002r66">setf</a> method has more than one store variable (see
<a 
href="#x48-80038r72">deﬁne-setf-method</a>). In such a case as many values are accepted from the
<i>newvalue</i> form as there are store variables; extra values are ignored and
missing values default to <a 
href="clmse31.html#x42-70002r19">nil</a>, as is usual in situations involving multiple
values.
</div>
</div>
                                                                          

                                                                          
<!--l. 1181--><p class="indent" >   Other macros that manipulate generalized variables include <a 
href="clmse54.html#x69-108010r162">getf</a>, <a 
href="clmse54.html#x69-108014r163">remf</a>, <a 
href="clmse69.html#x86-125014r224">incf</a>,
<a 
href="clmse69.html#x86-125016r225">decf</a>, <a 
href="clmse87.html#x107-149060r503">push</a>, <a 
href="clmse87.html#x107-149066r505">pop</a>, <a 
href="clmse155.html#x189-336004r995">assert</a>, <a 
href="clmse155.html#x189-337004r997">ctypecase</a>, and <a 
href="clmse155.html#x189-337008r999">ccase</a>.
<!--l. 1186--><p class="indent" >   Macros that manipulate generalized variables must guarantee the “obvious”
semantics: subforms of generalized-variable references are evaluated exactly as
many times as they appear in the source program, and they are evaluated in
exactly the same order as they appear in the source program.
<!--l. 1192--><p class="indent" >   In generalized-variable references such as <a 
href="#x48-80021r68">shiftf</a>, <a 
href="clmse69.html#x86-125014r224">incf</a>, <a 
href="clmse87.html#x107-149060r503">push</a>, and <a 
href="#x48-80002r66">setf</a> of <a 
href="clmse73.html#x90-132008r312">ldb</a>, the
generalized variables are both read and written in the same reference. Preserving
the source program order of evaluation and the number of evaluations is
particularly important.
<!--l. 1197--><p class="indent" >   As an example of these semantic rules, in the generalized-variable
reference (setf <i>reference</i> <i>value</i>) the <i>value</i> form must be evaluated <i>after</i> all the
subforms of the reference because the <i>value</i> form appears to the right of
them.
<!--l. 1202--><p class="indent" >   The expansion of these macros must consist of code that follows these rules or
has the same eﬀect as such code. This is accomplished by introducing temporary
variables bound to the subforms of the reference. As an optimization in
the implementation, temporary variables may be eliminated whenever it
can be proved that removing them has no eﬀect on the semantics of the
program. For example, a constant need never be saved in a temporary
variable. A variable, or for that matter any form that does not have side
eﬀects, need not be saved in a temporary variable if it can be proved
that its value will not change within the scope of the generalized-variable
reference.
<!--l. 1213--><p class="indent" >   Common Lisp provides built-in facilities to take care of these semantic
complications and optimizations. Since the required semantics can be guaranteed
by these facilities, the user does not have to worry about writing correct code for
them, especially in complex cases. Even experts can become confused and make
mistakes while writing this sort of code.
<div class=newer>
<!--l. 1221--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-80026"></a>to clarify the preceding discussion about the order
of evaluation of subforms in calls to <a 
href="#x48-80002r66">setf</a> and related macros. The general
intent is clear: evaluation proceeds from left to right whenever possible.
However, the left-to-right rule does not remove the obligation on writers of
macros and <a 
href="#x48-80038r72">deﬁne-setf-method</a> to work to ensure left-to-right order of
evaluation.
<!--l. 1229--><p class="indent" >   Let it be emphasized that, in the following discussion, a <i>form</i> is something
whose syntactic use is such that it will be evaluated. A <i>subform</i> means a form
                                                                          

                                                                          
that is nested inside another form, not merely any Lisp object nested inside a
form regardless of syntactic context.
<!--l. 1234--><p class="indent" >   The evaluation ordering of subforms within a generalized variable
reference is determined by the order speciﬁed by the second value returned by
<a 
href="#x48-80046r74">get-setf-method</a>. For all predeﬁned generalized variable references (<a 
href="clmse54.html#x69-108010r162">getf</a>,
<a 
href="clmse73.html#x90-132008r312">ldb</a>), this order of evaluation is exactly left-to-right. When a generalized
variable reference is derived from a macro expansion, this rule is applied
<i>after</i> the macro is expanded to ﬁnd the appropriate generalized variable
reference.
<!--l. 1243--><p class="indent" >   This is intended to make it clear that if the user writes a <a 
href="clmse46.html#x59-98007r137">defmacro</a> or
<a 
href="#x48-80038r72">deﬁne-setf-method</a> macro that doesn&#x2019;t preserve left-to-right evaluation
order, the order speciﬁed in the user&#x2019;s code holds. For example, given <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro wrong-order (x y) ‘(getf ,y ,x))
</td></tr></table>
<!--l. 1249--><p class="indent" >
</div>
</div>
<!--l. 1250--><p class="noindent" >then <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(push <i>value</i> (wrong-order <i>place1</i> <i>place2</i>))
</td></tr></table>
<!--l. 1253--><p class="indent" >
</div>
</div>
<!--l. 1254--><p class="noindent" >will evaluate <i>place2</i> ﬁrst and then <i>place1</i> because that is the order they are evaluated
in the macro expansion.
<!--l. 1257--><p class="indent" >   For the macros that manipulate generalized variables (<a 
href="clmse87.html#x107-149060r503">push</a>, <a 
href="clmse87.html#x107-149063r504">pushnew</a>, <a 
href="clmse54.html#x69-108010r162">getf</a>,
<a 
href="clmse54.html#x69-108014r163">remf</a>, <a 
href="clmse69.html#x86-125014r224">incf</a>, <a 
href="clmse69.html#x86-125016r225">decf</a>, <a 
href="#x48-80021r68">shiftf</a>, <a 
href="#x48-80024r69">rotatef</a>, <a 
href="#x48-80018r67">psetf</a>, <a 
href="#x48-80002r66">setf</a>, <a 
href="clmse87.html#x107-149066r505">pop</a>, and those deﬁned with
<a 
href="#x48-80030r70">deﬁne-modify-macro</a>) the subforms of the macro call are evaluated exactly once in
left-to-right order, with the subforms of the generalized variable references
evaluated in the order speciﬁed above.
<!--l. 1264--><p class="indent" >   Each of <a 
href="clmse87.html#x107-149060r503">push</a>, <a 
href="clmse87.html#x107-149063r504">pushnew</a>, <a 
href="clmse54.html#x69-108010r162">getf</a>, <a 
href="clmse54.html#x69-108014r163">remf</a>, <a 
href="clmse69.html#x86-125014r224">incf</a>, <a 
href="clmse69.html#x86-125016r225">decf</a>, <a 
href="#x48-80021r68">shiftf</a>, <a 
href="#x48-80024r69">rotatef</a>, <a 
href="#x48-80018r67">psetf</a>, and <a 
href="clmse87.html#x107-149066r505">pop</a>
evaluates all subforms before modifying any of the generalized variable locations.
                                                                          

                                                                          
Moreover, <a 
href="#x48-80002r66">setf</a> itself, in the case when a call on it has more than two
arguments, performs its operation on each pair in sequence. That is, in <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf <i>place1</i> <i>value1</i> <i>place2</i> <i>value2</i> ...)
</td></tr></table>
<!--l. 1273--><p class="indent" >
</div>
</div>
<!--l. 1274--><p class="noindent" >the subforms of <i>place1</i> and <i>value1</i> are evaluated, the location speciﬁed by <i>place1</i> is
modiﬁed to contain the value returned by <i>value1</i>, and then the rest of the <a 
href="#x48-80002r66">setf</a>
form is processed in a like manner.
<!--l. 1278--><p class="indent" >   For the macros <a 
href="clmse155.html#x189-336002r994">check-type</a>, <a 
href="clmse155.html#x189-337004r997">ctypecase</a>, and <a 
href="clmse155.html#x189-337008r999">ccase</a>, subforms of the generalized
variable reference are evaluated once per test of a generalized variable, but they
may be evaluated again if the type check fails (in the case of <a 
href="clmse155.html#x189-336002r994">check-type</a>) or if
none of the cases holds (in <a 
href="clmse155.html#x189-337004r997">ctypecase</a> or <a 
href="clmse155.html#x189-337008r999">ccase</a>).
<!--l. 1284--><p class="indent" >   For the macro <a 
href="clmse155.html#x189-336004r995">assert</a>, the order of evaluation of the generalized variable
references is not speciﬁed.
</div>
<!--l. 1288--><p class="indent" >   Another reason for building in these functions is that the appropriate
optimizations will diﬀer from implementation to implementation. In some
implementations most of the optimization is performed by the compiler, while in
others a simpler compiler is used and most of the optimization is performed in the
macros. The cost of binding a temporary variable relative to the cost of other Lisp
operations may diﬀer greatly between one implementation and another, and some
implementations may ﬁnd it best never to remove temporary variables except in
the simplest cases.
<!--l. 1298--><p class="indent" >   A good example of the issues involved can be seen in the following
generalized-variable reference: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(incf (ldb byte-ﬁeld variable))
</td></tr></table>
<!--l. 1302--><p class="indent" >
</div>
</div>
<!--l. 1303--><p class="noindent" >This ought to expand into something like <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setq variable
</td></tr></table>
<!--l. 1305--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (dpb (1+ (ldb byte-ﬁeld variable))</td></tr></table>
<!--l. 1306--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           byte-ﬁeld</td></tr></table>
<!--l. 1307--><p class="indent" >                                                    <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           variable))</td></tr></table>
<!--l. 1309--><p class="indent" >
</div>
</div>
<!--l. 1310--><p class="noindent" >In this expansion example we have ignored the further complexity of returning the
correct value, which is the incremented byte, not the new value of variable. Note
that the variable byte-ﬁeld is evaluated twice, and the variable variable is referred
to three times: once as the location in which to store a value, and twice during the
computation of that value.
<!--l. 1318--><p class="indent" >   Now consider this expression: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(incf (ldb (aref byte-ﬁelds (incf i))
</td></tr></table>
<!--l. 1320--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">           (aref (determine-words-array) i)))</td></tr></table>
<!--l. 1322--><p class="indent" >
</div>
</div>
<!--l. 1323--><p class="noindent" >It ought to expand into something like this: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(let ((temp1 (aref byte-ﬁelds (incf i)))
</td></tr></table>
<!--l. 1325--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (temp2 (determine-words-array)))</td></tr></table>
<!--l. 1326--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (setf (aref temp2 i)</td></tr></table>
<!--l. 1327--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">        (dpb (1+ (ldb temp1 (aref temp2 i)))</td></tr></table>
<!--l. 1328--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             temp1</td></tr></table>
<!--l. 1329--><p class="indent" >                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">             (aref temp2 i))))</td></tr></table>
<!--l. 1331--><p class="indent" >
</div>
</div>
                                                                          

                                                                          
<!--l. 1332--><p class="noindent" >Again we have ignored the complexity of returning the correct value. What is
important here is that the expressions (incf i) and (determine-words-array) must
not be duplicated because each may have a side eﬀect or be aﬀected by side
eﬀects.
<div class=newer>
<!--l. 1339--><p class="indent" >   X3J13 voted in January 1989 <a 
 id="dx48-80027"></a>to specify more precisely the order of evaluation
of subforms when <a 
href="#x48-80002r66">setf</a> is used with an access function that itself takes a <i>place</i> as
an argument, for example, <a 
href="clmse73.html#x90-132008r312">ldb</a>, <a 
href="clmse73.html#x90-132012r314">mask-ﬁeld</a>, and <a 
href="clmse54.html#x69-108010r162">getf</a>. (The vote also discussed the
function <a 
href="clmse80.html#x98-140011r396">char-bit</a>, but another vote <a 
 id="dx48-80028"></a>removed that function from the language.)
The <a 
href="#x48-80002r66">setf</a> methods for such accessors produce expansions that eﬀectively require
explicit calls to <a 
href="#x48-80046r74">get-setf-method</a>.
<!--l. 1348--><p class="indent" >   The code produced as the macro expansion of a <a 
href="#x48-80002r66">setf</a> form that itself admits a
generalized variable as an argument must essentially do the following major
steps:
      <ul class="itemize1">
      <li class="itemize">It evaluates the value-producing subforms, in left-to-right order, and
      binds  the  temporary  variables  to  them;  this  is  called  <i>binding  the
      temporaries</i>.
      </li>
      <li class="itemize">It reads the value from the generalized variable, using the supplied
      accessing form, to get the old value; this is called <i>doing the access</i>.
      Note that this is done after all the evaluations of the preceding step,
      including any side eﬀects they may have.
      </li>
      <li class="itemize">It binds the store variable to a new value, and then installs this new
      value into the generalized variable using the supplied storing form; this
      is called <i>doing the store</i>.</li></ul>
<!--l. 1364--><p class="noindent" >Doing the access for a generalized variable reference is not part of the series of
evaluations that must be done in left-to-right order.
<!--l. 1367--><p class="indent" >   The place-speciﬁer forms <a 
href="clmse73.html#x90-132008r312">ldb</a>, <a 
href="clmse73.html#x90-132012r314">mask-ﬁeld</a>, and <a 
href="clmse54.html#x69-108010r162">getf</a> admit (other) <i>place</i>
speciﬁers as arguments. During the <a 
href="#x48-80002r66">setf</a> expansion of these forms, it is necessary to
call <a 
href="#x48-80046r74">get-setf-method</a> to determine how the inner, nested generalized variable must
be treated.
<!--l. 1372--><p class="indent" >   In a form such as <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (ldb <i>byte-spec</i> <i>place-form</i>) <i>newvalue-form</i>)
</td></tr></table>
<!--l. 1375--><p class="indent" >
</div>
</div>
<!--l. 1376--><p class="noindent" >the place referred to by the <i>place-form</i> must always be both accessed and updated;
note that the update is to the generalized variable speciﬁed by <i>place-form</i>, not to
any object of type integer.
<!--l. 1380--><p class="indent" >   Thus this call to <a 
href="#x48-80002r66">setf</a> should generate code to do the following:
      <ul class="itemize1">
      <li class="itemize">Evaluate <i>byte-spec</i> and bind into a temporary
      </li>
      <li class="itemize">Bind the temporaries for <i>place-form</i>
      </li>
      <li class="itemize">Evaluate <i>newvalue-form</i> and bind into the store variable
      </li>
      <li class="itemize">Do the access to <i>place-form</i>
      </li>
      <li class="itemize">Do the store into <i>place-form</i> with the given bit-ﬁeld of the accessed
      integer replaced with the value in the store variable</li></ul>
<!--l. 1389--><p class="noindent" >If the evaluation of <i>newvalue-form</i> alters what is found in the given <i>place</i>—such as
setting a diﬀerent bit-ﬁeld of the integer—then the change of the bit-ﬁeld denoted
by <i>byte-spec</i> will be to that altered integer, because the access step must be
done after the <i>newvalue-form</i> evaluation. Nevertheless, the evaluations
required for binding the temporaries are done before the evaluation of the
<i>newvalue-form</i>, thereby preserving the required left-to-right evaluation
order.
<!--l. 1399--><p class="indent" >   The treatment of <a 
href="clmse73.html#x90-132012r314">mask-ﬁeld</a> is similar to that of <a 
href="clmse73.html#x90-132008r312">ldb</a>.
<!--l. 1401--><p class="indent" >   In a form such as: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (getf <i>place-form</i> <i>ind-form</i>) <i>newvalue-form</i>)
</td></tr></table>
<!--l. 1404--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1405--><p class="noindent" >the place referred to by the <i>place-form</i> must always be both accessed and
updated; note that the update is to the generalized variable speciﬁed by
<i>place-form</i>, not necessarily to the particular list which is the property list in
question.
<!--l. 1410--><p class="indent" >   Thus this call to <a 
href="#x48-80002r66">setf</a> should generate code to do the following:
      <ul class="itemize1">
      <li class="itemize">Bind the temporaries for <i>place-form</i>
      </li>
      <li class="itemize">Evaluate <i>ind-form</i> and bind into a temporary
      </li>
      <li class="itemize">Evaluate the <i>newvalue-form</i> and bind into the store variable
      </li>
      <li class="itemize">Do the access to <i>place-form</i>
      </li>
      <li class="itemize">Do the store into <i>place-form</i> with a possibly new property list obtained
      by combining the results of the evaluations and the access</li></ul>
<!--l. 1420--><p class="indent" >   If the evaluation of <i>newvalue-form</i> alters what is found in the given
<i>place</i>—such as setting a diﬀerent named property in the list—then the change of
the property denoted by <i>ind-form</i> will be to that altered list, because the access
step is done after the <i>newvalue-form</i> evaluation. Nevertheless, the evaluations
required for binding the temporaries are done before the evaluation of the
<i>newvalue-form</i>, thereby preserving the required left-to-right evaluation
order.
<!--l. 1429--><p class="indent" >   Note that the phrase “possibly new property list” treats the implementation of
property lists as a “black box”; it can mean that the former property list is
somehow destructively re-used, or it can mean partial or full copying of it. A side
eﬀect may or may not occur; therefore <a 
href="#x48-80002r66">setf</a> must proceed as if the resultant
property list were a diﬀerent copy needing to be stored back into the generalized
variable.
</div>
<!--l. 1438--><p class="indent" >   The Common Lisp facilities provided to deal with these semantic issues
include:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">Built-in macros such as <a 
href="#x48-80002r66">setf</a> and <a 
href="clmse87.html#x107-149060r503">push</a> that follow the semantic rules.
      </li>
      <li class="itemize">The <a 
href="#x48-80030r70">deﬁne-modify-macro</a> macro, which allows new generalized-variable
      manipulating macros (of a certain restricted kind) to be deﬁned easily.
      It takes care of the semantic rules automatically.
      </li>
      <li class="itemize">The  <a 
href="#x48-80033r71">defsetf</a>  macro,  which  allows  new  types  of  generalized-variable
      references  to  be  deﬁned  easily.  It  takes  care  of  the  semantic  rules
      automatically.
      </li>
      <li class="itemize">The <a 
href="#x48-80038r72">deﬁne-setf-method</a> macro and the <a 
href="#x48-80046r74">get-setf-method</a> function, which
      provide  access  to  the  internal  mechanisms  when  it  is  necessary  to
      deﬁne  a  complicated  new  type  of  generalized-variable  reference  or
      generalized-variable-manipulating macro.</li></ul>
<div class=newer>
<!--l. 1460--><p class="indent" >   Also important are the changes that allow lexical environments to be used in
appropriate ways in <a 
href="#x48-80002r66">setf</a> methods.
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <i>[Macro]</i> <b> deﬁne-modify-macro </b> <a 
 id="dx48-80029"></a><a 
 id="x48-80030r70"></a>  name lambda-list function [doc-string]
</td></tr></table>
<!--l. 1466--><p class="indent" >
</div>
   This macro deﬁnes a read-modify-write macro named <i>name</i>. An example of
such a macro is <a 
href="clmse69.html#x86-125014r224">incf</a>. The ﬁrst subform of the macro will be a generalized-variable
reference. The <i>function</i> is literally the function to apply to the old contents of the
generalized-variable to get the new contents; it is not evaluated. <i>lambda-list</i>
describes the remaining arguments for the <i>function</i>; these arguments come
from the remaining subforms of the macro after the generalized-variable
reference. <i>lambda-list</i> may contain &#x0026;optional and &#x0026;rest markers. (The
                                                                          

                                                                          
&#x0026;key marker is not permitted here; &#x0026;rest suﬃces for the purposes of
<a 
href="#x48-80030r70">deﬁne-modify-macro</a>.) <i>doc-string</i> is documentation for the macro <i>name</i> being
deﬁned.
   The expansion of a <a 
href="#x48-80030r70">deﬁne-modify-macro</a> is equivalent to the following, except
that it generates code that follows the semantic rules outlined above. <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro <i>name</i> (<i>reference</i> . <i>lambda-list</i>)
</td></tr></table>
<!--l. 1483--><p class="indent" >                                                              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <i>doc-string</i></td></tr></table>
<!--l. 1484--><p class="indent" >                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ‘(setf ,<i>reference</i></td></tr></table>
<!--l. 1485--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">         (<i>function</i> ,<i>reference</i> ,<i>arg1</i> ,<i>arg2</i> ...)))</td></tr></table>
<!--l. 1487--><p class="indent" >
</div>
</div>
<!--l. 1488--><p class="noindent" >where <i>arg1</i>, <i>arg2</i>, ..., are the parameters appearing in <i>lambda-list</i>; appropriate
provision is made for a &#x0026;rest parameter.
<!--l. 1491--><p class="indent" >   As an example, <a 
href="clmse69.html#x86-125014r224">incf</a> could have been deﬁned by: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deﬁne-modify-macro incf (&#x0026;optional (delta 1)) +)
</td></tr></table>
<!--l. 1494--><p class="indent" >
</div>
</div>
<!--l. 1496--><p class="indent" >   An example of a possibly useful macro not predeﬁned in Common Lisp is <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deﬁne-modify-macro unionf (other-set &#x0026;rest keywords) union)
</td></tr></table>
<!--l. 1499--><p class="indent" >
</div>
</div>
<div class=newer>
                                                                          

                                                                          
<!--l. 1502--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-80031"></a>to specify that <a 
href="#x48-80030r70">deﬁne-modify-macro</a> creates
macros that take &#x0026;environment arguments and perform the equivalent of
correctly passing such lexical environments to <a 
href="#x48-80046r74">get-setf-method</a> in order to
correctly maintain lexical references.
</div>
</div>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <i>[Macro]</i> <b> defsetf </b> <a 
 id="dx48-80032"></a><a 
 id="x48-80033r71"></a>  access-fn  {update-fn [doc-string] | lambda-list (store-variable)  [[ {declaration }*  | doc-string]]  { form }*  }
</td></tr></table>
<!--l. 1513--><p class="indent" >
</div>
   This deﬁnes how to <a 
href="#x48-80002r66">setf</a> a generalized-variable reference of the form (<i>access-fn</i>
...). The value of a generalized-variable reference can always be obtained
simply by evaluating it, so <i>access-fn</i> should be the name of a function or a
macro.
   The user of <a 
href="#x48-80033r71">defsetf</a> provides a description of how to store into the
generalized-variable reference and return the value that was stored (because <a 
href="#x48-80002r66">setf</a> is
deﬁned to return this value). The implementation of <a 
href="#x48-80033r71">defsetf</a> takes care
of ensuring that subforms of the reference are evaluated exactly once
and in the proper left-to-right order. In order to do this, <a 
href="#x48-80033r71">defsetf</a> requires
that <i>access-fn</i> be a function or a macro that evaluates its arguments,
behaving like a function. Furthermore, a <a 
href="#x48-80002r66">setf</a> of a call on <i>access-fn</i> will also
evaluate all of <i>access-fn</i>&#x2019;s arguments; it cannot treat any of them specially.
This means that <a 
href="#x48-80033r71">defsetf</a> cannot be used to describe how to store into
a generalized variable that is a byte, such as (ldb ﬁeld reference). To
handle situations that do not ﬁt the restrictions imposed by <a 
href="#x48-80033r71">defsetf</a>, use
<a 
href="#x48-80038r72">deﬁne-setf-method</a>, which gives the user additional control at the cost of increased
complexity.
   A <a 
href="#x48-80033r71">defsetf</a> declaration may take one of two forms. The simple form is <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defsetf <i>access-fn</i> <i>update-fn</i> [<i><i>doc-string</i></i>] )
</td></tr></table>
<!--l. 1539--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1540--><p class="noindent" >The <i>update-fn</i> must name a function (or macro) that takes one more argument than
<i>access-fn</i> takes. When <a 
href="#x48-80002r66">setf</a> is given a <i>place</i> that is a call on <i>access-fn</i>, it expands
into a call on <i>update-fn</i> that is given all the arguments to <i>access-fn</i> and also, as its
last argument, the new value (which must be returned by <i>update-fn</i> as its value).
For example, the eﬀect of <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defsetf symbol-value set)
</td></tr></table>
<!--l. 1549--><p class="indent" >
</div>
</div>
<!--l. 1550--><p class="noindent" >is built into the Common Lisp system. This causes the expansion <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(setf (symbol-value foo) fu)  → (set foo fu)
</td></tr></table>
<!--l. 1554--><p class="indent" >
</div>
</div>
<!--l. 1555--><p class="noindent" >for example. Note that <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defsetf car rplaca)
</td></tr></table>
<!--l. 1558--><p class="indent" >
</div>
</div>
<!--l. 1559--><p class="noindent" >would be incorrect because <a 
href="clmse88.html#x108-150002r509">rplaca</a> does not return its last argument.
<!--l. 1561--><p class="indent" >   The complex form of <a 
href="#x48-80033r71">defsetf</a> looks like <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defsetf <i>access-fn</i> <i>lambda-list</i> (<i>store-variable</i>) . <i>body</i>)
</td></tr></table>
<!--l. 1564--><p class="indent" >
                                                                          

                                                                          
</div>
</div>
<!--l. 1565--><p class="noindent" >and resembles <a 
href="clmse46.html#x59-98007r137">defmacro</a>. The <i>body</i> must compute the expansion of a <a 
href="#x48-80002r66">setf</a> of a call on
<i>access-fn</i>.
<!--l. 1568--><p class="indent" >   The <i>lambda-list</i> describes the arguments of <i>access-fn</i>. &#x0026;optional, &#x0026;rest, and
&#x0026;key markers are permitted in <i>lambda-list</i>. Optional arguments may have defaults
and “supplied-p” ﬂags. The <i>store-variable</i> describes the value to be stored into the
generalized-variable reference.
<div class=rationale>
<!--l. 1575--><p class="noindent" ><b>Rationale:</b> The <i>store-variable</i> is enclosed in parentheses to provide for an extension to
multiple store variables that would receive multiple values from the second subform of
<a 
href="#x48-80002r66">setf</a>. The rules given below for coding <a 
href="#x48-80002r66">setf</a> methods discuss the proper handling of
multiple store variables to allow for the possibility that this extension may be
incorporated into Common Lisp in the future.
</div>
<!--l. 1587--><p class="indent" >   The <i>body</i> forms can be written as if the variables in the <i>lambda-list</i> were
bound to subforms of the call on <i>access-fn</i> and the <i>store-variable</i> were
bound to the second subform of <a 
href="#x48-80002r66">setf</a>. However, this is not actually the case.
During the evaluation of the <i>body</i> forms, these variables are bound to
names of temporary variables, generated as if by <a 
href="clmse56.html#x71-110008r168">gensym</a> or <a 
href="clmse56.html#x71-110014r170">gentemp</a>, that
will be bound by the expansion of <a 
href="#x48-80002r66">setf</a> to the values of those subforms.
This binding permits the <i>body</i> forms to be written without regard for
order-of-evaluation issues. <a 
href="#x48-80033r71">defsetf</a> arranges for the temporary variables to be
optimized out of the ﬁnal result in cases where that is possible. In other words, an
attempt is made by <a 
href="#x48-80033r71">defsetf</a> to generate the best code possible in a particular
implementation.
<!--l. 1602--><p class="indent" >   Note that the code generated by the <i>body</i> forms must include provision for
returning the correct value (the value of <i>store-variable</i>). This is handled by the
<i>body</i> forms rather than by <a 
href="#x48-80033r71">defsetf</a> because in many cases this value can be
returned at no extra cost, by calling a function that simultaneously stores into the
generalized variable and returns the correct value.
<!--l. 1609--><p class="indent" >   An example of the use of the complex form of <a 
href="#x48-80033r71">defsetf</a>: <div class=lisp> <div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defsetf subseq (sequence start &#x0026;optional end) (new-sequence)
</td></tr></table>
<!--l. 1611--><p class="indent" >                                <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  ‘(progn (replace ,sequence ,new-sequence</td></tr></table>
<!--l. 1612--><p class="indent" >                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                   :start1 ,start :end1 ,end)</td></tr></table>
                                                                          

                                                                          
<!--l. 1613--><p class="indent" >                                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          ,new-sequence))</td></tr></table>
<!--l. 1615--><p class="indent" >
</div>
</div>
<div class=newer>
<!--l. 1618--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-80034"></a>to specify that the body of the expander function
deﬁned by the complex form of <a 
href="#x48-80033r71">defsetf</a> is implicitly enclosed in a <a 
href="clmse41.html#x53-85002r103">block</a> construct
whose name is the same as the <i>name</i> of the <i>access-fn</i>. Therefore <a 
href="clmse41.html#x53-85004r104">return-from</a> may
be used to exit from the function.
</div>
<div class=newer>
<!--l. 1626--><p class="indent" >   X3J13 voted in March 1989 <a 
 id="dx48-80035"></a>to clarify that, while deﬁning forms normally
appear at top level, it is meaningful to place them in non-top-level contexts; the
complex form of <a 
href="#x48-80033r71">defsetf</a> must deﬁne the expander function within the enclosing
lexical environment, not within the global environment.
</div>
</div>
<!--l. 1635--><p class="indent" >   The underlying theory by which <a 
href="#x48-80002r66">setf</a> and related macros arrange to conform to
the semantic rules given above is that from any generalized-variable reference one
may derive its “<a 
href="#x48-80002r66">setf</a> method,” which describes how to store into that reference and
which subforms of it are evaluated.
<div class=incompatibility>
<!--l. 1642--><p class="noindent" ><b>Compatibility note:</b> To avoid confusion, it should be noted that the use of the word
“method” here in connection with <a 
href="#x48-80002r66">setf</a> has nothing to do with its use in Lisp Machine
Lisp in connection with message-passing and the Lisp Machine Lisp “ﬂavor system.” <div class=new>
And of course it also has nothing to do with the methods in the Common Lisp Object
System <a 
 id="dx48-80036"></a>.
</div>
</div>
<!--l. 1655--><p class="indent" >   Given knowledge of the subforms of the reference, it is possible to avoid
evaluating them multiple times or in the wrong order. A <a 
href="#x48-80002r66">setf</a> method for a given
access form can be expressed as ﬁve values:
      <ul class="itemize1">
      <li class="itemize">A list of <i>temporary variables</i>
      </li>
      <li class="itemize">A list of <i>value forms</i> (subforms of the given form) to whose values the
      temporary variables are to be bound
                                                                          

                                                                          
      </li>
      <li class="itemize">A second list of temporary variables, called <i>store variables</i>
      </li>
      <li class="itemize">A <i>storing form</i>
      </li>
      <li class="itemize">An <i>accessing form</i></li></ul>
<!--l. 1677--><p class="indent" >   The temporary variables will be bound to the values of the value forms as if by
let*; that is, the value forms will be evaluated in the order given and
may refer to the values of earlier value forms by using the corresponding
variables.
<!--l. 1683--><p class="indent" >   The store variables are to be bound to the values of the <i>newvalue</i> form,
that is, the values to be stored into the generalized variable. In almost
all cases only a single value is to be stored, and there is only one store
variable.
<!--l. 1688--><p class="indent" >   The storing form and the accessing form may contain references to the
temporary variables (and also, in the case of the storing form, to the
store variables). The accessing form returns the value of the generalized
variable. The storing form modiﬁes the value of the generalized variable and
guarantees to return the values of the store variables as its values; these are the
correct values for <a 
href="#x48-80002r66">setf</a> to return. (Again, in most cases there is a single store
variable and thus a single value to be returned.) The value returned by the
accessing form is, of course, aﬀected by execution of the storing form, but
either of these forms may be evaluated any number of times and therefore
should be free of side eﬀects (other than the storing action of the storing
form).
<!--l. 1702--><p class="indent" >   The temporary variables and the store variables are generated names, as if by
<a 
href="clmse56.html#x71-110008r168">gensym</a> or <a 
href="clmse56.html#x71-110014r170">gentemp</a>, so that there is never any problem of name clashes among
them, or between them and other variables in the program. This is necessary to
make the special forms that do more than one <a 
href="#x48-80002r66">setf</a> in parallel work properly;
these are <a 
href="#x48-80018r67">psetf</a>, <a 
href="#x48-80021r68">shiftf</a>, and <a 
href="#x48-80024r69">rotatef</a>. Computation of the <a 
href="#x48-80002r66">setf</a> method must
always create new variable names; it may not return the same ones every
time.
<!--l. 1711--><p class="indent" >   Some examples of <a 
href="#x48-80002r66">setf</a> methods for particular forms:
      <ul class="itemize1">
      <li class="itemize">For a variable x: <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">()
</td></tr></table>
      <!--l. 1716--><p class="noindent" >                                                                                          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">()</td></tr></table>
      <!--l. 1717--><p class="noindent" >                                                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(g0001)</td></tr></table>
      <!--l. 1718--><p class="noindent" >                                                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(setq x g0001)</td></tr></table>
      <!--l. 1719--><p class="noindent" >                                                                                           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">x</td></tr></table>
      <!--l. 1721--><p class="noindent" >
</div>
</div>
      </li>
      <li class="itemize">For (car <i>exp</i>): <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(g0002)
</td></tr></table>
      <!--l. 1726--><p class="noindent" >                                                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(<i>exp</i>)</td></tr></table>
      <!--l. 1727--><p class="noindent" >                                                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(g0003)</td></tr></table>
      <!--l. 1728--><p class="noindent" >                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(progn (rplaca g0002 g0003) g0003)</td></tr></table>
      <!--l. 1729--><p class="noindent" >                                                                             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(car g0002)</td></tr></table>
      <!--l. 1731--><p class="noindent" >
</div>
</div>
      </li>
      <li class="itemize">For (subseq <i>seq</i> <i>s</i> <i>e</i>): <div class=lisp> <div class=tabbing>
      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(g0004 g0005 g0006)
</td></tr></table>
      <!--l. 1736--><p class="noindent" >                                                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(<i>seq</i> <i>s</i> <i>e</i>)</td></tr></table>
                                                                          

                                                                          
      <!--l. 1737--><p class="noindent" >                                                                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(g0007)</td></tr></table>
      <!--l. 1738--><p class="noindent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(progn (replace g0004 g0007 :start1 g0005 :end1 g0006)</td></tr></table>
      <!--l. 1739--><p class="noindent" >                                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">       g0007)</td></tr></table>
      <!--l. 1740--><p class="noindent" >                                                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:44;" 
class="tabbing"></td><td  
class="tabbing">(subseq g0004 g0005 g0006)</td></tr></table>
      <!--l. 1742--><p class="noindent" >
</div>
</div>
      </li></ul>
<div class=defmac>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  <i>[Macro]</i> <b> deﬁne-setf-method </b> <a 
 id="dx48-80037"></a><a 
 id="x48-80038r72"></a>  access-fn lambda-list
</td></tr></table>
<!--l. 1747--><p class="indent" >                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"> [[ {declaration }*  | doc-string]]  { form }* </td></tr></table>
<!--l. 1748--><p class="indent" >
</div>
   This deﬁnes how to <a 
href="#x48-80002r66">setf</a> a generalized-variable reference that is of the form
(<i>access-fn</i>...). The value of a generalized-variable reference can always be obtained
simply by evaluating it, so <i>access-fn</i> should be the name of a function or a
macro.
   The <i>lambda-list</i> describes the subforms of the generalized-variable reference, as
with <a 
href="clmse46.html#x59-98007r137">defmacro</a>. The result of evaluating the <i>forms</i> in the body must be
ﬁve values representing the <a 
href="#x48-80002r66">setf</a> method, as described above. Note that
<a 
href="#x48-80038r72">deﬁne-setf-method</a> diﬀers from the complex form of <a 
href="#x48-80033r71">defsetf</a> in that while the
body is being executed the variables in <i>lambda-list</i> are bound to parts of
the generalized-variable reference, not to temporary variables that will
be bound to the values of such parts. In addition, <a 
href="#x48-80038r72">deﬁne-setf-method</a>
does not have <a 
href="#x48-80033r71">defsetf</a>&#x2019;s restriction that <i>access-fn</i> must be a function or a
function-like macro; an arbitrary <a 
href="clmse46.html#x59-98007r137">defmacro</a> destructuring pattern is permitted in
<i>lambda-list</i>.
   By deﬁnition there are no good small examples of <a 
href="#x48-80038r72">deﬁne-setf-method</a> because
the easy cases can all be handled by <a 
href="#x48-80033r71">defsetf</a>. A typical use is to deﬁne the <a 
href="#x48-80002r66">setf</a>
method for <a 
href="clmse73.html#x90-132008r312">ldb</a>: <div class=obsolete> <div class=lisp> <div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; SETF method for the form (LDB bytespec int).
</td></tr></table>
<!--l. 1773--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Recall that the int form must itself be suitable for SETF.</td></tr></table>
<!--l. 1774--><p class="indent" >                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deﬁne-setf-method ldb (bytespec int)</td></tr></table>
<!--l. 1775--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-bind (temps vals stores</td></tr></table>
<!--l. 1776--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                        store-form access-form)</td></tr></table>
<!--l. 1777--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (get-setf-method int)         ;Get SETF method for int</td></tr></table>
<!--l. 1778--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((btemp (gensym))          ;Temp var for byte speciﬁer</td></tr></table>
<!--l. 1779--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (store (gensym))          ;Temp var for byte to store</td></tr></table>
<!--l. 1780--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (stemp (ﬁrst stores)))   ;Temp var for int to store</td></tr></table>
<!--l. 1781--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ;; Return the SETF method for LDB as ﬁve values.</td></tr></table>
<!--l. 1782--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (values (cons btemp temps)    ;Temporary variables</td></tr></table>
<!--l. 1783--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (cons bytespec vals)  ;Value forms</td></tr></table>
<!--l. 1784--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (list store)          ;Store variables</td></tr></table>
<!--l. 1785--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              ‘(let ((,stemp (dpb ,store ,btemp ,access-form)))</td></tr></table>
<!--l. 1786--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 ,store-form</td></tr></table>
<!--l. 1787--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 ,store)                     ;Storing form</td></tr></table>
<!--l. 1788--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              ‘(ldb ,btemp ,access-form)     ;Accessing form</td></tr></table>
<!--l. 1789--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              ))))</td></tr></table>
<!--l. 1791--><p class="indent" >
</div>
</div>
</div>
<div class=newer>
<!--l. 1795--><p class="noindent" >X3J13 voted in March 1988 <a 
 id="dx48-80039"></a>to specify that the &#x0026;environment lambda-list keyword
may appear in the <i>lambda-list</i> in the same manner as for <a 
href="clmse46.html#x59-98007r137">defmacro</a> in order to
obtain the lexical environment of the call to the <a 
href="#x48-80002r66">setf</a> macro. The preceding
example should be modiﬁed to take advantage of this new feature. The <a 
href="#x48-80002r66">setf</a>
method must accept an &#x0026;environment parameter, which will receive the lexical
environment of the call to <a 
href="#x48-80002r66">setf</a>; this environment must then be given to
<a 
href="#x48-80046r74">get-setf-method</a> in order that it may correctly use any locally bound <a 
href="#x48-80002r66">setf</a> method
that might be applicable to the <i>place</i> form that appears as the second argument
to <a 
href="clmse73.html#x90-132008r312">ldb</a> in the call to <a 
href="#x48-80002r66">setf</a>.
<div class=lisp>
<div class=tabbing>
                                                                          

                                                                          
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; SETF method for the form (LDB bytespec int).
</td></tr></table>
<!--l. 1808--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Recall that the int form must itself be suitable for SETF.</td></tr></table>
<!--l. 1809--><p class="indent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; Note the use of an &#x0026;environment parameter to receive the</td></tr></table>
<!--l. 1810--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">;;; lexical environment of the call for use with GET-SETF-METHOD.</td></tr></table>
<!--l. 1811--><p class="indent" >                   <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(deﬁne-setf-method ldb (bytespec int &#x0026;environment env)</td></tr></table>
<!--l. 1812--><p class="indent" >                                  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-bind (temps vals stores</td></tr></table>
<!--l. 1813--><p class="indent" >                       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                        store-form access-form)</td></tr></table>
<!--l. 1814--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (get-setf-method int env)     ;Get SETF method for int</td></tr></table>
<!--l. 1815--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (let ((btemp (gensym))          ;Temp var for byte speciﬁer</td></tr></table>
<!--l. 1816--><p class="indent" >        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (store (gensym))          ;Temp var for byte to store</td></tr></table>
<!--l. 1817--><p class="indent" >             <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">          (stemp (ﬁrst stores)))   ;Temp var for int to store</td></tr></table>
<!--l. 1818--><p class="indent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      ;; Return the SETF method for LDB as ﬁve values.</td></tr></table>
<!--l. 1819--><p class="indent" >               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (values (cons btemp temps)    ;Temporary variables</td></tr></table>
<!--l. 1820--><p class="indent" >                        <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (cons bytespec vals)  ;Value forms</td></tr></table>
<!--l. 1821--><p class="indent" >                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              (list store)          ;Store variables</td></tr></table>
<!--l. 1822--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              ‘(let ((,stemp (dpb ,store ,btemp ,access-form)))</td></tr></table>
<!--l. 1823--><p class="indent" >                                            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 ,store-form</td></tr></table>
<!--l. 1824--><p class="indent" >          <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                 ,store)                     ;Storing form</td></tr></table>
<!--l. 1825--><p class="indent" >           <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              ‘(ldb ,btemp ,access-form)     ;Accessing form</td></tr></table>
<!--l. 1826--><p class="indent" >                                                      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">              ))))</td></tr></table>
<!--l. 1828--><p class="indent" >
</div>
</div>
</div>
<div class=newer>
<!--l. 1832--><p class="noindent" >X3J13 voted in March 1988 <a 
 id="dx48-80040"></a>to specify that the body of the expander function
deﬁned by <a 
href="#x48-80038r72">deﬁne-setf-method</a> is implicitly enclosed in a <a 
href="clmse41.html#x53-85002r103">block</a> construct whose
name is the same as the <i>name</i> of the <i>access-fn</i>. Therefore <a 
href="clmse41.html#x53-85004r104">return-from</a> may be
used to exit from the function.
</div>
<div class=newer>
<!--l. 1840--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx48-80041"></a>to clarify that, while deﬁning forms normally appear
at top level, it is meaningful to place them in non-top-level contexts;
<a 
href="#x48-80038r72">deﬁne-setf-method</a> must deﬁne the expander function within the enclosing lexical
environment, not within the global environment.
                                                                          

                                                                          
</div>
</div>
<div class=obsolete>
<div class=defun>
<!--l. 1850--><p class="noindent" ><i>[Function]</i><a 
 id="dx48-80042"></a><a 
 id="x48-80043r73"></a><b> get-setf-method</b>  <i>form</i>
<!--l. 1852--><p class="noindent" ><a 
href="#x48-80046r74">get-setf-method</a> returns ﬁve values constituting the <a 
href="#x48-80002r66">setf</a> method for <i>form</i>. The
<i>form</i> must be a generalized-variable reference. <a 
href="#x48-80046r74">get-setf-method</a> takes care of
error-checking and macro expansion and guarantees to return exactly one store
variable.
<!--l. 1860--><p class="indent" >   As an example, an extremely simpliﬁed version of <a 
href="#x48-80002r66">setf</a>, allowing no more and
no fewer than two subforms, containing no optimization to remove unnecessary
variables, and not allowing storing of multiple values, could be deﬁned by: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro setf (reference value)
</td></tr></table>
<!--l. 1865--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-bind (vars vals stores store-form access-form)</td></tr></table>
<!--l. 1866--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (get-setf-method reference)</td></tr></table>
<!--l. 1867--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (declare (ignore access-form))</td></tr></table>
<!--l. 1868--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ‘(let* ,(mapcar #&#x2019;list</td></tr></table>
<!--l. 1869--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    (append vars stores)</td></tr></table>
<!--l. 1870--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    (append vals (list value)))</td></tr></table>
<!--l. 1871--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       ,store-form)))</td></tr></table>
<!--l. 1873--><p class="indent" >
</div>
</div>
</div>
</div>
<div class=newer>
<!--l. 1878--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-80044"></a>to add an optional environment argument to
<a 
href="#x48-80046r74">get-setf-method</a>. The revised deﬁnition and example are as follows.
<div class=defun>
<!--l. 1882--><p class="noindent" ><i>[Function]</i><a 
 id="dx48-80045"></a><a 
 id="x48-80046r74"></a><b> get-setf-method</b>  <i>form</i> &#x0026;optional  <i>env</i>
<!--l. 1884--><p class="noindent" ><a 
href="#x48-80046r74">get-setf-method</a> returns ﬁve values constituting the <a 
href="#x48-80002r66">setf</a> method for <i>form</i>. The
<i>form</i> must be a generalized-variable reference. The <i>env</i> must be an environment
of the sort obtained through the &#x0026;environment lambda-list keyword; if <i>env</i> is <a 
href="clmse31.html#x42-70002r19">nil</a>
                                                                          

                                                                          
or omitted, the null lexical environment is assumed. <a 
href="#x48-80046r74">get-setf-method</a> takes care of
error checking and macro expansion and guarantees to return exactly one store
variable.
<!--l. 1896--><p class="indent" >   As an example, an extremely simpliﬁed version of <a 
href="#x48-80002r66">setf</a>, allowing no more and
no fewer than two subforms, containing no optimization to remove unnecessary
variables, and not allowing storing of multiple values, could be deﬁned by: <div class=lisp>
<div class=tabbing>
<table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">(defmacro setf (reference value &#x0026;environment env)
</td></tr></table>
<!--l. 1901--><p class="indent" >            <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">  (multiple-value-bind (vars vals stores store-form access-form)</td></tr></table>
<!--l. 1902--><p class="indent" >      <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">      (get-setf-method reference env)     ;Note use of environment</td></tr></table>
<!--l. 1903--><p class="indent" >                                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    (declare (ignore access-form))</td></tr></table>
<!--l. 1904--><p class="indent" >                                                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">    ‘(let* ,(mapcar #&#x2019;list</td></tr></table>
<!--l. 1905--><p class="indent" >                               <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    (append vars stores)</td></tr></table>
<!--l. 1906--><p class="indent" >                         <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">                    (append vals (list value)))</td></tr></table>
<!--l. 1907--><p class="indent" >                                                     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing">       ,store-form)))</td></tr></table>
<!--l. 1909--><p class="indent" >
</div>
</div>
</div>
</div>
<div class=obsolete>
<div class=defun>
<!--l. 1914--><p class="noindent" ><i>[Function]</i><a 
 id="dx48-80047"></a><a 
 id="x48-80048r75"></a><b> get-setf-method-multiple-value</b>  <i>form</i>
<!--l. 1916--><p class="noindent" ><a 
href="#x48-80051r76">get-setf-method-multiple-value</a> returns ﬁve values constituting the <a 
href="#x48-80002r66">setf</a> method for
<i>form</i>. The <i>form</i> must be a generalized-variable reference. This is the same as
<a 
href="#x48-80046r74">get-setf-method</a> except that it does not check the number of store variables; use
this in cases that allow storing multiple values into a generalized variable. There
are no such cases in standard Common Lisp, but this function is provided to allow
for possible extensions.
</div>
</div>
<div class=newer>
<!--l. 1929--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-80049"></a>to add an optional environment argument to
<a 
href="#x48-80046r74">get-setf-method</a>. The revised deﬁnition is as follows.
                                                                          

                                                                          
<div class=defun>
<!--l. 1933--><p class="noindent" ><i>[Function]</i><a 
 id="dx48-80050"></a><a 
 id="x48-80051r76"></a><b> get-setf-method-multiple-value</b>  <i>form</i> &#x0026;optional  <i>env</i>
<!--l. 1935--><p class="noindent" ><a 
href="#x48-80051r76">get-setf-method-multiple-value</a> returns ﬁve values constituting the <a 
href="#x48-80002r66">setf</a> method
for <i>form</i>. The <i>form</i> must be a generalized-variable reference. The <i>env</i>
must be an environment of the sort obtained through the &#x0026;environment
lambda-list keyword; if <i>env</i> is <a 
href="clmse31.html#x42-70002r19">nil</a> or omitted, the null lexical environment is
assumed.
<!--l. 1944--><p class="indent" >   This is the same as <a 
href="#x48-80046r74">get-setf-method</a> except that it does not check the number
of store variables; use this in cases that allow storing multiple values into a
generalized variable. There are no such cases in standard Common Lisp, but this
function is provided to allow for possible extensions.
</div>
</div>
<div class=newer>
<!--l. 1954--><p class="indent" >   X3J13 voted in March 1988 <a 
 id="dx48-80052"></a>to clarify that a <a 
href="#x48-80002r66">setf</a> method for a functional
name is applicable only when the global binding of that name is lexically
visible. If such a name has a local binding introduced by <a 
href="clmse39.html#x51-83030r93">ﬂet</a>, <a 
href="clmse39.html#x51-83032r94">labels</a>, or
<a 
href="clmse39.html#x51-83034r95">macrolet</a>, then global deﬁnitions of <a 
href="#x48-80002r66">setf</a> methods for that name do not
apply and are not visible. All of the standard Common Lisp macros that
modify a <a 
href="#x48-80002r66">setf</a> <i>place</i> (for example, <a 
href="clmse69.html#x86-125014r224">incf</a>, <a 
href="clmse69.html#x86-125016r225">decf</a>, <a 
href="clmse87.html#x107-149066r505">pop</a>, and <a 
href="#x48-80024r69">rotatef</a>) obey this
convention.
</div>
                                                                          

                                                                          
   <!--l. 1964--><div class="crosslinks"><p class="noindent"><tt>&#x003C;</tt><a 
href="clmse37.html" >Next</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html" >Prev</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse35.html#tailclmse35.html" >PrevTail</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmse36.html" >Front</a><tt>&#x003E;</tt><tt>&#x003C;</tt><a 
href="clmch7.html#clmse36.html" >Up</a><tt>&#x003E;</tt></p></div>
<!--l. 1964--><p class="indent" >   <a 
 id="tailclmse36.html"></a>  
</body></html> 
